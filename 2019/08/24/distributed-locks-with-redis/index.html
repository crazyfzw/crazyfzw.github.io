<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazyfzw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="# 产生背景 Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.  在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最">
<meta property="og:type" content="article">
<meta property="og:title" content="慢谈 Redis 实现分布式锁 以及 Redisson 源码解析">
<meta property="og:url" content="https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/index.html">
<meta property="og:site_name" content="Crazyfzw&#39;s blog">
<meta property="og:description" content="# 产生背景 Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.  在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最">
<meta property="og:image" content="https://crazyfzw.github.io/images/2019041501.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2019041502.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2019041503.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2019041504.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2019041505.png">
<meta property="article:published_time" content="2019-08-24T03:51:21.000Z">
<meta property="article:modified_time" content="2020-12-18T05:31:23.278Z">
<meta property="article:author" content="crazyfzw">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redisson">
<meta property="article:tag" content="RedissonLock">
<meta property="article:tag" content="RedissonRedLock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crazyfzw.github.io/images/2019041501.png">

<link rel="canonical" href="https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>慢谈 Redis 实现分布式锁 以及 Redisson 源码解析 | Crazyfzw's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Crazyfzw's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crazyfzw's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Return to base, step by step.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="crazyfzw">
      <meta itemprop="description" content="做个有趣的技术人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crazyfzw's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          慢谈 Redis 实现分布式锁 以及 Redisson 源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-24 11:51:21" itemprop="dateCreated datePublished" datetime="2019-08-24T11:51:21+08:00">2019-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-18 13:31:23" itemprop="dateModified" datetime="2020-12-18T13:31:23+08:00">2020-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/distributed/" itemprop="url" rel="index"><span itemprop="name">distributed</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/24/distributed-locks-with-redis/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/24/distributed-locks-with-redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="产生背景"><a href="#产生背景" class="headerlink" title="# 产生背景"></a><a href="#产生背景" title="# 产生背景"></a># 产生背景</h2><blockquote>
<p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p>
</blockquote>
<p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p>
<p>随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p>
<a id="more"></a>

<h2 id="实现分布式锁的三种选择"><a href="#实现分布式锁的三种选择" class="headerlink" title="# 实现分布式锁的三种选择"></a><a href="#实现分布式锁的三种选择" title="# 实现分布式锁的三种选择"></a># 实现分布式锁的三种选择</h2><ul>
<li>基于数据库实现分布式锁*   基于zookeeper实现分布式锁</li>
<li>基于Redis缓存实现分布式锁</li>
</ul>
<p>以上三种方式都可以实现分布式锁，其中，从健壮性考虑， 用 zookeeper 会比用 Redis 实现更好，但从性能角度考虑，基于 Redis 实现性能会更好，如何选择，还是取决于业务需求。</p>
<h2 id="基于-Redis-实现分布式锁的三种方案"><a href="#基于-Redis-实现分布式锁的三种方案" class="headerlink" title="# 基于 Redis 实现分布式锁的三种方案"></a><a href="#基于-Redis-实现分布式锁的三种方案" title="# 基于 Redis 实现分布式锁的三种方案"></a># 基于 Redis 实现分布式锁的三种方案</h2><ul>
<li>用 Redis 实现分布式锁的正确姿势（实现一）</li>
<li>用 Redisson 实现分布式可重入锁（RedissonLock）（实现二）</li>
<li>用 Redisson 实现分布式锁(红锁 RedissonRedLock)（实现三）</li>
</ul>
<p><strong>本文主要探讨基于 Redis 实现分布式锁的方案，主要分析并对比了以上三种方案，并大致分析了 Redisson 的 RedissonLock 、 RedissonRedLock 源码。</strong></p>
<h2 id="分布式锁需满足四个条件"><a href="#分布式锁需满足四个条件" class="headerlink" title="# 分布式锁需满足四个条件"></a><a href="#分布式锁需满足四个条件" title="# 分布式锁需满足四个条件"></a># 分布式锁需满足四个条件</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li>
<li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li>
</ol>
<h2 id="用-Redis-实现分布式锁的正确姿势（实现一）"><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" class="headerlink" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a># 用 Redis 实现分布式锁的正确姿势（实现一）</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a><a href="#主要思路" title="主要思路"></a>主要思路</h3><p>通过 set key value px milliseconds nx 命令实现加锁， 通过Lua脚本实现解锁。核心实现命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁（unique_value可以是UUID等）</span></span>
<span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span>
<span class="line"></span>
<span class="line"><span class="comment">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span></span>
<span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span>
<span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span>
<span class="line"><span class="keyword">else</span></span>
<span class="line">    <span class="keyword">return</span> <span class="number">0</span></span>
<span class="line">end</span>
</pre></td></tr></table></figure>

<p>这种实现方式主要有以下几个要点：</p>
<ul>
<li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p>
</li>
<li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p>
</li>
<li><p>释放锁时要验证 value 值，防止误解锁；</p>
</li>
<li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p>
</li>
</ul>
<h3 id="完整代码实现如下："><a href="#完整代码实现如下：" class="headerlink" title="完整代码实现如下："></a><a href="#完整代码实现如下：" title="完整代码实现如下："></a>完整代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span>
<span class="line">        </span>
<span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><a href="#加锁代码分析" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>
<h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><a href="#解锁代码分析" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p>
<h3 id="这种方式仍存在单点风险"><a href="#这种方式仍存在单点风险" class="headerlink" title="这种方式仍存在单点风险"></a><a href="#这种方式仍存在单点风险" title="这种方式仍存在单点风险"></a>这种方式仍存在单点风险</h3><p><strong>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</strong></p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。</li>
<li>主从切换，slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</li>
</ol>
<p><strong>所以在这种实现之下，不论Redis的部署架构是单机模式、主从模式、哨兵模式还是集群模式，都存在这种风险。因为Redis的主从同步是异步的。 运行的是，Redis 之父 antirez 提出了 redlock算法 可以解决这个问题。</strong></p>
<h2 id="Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" class="headerlink" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</h2><h3 id="什么是-Redisson"><a href="#什么是-Redisson" class="headerlink" title="什么是 Redisson"></a><a href="#什么是-Redisson" title="什么是 Redisson"></a>什么是 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><a href="#Redisson-分布式重入锁用法" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span>
<span class="line">Config config = <span class="keyword">new</span> Config();</span>
<span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line"><span class="comment">// 2.构造RedissonClient</span></span>
<span class="line">RedissonClient redissonClient = Redisson.create(config);</span>
<span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span>
<span class="line">RLock rLock = redissonClient.getLock(lockKey);</span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    rLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁源码分析"><a href="#加锁源码分析" class="headerlink" title="加锁源码分析"></a><a href="#加锁源码分析" title="加锁源码分析"></a>加锁源码分析</h3><p><strong>1.通过 getLock 方法获取对象</strong></p>
<p><strong>org.redisson.Redisson#getLock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     *  构造并返回一个 RedissonLock 对象 </span></span>
<span class="line"><span class="comment">     * commandExecutor: 与 Redis 节点通信并发送指令的真正实现。需要说明一下，CommandExecutor 实现是通过 eval 命令来执行 Lua 脚本</span></span>
<span class="line"><span class="comment">     * name: 锁的全局名称</span></span>
<span class="line"><span class="comment">     * id: Redisson 客户端唯一标识，实际上就是一个 UUID.randomUUID()</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name, id);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>2.通过tryLock方法尝试获取锁</strong></p>
<p>tryLock方法里的调用关系大致如下：</p>
<p><img src="/images/2019041501.png" alt=""></p>
<p><strong>org.redisson.RedissonLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="comment">//取得最大等待时间</span></span>
<span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span>
<span class="line">    <span class="comment">//记录下当前时间</span></span>
<span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span>
<span class="line">    <span class="comment">//取得当前线程id（判断是否可重入锁的关键）</span></span>
<span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span>
<span class="line">    <span class="comment">//1.尝试申请锁，返回还剩余的锁过期时间</span></span>
<span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">    <span class="comment">//2.如果为空，表示申请锁成功</span></span>
<span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="comment">//3.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span>
<span class="line">    time -= System.currentTimeMillis() - current;</span>
<span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 通过 promise.trySuccess 设置异步执行的结果为null</span></span>
<span class="line"><span class="comment">         * Promise从Uncompleted--&gt;Completed ,通知 Future 异步执行已完成</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    current = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.订阅锁释放事件，并通过await方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：</span></span>
<span class="line"><span class="comment">     * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争</span></span>
<span class="line"><span class="comment">     * 当 this.await返回false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败</span></span>
<span class="line"><span class="comment">     * 当 this.await返回true，进入循环尝试获取锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span>
<span class="line">    <span class="comment">//await 方法内部是用CountDownLatch来实现阻塞，获取subscribe异步执行的结果（应用了Netty 的 Future）</span></span>
<span class="line">    <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span>
<span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span>
<span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span>
<span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    unsubscribe(subscribeFuture, threadId);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;);</span>
<span class="line">        &#125;</span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        <span class="comment">//计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败</span></span>
<span class="line">        time -= System.currentTimeMillis() - current;</span>
<span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">            acquireFailed(threadId);</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 5.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁</span></span>
<span class="line"><span class="comment">         * 获取锁成功，则立马返回true，</span></span>
<span class="line"><span class="comment">         * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回false结束循环</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="comment">// 再次尝试申请锁</span></span>
<span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">            <span class="comment">// 成功获取锁则直接返回true结束循环</span></span>
<span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//超过最大等待时间则返回false结束循环，获取锁失败</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span>
<span class="line">                <span class="comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="comment">//则就在wait time 时间范围内等待可以通过信号量</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//7.更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125; <span class="keyword">finally</span> &#123;</span>
<span class="line">        <span class="comment">//7.无论是否获得锁,都要取消订阅解锁消息</span></span>
<span class="line">        unsubscribe(subscribeFuture, threadId);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>其中 tryAcquire 内部通过调用 tryLockInnerAsync 实现申请锁的逻辑。申请锁并返回锁有效期还剩余的时间，如果为空说明锁未被其它线程申请则直接获取并返回，如果获取到时间，则进入等待竞争逻辑。</p>
<p><strong>org.redisson.RedissonLock#tryLockInnerAsync</strong></p>
<p><strong>加锁流程图：</strong><br><img src="/images/2019041502.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span>
<span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span>
<span class="line">              <span class="comment">// 1.如果缓存中的key不存在，则执行 hset 命令(hset key UUID+threadId 1),然后通过 pexpire 命令设置锁的过期时间(即锁的租约时间)</span></span>
<span class="line">              <span class="comment">// 返回空值 nil ，表示获取锁成功</span></span>
<span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">// 如果key已经存在，并且value也匹配，表示是当前线程持有的锁，则执行 hincrby 命令，重入次数加1，并且设置失效时间</span></span>
<span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">//如果key已经存在，但是value不匹配，说明锁已经被其他线程持有，通过 pttl 命令获取锁的剩余存活时间并返回，至此获取锁失败</span></span>
<span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span>
<span class="line">               <span class="comment">//这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span>
<span class="line">               Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><p>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key；</p>
</li>
<li><p>ARGV[1]就是internalLockLeaseTime，即锁的租约时间（持有锁的有效时间），默认30s；</p>
</li>
<li><p>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值 value，即UUID+threadId。</p>
</li>
</ul>
<h3 id="解锁源码分析"><a href="#解锁源码分析" class="headerlink" title="解锁源码分析"></a><a href="#解锁源码分析" title="解锁源码分析"></a>解锁源码分析</h3><p>unlock 内部通过 get(unlockAsync(Thread.currentThread().getId()))  调用 unlockInnerAsync 解锁。</p>
<p><strong>org.redisson.RedissonLock#unlock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span>
<span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span>
<span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span>
<span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="keyword">throw</span> e;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>get方法利用是 CountDownLatch 在异步调用结果返回前将当前线程阻塞，然后通过 Netty 的 FutureListener 在异步调用完成后解除阻塞，并返回调用结果。</p>
<p><strong>org.redisson.command.CommandAsyncService#get</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;   <span class="comment">//任务还没完成</span></span>
<span class="line">        <span class="comment">// 设置一个单线程的同步控制器</span></span>
<span class="line">        CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span>
<span class="line">        future.onComplete((res, e) -&gt; &#123;</span>
<span class="line">            <span class="comment">//操作完成时，唤醒在await()方法中等待的线程</span></span>
<span class="line">            l.countDown();</span>
<span class="line">        &#125;);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span>
<span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span>
<span class="line">            <span class="keyword">try</span> &#123;</span>
<span class="line">                <span class="comment">//阻塞等待</span></span>
<span class="line">                l.await();</span>
<span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span>
<span class="line">                interrupted = <span class="keyword">true</span>;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span>
<span class="line">            Thread.currentThread().interrupt();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span>
<span class="line">        <span class="keyword">return</span> future.getNow();</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">throw</span> convertException(future);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>org.redisson.RedissonLock#unlockInnerAsync</strong></p>
<p><strong>解锁流程图：</strong><br><img src="/images/2019041503.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span>
<span class="line">            <span class="comment">//如果分布式锁存在，但是value不匹配，表示锁已经被其他线程占用，无权释放锁，那么直接返回空值（解铃还须系铃人）</span></span>
<span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span>
<span class="line">                <span class="string">"return nil;"</span> +</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">             <span class="comment">//如果value匹配，则就是当前线程占有分布式锁，那么将重入次数减1</span></span>
<span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只能更新失效时间，还不能删除</span></span>
<span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span>
<span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span>
<span class="line">                <span class="string">"return 0; "</span> +</span>
<span class="line">            <span class="string">"else "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果为0，这时就可以删除这个KEY，并发布解锁消息，返回1</span></span>
<span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span>
<span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span>
<span class="line">                <span class="string">"return 1; "</span>+</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">            <span class="string">"return nil;"</span>,</span>
<span class="line">            <span class="comment">//这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span>
<span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="解锁消息处理"><a href="#解锁消息处理" class="headerlink" title="解锁消息处理"></a><a href="#解锁消息处理" title="解锁消息处理"></a>解锁消息处理</h3><p><strong>org.redisson.pubsub#onMessage</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_MESSAGE = <span class="number">0L</span>;</span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long READ_UNLOCK_MESSAGE = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockPubSub</span><span class="params">(PublishSubscribeService service)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">super</span>(service);</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 判断是否是解锁消息</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 释放一个信号量，唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            value.getLatch().release();</span>
<span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">                <span class="comment">/**</span></span>
<span class="line"><span class="comment">                 * 如果还有其他Listeners回调，则也唤醒执行</span></span>
<span class="line"><span class="comment">                 */</span></span>
<span class="line">                Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    <span class="keyword">break</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            value.getLatch().release(value.getLatch().getQueueLength());</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><a href="#总结对比" title="总结对比"></a>总结对比</h3><p>通过 Redisson 实现分布式可重入锁（实现二），比纯自己通过set key value px milliseconds nx +lua 实现（实现一）的效果更好些，虽然基本原理都一样，因为通过分析源码可知，RedissonLock<br>是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。   </p>
<p><strong>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</strong></p>
<p><strong>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</strong></p>
<h2 id="redlock算法"><a href="#redlock算法" class="headerlink" title="# redlock算法"></a><a href="#redlock算法" title="# redlock算法"></a># redlock算法</h2><p>Redis 官网对 redLock 算法的介绍大致如下：</p>
<blockquote>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">The Redlock algorithm</a></p>
</blockquote>
<p>在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li><p>获取当前Unix时间，以毫秒为单位。</p>
</li>
<li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p>
</li>
<li><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p>
</li>
<li><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p>
</li>
</ol>
<h2 id="用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" class="headerlink" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</h2><p>这里以三个单机模式为例，需要特别注意的是他们完全互相独立，不存在主从复制或者其他集群协调机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
</pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span>
<span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span>
<span class="line"></span>
<span class="line">Config config2 = <span class="keyword">new</span> Config();</span>
<span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span>
<span class="line"></span>
<span class="line">Config config3 = <span class="keyword">new</span> Config();</span>
<span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span>
<span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span>
<span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span>
<span class="line"></span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    redLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>最核心的变化就是需要构建多个 RLock ,然后根据多个 RLock 构建成一个 RedissonRedLock，因为 redLock 算法是建立在多个互相独立的 Redis 环境之上的（为了区分可以叫为 Redission node），Redission node 节点既可以是单机模式(single)，也可以是主从模式(master/salve)，哨兵模式(sentinal)，或者集群模式(cluster)。这就意味着，不能跟以往这样只搭建 1个 cluster、或 1个 sentinel 集群，或是1套主从架构就了事了，需要为 RedissonRedLock 额外搭建多几套独立的 Redission 节点。 比如可以搭建3个 或者5个 Redission节点，具体可看视资源及业务情况而定。</strong></p>
<p><strong>下图是一个利用多个 Redission node 最终 组成 RedLock分布式锁的例子，需要特别注意的是每个  Redission node 是互相独立的，不存在任何复制或者其他隐含的分布式协调机制。</strong></p>
<p><img src="/images/2019041504.png" alt=""><br><img src="/images/2019041505.png" alt=""></p>
<h2 id="Redisson-实现redlock算法源码分析（RedLock）"><a href="#Redisson-实现redlock算法源码分析（RedLock）" class="headerlink" title="# Redisson 实现redlock算法源码分析（RedLock）"></a><a href="#Redisson-实现redlock算法源码分析（RedLock）" title="# Redisson 实现redlock算法源码分析（RedLock）"></a># Redisson 实现redlock算法源码分析（RedLock）</h2><p><strong>加锁核心代码</strong></p>
<p> <strong>org.redisson.RedissonMultiLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
<span class="line">101</span>
<span class="line">102</span>
<span class="line">103</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span>
<span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        remainTime = unit.toMillis(waitTime);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 1\. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 2\. 遍历所有节点通过EVAL命令执行lua加锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span>
<span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span>
<span class="line">        RLock lock = iterator.next();</span>
<span class="line">        <span class="keyword">boolean</span> lockAcquired;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">try</span> &#123;</span>
<span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                lockAcquired = lock.tryLock();</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span>
<span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span>
<span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span>
<span class="line">            unlockInner(Arrays.asList(lock));</span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             *4\. 如果获取到锁则添加到已获取锁集合中</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            acquiredLocks.add(lock);</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 5\. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span>
<span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span>
<span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                failedLocksLimit = failedLocksLimit();</span>
<span class="line">                acquiredLocks.clear();</span>
<span class="line">                <span class="comment">// reset iterator</span></span>
<span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span>
<span class="line">                    iterator.previous();</span>
<span class="line">                &#125;</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                failedLocksLimit--;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span>
<span class="line">            remainTime -= System.currentTimeMillis() - time;</span>
<span class="line">            time = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span>
<span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span>
<span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span>
<span class="line">            futures.add(future);</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span>
<span class="line">            rFuture.syncUninterruptibly();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p>
<p>[2]<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Distributed locks with Redis 中文版</a></p>
<p>[3]<a href="https://redis.io/commands/set" target="_blank" rel="noopener">SET - Redis</a></p>
<p>[4]<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">EVAL command</a></p>
<p>[5] <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></p>
<p>[6]<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p>
<p>[7]<a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">Redlock实现分布式锁</a></p>
<p>[8]<a href="https://mp.weixin.qq.com/s/iaZcc7QGbGHkZkfLeYp1yg" target="_blank" rel="noopener">Redisson实现Redis分布式锁</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/Redisson/" rel="tag"># Redisson</a>
              <a href="/tags/RedissonLock/" rel="tag"># RedissonLock</a>
              <a href="/tags/RedissonRedLock/" rel="tag"># RedissonRedLock</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/24/java-spi/" rel="prev" title="Java SPI 机制">
      <i class="fa fa-chevron-left"></i> Java SPI 机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/09/redis-keyspace-notifications/" rel="next" title="订阅 Redis 的 key 过期事件实现动态定时任务">
      订阅 Redis 的 key 过期事件实现动态定时任务 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#产生背景"><span class="nav-number">1.</span> <span class="nav-text"># 产生背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现分布式锁的三种选择"><span class="nav-number">2.</span> <span class="nav-text"># 实现分布式锁的三种选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-Redis-实现分布式锁的三种方案"><span class="nav-number">3.</span> <span class="nav-text"># 基于 Redis 实现分布式锁的三种方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式锁需满足四个条件"><span class="nav-number">4.</span> <span class="nav-text"># 分布式锁需满足四个条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Redis-实现分布式锁的正确姿势（实现一）"><span class="nav-number">5.</span> <span class="nav-text"># 用 Redis 实现分布式锁的正确姿势（实现一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要思路"><span class="nav-number">5.1.</span> <span class="nav-text">主要思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整代码实现如下："><span class="nav-number">5.2.</span> <span class="nav-text">完整代码实现如下：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁代码分析"><span class="nav-number">5.3.</span> <span class="nav-text">加锁代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解锁代码分析"><span class="nav-number">5.4.</span> <span class="nav-text">解锁代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这种方式仍存在单点风险"><span class="nav-number">5.5.</span> <span class="nav-text">这种方式仍存在单点风险</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><span class="nav-number">6.</span> <span class="nav-text"># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Redisson"><span class="nav-number">6.1.</span> <span class="nav-text">什么是 Redisson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson-分布式重入锁用法"><span class="nav-number">6.2.</span> <span class="nav-text">Redisson 分布式重入锁用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加锁源码分析"><span class="nav-number">6.3.</span> <span class="nav-text">加锁源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解锁源码分析"><span class="nav-number">6.4.</span> <span class="nav-text">解锁源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解锁消息处理"><span class="nav-number">6.5.</span> <span class="nav-text">解锁消息处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结对比"><span class="nav-number">6.6.</span> <span class="nav-text">总结对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redlock算法"><span class="nav-number">7.</span> <span class="nav-text"># redlock算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><span class="nav-number">8.</span> <span class="nav-text"># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson-实现redlock算法源码分析（RedLock）"><span class="nav-number">9.</span> <span class="nav-text"># Redisson 实现redlock算法源码分析（RedLock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">10.</span> <span class="nav-text"># 参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="crazyfzw"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">crazyfzw</p>
  <div class="site-description" itemprop="description">做个有趣的技术人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">133</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazyfzw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazyfzw" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.douban.com/people/crazyfzw/" title="Booklist → https:&#x2F;&#x2F;book.douban.com&#x2F;people&#x2F;crazyfzw&#x2F;" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Booklist</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:crazyfzw@gmail.com" title="E-Mail → mailto:crazyfzw@gmail.com" rel="noopener" target="_blank"><i class="fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/104894167431407693109" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;104894167431407693109" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100011315733045" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100011315733045" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3829383159" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3829383159" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.importnew.com/" title="http:&#x2F;&#x2F;www.importnew.com&#x2F;" rel="noopener" target="_blank">ImportNew</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/categories/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;categories&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ibm.com/developerworks/cn/java/" title="https:&#x2F;&#x2F;www.ibm.com&#x2F;developerworks&#x2F;cn&#x2F;java&#x2F;" rel="noopener" target="_blank">IBM developerworks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com&#x2F;" rel="noopener" target="_blank">美团点评技术团队</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://calvin1978.blogcn.com/" title="http:&#x2F;&#x2F;calvin1978.blogcn.com&#x2F;" rel="noopener" target="_blank">江南白衣的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.720ui.com/" title="http:&#x2F;&#x2F;blog.720ui.com" rel="noopener" target="_blank">梁桂钊的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/581f548ef0ec" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;581f548ef0ec" rel="noopener" target="_blank">李艳鹏的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jinnianshilongnian.iteye.com/" title="http:&#x2F;&#x2F;jinnianshilongnian.iteye.com&#x2F;" rel="noopener" target="_blank">张开涛的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/zuoxiaolong" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;zuoxiaolong" rel="noopener" target="_blank">左潇龙的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/xrq730/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xrq730&#x2F;" rel="noopener" target="_blank">五月的仓颉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yikun.github.io/" title="https:&#x2F;&#x2F;yikun.github.io&#x2F;" rel="noopener" target="_blank">Yikun的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/" title="http:&#x2F;&#x2F;www.ruanyifeng.com" rel="noopener" target="_blank">阮一峰的个人网站</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyfzw</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">213k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'jyxPxkBMeEmDfMMTuuyBdGdu-gzGzoHsz',
      appKey     : '7SEECyfT4R10oTtj4zDMOdBt',
      placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
