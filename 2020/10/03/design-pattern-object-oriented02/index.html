<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazyfzw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？1.什么是基于贫血模型的传统开发模式？像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码">
<meta property="og:url" content="https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/index.html">
<meta property="og:site_name" content="Crazyfzw&#39;s blog">
<meta property="og:description" content="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？1.什么是基于贫血模型的传统开发模式？像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。">
<meta property="og:image" content="https://crazyfzw.github.io/images/or01.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or02.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or03.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or04.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or05.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or06.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or07.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or08.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or09.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or10.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/or11.jpg">
<meta property="article:published_time" content="2020-10-03T15:37:56.000Z">
<meta property="article:modified_time" content="2021-01-02T07:49:47.215Z">
<meta property="article:author" content="crazyfzw">
<meta property="article:tag" content="Design Pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crazyfzw.github.io/images/or01.jpg">

<link rel="canonical" href="https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码 | Crazyfzw's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Crazyfzw's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crazyfzw's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Return to base, step by step.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="crazyfzw">
      <meta itemprop="description" content="做个有趣的技术人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crazyfzw's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-03 23:37:56" itemprop="dateCreated datePublished" datetime="2020-10-03T23:37:56+08:00">2020-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-02 15:49:47" itemprop="dateModified" datetime="2021-01-02T15:49:47+08:00">2021-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index"><span itemprop="name">Design Pattern</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/03/design-pattern-object-oriented02/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/03/design-pattern-object-oriented02/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h2><h3 id="1-什么是基于贫血模型的传统开发模式？"><a href="#1-什么是基于贫血模型的传统开发模式？" class="headerlink" title="1.什么是基于贫血模型的传统开发模式？"></a>1.什么是基于贫血模型的传统开发模式？</h3><p>像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo &#x3D; userService.getUserById(userId);</span><br><span class="line">    UserVo userVo &#x3D; [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity &#x3D; userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo &#x3D; [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-什么是基于充血模型的-DDD-开发模式？"><a href="#2-什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="2.什么是基于充血模型的 DDD 开发模式？"></a>2.什么是基于充血模型的 DDD 开发模式？</h3><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<h3 id="3-贫血模型-与-充血模型的代码模式区别"><a href="#3-贫血模型-与-充血模型的代码模式区别" class="headerlink" title="3.贫血模型 与 充血模型的代码模式区别"></a>3.贫血模型 与 充血模型的代码模式区别</h3><p>基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p>
<h3 id="4-为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#4-为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="4.为什么基于贫血模型的传统开发模式如此受欢迎？"></a>4.为什么基于贫血模型的传统开发模式如此受欢迎？</h3><ol>
<li><p>一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，基于贫血模型的传统开发模式简单够用</p>
</li>
<li><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p>
</li>
<li><p>思维已固化，转型有成本</p>
</li>
</ol>
<h3 id="5-什么时候该选择用贫血模型？什么时候该用充血模型？"><a href="#5-什么时候该选择用贫血模型？什么时候该用充血模型？" class="headerlink" title="5.什么时候该选择用贫血模型？什么时候该用充血模型？"></a>5.什么时候该选择用贫血模型？什么时候该用充血模型？</h3><p>基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p>
<p>对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p>
<h2 id="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h2><h3 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h3><p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p>
<p><img src="/images/or01.jpg" alt="9e91377602ef154eaf866c7e9263a64a.jpeg"></p>
<h4 id="1-充值"><a href="#1-充值" class="headerlink" title="1.充值"></a>1.充值</h4><p>充值用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水</p>
<p><img src="/images/or02.jpg" alt="3915a6544403854d35678c81fe65f014.jpeg"></p>
<h4 id="2-支付"><a href="#2-支付" class="headerlink" title="2. 支付"></a>2. 支付</h4><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。<br><img src="/images/or03.jpg" alt="7eb44e2f8661d1c3debde85f79fb2c5e.jpeg"></p>
<h4 id="3-提现"><a href="#3-提现" class="headerlink" title="3. 提现"></a>3. 提现</h4><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。<br><img src="/images/or04.jpg" alt="66ede1de93d29b86a9194ea0f80d1e43.jpeg"></p>
<h4 id="4-查询余额"><a href="#4-查询余额" class="headerlink" title="4.查询余额"></a>4.查询余额</h4><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p>
<h4 id="5-查询交易流水"><a href="#5-查询交易流水" class="headerlink" title="5.查询交易流水"></a>5.查询交易流水</h4><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p>
<h4 id="钱包系统的设计思路-1"><a href="#钱包系统的设计思路-1" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h4><p>可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p>
<p><img src="/images/or05.jpg" alt="60d3cfec73986b52e3a6ef4fe147e562.jpeg"></p>
<p>以虚拟钱包的设计为例，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</p>
<p><img src="/images/or06.jpg" alt="d1a9aeb6642404f80a62293ab2e45630.jpeg"></p>
<p>充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？<br>虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p>
<p>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</p>
<p>可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p>
<p><img src="/images/or07.jpg" alt="fb356a2589a14f2f3440247e3c7a7718.jpeg"></p>
<h3 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h3><p>是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，省略了具体的代码实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VirtualWalletController &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123; ... &#125; &#x2F;&#x2F;查询余额</span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;出账</span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;入账</span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123; ...&#125; &#x2F;&#x2F;转账</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWalletBo &#123;&#x2F;&#x2F;省略getter&#x2F;setter&#x2F;constructor方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime;</span><br><span class="line">  private BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWalletBo getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWalletBo walletBo &#x3D; convert(walletEntity);</span><br><span class="line">    return walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    if (balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new NoSufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity &#x3D; new VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId &#x3D; transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    try &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; catch (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h3><p>跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。</p>
<p>把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWallet &#123; &#x2F;&#x2F; Domain领域模型(充血模型)</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime &#x3D; System.currentTimeMillis();;</span><br><span class="line">  private BigDecimal balance &#x3D; BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet(Long preAllocatedId) &#123;</span><br><span class="line">    this.id &#x3D; preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal balance() &#123;</span><br><span class="line">    return this.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(BigDecimal amount) &#123;</span><br><span class="line">    if (this.balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(BigDecimal amount) &#123;</span><br><span class="line">    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">      throw new InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    return wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    &#x2F;&#x2F;...跟基于贫血模型的传统开发模式的代码一样...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p>
<p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p>
<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p>
<h3 id="精彩评论：充血模型可以说是业务的精准抽象"><a href="#精彩评论：充血模型可以说是业务的精准抽象" class="headerlink" title="精彩评论：充血模型可以说是业务的精准抽象"></a>精彩评论：充血模型可以说是业务的精准抽象</h3><p>我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。</p>
<p>在维护性上来说，如果项目新进了开发人员，如果是贫血模型的service代码，无论代码如何清晰，注释如何完备，代码结构设计得如何优雅，都没有办法第一时间理解系统的核心业务逻辑，但是如果是充血模型，直接阅读充血模型的行为方法，起码能够很快理解70%左右的业务逻辑，因为充血模型可以说是业务的精准抽象，我想，这就是领域模型驱动能够达到”驱动”效果的由来吧。</p>
<h2 id="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"></a>实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>1.第一轮寄出分析：<br>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>2.第二轮优化分析<br>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的， 存在 重放攻击问题。我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>3.第三轮优化分析</p>
<p>4.第四轮优化分析</p>
<p><img src="/images/or08.jpg" alt="bde932c73c6636ad85380e4801dbfb60.jpeg"></p>
<p>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p>
</li>
<li><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p>
</li>
</ol>
<p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p>
<p>3.针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求</p>
<h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.工作中遇到非crud的需求我就会想尽一切办法让他通用，基本需求分析和需求设计的时间占用百分之五十，开发和重构到自认为最优占用百分之五十。比如最简单的验证码功能，几乎每个项目都有，我就封装一套验证码服务，主要功能有你在配置文件里配置好需要被验证码拦截的路径，这里还要考虑到通配符，空格等等细节和可扩展的点，内置图片验证码，极验证，手机验证以及自定义验证码等等，总之我认为如果有机会遇到非crud的需求，一定要好好珍惜，好好把握，把他打造成属于自己的产品，这样会让自己下意识的去想尽一切办法把他做到最优，亲儿子一样的待遇，再也不会无脑cv</p>
<ol start="2">
<li>一句话：使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进。<br>拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：</li>
<li>什么叫接口鉴权？搞清基本概念</li>
<li>接口鉴权最佳实践是什么？技术调研</li>
<li>appid和secret key从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。</li>
<li>appid secretkey存储在什么地方呢？数据存储</li>
<li>用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。</li>
<li>这个功能如何测试？提前想好如何测试</li>
<li>接口鉴权功能何时上线？估计工期</li>
<li>鉴权成功或失败返回码和信息定义？约定返回结果</li>
</ol>
<p>关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击。</p>
<ol start="3">
<li>程序员十倍法则</li>
</ol>
<h2 id="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h2><p>向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p>
<h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p>
<p>例子：我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p>
<p>1.把 URL、AppID、密码、时间戳拼接为一个字符串；<br>2.对字符串通过加密算法加密生成 token；<br>3.将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；<br>4.解析 URL，得到 token、AppID、时间戳等信息；<br>5.从存储中取出 AppID 和对应的密码；<br>6.根据时间戳判断 token 是否过期失效；<br>7.验证两个 token 是否匹配；</p>
<p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p>
<h3 id="2-定义类及其属性和方法"><a href="#2-定义类及其属性和方法" class="headerlink" title="2. 定义类及其属性和方法"></a>2. 定义类及其属性和方法</h3><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p>
<p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage</p>
<p>AuthToken 类相关的功能点有四个：</p>
<ul>
<li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li>
<li>对字符串通过加密算法加密生成 token；</li>
<li>根据时间戳判断 token 是否过期失效；</li>
<li>验证两个 token 是否匹配。</li>
</ul>
<p><img src="/images/or09.jpg" alt="69c8954e0db1a4db99a6094ee359fc9b.jpeg"></p>
<p>Url 类相关的功能点有两个：</p>
<ul>
<li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li>解析 URL，得到 token、AppID、时间戳等信息。<br><img src="/images/or10.jpg" alt="1cc9b95e511bd49fbc23c00ac5c0fed6.jpeg"></li>
</ul>
<p>CredentialStorage 类相关的功能点有一个：</p>
<ul>
<li>从存储中取出 AppID 和对应的密码。</li>
</ul>
<p><img src="/images/or11.jpg" alt="3b6d2c0cadafa723e26cc032c29c8785.jpeg"></p>
<h3 id="3-定义类与类之间的交互关系"><a href="#3-定义类与类之间的交互关系" class="headerlink" title="3. 定义类与类之间的交互关系"></a>3. 定义类与类之间的交互关系</h3><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p>
<p>泛化（Generalization）可以简单理解为继承关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实现（Realization）一般是指接口和实现类之间的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>组合 （Composition）只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系强调部分与整体的关系，其中包括两种情况，关联性强（大雁与翅膀）的与关联性弱（学生与班级）的。（这里将将 UML 定义的 关联、聚合、组合 统一归类为组合）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">组合（Composition）：关联性强（大雁与翅膀）</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">聚合（Aggregation）：关联性弱（学生与班级）</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  public void func(B b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-将类组装起来并提供执行入口"><a href="#4-将类组装起来并提供执行入口" class="headerlink" title="4. 将类组装起来并提供执行入口"></a>4. 将类组装起来并提供执行入口</h3><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
<h3 id="评论区的代码实现参考"><a href="#评论区的代码实现参考" class="headerlink" title="评论区的代码实现参考"></a>评论区的代码实现参考</h3><p><a href="https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014</a></p>
<p><a href="https://gitee.com/MondayLiu/geek-design" target="_blank" rel="noopener">https://gitee.com/MondayLiu/geek-design</a></p>
<p><a href="https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth" target="_blank" rel="noopener">https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Design-Pattern/" rel="tag"># Design Pattern</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/05/design-pattern-design-principle/" rel="prev" title="设计模式之美-笔记Part3：设计原则">
      <i class="fa fa-chevron-left"></i> 设计模式之美-笔记Part3：设计原则
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/01/design-pattern-object-oriented01/" rel="next" title="设计模式之美-笔记Part1：面向对象-如何写出高质量的代码">
      设计模式之美-笔记Part1：面向对象-如何写出高质量的代码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><span class="nav-number">1.</span> <span class="nav-text">实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是基于贫血模型的传统开发模式？"><span class="nav-number">1.1.</span> <span class="nav-text">1.什么是基于贫血模型的传统开发模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-什么是基于充血模型的-DDD-开发模式？"><span class="nav-number">1.2.</span> <span class="nav-text">2.什么是基于充血模型的 DDD 开发模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-贫血模型-与-充血模型的代码模式区别"><span class="nav-number">1.3.</span> <span class="nav-text">3.贫血模型 与 充血模型的代码模式区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-为什么基于贫血模型的传统开发模式如此受欢迎？"><span class="nav-number">1.4.</span> <span class="nav-text">4.为什么基于贫血模型的传统开发模式如此受欢迎？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-什么时候该选择用贫血模型？什么时候该用充血模型？"><span class="nav-number">1.5.</span> <span class="nav-text">5.什么时候该选择用贫血模型？什么时候该用充血模型？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><span class="nav-number">2.</span> <span class="nav-text">实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#钱包系统的设计思路"><span class="nav-number">2.1.</span> <span class="nav-text">钱包系统的设计思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-充值"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.充值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-支付"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. 支付</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-提现"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. 提现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-查询余额"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.查询余额</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-查询交易流水"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.查询交易流水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#钱包系统的设计思路-1"><span class="nav-number">2.1.6.</span> <span class="nav-text">钱包系统的设计思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于贫血模型的传统开发模式"><span class="nav-number">2.2.</span> <span class="nav-text">基于贫血模型的传统开发模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于充血模型的-DDD-开发模式"><span class="nav-number">2.3.</span> <span class="nav-text">基于充血模型的 DDD 开发模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#精彩评论：充血模型可以说是业务的精准抽象"><span class="nav-number">2.5.</span> <span class="nav-text">精彩评论：充血模型可以说是业务的精准抽象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"><span class="nav-number">3.</span> <span class="nav-text">实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#需求："><span class="nav-number">3.1.</span> <span class="nav-text">需求：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析："><span class="nav-number">3.2.</span> <span class="nav-text">分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">3.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#精彩评论"><span class="nav-number">3.4.</span> <span class="nav-text">精彩评论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><span class="nav-number">4.</span> <span class="nav-text">实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-划分职责进而识别出有哪些类"><span class="nav-number">4.1.</span> <span class="nav-text">1. 划分职责进而识别出有哪些类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-定义类及其属性和方法"><span class="nav-number">4.2.</span> <span class="nav-text">2. 定义类及其属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-定义类与类之间的交互关系"><span class="nav-number">4.3.</span> <span class="nav-text">3. 定义类与类之间的交互关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-将类组装起来并提供执行入口"><span class="nav-number">4.4.</span> <span class="nav-text">4. 将类组装起来并提供执行入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#评论区的代码实现参考"><span class="nav-number">4.5.</span> <span class="nav-text">评论区的代码实现参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="crazyfzw"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">crazyfzw</p>
  <div class="site-description" itemprop="description">做个有趣的技术人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazyfzw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazyfzw" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.douban.com/people/crazyfzw/" title="Booklist → https:&#x2F;&#x2F;book.douban.com&#x2F;people&#x2F;crazyfzw&#x2F;" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Booklist</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:crazyfzw@gmail.com" title="E-Mail → mailto:crazyfzw@gmail.com" rel="noopener" target="_blank"><i class="fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/104894167431407693109" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;104894167431407693109" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100011315733045" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100011315733045" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3829383159" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3829383159" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.importnew.com/" title="http:&#x2F;&#x2F;www.importnew.com&#x2F;" rel="noopener" target="_blank">ImportNew</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/categories/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;categories&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ibm.com/developerworks/cn/java/" title="https:&#x2F;&#x2F;www.ibm.com&#x2F;developerworks&#x2F;cn&#x2F;java&#x2F;" rel="noopener" target="_blank">IBM developerworks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com&#x2F;" rel="noopener" target="_blank">美团点评技术团队</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://calvin1978.blogcn.com/" title="http:&#x2F;&#x2F;calvin1978.blogcn.com&#x2F;" rel="noopener" target="_blank">江南白衣的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.720ui.com/" title="http:&#x2F;&#x2F;blog.720ui.com" rel="noopener" target="_blank">梁桂钊的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/581f548ef0ec" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;581f548ef0ec" rel="noopener" target="_blank">李艳鹏的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jinnianshilongnian.iteye.com/" title="http:&#x2F;&#x2F;jinnianshilongnian.iteye.com&#x2F;" rel="noopener" target="_blank">张开涛的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/zuoxiaolong" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;zuoxiaolong" rel="noopener" target="_blank">左潇龙的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/xrq730/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xrq730&#x2F;" rel="noopener" target="_blank">五月的仓颉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yikun.github.io/" title="https:&#x2F;&#x2F;yikun.github.io&#x2F;" rel="noopener" target="_blank">Yikun的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/" title="http:&#x2F;&#x2F;www.ruanyifeng.com" rel="noopener" target="_blank">阮一峰的个人网站</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyfzw</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">545k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:16</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'jyxPxkBMeEmDfMMTuuyBdGdu-gzGzoHsz',
      appKey     : '7SEECyfT4R10oTtj4zDMOdBt',
      placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
