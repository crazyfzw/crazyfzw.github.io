<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazyfzw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。">
<meta property="og:type" content="article">
<meta property="og:title" content="总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）">
<meta property="og:url" content="https://crazyfzw.github.io/2020/10/08/design-pattern05/index.html">
<meta property="og:site_name" content="Crazyfzw&#39;s blog">
<meta property="og:description" content="总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。">
<meta property="og:image" content="https://crazyfzw.github.io/images/dp01.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/dp02.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/dp03.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/dp04.jpg">
<meta property="og:image" content="https://crazyfzw.github.io/images/dp05.jpg">
<meta property="article:published_time" content="2020-10-08T11:57:23.000Z">
<meta property="article:modified_time" content="2020-12-22T05:21:49.298Z">
<meta property="article:author" content="crazyfzw">
<meta property="article:tag" content="Design Pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crazyfzw.github.io/images/dp01.png">

<link rel="canonical" href="https://crazyfzw.github.io/2020/10/08/design-pattern05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4） | Crazyfzw's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Crazyfzw's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crazyfzw's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Return to base, step by step.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://crazyfzw.github.io/2020/10/08/design-pattern05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="crazyfzw">
      <meta itemprop="description" content="做个有趣的技术人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crazyfzw's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-08 19:57:23" itemprop="dateCreated datePublished" datetime="2020-10-08T19:57:23+08:00">2020-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-22 13:21:49" itemprop="dateModified" datetime="2020-12-22T13:21:49+08:00">2020-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index"><span itemprop="name">Design Pattern</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/08/design-pattern05/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/08/design-pattern05/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。</p>
<a id="more"></a>

<h2 id="如何写出高质量的代码"><a href="#如何写出高质量的代码" class="headerlink" title="如何写出高质量的代码"></a>如何写出高质量的代码</h2><p><img src="/images/dp01.png" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p>
<h2 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h2><p><img src="/images/dp02.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b.jpeg"></p>
<h2 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h2><p><img src="/images/dp03.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7.jpeg"></p>
<h3 id="面向对象的四大特性"><a href="#面向对象的四大特性" class="headerlink" title="面向对象的四大特性"></a>面向对象的四大特性</h3><ul>
<li><p>封装<br>封装主要讲如何隐藏信息、保护数据。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p>
</li>
<li><p>抽象<br>抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
</li>
<li><p>继承<br>继承用来表示类之间的 is-a 关系，继承主要是用来解决代码复用的问题。</p>
</li>
<li><p>多态<br>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p>
</li>
</ul>
<h3 id="面向对象-VS-面向过程"><a href="#面向对象-VS-面向过程" class="headerlink" title="面向对象 VS 面向过程"></a>面向对象 VS 面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个：</p>
<ul>
<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li>
<li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li>
<li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li>
</ul>
<p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p>
<h3 id="面向对象分析、设计与编程"><a href="#面向对象分析、设计与编程" class="headerlink" title="面向对象分析、设计与编程"></a>面向对象分析、设计与编程</h3><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。面向对象分析就是要搞清楚做什么，产出是详细的需求描述；面向对象设计就是要搞清楚怎么做，产出是类；面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p>
<p>在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p>
<ul>
<li><p>划分职责进而识别出有哪些类<br>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p>
</li>
<li><p>定义类及其属性和方法<br>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p>
</li>
<li><p>定义类与类之间的交互关系<br>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。（需要注意聚合和组合的区别）</p>
</li>
<li><p>将类组装起来并提供执行入口<br>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
</li>
</ul>
<h3 id="接口-vs-抽象类"><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h3><p>可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p>
<p>接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p>
<p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p>
<p>什么时候该用抽象类？什么时候该用接口？<br>实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p>
<h3 id="基于接口而非实现编程（即基于抽象而非实现编程）"><a href="#基于接口而非实现编程（即基于抽象而非实现编程）" class="headerlink" title="基于接口而非实现编程（即基于抽象而非实现编程）"></a>基于接口而非实现编程（即基于抽象而非实现编程）</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>组合相比继承有哪些优势？<br>继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。但是继承容易出现层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<p>而通过组合、接口、委托三个技术就可以在实现继承功能的同时，解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<p>如何判断该用组合还是继承？<br>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<h3 id="贫血模型-VS-充血模型"><a href="#贫血模型-VS-充血模型" class="headerlink" title="贫血模型 VS 充血模型"></a>贫血模型 VS 充血模型</h3><p>对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。  而对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用。</p>
<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p>
<h2 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h2><p><img src="/images/dp04.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f.jpeg"></p>
<h3 id="1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）"><a href="#1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）"></a>1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li>类依赖的其他类过多或者依赖类的其他类过多；</li>
<li>私有方法过多；</li>
<li>比较难给类起一个合适的名字；</li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>
<h3 id="2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）"><a href="#2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）" class="headerlink" title="2.SOLID 原则：OCP 开闭原则（Open Closed Principle）"></a>2.SOLID 原则：OCP 开闭原则（Open Closed Principle）</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<p>两点要注意：</p>
<ul>
<li>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li>
<li>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li>
</ul>
<h3 id="3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）"><a href="#3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）"></a>3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<p>里式替换原则跟多态的区别：</p>
<ul>
<li>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</li>
<li>里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li>
</ul>
<h3 id="4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）"><a href="#4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）" class="headerlink" title="4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）"></a>4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。</p>
<ul>
<li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li>
<li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li>
<li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</li>
</ul>
<p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）"><a href="#5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）" class="headerlink" title="5.DIP 依赖倒置原则 （Dependency Inversion Principle）"></a>5.DIP 依赖倒置原则 （Dependency Inversion Principle）</h3><p>依赖反转原则也叫作依赖倒置原则。主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p>
<h3 id="6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）"><a href="#6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）" class="headerlink" title="6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）"></a>6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）</h3><h4 id="Keep-It-Simple-and-Stupid"><a href="#Keep-It-Simple-and-Stupid" class="headerlink" title="Keep It Simple and Stupid"></a>Keep It Simple and Stupid</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段</p>
<p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码；</li>
<li>不要重复造轮子，善于使用已经有的工具类库；</li>
<li>不要过度优化。</li>
</ul>
<h4 id="You-Ain’t-Gonna-Need-It"><a href="#You-Ain’t-Gonna-Need-It" class="headerlink" title="You Ain’t Gonna Need It"></a>You Ain’t Gonna Need It</h4><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p>
<p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p>
<h3 id="7-DRY-原则（Don’t-Repeat-Yourself）"><a href="#7-DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="7.DRY 原则（Don’t Repeat Yourself）"></a>7.DRY 原则（Don’t Repeat Yourself）</h3><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p>
<p>三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，</p>
<ul>
<li>功能语义不重复的代码，并不违反 DRY 原则。</li>
<li>实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。</li>
<li>代码执行重复也算是违反 DRY 原则。</li>
</ul>
<h3 id="8-LOD-迪米特法则（Law-of-Demeter）"><a href="#8-LOD-迪米特法则（Law-of-Demeter）" class="headerlink" title="8.LOD 迪米特法则（Law of Demeter）"></a>8.LOD 迪米特法则（Law of Demeter）</h3><p>迪米特法则的描述为：</p>
<ul>
<li>不该有直接依赖关系的类之间，不要有依赖；</li>
<li>有依赖关系的类之间，尽量只依赖必要的接口。</li>
</ul>
<p>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p>
<ul>
<li><p>高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</p>
</li>
<li><p>松耦合，指的是在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
</li>
</ul>
<h2 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h2><p><img src="/images/dp05.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a.jpeg"></p>
<h3 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1.重构概述"></a>1.重构概述</h3><h4 id="重构的目的：为什么重构（why）？"><a href="#重构的目的：为什么重构（why）？" class="headerlink" title="重构的目的：为什么重构（why）？"></a>重构的目的：为什么重构（why）？</h4><p>重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p>
<h4 id="重构的对象：重构什么（what）？"><a href="#重构的对象：重构什么（what）？" class="headerlink" title="重构的对象：重构什么（what）？"></a>重构的对象：重构什么（what）？</h4><p>可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p>
<ul>
<li>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</li>
<li></li>
<li>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</li>
</ul>
<h4 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p>
<h4 id="重构的方法：如何重构（how）？"><a href="#重构的方法：如何重构（how）？" class="headerlink" title="重构的方法：如何重构（how）？"></a>重构的方法：如何重构（how）？</h4><ul>
<li><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。</p>
</li>
<li><p>小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p>
</li>
</ul>
<h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><h4 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h4><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。这个“单元”一般是类或函数，而不是模块或者系统。</p>
<h4 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h4><p>单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。</p>
<h4 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h4><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。</p>
<p>对于单元测试，我们需要建立以下正确的认知：</p>
<ul>
<li>编写单元测试尽管繁琐，但并不是太耗时；</li>
<li>我们可以稍微放低单元测试的质量要求；</li>
<li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li>
<li>写单元测试一般不需要了解代码的实现逻辑；</li>
<li>单元测试框架无法测试多半是代码的可测试性不好。</li>
</ul>
<h4 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h4><ul>
<li>写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。</li>
<li>国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，</li>
<li>没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</li>
</ul>
<h3 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3.代码的可测试性"></a>3.代码的可测试性</h3><h4 id="什么是代码的可测试性？"><a href="#什么是代码的可测试性？" class="headerlink" title="什么是代码的可测试性？"></a>什么是代码的可测试性？</h4><p>所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p>
<h4 id="编写可测试性代码的最有效手段"><a href="#编写可测试性代码的最有效手段" class="headerlink" title="编写可测试性代码的最有效手段"></a>编写可测试性代码的最有效手段</h4><ul>
<li><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p>
</li>
<li><p>除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况</p>
</li>
</ul>
<h4 id="典型的、常见的测试不友好的代码（Anti-Patterns）"><a href="#典型的、常见的测试不友好的代码（Anti-Patterns）" class="headerlink" title="典型的、常见的测试不友好的代码（Anti-Patterns）"></a>典型的、常见的测试不友好的代码（Anti-Patterns）</h4><ul>
<li>代码中包含未决行为逻辑；</li>
<li>滥用可变全局变量；</li>
<li>滥用静态方法；</li>
<li>使用复杂的继承关系；</li>
<li>高度耦合的代码。</li>
</ul>
<h3 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h3><p>解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p>
<h4 id="如何判断代码是否需要解耦？"><a href="#如何判断代码是否需要解耦？" class="headerlink" title="如何判断代码是否需要解耦？"></a>如何判断代码是否需要解耦？</h4><p>间接的衡量：</p>
<ul>
<li>比如改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动</li>
<li>代码的可测试性是否好等等</li>
</ul>
<h4 id="如何给代码进行解耦"><a href="#如何给代码进行解耦" class="headerlink" title="如何给代码进行解耦"></a>如何给代码进行解耦</h4><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。还有一些设计模式，比如观察者模式。</p>
<h3 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h3><p>持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p>
<h4 id="命名与注释"><a href="#命名与注释" class="headerlink" title="命名与注释"></a>命名与注释</h4><ul>
<li><p>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</p>
</li>
<li><p>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p>
</li>
<li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。接口有两种命名方式。</p>
</li>
<li><p>一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</p>
</li>
<li><p>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p>
</li>
<li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</p>
</li>
</ul>
<h4 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h4><ul>
<li>将复杂的逻辑提炼拆分成函数和类；</li>
<li>通过拆分成多个函数的方式来处理参数过多的情况；</li>
<li>通过将参数封装为对象来处理参数过多的情况；</li>
<li>函数中不要使用参数来做代码执行逻辑的控制；</li>
<li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li>
<li>用字面常量取代魔法数；</li>
<li>利用解释性变量来解释复杂表达式。</li>
</ul>
<h4 id="统一代码风格、编码规范"><a href="#统一代码风格、编码规范" class="headerlink" title="统一代码风格、编码规范"></a>统一代码风格、编码规范</h4><p>最好能跟业内推荐的风格、开源项目的代码风格相一致，然后在公司内部形成统一，比如可以参照<br><a href="https://ucc-private-download.oss-cn-beijing.aliyuncs.com/66995068b45c4ebfa74afcfc2e76212c.pdf?Expires=1607054448&OSSAccessKeyId=LTAIvsP3ECkg4Nm9&Signature=KOnMQdpuOGJtZVeyIrGlDxkXIlU%3D" target="_blank" rel="noopener">阿里《Java开发手册（嵩山版）》</a></p>
<h4 id="阿里-Java开发手册（嵩山版）"><a href="#阿里-Java开发手册（嵩山版）" class="headerlink" title="阿里 Java开发手册（嵩山版）"></a>阿里 Java开发手册（嵩山版）</h4><p><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">下载地址</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Design-Pattern/" rel="tag"># Design Pattern</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/09/design-pattern-creational-pattern/" rel="prev" title="设计模式之美-笔记Part5：设计模式与范式-创建型">
      <i class="fa fa-chevron-left"></i> 设计模式之美-笔记Part5：设计模式与范式-创建型
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/07/design-pattern-refactoring/" rel="next" title="设计模式之美-笔记Part4：规范与重构">
      设计模式之美-笔记Part4：规范与重构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何写出高质量的代码"><span class="nav-number">1.</span> <span class="nav-text">如何写出高质量的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、代码质量评判标准"><span class="nav-number">2.</span> <span class="nav-text">一、代码质量评判标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、面向对象"><span class="nav-number">3.</span> <span class="nav-text">二、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的四大特性"><span class="nav-number">3.1.</span> <span class="nav-text">面向对象的四大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象-VS-面向过程"><span class="nav-number">3.2.</span> <span class="nav-text">面向对象 VS 面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象分析、设计与编程"><span class="nav-number">3.3.</span> <span class="nav-text">面向对象分析、设计与编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口-vs-抽象类"><span class="nav-number">3.4.</span> <span class="nav-text">接口 vs 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于接口而非实现编程（即基于抽象而非实现编程）"><span class="nav-number">3.5.</span> <span class="nav-text">基于接口而非实现编程（即基于抽象而非实现编程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用组合少用继承"><span class="nav-number">3.6.</span> <span class="nav-text">多用组合少用继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贫血模型-VS-充血模型"><span class="nav-number">3.7.</span> <span class="nav-text">贫血模型 VS 充血模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、设计原则"><span class="nav-number">4.</span> <span class="nav-text">三、设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）"><span class="nav-number">4.1.</span> <span class="nav-text">1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）"><span class="nav-number">4.2.</span> <span class="nav-text">2.SOLID 原则：OCP 开闭原则（Open Closed Principle）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）"><span class="nav-number">4.3.</span> <span class="nav-text">3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）"><span class="nav-number">4.4.</span> <span class="nav-text">4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）"><span class="nav-number">4.5.</span> <span class="nav-text">5.DIP 依赖倒置原则 （Dependency Inversion Principle）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）"><span class="nav-number">4.6.</span> <span class="nav-text">6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Keep-It-Simple-and-Stupid"><span class="nav-number">4.6.1.</span> <span class="nav-text">Keep It Simple and Stupid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#You-Ain’t-Gonna-Need-It"><span class="nav-number">4.6.2.</span> <span class="nav-text">You Ain’t Gonna Need It</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-DRY-原则（Don’t-Repeat-Yourself）"><span class="nav-number">4.7.</span> <span class="nav-text">7.DRY 原则（Don’t Repeat Yourself）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-LOD-迪米特法则（Law-of-Demeter）"><span class="nav-number">4.8.</span> <span class="nav-text">8.LOD 迪米特法则（Law of Demeter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何理解“高内聚、松耦合”？"><span class="nav-number">4.9.</span> <span class="nav-text">如何理解“高内聚、松耦合”？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、规范与重构"><span class="nav-number">5.</span> <span class="nav-text">四、规范与重构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-重构概述"><span class="nav-number">5.1.</span> <span class="nav-text">1.重构概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重构的目的：为什么重构（why）？"><span class="nav-number">5.1.1.</span> <span class="nav-text">重构的目的：为什么重构（why）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重构的对象：重构什么（what）？"><span class="nav-number">5.1.2.</span> <span class="nav-text">重构的对象：重构什么（what）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重构的时机：什么时候重构（when）？"><span class="nav-number">5.1.3.</span> <span class="nav-text">重构的时机：什么时候重构（when）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重构的方法：如何重构（how）？"><span class="nav-number">5.1.4.</span> <span class="nav-text">重构的方法：如何重构（how）？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-单元测试"><span class="nav-number">5.2.</span> <span class="nav-text">2.单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是单元测试？"><span class="nav-number">5.2.1.</span> <span class="nav-text">什么是单元测试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要写单元测试？"><span class="nav-number">5.2.2.</span> <span class="nav-text">为什么要写单元测试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何编写单元测试？"><span class="nav-number">5.2.3.</span> <span class="nav-text">如何编写单元测试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试为何难落地执行？"><span class="nav-number">5.2.4.</span> <span class="nav-text">单元测试为何难落地执行？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-代码的可测试性"><span class="nav-number">5.3.</span> <span class="nav-text">3.代码的可测试性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是代码的可测试性？"><span class="nav-number">5.3.1.</span> <span class="nav-text">什么是代码的可测试性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写可测试性代码的最有效手段"><span class="nav-number">5.3.2.</span> <span class="nav-text">编写可测试性代码的最有效手段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#典型的、常见的测试不友好的代码（Anti-Patterns）"><span class="nav-number">5.3.3.</span> <span class="nav-text">典型的、常见的测试不友好的代码（Anti-Patterns）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-大型重构：解耦"><span class="nav-number">5.4.</span> <span class="nav-text">4. 大型重构：解耦</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何判断代码是否需要解耦？"><span class="nav-number">5.4.1.</span> <span class="nav-text">如何判断代码是否需要解耦？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何给代码进行解耦"><span class="nav-number">5.4.2.</span> <span class="nav-text">如何给代码进行解耦</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-小型重构：编码规范"><span class="nav-number">5.5.</span> <span class="nav-text">5. 小型重构：编码规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命名与注释"><span class="nav-number">5.5.1.</span> <span class="nav-text">命名与注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编程技巧"><span class="nav-number">5.5.2.</span> <span class="nav-text">编程技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#统一代码风格、编码规范"><span class="nav-number">5.5.3.</span> <span class="nav-text">统一代码风格、编码规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阿里-Java开发手册（嵩山版）"><span class="nav-number">5.5.4.</span> <span class="nav-text">阿里 Java开发手册（嵩山版）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="crazyfzw"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">crazyfzw</p>
  <div class="site-description" itemprop="description">做个有趣的技术人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazyfzw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazyfzw" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.douban.com/people/crazyfzw/" title="Booklist → https:&#x2F;&#x2F;book.douban.com&#x2F;people&#x2F;crazyfzw&#x2F;" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Booklist</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:crazyfzw@gmail.com" title="E-Mail → mailto:crazyfzw@gmail.com" rel="noopener" target="_blank"><i class="fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/104894167431407693109" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;104894167431407693109" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100011315733045" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100011315733045" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3829383159" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3829383159" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.importnew.com/" title="http:&#x2F;&#x2F;www.importnew.com&#x2F;" rel="noopener" target="_blank">ImportNew</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/categories/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;categories&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ibm.com/developerworks/cn/java/" title="https:&#x2F;&#x2F;www.ibm.com&#x2F;developerworks&#x2F;cn&#x2F;java&#x2F;" rel="noopener" target="_blank">IBM developerworks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com&#x2F;" rel="noopener" target="_blank">美团点评技术团队</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://calvin1978.blogcn.com/" title="http:&#x2F;&#x2F;calvin1978.blogcn.com&#x2F;" rel="noopener" target="_blank">江南白衣的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.720ui.com/" title="http:&#x2F;&#x2F;blog.720ui.com" rel="noopener" target="_blank">梁桂钊的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/581f548ef0ec" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;581f548ef0ec" rel="noopener" target="_blank">李艳鹏的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jinnianshilongnian.iteye.com/" title="http:&#x2F;&#x2F;jinnianshilongnian.iteye.com&#x2F;" rel="noopener" target="_blank">张开涛的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/zuoxiaolong" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;zuoxiaolong" rel="noopener" target="_blank">左潇龙的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/xrq730/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xrq730&#x2F;" rel="noopener" target="_blank">五月的仓颉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yikun.github.io/" title="https:&#x2F;&#x2F;yikun.github.io&#x2F;" rel="noopener" target="_blank">Yikun的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/" title="http:&#x2F;&#x2F;www.ruanyifeng.com" rel="noopener" target="_blank">阮一峰的个人网站</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyfzw</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">549k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'jyxPxkBMeEmDfMMTuuyBdGdu-gzGzoHsz',
      appKey     : '7SEECyfT4R10oTtj4zDMOdBt',
      placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
