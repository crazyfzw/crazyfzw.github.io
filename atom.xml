<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Crazyfzw&#39;s blog</title>
  
  <subtitle>Return to base, step by step.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crazyfzw.github.io/"/>
  <updated>2021-01-02T07:50:20.179Z</updated>
  <id>https://crazyfzw.github.io/</id>
  
  <author>
    <name>crazyfzw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之美-笔记Part7：设计模式与范式-行为型</title>
    <link href="https://crazyfzw.github.io/2020/10/15/design-pattern-behavioral-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/15/design-pattern-behavioral-pattern/</id>
    <published>2020-10-15T01:17:50.000Z</published>
    <updated>2021-01-02T07:50:20.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式-详解各种应用场景下观察者模式的不同实现方式"><a href="#观察者模式-详解各种应用场景下观察者模式的不同实现方式" class="headerlink" title="观察者模式 详解各种应用场景下观察者模式的不同实现方式"></a>观察者模式 详解各种应用场景下观察者模式的不同实现方式</h2><p>（Observer Design Pattern）</p><h3 id="观察者模式的原理"><a href="#观察者模式的原理" class="headerlink" title="观察者模式的原理"></a>观察者模式的原理</h3><p>观察者模式（Observer Design Pattern） 也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：</p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p></blockquote><p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p><a id="more"></a><h3 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h3><p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：</p><ul><li>有同步阻塞的实现方式  </li><li>也有异步非阻塞的实现方式；</li><li>有进程内的实现方式，也有跨进程的实现方式。</li></ul><p>其中，进程内的观察者模式： </p><ol><li>可以通过handleRequest中创建新的线程代码的方式实现异步非阻塞的观察者模式 </li><li>更优雅的实现方式：基于 Google Guava EventBus 框架的设计思想去实现观察者模式</li></ol><p>跨进程的观察者模式（跨系统）：<br>基于消息队列（Message Queue）来实现。</p><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>根据不同的应用场景和需求，有完全不同的实现方式。<br>下面给出一种最经典的实现方式代码模版样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">  void registerObserver(Observer observer);</span><br><span class="line">  void removeObserver(Observer observer);</span><br><span class="line">  void notifyObservers(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">  void update(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">  private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerObserver(Observer observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void removeObserver(Observer observer) &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notifyObservers(Message message) &#123;</span><br><span class="line">    for (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverOne implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverTwo implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ConcreteSubject subject &#x3D; new ConcreteSubject();</span><br><span class="line">    subject.registerObserver(new ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(new ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(new Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a>观察者模式的应用场景</h3><p>观察者主要目的是将观察者与被观察者的代码解耦，观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><h3 id="以用户注册成功后需要发放优惠券等操作为例"><a href="#以用户注册成功后需要发放优惠券等操作为例" class="headerlink" title="以用户注册成功后需要发放优惠券等操作为例"></a>以用户注册成功后需要发放优惠券等操作为例</h3><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们需要做下面几件事：</p><ol><li>发放优惠券</li><li>发送欢迎邮件<br>…</li></ol><p>一开始最简单的代码说这样的， 但是存在一个问题， 比如后面需要添加更多的动作，或者把发放优惠券改成发放体验金，就需要频繁改动 register()函数的代码，违反开闭原则。</p><p>这时候如果应用  观察者模式 重构上述代码，则会让代码的拓展性和维护性变得很好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public interface RegObserver &#123;</span><br><span class="line">  void handleRegSuccess(long userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver implements RegObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver implements RegObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改</span><br><span class="line">  public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    for (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</p><h3 id="对比一下“生产者-消费者”模型和观察者模式的区别和联系"><a href="#对比一下“生产者-消费者”模型和观察者模式的区别和联系" class="headerlink" title="对比一下“生产者 - 消费者”模型和观察者模式的区别和联系"></a>对比一下“生产者 - 消费者”模型和观察者模式的区别和联系</h3><p>发布订阅和生产消费模型最大的区别在于：发布者（可观测对象）是知道订阅者（观察对象）的存在，因为它需要遍历订阅列表去发布事件；而生产消费模型因为有中间消息代理的存在，生产者和消费者完全不知道对方的存在，完全解耦</p><h3 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h3><h4 id="Google-Guava-EventBus"><a href="#Google-Guava-EventBus" class="headerlink" title="Google Guava EventBus"></a>Google Guava EventBus</h4><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p><p>用法示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  private EventBus eventBus;</span><br><span class="line">  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式</span><br><span class="line">    eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞模式</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRegObservers(List&lt;Object&gt; observers) &#123;</span><br><span class="line">    for (Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>EventBus、AsyncEventBus：Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。</li><li>register() 函数：EventBus 类提供了 register() 函数用来注册观察者。</li><li>unregister() 函数：从 EventBus 中删除某个观察者</li><li>post() 函数：EventBus 类提供了 post() 函数，用来给观察者发送消息。</li></ul><h4 id="手把手实现一个-EventBus-框架-1"><a href="#手把手实现一个-EventBus-框架-1" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2474" alt="ce842666fa3dc92bb8f4f2d8e75d12c6.jpeg"></p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2475" alt="bf7ef52a40b1e35b18f369265caca645.jpeg"></p><p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p><p>整个小框架的代码实现包括 5 个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。具体代码在《设计模式之美》 第57讲。<br><a href="https://time.geekbang.org/column/article/211239" target="_blank" rel="noopener">https://time.geekbang.org/column/article/211239</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><p>2.具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><p>3.观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><h2 id="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"><a href="#模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用" class="headerlink" title="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"></a>模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用</h2><p>Template Method Design Pattern</p><h3 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h3><p>模板模式，全称是模板方法设计模式，在 GoF 的《设计模式》一书中，它是这么定义的：</p><blockquote><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p></blockquote><p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>一个简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method1();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method2();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo &#x3D; ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><p>templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活。</p><h3 id="模板模式作的作用"><a href="#模板模式作的作用" class="headerlink" title="模板模式作的作用"></a>模板模式作的作用</h3><p>常用在框架开发中，通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。除此之外，模板模式还可以起到代码复用的作用。</p><h4 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h4><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p><h5 id="1-Java-InputStream-对模板模式的应用"><a href="#1-Java-InputStream-对模板模式的应用" class="headerlink" title="1.Java InputStream 对模板模式的应用"></a>1.Java InputStream 对模板模式的应用</h5><p>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。</p><p>下面以 InputStream 为例， read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    if (b &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;</span><br><span class="line">      throw new IndexOutOfBoundsException();</span><br><span class="line">    &#125; else if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int c &#x3D; read();</span><br><span class="line">    if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] &#x3D; (byte)c;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (; i &lt; len ; i++) &#123;</span><br><span class="line">        c &#x3D; read();</span><br><span class="line">        if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] &#x3D; (byte)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public abstract int read() throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ByteArrayInputStream extends InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public synchronized int read() &#123;</span><br><span class="line">    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Java-AbstractList-对模版模式的应用"><a href="#2-Java-AbstractList-对模版模式的应用" class="headerlink" title="2.Java AbstractList 对模版模式的应用"></a>2.Java AbstractList 对模版模式的应用</h5><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。相当于强制了子类必须重写add方法才能使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    boolean modified &#x3D; false;</span><br><span class="line">    for (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h4><h5 id="1-Java-Servlet-对模版模式的应用"><a href="#1-Java-Servlet-对模版模式的应用" class="headerlink" title="1.Java Servlet 对模版模式的应用"></a>1.Java Servlet 对模版模式的应用</h5><p>HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><p>HttpServlet 的 service() 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    if (!(req instanceof HttpServletRequest &amp;&amp;</span><br><span class="line">            res instanceof HttpServletResponse)) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; (HttpServletRequest) req;</span><br><span class="line">    response &#x3D; (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">            &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            if (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[1];</span><br><span class="line">        errArgs[0] &#x3D; method;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面看下 基于 Servlet 来开发一个Web项目的 hello world:</strong></p><p>如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    this.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(&quot;Hello World.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外,还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><h5 id="2-JUnit-TestCase"><a href="#2-JUnit-TestCase" class="headerlink" title="2.JUnit TestCase"></a>2.JUnit TestCase</h5><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</p><p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。TestCase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TestCase extends Assert implements Test &#123;</span><br><span class="line">  public void runBare() throws Throwable &#123;</span><br><span class="line">    Throwable exception &#x3D; null;</span><br><span class="line">    setUp();</span><br><span class="line">    try &#123;</span><br><span class="line">      runTest();</span><br><span class="line">    &#125; catch (Throwable running) &#123;</span><br><span class="line">      exception &#x3D; running;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">      &#125; catch (Throwable tearingDown) &#123;</span><br><span class="line">        if (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception !&#x3D; null) throw exception;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Sets up the fixture, for example, open a network connection.</span><br><span class="line">  * This method is called before a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void setUp() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Tears down the fixture, for example, close a network connection.</span><br><span class="line">  * This method is called after a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void tearDown() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式与Callback回调函数有何区别和联系？"></a>模板模式与Callback回调函数有何区别和联系？</h3><h4 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h4><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><h4 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。在一些框架、类库、组件等的设计中经常会用到。</p><p>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p><h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p><h5 id="一个经典的回调回调代码样例"><a href="#一个经典的回调回调代码样例" class="headerlink" title="一个经典的回调回调代码样例"></a>一个经典的回调回调代码样例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface ICallback &#123;</span><br><span class="line">  void methodToCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BClass &#123;</span><br><span class="line">  public void process(ICallback callback) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    BClass b &#x3D; new BClass();</span><br><span class="line">    b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象</span><br><span class="line">      @Override</span><br><span class="line">      public void methodToCallback() &#123;</span><br><span class="line">        System.out.println(&quot;Call back me.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p><h5 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h5><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。</p><p>JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class="line"> return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class="line"> Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class="line"> if (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class="line">   ResultSet rs &#x3D; null;</span><br><span class="line">   try &#123;</span><br><span class="line">    rs &#x3D; stmt.executeQuery(sql);</span><br><span class="line">    ResultSet rsToUse &#x3D; rs;</span><br><span class="line">    if (nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">     rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return rse.extractData(rsToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">    JdbcUtils.closeResultSet(rs);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String getSql() &#123;</span><br><span class="line">   return sql;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return execute(new QueryStatementCallback());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line"></span><br><span class="line"> Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());</span><br><span class="line"> Statement stmt &#x3D; null;</span><br><span class="line"> try &#123;</span><br><span class="line">  Connection conToUse &#x3D; con;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;</span><br><span class="line">    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class="line">   conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">  &#125;</span><br><span class="line">  stmt &#x3D; conToUse.createStatement();</span><br><span class="line">  applyStatementSettings(stmt);</span><br><span class="line">  Statement stmtToUse &#x3D; stmt;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">   stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  T result &#x3D; action.doInStatement(stmtToUse);</span><br><span class="line">  handleWarnings(stmt);</span><br><span class="line">  return result;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (SQLException ex) &#123;</span><br><span class="line">  &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock</span><br><span class="line">  &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  stmt &#x3D; null;</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">  con &#x3D; null;</span><br><span class="line">  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> finally &#123;</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h5><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button button &#x3D; (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    System.out.println(&quot;I am clicked.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。</p><h4 id="回调函数的区别和联系"><a href="#回调函数的区别和联系" class="headerlink" title="回调函数的区别和联系"></a>回调函数的区别和联系</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p><p>组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li></ul><p>小结：</p><ul><li><p>共同点：<br>回调函数跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。</p></li><li><p>不同点：<br>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p></li></ul><h2 id="策略模式-如何避免冗长的if-else-switch分支判断代码？"><a href="#策略模式-如何避免冗长的if-else-switch分支判断代码？" class="headerlink" title="策略模式 如何避免冗长的if-else/switch分支判断代码？"></a>策略模式 如何避免冗长的if-else/switch分支判断代码？</h2><p>Strategy Design Pattern</p><h3 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h3><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p><h3 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h3><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><ul><li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li><li>策略的创建由工厂类来完成，封装策略创建的细节。</li><li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li></ul><h4 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h4><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">  void algorithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h4><p>策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p><p>如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的。则可以事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(&quot;A&quot;, new ConcreteStrategyA());</span><br><span class="line">    strategies.put(&quot;B&quot;, new ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return strategies.get(type);</span><br></pre></td></tr></table></figure><p>如果策略是由状态的，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，则可以按下面传统的方式创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type.equals(&quot;A&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyA();</span><br><span class="line">    &#125; else if (type.equals(&quot;B&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3.策略的使用"></a>3.策略的使用</h4><p>策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p><p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略接口：EvictionStrategy</span><br><span class="line">&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span><br><span class="line">&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory</span><br><span class="line"></span><br><span class="line">public class UserCache &#123;</span><br><span class="line">  private Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  public UserCache(EvictionStrategy eviction) &#123;</span><br><span class="line">    this.eviction &#x3D; eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略 </span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; null;</span><br><span class="line">    Properties props &#x3D; new Properties();</span><br><span class="line">    props.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));</span><br><span class="line">    String type &#x3D; props.getProperty(&quot;eviction_type&quot;);</span><br><span class="line">    evictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略 (在种事先需要知道使用哪种策略，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。)</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用策略模式组合工厂模式避免分支判断"><a href="#利用策略模式组合工厂模式避免分支判断" class="headerlink" title="利用策略模式组合工厂模式避免分支判断"></a>利用策略模式组合工厂模式避免分支判断</h3><p>下面是一种非常常见的 if-else 场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    double discount &#x3D; 0.0;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125;</span><br><span class="line">    return discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。重构代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略的定义</span><br><span class="line">public interface DiscountStrategy &#123;</span><br><span class="line">  double calDiscount(Order order);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的创建</span><br><span class="line">public class DiscountStrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的使用</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    return discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。总结下本质，就是是借助“查表法”，根据 type查表来替代根据 type 分支判断。</p><h3 id="如何实现一个支持给不同大小文件排序的小程序？"><a href="#如何实现一个支持给不同大小文件排序的小程序？" class="headerlink" title="如何实现一个支持给不同大小文件排序的小程序？"></a>如何实现一个支持给不同大小文件排序的小程序？</h3><p>案例：写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。</p><p>最小原型原则，先实现个最基础的版本，然后再在这个基础上进行迭代优化。</p><p>1.0 版本的思路：将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      quickSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      externalSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      concurrentExternalSort(filePath);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      mapreduceSort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void quickSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 快速排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void externalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void concurrentExternalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 多线程外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void mapreduceSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用MapReduce多机排序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SortingTool &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Sorter sorter &#x3D; new Sorter();</span><br><span class="line">    sorter.sortFile(args[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行拆分重构,版本2.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public interface ISortAlg &#123;</span><br><span class="line">  void sort(String filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QuickSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcurrentExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapReduceSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SortAlgFactory &#123;</span><br><span class="line">  private static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    algs.put(&quot;QuickSort&quot;, new QuickSort());</span><br><span class="line">    algs.put(&quot;ExternalSort&quot;, new ExternalSort());</span><br><span class="line">    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());</span><br><span class="line">    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ISortAlg getSortAlg(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return algs.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg;</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写完全没问题。但如果特别想将 if-else 分支判断移除掉，可以进一步优化<br>出下面。 </p><p>3.0版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line">  private static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg &#x3D; null;</span><br><span class="line">    for (AlgRange algRange : algs) &#123;</span><br><span class="line">      if (algRange.inRange(fileSize)) &#123;</span><br><span class="line">        sortAlg &#x3D; algRange.getAlg();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class AlgRange &#123;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line">    private ISortAlg alg;</span><br><span class="line"></span><br><span class="line">    public AlgRange(long start, long end, ISortAlg alg) &#123;</span><br><span class="line">      this.start &#x3D; start;</span><br><span class="line">      this.end &#x3D; end;</span><br><span class="line">      this.alg &#x3D; alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ISortAlg getAlg() &#123;</span><br><span class="line">      return alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean inRange(long size) &#123;</span><br><span class="line">      return size &gt;&#x3D; start &amp;&amp; size &lt; end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重构后，把可变的部分隔离到了策略工厂类和 Sorter 类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</strong></p><p>有没办法在添加新策略的时候避免对策略工厂类的修改呢？ </p><p>具体是这么做的：可以通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。</p><p>一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h2 id="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"><a href="#职责链模式：框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"></a>职责链模式：框架中常用的过滤器、拦截器是如何实现的？</h2><p>模板模式、策略模式、职责链模式 这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h3 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h3><p>Chain Of Responsibility Design Pattern</p><blockquote><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><h4 id="实现方式一举例：-基于抽象类实现"><a href="#实现方式一举例：-基于抽象类实现" class="headerlink" title="实现方式一举例：(基于抽象类实现)"></a>实现方式一举例：(基于抽象类实现)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor &#x3D; successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void handle() &#123;</span><br><span class="line">    boolean handled &#x3D; doHandle();</span><br><span class="line">    if (successor !&#x3D; null &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract boolean doHandle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head &#x3D; null;</span><br><span class="line">  private Handler tail &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">      head &#x3D; handler;</span><br><span class="line">      tail &#x3D; handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head !&#x3D; null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式二举例：（基于接口实现）"><a href="#实现方式二举例：（基于接口实现）" class="headerlink" title="实现方式二举例：（基于接口实现）"></a>实现方式二举例：（基于接口实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled &#x3D; handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。</p><h3 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h3><h4 id="实现可灵活扩展算法的敏感信息过滤框架"><a href="#实现可灵活扩展算法的敏感信息过滤框架" class="headerlink" title="实现可灵活扩展算法的敏感信息过滤框架"></a>实现可灵活扩展算法的敏感信息过滤框架</h4><p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface SensitiveWordFilter &#123;</span><br><span class="line">  boolean doFilter(Content content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SexyWordFilter implements SensitiveWordFilter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean doFilter(Content content) &#123;</span><br><span class="line">    boolean legal &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="line"></span><br><span class="line">public class SensitiveWordFilterChain &#123;</span><br><span class="line">  private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addFilter(SensitiveWordFilter filter) &#123;</span><br><span class="line">    this.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.</span><br><span class="line">  public boolean filter(Content content) &#123;</span><br><span class="line">    for (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      if (!filter.doFilter(content)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();</span><br><span class="line">    filterChain.addFilter(new AdsWordFilter());</span><br><span class="line">    filterChain.addFilter(new SexyWordFilter());</span><br><span class="line">    filterChain.addFilter(new PoliticalWordFilter());</span><br><span class="line"></span><br><span class="line">    boolean legal &#x3D; filterChain.filter(new Content());</span><br><span class="line">    if (!legal) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不发表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 发表</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>职责链模式降低了代码的复杂性：<br>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p><p>职责链模式让代码满足开闭原则，提高了代码的扩展性：<br>当需要添加新的过滤算法进来的时候，只需要新添加一个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。</p><p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</p><h3 id="框架中常用的过滤器、拦截器是如何实现的？"><a href="#框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="框架中常用的过滤器、拦截器是如何实现的？"></a>框架中常用的过滤器、拦截器是如何实现的？</h3><p>责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。</p><h4 id="Servlet-Filter-对职责链模式对应用"><a href="#Servlet-Filter-对职责链模式对应用" class="headerlink" title="Servlet Filter 对职责链模式对应用"></a>Servlet Filter 对职责链模式对应用</h4><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。</p><p>Servlet Filter 的工作原理<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2478" alt="3296abd63a61ebdf4eff3a6530979e21.jpeg"></p><h5 id="项目中该如何使用-Servlet-Filter-呢"><a href="#项目中该如何使用-Servlet-Filter-呢" class="headerlink" title="项目中该如何使用 Servlet Filter 呢?"></a>项目中该如何使用 Servlet Filter 呢?</h5><p>如下面的代码示例所示，添加一个过滤器，我们只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; 在创建Filter时自动调用，</span><br><span class="line">    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在销毁Filter时自动调用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在web.xml配置文件中如下配置：</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><h5 id="Servlet-Filter-的底层实现"><a href="#Servlet-Filter-的底层实现" class="headerlink" title="Servlet Filter 的底层实现"></a>Servlet Filter 的底层实现</h5><p>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。</p><p>Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final class ApplicationFilterChain implements FilterChain &#123;</span><br><span class="line">  private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter</span><br><span class="line">  private int n; &#x2F;&#x2F;filter的个数</span><br><span class="line">  private ApplicationFilterConfig[] filters;</span><br><span class="line">  private Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">    if (pos &lt; n) &#123;</span><br><span class="line">      ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br><span class="line">      Filter filter &#x3D; filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, this);&#x2F;&#x2F;这行就是递归调用了我们客户端自定义的Filter的方法</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; filter都处理完毕后，执行servlet</span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFilter(ApplicationFilterConfig filterConfig) &#123;</span><br><span class="line">    for (ApplicationFilterConfig filter:filters)</span><br><span class="line">      if (filter&#x3D;&#x3D;filterConfig)</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">    if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容</span><br><span class="line">      ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, 0, newFilters, 0, n);</span><br><span class="line">      filters &#x3D; newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] &#x3D; filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationFilterChain 的实现主要是 在FilterChai 的 doFilter 方法里面 递归调用。Filter 的  doFilter 方法。</p><h4 id="Spring-Interceptor-对职责链模式对应用"><a href="#Spring-Interceptor-对职责链模式对应用" class="headerlink" title="Spring Interceptor 对职责链模式对应用"></a>Spring Interceptor 对职责链模式对应用</h4><p>Spring Interceptor，翻译成中文就是拦截器。与 Servlet Filter 一样，都可以实现对 HTTP 请求进行拦截处理。</p><p>Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2477" alt="febaa9220cb9ad2f0aafd4e5c3c19868.jpeg"></p><p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p><h5 id="项目中该如何实现-Spring-Interceptor呢？"><a href="#项目中该如何实现-Spring-Interceptor呢？" class="headerlink" title="项目中该如何实现 Spring Interceptor呢？"></a>项目中该如何实现 Spring Interceptor呢？</h5><p>LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 继续后续的处理</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;这里总是被执行.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h5 id="Spring-Interceptor-的底层实现"><a href="#Spring-Interceptor-的底层实现" class="headerlink" title="Spring Interceptor 的底层实现"></a>Spring Interceptor 的底层实现</h5><p>andlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"> private final Object handler;</span><br><span class="line"> private HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, null);</span><br><span class="line">     return false;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">   throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    try &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">    &#125; catch (Throwable ex2) &#123;</span><br><span class="line">     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？"><a href="#AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？" class="headerlink" title="AOP、Servlet Filter、Spring Interceptor 该怎么选择？"></a>AOP、Servlet Filter、Spring Interceptor 该怎么选择？</h3><p>其实要实现一个鉴权的过滤器，通过以上3种方式都是可以去实现的，然而从粒度，场景，和方式上边有有所区别，主要采取用哪个，还是有业务来决定去用，没有统一的参考标准。比如要对所有的web接口，进行统一的权限处理，不需要区分动作，写或者读，所有一视同仁，这种情况下，servlet的更加适合。针对一些存在状态的，比如做一些统一的去参数转换，cookie转uid之类，以及通用检验uid是否符合当前权限，则很用mvc较好，而aop粒度就可以分的更加细致了，在一些更新需要，查询不需要的，如分控，日志记录等，就比较适合。</p><p>三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li><p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p></li><li><p>通过 Servlet Filter、Spring Interceptor 两个实际的例子，展示了在框架开发中职责链模式具体是怎么应用的。可以看到，职责链模式除了上面介绍的两种经典实现外，在实际使用中代码还是笔记灵活的，代码实现会根据不同的需求有所变化。</p></li></ul><h2 id="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"><a href="#状态模式：游戏、工作流引擎中常用的状态机是如何实现的？" class="headerlink" title="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"></a>状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</h2><p>Finite State Machine</p><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p><h3 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h3><p>状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>举例说明比如：马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2479" alt="5aa0310b9b3ea08794cfc2f376c8f96c.jpeg"></p><h3 id="举例说明状态及的三种实现方式"><a href="#举例说明状态及的三种实现方式" class="headerlink" title="举例说明状态及的三种实现方式"></a>举例说明状态及的三种实现方式</h3><h4 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SUPER;</span><br><span class="line">      this.score +&#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.CAPE;</span><br><span class="line">      this.score +&#x3D; 200;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.FIRE;</span><br><span class="line">      this.score +&#x3D; 300;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    if (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 100;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 200;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 300;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。</p><h4 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2480" alt="4f4ea3787bd955918578181e18173491.jpeg"></p><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public enum Event &#123;</span><br><span class="line">  GOT_MUSHROOM(0),</span><br><span class="line">  GOT_CAPE(1),</span><br><span class="line">  GOT_FIRE(2),</span><br><span class="line">  MET_MONSTER(3);</span><br><span class="line"></span><br><span class="line">  private int value;</span><br><span class="line"></span><br><span class="line">  private Event(int value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  private static final State[][] transitionTable &#x3D; &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private static final int[][] actionTable &#x3D; &#123;</span><br><span class="line">          &#123;+100, +200, +300, +0&#125;,</span><br><span class="line">          &#123;+0, +200, +300, -100&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -200&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -300&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void executeEvent(Event event) &#123;</span><br><span class="line">    int stateValue &#x3D; currentState.getValue();</span><br><span class="line">    int eventValue &#x3D; event.getValue();</span><br><span class="line">    this.currentState &#x3D; transitionTable[stateValue][eventValue];</span><br><span class="line">    this.score +&#x3D; actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h4><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p><p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。</p><p>IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public interface IMario &#123; &#x2F;&#x2F;所有状态类的接口</span><br><span class="line">  State getName();</span><br><span class="line">  &#x2F;&#x2F;以下是定义的事件</span><br><span class="line">  void obtainMushRoom();</span><br><span class="line">  void obtainCape();</span><br><span class="line">  void obtainFireFlower();</span><br><span class="line">  void meetMonster();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SmallMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SmallMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SuperMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SuperMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SuperMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SmallMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略CapeMario、FireMario类...</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; new SmallMario(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    this.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    this.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    this.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    this.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setScore(int score) &#123;</span><br><span class="line">    this.score &#x3D; score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setCurrentState(IMario currentState) &#123;</span><br><span class="line">    this.currentState &#x3D; currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式的代码实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。</p><p>针对这个问题，可以在接口和实现类中间加一层抽象类解决此问题，抽象类实现状态接口，状态类继承抽象类，只需要重写需要的方法即可。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h4 id="状态机的三个组成-状态、事件、动作"><a href="#状态机的三个组成-状态、事件、动作" class="headerlink" title="状态机的三个组成 状态、事件、动作"></a>状态机的三个组成 状态、事件、动作</h4><p>状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><h4 id="状态的三种实现方式的使用场景"><a href="#状态的三种实现方式的使用场景" class="headerlink" title="状态的三种实现方式的使用场景"></a>状态的三种实现方式的使用场景</h4><ul><li><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p></li><li><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p></li><li><p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p></li></ul><h2 id="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"><a href="#迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？" class="headerlink" title="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"></a>迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？</h2><p>Iterator Design Pattern</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p><p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p><h3 id="自己如何开发一个迭代器"><a href="#自己如何开发一个迭代器" class="headerlink" title="自己如何开发一个迭代器"></a>自己如何开发一个迭代器</h3><p>定义接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 接口定义方式一</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口定义方式二 (Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据)</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  E next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">  &#x2F;&#x2F;...省略其他接口函数...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用迭代器有哪些优势？"><a href="#使用迭代器有哪些优势？" class="headerlink" title="使用迭代器有哪些优势？"></a>使用迭代器有哪些优势？</h3><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p><ul><li><p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</p></li><li><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</p></li><li><p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p></li></ul><h3 id="遍历集合的同时，为什么不能增删集合元素？"><a href="#遍历集合的同时，为什么不能增删集合元素？" class="headerlink" title="遍历集合的同时，为什么不能增删集合元素？"></a>遍历集合的同时，为什么不能增删集合元素？</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor &lt; arrayList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;a&quot;);</span><br><span class="line">    names.add(&quot;b&quot;);</span><br><span class="line">    names.add(&quot;c&quot;);</span><br><span class="line">    names.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(&quot;a&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到第 57 行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2482" alt="d86223f2b0f996ebb2b21e5abbeceae9.jpeg"></p><p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><p>Visitor Design Pattern</p><blockquote><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p></blockquote><p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><h3 id="访问者模式实现举例"><a href="#访问者模式实现举例" class="headerlink" title="访问者模式实现举例"></a>访问者模式实现举例</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2483" alt="c42c636c5384da5bd5343618305db865.jpeg"></p><p>设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath &#x3D; filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line"></span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Extractor extractor &#x3D; new Extractor();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor &#x3D; new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h2 id="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"><a href="#备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？" class="headerlink" title="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"></a>备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？</h2><p>Memento Design Pattern</p><h3 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h3><p>备忘录模式，也叫快照（Snapshot）模式</p><blockquote><p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p></blockquote><p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h2 id="命令模式：如何利用命令模式实现一个手游后端架构？"><a href="#命令模式：如何利用命令模式实现一个手游后端架构？" class="headerlink" title="命令模式：如何利用命令模式实现一个手游后端架构？"></a>命令模式：如何利用命令模式实现一个手游后端架构？</h2><p>Command Design Pattern</p><blockquote><p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p></blockquote><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2 id="解释器模式：如何设计实现一个自定义接口告警规则功能？"><a href="#解释器模式：如何设计实现一个自定义接口告警规则功能？" class="headerlink" title="解释器模式：如何设计实现一个自定义接口告警规则功能？"></a>解释器模式：如何设计实现一个自定义接口告警规则功能？</h2><p>解释器模式的英文翻译是 Interpreter Design Pattern</p><blockquote><p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p></blockquote><p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h2 id="中介模式：什么时候用中介模式？什么时候用观察者模式？"><a href="#中介模式：什么时候用中介模式？什么时候用观察者模式？" class="headerlink" title="中介模式：什么时候用中介模式？什么时候用观察者模式？"></a>中介模式：什么时候用中介模式？什么时候用观察者模式？</h2><p>中介模式的英文翻译是 Mediator Design Pattern。</p><h3 id="中介模式的原理与实现"><a href="#中介模式的原理与实现" class="headerlink" title="中介模式的原理与实现"></a>中介模式的原理与实现</h3><blockquote><p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p></blockquote><p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2502" alt="4376d541bf17a029f37aa76009ef3a9f.jpeg"></p><h3 id="中介模式与观察者模式的区别"><a href="#中介模式与观察者模式的区别" class="headerlink" title="中介模式与观察者模式的区别"></a>中介模式与观察者模式的区别</h3><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式-详解各种应用场景下观察者模式的不同实现方式&quot;&gt;&lt;a href=&quot;#观察者模式-详解各种应用场景下观察者模式的不同实现方式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式 详解各种应用场景下观察者模式的不同实现方式&quot;&gt;&lt;/a&gt;观察者模式 详解各种应用场景下观察者模式的不同实现方式&lt;/h2&gt;&lt;p&gt;（Observer Design Pattern）&lt;/p&gt;
&lt;h3 id=&quot;观察者模式的原理&quot;&gt;&lt;a href=&quot;#观察者模式的原理&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的原理&quot;&gt;&lt;/a&gt;观察者模式的原理&lt;/h3&gt;&lt;p&gt;观察者模式（Observer Design Pattern） 也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。&lt;/p&gt;
&lt;p&gt;一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part6：设计模式与范式-结构型</title>
    <link href="https://crazyfzw.github.io/2020/10/09/design-pattern-structural-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/09/design-pattern-structural-pattern/</id>
    <published>2020-10-09T14:37:56.000Z</published>
    <updated>2021-01-02T07:50:11.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>Proxy Design Pattern</p><a id="more"></a><h3 id="代理模式的原理与实现"><a href="#代理模式的原理与实现" class="headerlink" title="代理模式的原理与实现"></a>代理模式的原理与实现</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><h3 id="代理模式的具体实现"><a href="#代理模式的具体实现" class="headerlink" title="代理模式的具体实现"></a>代理模式的具体实现</h3><h4 id="1-让代理类和原始类实现同样的接口"><a href="#1-让代理类和原始类实现同样的接口" class="headerlink" title="1.让代理类和原始类实现同样的接口"></a>1.让代理类和原始类实现同样的接口</h4><p>如果原始类已经定义了接口，则代理类实现与原始类同样的接口</p><p>案例代码（收集接口的请求信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserController &#123;</span><br><span class="line">  UserVo login(String telephone, String password);</span><br><span class="line">  UserVo register(String telephone, String password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController implements IUserController &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略login逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略register逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserControllerProxy implements IUserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line">  private UserController userController;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy(UserController userController) &#123;</span><br><span class="line">    this.userController &#x3D; userController;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 委托</span><br><span class="line">    UserVo userVo &#x3D; userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="line">&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="line">IUserController userController &#x3D; new UserControllerProxy(new UserController());</span><br></pre></td></tr></table></figure><h4 id="2-让代理类继承原始类的方法来实现代理模式"><a href="#2-让代理类继承原始类的方法来实现代理模式" class="headerlink" title="2.让代理类继承原始类的方法来实现代理模式"></a>2.让代理类继承原始类的方法来实现代理模式</h4><p>如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class UserControllerProxy extends UserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">UserController userController &#x3D; new UserControllerProxy();</span><br></pre></td></tr></table></figure><h4 id="两种实现方式的对比"><a href="#两种实现方式的对比" class="headerlink" title="两种实现方式的对比"></a>两种实现方式的对比</h4><ul><li><p>组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。</p></li><li><p>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。</p></li></ul><h3 id="动态代理的原理与实现"><a href="#动态代理的原理与实现" class="headerlink" title="动态代理的原理与实现"></a>动态代理的原理与实现</h3><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。</p><p>所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。</p><p>代码例子：（收集所有类的接口请求信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</span><br><span class="line">public class MetricsCollectorProxy &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public MetricsCollectorProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object createProxy(Object proxiedObject) &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);</span><br><span class="line">    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    public DynamicProxyHandler(Object proxiedObject) &#123;</span><br><span class="line">      this.proxiedObject &#x3D; proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">      long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      Object result &#x3D; method.invoke(proxiedObject, args);</span><br><span class="line">      long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();</span><br><span class="line">      RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MetricsCollectorProxy使用举例</span><br><span class="line">MetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();</span><br><span class="line">IUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</span><br></pre></td></tr></table></figure><p><strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</strong></p><h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><h4 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1. 业务系统的非功能性需求开发"></a>1. 业务系统的非功能性需求开发</h4><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><h4 id="2-代理模式在-RPC中的应用"><a href="#2-代理模式在-RPC中的应用" class="headerlink" title="2. 代理模式在 RPC中的应用"></a>2. 代理模式在 RPC中的应用</h4><p>RPC 框架也可以看作一种代理模式，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><h4 id="3-代理模式在缓存中的应用"><a href="#3-代理模式在缓存中的应用" class="headerlink" title="3. 代理模式在缓存中的应用"></a>3. 代理模式在缓存中的应用</h4><p>比如我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p><p>最简单的实现方法就是给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p><p>如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p><h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，只需要简单了解，见到能认识就可以。</p><h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：</p><blockquote><p>Decouple an abstraction from its implementation so that the two can vary independently。</p></blockquote><p>翻译成中文就是：将抽象和实现解耦，让它们可以独立变化。<br>弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p><p>还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><h3 id="JDBC利用桥接模式优雅实现数据库切换"><a href="#JDBC利用桥接模式优雅实现数据库切换" class="headerlink" title="JDBC利用桥接模式优雅实现数据库切换"></a>JDBC利用桥接模式优雅实现数据库切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序</span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;</span><br><span class="line">Connection con &#x3D; DriverManager.getConnection(url);</span><br><span class="line">Statement stmt &#x3D; con.createStatement()；</span><br><span class="line">String query &#x3D; &quot;select * from test&quot;;</span><br><span class="line">ResultSet rs&#x3D;stmt.executeQuery(query);</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">  rs.getString(1);</span><br><span class="line">  rs.getInt(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。</p><p>先看下 com.mysql.jdbc.Driver 的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">  static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Construct a new driver and register it with DriverManager</span><br><span class="line">   * @throws SQLException if a database error occurs.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Driver() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; Required for Class.forName().newInstance()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。</p><ul><li>第一件事情是要求 JVM 查找并加载指定的 Driver 类</li><li>第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</li></ul><p>Drivermanage代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line">  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;</span><br><span class="line">    if (driver !&#x3D; null) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(new DriverInfo(driver));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Connection getConnection(String url, String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2470" alt="812234b0717043a67c2d62ea8e783b40.jpeg"></p><p>JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p><h3 id="如何实现支持不同类型和渠道的消息推送系统？"><a href="#如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="如何实现支持不同类型和渠道的消息推送系统？"></a>如何实现支持不同类型和渠道的消息推送系统？</h3><p>一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>有两个维度，一个是不同规则，一个是不同渠道。</p><p>先看下最简单直接的代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public enum NotificationEmergencyLevel &#123;</span><br><span class="line">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Notification &#123;</span><br><span class="line">  private List&lt;String&gt; emailAddresses;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line">  private List&lt;String&gt; wechatIds;</span><br><span class="line"></span><br><span class="line">  public Notification() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public void setEmailAddress(List&lt;String&gt; emailAddress) &#123;</span><br><span class="line">    this.emailAddresses &#x3D; emailAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTelephones(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setWechatIds(List&lt;String&gt; wechatIds) &#123;</span><br><span class="line">    this.wechatIds &#x3D; wechatIds;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void notify(NotificationEmergencyLevel level, String message) &#123;</span><br><span class="line">    if (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...自动语音电话</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发微信</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p><p>按这个思路，对代码进行重构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public interface MsgSender &#123;</span><br><span class="line">  void send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TelephoneMsgSender implements MsgSender &#123;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line"></span><br><span class="line">  public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void send(String message) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WechatMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Notification &#123;</span><br><span class="line">  protected MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">  public Notification(MsgSender msgSender) &#123;</span><br><span class="line">    this.msgSender &#x3D; msgSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract void notify(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SevereNotification extends Notification &#123;</span><br><span class="line">  public SevereNotification(MsgSender msgSender) &#123;</span><br><span class="line">    super(msgSender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notify(String message) &#123;</span><br><span class="line">    msgSender.send(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UrgencyNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class NormalNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class TrivialNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>桥接看着就像是面向接口编程这一原则的原旨—将实现与抽象分离。</p><p>多个纬度独立变化那个解释倒是比较容易理解。文中举的警报的例子很贴切。紧急程度和警报的方式可以是两个不同的纬度。可以有不同的组合方式。</p><p>这与slf4j这一日志门面的设计有异曲同工之妙。slf4j其中有三个核心概念，logger,appender和encoder。分别指这个日志记录器负责哪个类的日志，日志打印到哪里以及日志打印的格式。三个纬度上可以有不同的实现，使用者可以在每一纬度上定义多个实现，配置文件中将各个纬度的某一个实现组合在一起就ok了。</p><p>一句话就是，桥接就是面向接口编程的集大成者。面向接口编程只是说在系统的某一个功能上将接口和实现解藕，而桥接是详细的分析系统功能，将各个独立的纬度都抽象出来，使用时按需组合。</p><h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>Decorator Pattern</p><h3 id="装饰器模式的理解"><a href="#装饰器模式的理解" class="headerlink" title="装饰器模式的理解"></a>装饰器模式的理解</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h3 id="装饰器的模版代码"><a href="#装饰器的模版代码" class="headerlink" title="装饰器的模版代码"></a>装饰器的模版代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-IO类库源码对装饰器模式的应用"><a href="#Java-IO类库源码对装饰器模式的应用" class="headerlink" title="Java IO类库源码对装饰器模式的应用"></a>Java IO类库源码对装饰器模式的应用</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2471" alt="507526c2e4b255a45c60722df14f9a05.jpeg"></p><p>避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void close() throws IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    throw new IOException(&quot;mark&#x2F;reset not supported&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FilterInputStream extends InputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected FilterInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read() throws IOException &#123;</span><br><span class="line">    return in.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    return in.read(b, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    return in.skip(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return in.available();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void close() throws IOException &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    in.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return in.markSupported();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BufferedInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected BufferedInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现基于缓存的读数据接口...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DataInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected DataInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现读取基本类型数据的接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2472" alt="5082df8e7d5a4d44a34811b9f562d613.jpeg"></p><h3 id="装饰器模式与代理模式的区别"><a href="#装饰器模式与代理模式的区别" class="headerlink" title="装饰器模式与代理模式的区别"></a>装饰器模式与代理模式的区别</h3><ul><li>代理模式中，代理类附加的是跟原始类无关的功能，侧重于业务无关的功能，隐藏了实现细节，是不需要使用者关注的</li></ul><ul><li>装饰器模式中，装饰器类附加的是跟原始类相关的增强功能，定制化诉求高，柔和了业务属性，后面可能改动频繁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A impelements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AProxy implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public AProxy(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);</span><br><span class="line">InputStream bin &#x3D; new BufferedInputStream(in);</span><br><span class="line">DataInputStream din &#x3D; new DataInputStream(bin);</span><br><span class="line">int data &#x3D; din.readInt();</span><br></pre></td></tr></table></figure><h3 id="添加缓存场景应该使用代理模式还说装饰者模式？"><a href="#添加缓存场景应该使用代理模式还说装饰者模式？" class="headerlink" title="添加缓存场景应该使用代理模式还说装饰者模式？"></a>添加缓存场景应该使用代理模式还说装饰者模式？</h3><ul><li><p>对于添加缓存这个应用场景使用哪种模式，要看设计者的意图，如果设计者不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之，如果设计者需要用户自己决定是否使用缓存的功能，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式。</p></li><li><p>缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活。</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>代理模式和装饰者模式都是 代码增强这一件事的落地方案。前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。</li></ul><ul><li>Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.Decorator体现多态性, Proxy体现封装性.reference:<br><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern" target="_blank" rel="noopener">https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern</a></li></ul><h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h2><p>Adapter Design Pattern</p><h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类适配器: 基于继承</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee &#x3D; adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); &#x2F;&#x2F;委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。</p><h4 id="1-封装有缺陷的接口设计"><a href="#1-封装有缺陷的接口设计" class="headerlink" title="1. 封装有缺陷的接口设计"></a>1. 封装有缺陷的接口设计</h4><p>当我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public static void staticFunction1() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">  public void uglyNamingFunction2() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line"></span><br><span class="line">  public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">   public void lowPerformanceFunction4() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行重构</span><br><span class="line">public class ITarget &#123;</span><br><span class="line">  void function1();</span><br><span class="line">  void function2();</span><br><span class="line">  void fucntion3(ParamsWrapperDefinition paramsWrapper);</span><br><span class="line">  void function4();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="line">public class CDAdaptor extends CD implements ITarget &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void function1() &#123;</span><br><span class="line">     super.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function2() &#123;</span><br><span class="line">    super.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function3(ParamsWrapperDefinition paramsWrapper) &#123;</span><br><span class="line">     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function4() &#123;</span><br><span class="line">    &#x2F;&#x2F;...reimplement it...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-统一多个类的接口设计"><a href="#2-统一多个类的接口设计" class="headerlink" title="2. 统一多个类的接口设计"></a>2. 统一多个类的接口设计</h4><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体</p><p>例子：假设我们的系统要对用户输入的文本内容做敏感词过滤，，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class ASensitiveWordsFilter &#123; &#x2F;&#x2F; A敏感词过滤系统提供的接口</span><br><span class="line">  &#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本</span><br><span class="line">  public String filterSexyWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterPoliticalWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BSensitiveWordsFilter  &#123; &#x2F;&#x2F; B敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CSensitiveWordsFilter &#123; &#x2F;&#x2F; C敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text, String mask) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="line">public class RiskManagement &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();</span><br><span class="line">  private BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();</span><br><span class="line">  private CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText &#x3D; bFilter.filter(maskedText);</span><br><span class="line">    maskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行改造</span><br><span class="line">public interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义</span><br><span class="line">  String filter(String text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter;</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="line">&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="line">public class RiskManagement &#123; </span><br><span class="line">  private List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; text;</span><br><span class="line">    for (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText &#x3D; filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-替换依赖的外部系统"><a href="#3-替换依赖的外部系统" class="headerlink" title="3. 替换依赖的外部系统"></a>3. 替换依赖的外部系统</h4><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 外部系统A</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  void fa();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例</span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public Demo(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">Demo d &#x3D; new Demo(new A());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将外部系统A替换成外部系统B</span><br><span class="line">public class BAdaptor implemnts IA &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public BAdaptor(B b) &#123;</span><br><span class="line">    this.b&#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">  public void fa() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="line">&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="line">Demo d &#x3D; new Demo(new BAdaptor(new B()));</span><br></pre></td></tr></table></figure><h4 id="4-兼容老版本接口"><a href="#4-兼容老版本接口" class="headerlink" title="4. 兼容老版本接口"></a>4. 兼容老版本接口</h4><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">  public static Emueration emumeration(final Collection c) &#123;</span><br><span class="line">    return new Enumeration() &#123;</span><br><span class="line">      Iterator i &#x3D; c.iterator();</span><br><span class="line">      </span><br><span class="line">      public boolean hasMoreElments() &#123;</span><br><span class="line">        return i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public Object nextElement() &#123;</span><br><span class="line">        return i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-适配不同格式的数据"><a href="#5-适配不同格式的数据" class="headerlink" title="5. 适配不同格式的数据"></a>5. 适配不同格式的数据</h4><p>适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stooges &#x3D; Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br></pre></td></tr></table></figure><h3 id="剖析适配器模式在-Java-日志中的应用（Slf4j）"><a href="#剖析适配器模式在-Java-日志中的应用（Slf4j）" class="headerlink" title="剖析适配器模式在 Java 日志中的应用（Slf4j）"></a>剖析适配器模式在 Java 日志中的应用（Slf4j）</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p><p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</p><p>如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。比如引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p><p>Slf4j 就是为了解决这个问题而产生的，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。</p><p>Slf4j 的适配器实现就是一个很好的适配器模式例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; slf4j统一的接口定义</span><br><span class="line">package org.slf4j;</span><br><span class="line">public interface Logger &#123;</span><br><span class="line">  public boolean isTraceEnabled();</span><br><span class="line">  public void trace(String msg);</span><br><span class="line">  public void trace(String format, Object arg);</span><br><span class="line">  public void trace(String format, Object arg1, Object arg2);</span><br><span class="line">  public void trace(String format, Object[] argArray);</span><br><span class="line">  public void trace(String msg, Throwable t);</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled();</span><br><span class="line">  public void debug(String msg);</span><br><span class="line">  public void debug(String format, Object arg);</span><br><span class="line">  public void debug(String format, Object arg1, Object arg2)</span><br><span class="line">  public void debug(String format, Object[] argArray)</span><br><span class="line">  public void debug(String msg, Throwable t);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...省略info、warn、error等一堆接口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; log4j日志框架的适配器</span><br><span class="line">&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="line">&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，</span><br><span class="line">&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="line">package org.slf4j.impl;</span><br><span class="line">public final class Log4jLoggerAdapter extends MarkerIgnoringBase</span><br><span class="line">  implements LocationAwareLogger, Serializable &#123;</span><br><span class="line">  final transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled() &#123;</span><br><span class="line">    return logger.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg1, Object arg2) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object[] argArray) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg, Throwable t) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略一堆接口的实现...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p><p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p><ul><li><p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p></li><li><p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p></li><li><p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p></li><li><p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p></li></ul><h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h2><p>Facade Design Pattern</p><h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>接口力度太大，则会不通用，接口力度太小，又影响易用性，门面模式就是用来解决接口的可复用性（通用性）和易用性之间的矛盾的。</p><p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。</p><blockquote><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p></blockquote><p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p><p>具体的做法就是：设计接口的时候还优先考虑复用性设计成比较单一职责的细粒度接口，然后额外根据外部系统的使用场景包装一层，提供一组更加简单易用、更高层的接口，从而让接口更易用。</p><p>比如A系统提供了a b c d 4个 接口，现在系统B 完成某个业务功能需要调用系统的 a b d 接口，考虑易用性，提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。这就是门面模式的应用了。</p><h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><h4 id="1-解决易用性问题"><a href="#1-解决易用性问题" class="headerlink" title="1. 解决易用性问题"></a>1. 解决易用性问题</h4><p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p><p>实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p><h4 id="2-解决性能问题"><a href="#2-解决性能问题" class="headerlink" title="2.解决性能问题"></a>2.解决性能问题</h4><p>通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高客户端的响应速度。</p><h4 id="3-解决分布式事务问题"><a href="#3-解决分布式事务问题" class="headerlink" title="3. 解决分布式事务问题"></a>3. 解决分布式事务问题</h4><p>比如这样一个场景，在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p><h3 id="如何组织门面接口和非门面接口？"><a href="#如何组织门面接口和非门面接口？" class="headerlink" title="如何组织门面接口和非门面接口？"></a>如何组织门面接口和非门面接口？</h3><ul><li>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。</li><li>如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li></ul><h3 id="适配器模式和门面模式的区别"><a href="#适配器模式和门面模式的区别" class="headerlink" title="适配器模式和门面模式的区别"></a>适配器模式和门面模式的区别</h3><p>适配器模式和门面模式的共同点是，将不好用的接口适配成好用的接口。那他们的区别是什么？</p><ul><li>适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。是一种“补偿模式”。</li><li>门面模式做接口整合，解决的是多接口调用带来的问题。是一种事前行为，是接口设计时该考虑的。</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</li><li>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</li></ul><h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>组合模式（Composite Design Pattern）</p><h3 id="组合模式的理解："><a href="#组合模式的理解：" class="headerlink" title="组合模式的理解："></a>组合模式的理解：</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>业务场景必须能够表示成树形结构。</p><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。（在这里一般可以抽象出一个抽象类，叶子节点和中间节点（根节点）继承与抽象类，对中间节点（根节点）处理就是递归的调用）</p><h3 id="如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="如何设计实现支持递归遍历的文件系统目录树结构？"></a>如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li>动态地添加、删除某个目录下的子目录或文件；</li><li>统计指定目录下的文件个数；</li><li>统计指定目录下的文件总大小。</li></ul><p>FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class FileSystemNode &#123;</span><br><span class="line">  private String path;</span><br><span class="line">  private boolean isFile;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path, boolean isFile) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">    this.isFile &#x3D; isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      File file &#x3D; new File(path);</span><br><span class="line">      if (!file.exists()) return 0;</span><br><span class="line">      return file.length();</span><br><span class="line">    &#125;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;a.txt</span><br><span class="line">     * &#x2F;wz&#x2F;b.txt</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;c.avi</span><br><span class="line">     * &#x2F;xzg&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;d.txt</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Directory fileSystemTree &#x3D; new Directory(&quot;&#x2F;&quot;);</span><br><span class="line">    Directory node_wz &#x3D; new Directory(&quot;&#x2F;wz&#x2F;&quot;);</span><br><span class="line">    Directory node_xzg &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;&quot;);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    File node_wz_a &#x3D; new File(&quot;&#x2F;wz&#x2F;a.txt&quot;);</span><br><span class="line">    File node_wz_b &#x3D; new File(&quot;&#x2F;wz&#x2F;b.txt&quot;);</span><br><span class="line">    Directory node_wz_movies &#x3D; new Directory(&quot;&#x2F;wz&#x2F;movies&#x2F;&quot;);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    File node_wz_movies_c &#x3D; new File(&quot;&#x2F;wz&#x2F;movies&#x2F;c.avi&quot;);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    Directory node_xzg_docs &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;docs&#x2F;&quot;);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    File node_xzg_docs_d &#x3D; new File(&quot;&#x2F;xzg&#x2F;docs&#x2F;d.txt&quot;);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;&#x2F; files num:&quot; + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(&quot;&#x2F;wz&#x2F; files num:&quot; + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式 Flyweight Design Pattern</p><h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h3 id="享元模式的实现"><a href="#享元模式的实现" class="headerlink" title="享元模式的实现"></a>享元模式的实现</h3><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p><p>以利用享元模式在棋局游戏中节省内存为例：</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 享元类</span><br><span class="line">public class ChessPieceUnit &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String text;</span><br><span class="line">  private Color color;</span><br><span class="line"></span><br><span class="line">  public ChessPieceUnit(int id, String text, Color color) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.text &#x3D; text;</span><br><span class="line">    this.color &#x3D; color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static enum Color &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...省略其他属性和getter方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPieceUnitFactory &#123;</span><br><span class="line">  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;</span><br><span class="line">    return pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPiece &#123;</span><br><span class="line">  private ChessPieceUnit chessPieceUnit;</span><br><span class="line">  private int positionX;</span><br><span class="line">  private int positionY;</span><br><span class="line"></span><br><span class="line">  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;</span><br><span class="line">    this.chessPieceUnit &#x3D; unit;</span><br><span class="line">    this.positionX &#x3D; positionX;</span><br><span class="line">    this.positionY &#x3D; positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 省略getter、setter方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessBoard &#123;</span><br><span class="line">  private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public ChessBoard() &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init() &#123;</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(1), 0,0));</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(2), 1,0));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p><h3 id="如何利用享元模式优化文本编辑器的内存占用？"><a href="#如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="如何利用享元模式优化文本编辑器的内存占用？"></a>如何利用享元模式优化文本编辑器的内存占用？</h3><p>以下代码，在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Character &#123;&#x2F;&#x2F;文字</span><br><span class="line">  private char c;</span><br><span class="line"></span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public Character(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, font, size, colorRGB);</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化方案：</strong><br>在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class CharacterStyle &#123;</span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public CharacterStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean equals(Object o) &#123;</span><br><span class="line">    CharacterStyle otherStyle &#x3D; (CharacterStyle) o;</span><br><span class="line">    return font.equals(otherStyle.font)</span><br><span class="line">            &amp;&amp; size &#x3D;&#x3D; otherStyle.size</span><br><span class="line">            &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CharacterStyleFactory &#123;</span><br><span class="line">  private static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    CharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);</span><br><span class="line">    for (CharacterStyle style : styles) &#123;</span><br><span class="line">      if (style.equals(newStyle)) &#123;</span><br><span class="line">        return style;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    styles.add(newStyle);</span><br><span class="line">    return newStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Character &#123;</span><br><span class="line">  private char c;</span><br><span class="line">  private CharacterStyle style;</span><br><span class="line"></span><br><span class="line">  public Character(char c, CharacterStyle style) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.style &#x3D; style;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="享元模式-VS-单例、缓存、对象池-的区别"><a href="#享元模式-VS-单例、缓存、对象池-的区别" class="headerlink" title="享元模式 VS 单例、缓存、对象池 的区别"></a>享元模式 VS 单例、缓存、对象池 的区别</h3><p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。</p><ul><li><p>应用单例模式是为了保证对象全局唯一。</p></li><li><p>应用享元模式是为了实现对象复用，节省内存。享元模式中的“复用”可以理解为“共享使用”。</p></li><li><p>缓存是为了提高访问效率，而非复用。</p></li><li><p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。比如对象池，线程池</p></li></ul><p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p><h3 id="剖析享元模式在Java-Integer、String中的应用"><a href="#剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="剖析享元模式在Java Integer、String中的应用"></a>剖析享元模式在Java Integer、String中的应用</h3><h4 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h4><p>自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 56; &#x2F;&#x2F;自动装箱</span><br><span class="line">int j &#x3D; i; &#x2F;&#x2F;自动拆箱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i &#x3D; 56；底层执行了：Integer i &#x3D; Integer.valueOf(56);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j &#x3D; i; 底层执行了：int j &#x3D; i.intValue();</span><br></pre></td></tr></table></figure><p>为什么下面代码的运行结果为 一个 true, 一个false？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 &#x3D; 56;</span><br><span class="line">Integer i2 &#x3D; 56;</span><br><span class="line">Integer i3 &#x3D; 129;</span><br><span class="line">Integer i4 &#x3D; 129;</span><br><span class="line">System.out.println(i1 &#x3D;&#x3D; i2);</span><br><span class="line">System.out.println(i3 &#x3D;&#x3D; i4);</span><br></pre></td></tr></table></figure><p>这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建，Integer 类的 valueOf() 函数的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntegerCache 则是生产享元对象的工厂类 （只说名字不叫XXXFactory），代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">        int h &#x3D; 127;</span><br><span class="line">        String integerCacheHighPropValue &#x3D;</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">                i &#x3D; Math.max(i, 127);</span><br><span class="line">                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high &#x3D; h;</span><br><span class="line"></span><br><span class="line">        cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">        int j &#x3D; low;</span><br><span class="line">        for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] &#x3D; new Integer(j++);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。不过 JDK 也提供了方法来让我们可以自定义缓存的最大值(没有提供设置最小值的方法)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure><p>除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。比如 Long 类型对应的 LongCache 享元工厂类及 valueOf()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static class LongCache &#123;</span><br><span class="line">    private LongCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] &#x3D; new Long(i - 128);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Long valueOf(long l) &#123;</span><br><span class="line">    final int offset &#x3D; 128;</span><br><span class="line">    if (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; &#x2F;&#x2F; will cache</span><br><span class="line">        return LongCache.cache[(int)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面三种创建对象的方式，推荐使用哪种？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; new Integer(123);</span><br><span class="line">Integer a &#x3D; 123;</span><br><span class="line">Integer a &#x3D; Integer.valueOf(123);</span><br></pre></td></tr></table></figure><p>答案是推荐使用后面两种，第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p><h4 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s2 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;小争哥&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);  &#x2F;&#x2F;运行结果为：true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);  &#x2F;&#x2F;运行结果为：false</span><br></pre></td></tr></table></figure><p>跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2473" alt="2dfc18575c22efccca191c566b24a22d.jpeg"></p><h4 id="String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？"><a href="#String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？" class="headerlink" title="String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？"></a>String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？</h4><ul><li><p>Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。</p></li><li><p>对于字符串来说，没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。&lt;/p&gt;
&lt;h2 id=&quot;代理模式：代理在RPC、缓存、监控等场景中的应用&quot;&gt;&lt;a href=&quot;#代理模式：代理在RPC、缓存、监控等场景中的应用&quot; class=&quot;headerlink&quot; title=&quot;代理模式：代理在RPC、缓存、监控等场景中的应用&quot;&gt;&lt;/a&gt;代理模式：代理在RPC、缓存、监控等场景中的应用&lt;/h2&gt;&lt;p&gt;Proxy Design Pattern&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part5：设计模式与范式-创建型</title>
    <link href="https://crazyfzw.github.io/2020/10/09/design-pattern-creational-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/09/design-pattern-creational-pattern/</id>
    <published>2020-10-09T03:32:23.000Z</published>
    <updated>2021-01-02T07:50:06.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><ul><li><p>单例模式用来创建全局唯一的对象。</p></li><li><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p></li><li><p>建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p></li><li><p>原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p></li></ul><a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h3 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h3><h4 id="处理资源访问冲突"><a href="#处理资源访问冲突" class="headerlink" title="处理资源访问冲突"></a>处理资源访问冲突</h4><p>可以使用单例解决资源访问冲突的问题。</p><p>案例：实现了一个往文件中打印日志的 Logger 类</p><p>第一版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(&quot;Created an order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2466" alt="2b0e6141d10399430c59169af4edc3c2.jpeg"></p><p>改造一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2467" alt="203eb5070c3820b48500d4ab95732f29.jpeg"></p><p>FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题。</p><h5 id="通过类级别的锁解决日志覆盖问题"><a href="#通过类级别的锁解决日志覆盖问题" class="headerlink" title="通过类级别的锁解决日志覆盖问题"></a>通过类级别的锁解决日志覆盖问题</h5><p>把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。</p><p>单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(Logger.class) &#123; &#x2F;&#x2F; 类级别的锁</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过单例更优雅的解决日志覆盖问题"><a href="#通过单例更优雅的解决日志覆盖问题" class="headerlink" title="通过单例更优雅的解决日志覆盖问题"></a>通过单例更优雅的解决日志覆盖问题</h5><p>将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  private static final Logger instance &#x3D; new Logger();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static Logger getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表示全局唯一类"><a href="#表示全局唯一类" class="headerlink" title="表示全局唯一类"></a>表示全局唯一类</h4><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。</p><p>案例：实现一个唯一递增 ID 号码生成器</p><p>如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">public class IdGenerator &#123;</span><br><span class="line">  &#x2F;&#x2F; AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br><span class="line">  &#x2F;&#x2F; 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br><span class="line">  &#x2F;&#x2F; 比如下面会用到的incrementAndGet().</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">long id &#x3D; IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure><h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>要实现一个单例，主要关下面几个要点：</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><h4 id="饿汉式-不支持延迟加载"><a href="#饿汉式-不支持延迟加载" class="headerlink" title="饿汉式(不支持延迟加载)"></a>饿汉式(不支持延迟加载)</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式（支持延迟加载、并发度低）"><a href="#懒汉式（支持延迟加载、并发度低）" class="headerlink" title="懒汉式（支持延迟加载、并发度低）"></a>懒汉式（支持延迟加载、并发度低）</h4><p>懒汉式相对于饿汉式的优势是支持延迟加载。给 getInstance() 这个方法加了一把大锁（synchronzed），这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static synchronized IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      instance &#x3D; new IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检测-（支持延迟加载，支持高并发）"><a href="#双重检测-（支持延迟加载，支持高并发）" class="headerlink" title="双重检测 （支持延迟加载，支持高并发）"></a>双重检测 （支持延迟加载，支持高并发）</h4><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">          instance &#x3D; new IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低版本的JDK 因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。可以通过给 instance 成员变量加上 volatile 关键字，禁止指令重排序解决这个问题。  </p><p>需要注意的是高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p><h4 id="静态内部类-既保证了线程安全，又能做到延迟加载"><a href="#静态内部类-既保证了线程安全，又能做到延迟加载" class="headerlink" title="静态内部类 (既保证了线程安全，又能做到延迟加载)"></a>静态内部类 (既保证了线程安全，又能做到延迟加载)</h4><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评论区给出的一种Spring-源码中的实现"><a href="#评论区给出的一种Spring-源码中的实现" class="headerlink" title="评论区给出的一种Spring 源码中的实现"></a>评论区给出的一种Spring 源码中的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ublic class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance&#x3D;null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;&#x2F;&#x2F;</span><br><span class="line">        Singleton temp&#x3D;instance; &#x2F;&#x2F; 为什么要用局部变量来接收</span><br><span class="line">        if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                temp&#x3D;instance;</span><br><span class="line">                if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">                    temp&#x3D;new Singleton();</span><br><span class="line">                    instance&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring源码 如 ReactiveAdapterRegistry。<br>JDK 源码 如 AbstractQueuedSynchronizer。<br>很多地方 都有用 局部变量 来接收 静态的成员变量， 请问下 这么写有什么性能上的优化点吗？</p><p>Using localRef, we are reducing the access of volatile variable to just one for positive usecase. If we do not use localRef, then we would have to access volatile variable twice - once for checking null and then at method return time.<br>Accessing volatile memory is quite an expensive affair because it involves reaching out to main memory.<br>参考链接：<a href="https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6" target="_blank" rel="noopener">https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6</a></p><h3 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h3><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h3 id="有何替代的解决方案？"><a href="#有何替代的解决方案？" class="headerlink" title="有何替代的解决方案？"></a>有何替代的解决方案？</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h3 id="如何设计实现一个集群环境下的分布式单例模式？"><a href="#如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="如何设计实现一个集群环境下的分布式单例模式？"></a>如何设计实现一个集群环境下的分布式单例模式？</h3><h4 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h4><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><h4 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h4><p>通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    Long currentThreadId &#x3D; Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, new IdGenerator());</span><br><span class="line">    return instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long getId() &#123;</span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h4><p>这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p>实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);</span><br><span class="line">  private static DistributedLock lock &#x3D; new DistributedLock();</span><br><span class="line">  </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static IdGenerator getInstance() </span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      instance &#x3D; storage.load(IdGenerator.class);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchroinzed void freeInstance() &#123;</span><br><span class="line">    storage.save(this, IdGeneator.class);</span><br><span class="line">    instance &#x3D; null; &#x2F;&#x2F;释放对象</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">IdGenerator idGeneator &#x3D; IdGenerator.getInstance();</span><br><span class="line">long id &#x3D; idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure><h4 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h4><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><h5 id="创建指定数量的对象："><a href="#创建指定数量的对象：" class="headerlink" title="创建指定数量的对象："></a>创建指定数量的对象：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BackendServer &#123;</span><br><span class="line">  private long serverNo;</span><br><span class="line">  private String serverAddress;</span><br><span class="line"></span><br><span class="line">  private static final int SERVER_COUNT &#x3D; 3;</span><br><span class="line">  private static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));</span><br><span class="line">    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));</span><br><span class="line">    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private BackendServer(long serverNo, String serverAddress) &#123;</span><br><span class="line">    this.serverNo &#x3D; serverNo;</span><br><span class="line">    this.serverAddress &#x3D; serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getInstance(long serverNo) &#123;</span><br><span class="line">    return serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getRandomInstance() &#123;</span><br><span class="line">    Random r &#x3D; new Random();</span><br><span class="line">    int no &#x3D; r.nextInt(SERVER_COUNT)+1;</span><br><span class="line">    return serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不同类型创建多个对象"><a href="#不同类型创建多个对象" class="headerlink" title="不同类型创建多个对象"></a>不同类型创建多个对象</h5><p>对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private static final ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static Logger getInstance(String loggerName) &#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, new Logger());</span><br><span class="line">    return instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void log() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3</span><br><span class="line">Logger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</span><br></pre></td></tr></table></figure><h3 id="如何理解单例类对象的唯一性的作用范围是类加载器"><a href="#如何理解单例类对象的唯一性的作用范围是类加载器" class="headerlink" title="如何理解单例类对象的唯一性的作用范围是类加载器"></a>如何理解单例类对象的唯一性的作用范围是类加载器</h3><p>对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）,怎么理解？</p><p>java中，两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。单例类对象的唯一性前提也必须保证该类被同一个类加载器加载！</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如 Java 中的 Calendar、DateFormat 类。</p><p>工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。</p><h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>例子： 根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><p>简单工厂的第一种实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    if (parser &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(</span><br><span class="line">              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    IRuleConfigParser parser &#x3D; null;</span><br><span class="line">    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new JsonRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new XmlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new YamlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p><p>简单工厂的第二种实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;</span><br><span class="line">      return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>可以利用多态去掉if分支逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface IRuleConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createParser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    if (parserFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="line">&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="line">public class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂</span><br><span class="line">  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParserFactory getParserFactory(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());</span><br><span class="line">    return parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface IConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createRuleParser();</span><br><span class="line">  ISystemConfigParser createSystemParser();</span><br><span class="line">  &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="什么时候该用工厂模式？"><a href="#什么时候该用工厂模式？" class="headerlink" title="什么时候该用工厂模式？"></a>什么时候该用工厂模式？</h4><ul><li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</p></li><li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p></li></ul><p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p><h4 id="复杂度无法被消除，只能被转移："><a href="#复杂度无法被消除，只能被转移：" class="headerlink" title="复杂度无法被消除，只能被转移："></a>复杂度无法被消除，只能被转移：</h4><ul><li>不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起</li><li>简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中</li><li>工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中</li></ul><h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。</p><p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><p>DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p><h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><h3 id="如何实现一个简单的DI容器"><a href="#如何实现一个简单的DI容器" class="headerlink" title="如何实现一个简单的DI容器"></a>如何实现一个简单的DI容器</h3><p>一个简单的 DI 容器的实现原理，核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h4 id="1-最小原型设计"><a href="#1-最小原型设计" class="headerlink" title="1.最小原型设计"></a>1.最小原型设计</h4><p>配置文件beans.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">            &quot;beans.xml&quot;);</span><br><span class="line">    RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-执行入口"><a href="#2-执行入口" class="headerlink" title="2.执行入口"></a>2.执行入口</h4><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口ClassPathXmlApplicationContext 是接口的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">  Object getBean(String beanId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;</span><br><span class="line">  private BeansFactory beansFactory;</span><br><span class="line">  private BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  public ClassPathXmlApplicationContext(String configLocation) &#123;</span><br><span class="line">    this.beansFactory &#x3D; new BeansFactory();</span><br><span class="line">    this.beanConfigParser &#x3D; new XmlBeanConfigParser();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void loadBeanDefinitions(String configLocation) &#123;</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);</span><br><span class="line">      if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO: log error</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    return beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h4 id="3-配置文件解析"><a href="#3-配置文件解析" class="headerlink" title="3.配置文件解析"></a>3.配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanConfigParser &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(InputStream inputStream);</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(String configContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlBeanConfigParser implements BeanConfigParser &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;</span><br><span class="line">    String content &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(String configContent) &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private String className;</span><br><span class="line">  private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  private Scope scope &#x3D; Scope.SINGLETON;</span><br><span class="line">  private boolean lazyInit &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line"> </span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static enum Scope &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class ConstructorArg &#123;</span><br><span class="line">    private boolean isRef;</span><br><span class="line">    private Class type;</span><br><span class="line">    private Object arg;</span><br><span class="line">    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-核心工厂类设计"><a href="#4-核心工厂类设计" class="headerlink" title="4.核心工厂类设计"></a>4.核心工厂类设计</h4><p>BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class BeansFactory &#123;</span><br><span class="line">  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;</span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);</span><br><span class="line">    if (beanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    return createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected Object createBean(BeanDefinition beanDefinition) &#123;</span><br><span class="line">    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object bean &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();</span><br><span class="line">      if (args.isEmpty()) &#123;</span><br><span class="line">        bean &#x3D; beanClass.newInstance();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Class[] argClasses &#x3D; new Class[args.size()];</span><br><span class="line">        Object[] argObjects &#x3D; new Object[args.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg &#x3D; args.get(i);</span><br><span class="line">          if (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] &#x3D; arg.getType();</span><br><span class="line">            argObjects[i] &#x3D; arg.getArg();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());</span><br><span class="line">            if (refBeanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] &#x3D; createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      throw new BeanCreationFailureException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。</p><h3 id="1-使用场景："><a href="#1-使用场景：" class="headerlink" title="1.使用场景："></a>1.使用场景：</h3><ul><li>类的构造函数必填属性很多，通过set设置，没有办法校验必填属性</li><li>如果类的属性之间有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验</li><li>需要创建不可变对象，不能暴露set方法。<br>（前提是需要传递很多的属性，如果属性很少，可以不需要建造者模式）</li></ul><h3 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2.实现方式："></a>2.实现方式：</h3><p>把构造函数定义为private，定义public static class Builder 内部类，通过Builder 类的set方法设置属性，调用build方法创建对象。</p><p>比如：</p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal;</span><br><span class="line">  private int maxIdle;</span><br><span class="line">  private int minIdle;</span><br><span class="line"></span><br><span class="line">  private ResourcePoolConfig(Builder builder) &#123;</span><br><span class="line">    this.name &#x3D; builder.name;</span><br><span class="line">    this.maxTotal &#x3D; builder.maxTotal;</span><br><span class="line">    this.maxIdle &#x3D; builder.maxIdle;</span><br><span class="line">    this.minIdle &#x3D; builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br><span class="line">  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">    private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    public ResourcePoolConfig build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new ResourcePoolConfig(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxTotal(int maxTotal) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxIdle(int maxIdle) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMinIdle(int minIdle) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="line">ResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(&quot;dbconnectionpool&quot;)</span><br><span class="line">        .setMaxTotal(16)</span><br><span class="line">        .setMaxIdle(10)</span><br><span class="line">        .setMinIdle(12)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="3-和工厂模式的区别："><a href="#3-和工厂模式的区别：" class="headerlink" title="3.和工厂模式的区别："></a>3.和工厂模式的区别：</h3><ul><li>工厂模式：创建不同的同一类型对象（集成同一个父类或是接口的一组子类），由给定的参数来创建哪种类型的对象；</li><li>建造者模式：创建一种类型的复杂对象，通过很多可设置参数，“定制化”的创建对象</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1.什么是原型模式"></a>1.什么是原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><h3 id="2-原型模式的两种实现方法"><a href="#2-原型模式的两种实现方法" class="headerlink" title="2.原型模式的两种实现方法"></a>2.原型模式的两种实现方法</h3><p>原型模式有两种实现方法，深拷贝和浅拷贝。</p><ul><li>浅拷贝只会复制对象中基本数据类型数据（比如，int、long）和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2468" alt="74bceb7a0736957daaa4abeba6826182.jpeg"></li></ul><ul><li>深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2469" alt="b978d054ab3183b9e0ae461e6abac81b.jpeg"></li></ul><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险。</p><h3 id="实现深拷贝的两种常见方式"><a href="#实现深拷贝的两种常见方式" class="headerlink" title="实现深拷贝的两种常见方式"></a>实现深拷贝的两种常见方式</h3><p>那如何实现深拷贝呢？</p><p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。</p><p>第二种方法：先将对象序列化，然后再反序列化成新的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object deepCopy(Object object) &#123;</span><br><span class="line">  ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line">  </span><br><span class="line">  ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">  ObjectInputStream oi &#x3D; new ObjectInputStream(bi);</span><br><span class="line">  </span><br><span class="line">  return oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-如何最快速地clone一个包含10万数据的HashMap散列表"><a href="#3-如何最快速地clone一个包含10万数据的HashMap散列表" class="headerlink" title="3.如何最快速地clone一个包含10万数据的HashMap散列表"></a>3.如何最快速地clone一个包含10万数据的HashMap散列表</h3><p>使用深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Deep copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">      SearchWord searchWord &#x3D; e.getValue();</span><br><span class="line">      SearchWord newSearchWord &#x3D; new SearchWord(</span><br><span class="line">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class="line">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这种特别大数据量大场景，有没有更快、更省内存的实现方式呢？</p><p>方案是：先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。</p><p>优化代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Shallow copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">      &#125;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-什么时候该用深拷贝，什么时候该用还是浅拷贝"><a href="#4-什么时候该用深拷贝，什么时候该用还是浅拷贝" class="headerlink" title="4.什么时候该用深拷贝，什么时候该用还是浅拷贝"></a>4.什么时候该用深拷贝，什么时候该用还是浅拷贝</h3><ul><li>当需要复制的对象只包含基本类型数据的时候，或者要考呗的对象是不可变对象的时候 选择使用浅拷贝。</li><li>当需要拷贝的对象包含其他对象的时候，使用深拷贝</li></ul><p>不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间，当数量特别大的时候也可以使用案例的优化方式，但没有充分的理由，在包含对象的时候，不要为了一点点的性能提升而使用浅拷贝。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单例模式用来创建全局唯一的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）</title>
    <link href="https://crazyfzw.github.io/2020/10/08/design-pattern05/"/>
    <id>https://crazyfzw.github.io/2020/10/08/design-pattern05/</id>
    <published>2020-10-08T11:57:23.000Z</published>
    <updated>2020-12-22T05:21:49.298Z</updated>
    
    <content type="html"><![CDATA[<p>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。</p><a id="more"></a><h2 id="如何写出高质量的代码"><a href="#如何写出高质量的代码" class="headerlink" title="如何写出高质量的代码"></a>如何写出高质量的代码</h2><p><img src="/images/dp01.png" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p><h2 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h2><p><img src="/images/dp02.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b.jpeg"></p><h2 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h2><p><img src="/images/dp03.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7.jpeg"></p><h3 id="面向对象的四大特性"><a href="#面向对象的四大特性" class="headerlink" title="面向对象的四大特性"></a>面向对象的四大特性</h3><ul><li><p>封装<br>封装主要讲如何隐藏信息、保护数据。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p></li><li><p>抽象<br>抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p></li><li><p>继承<br>继承用来表示类之间的 is-a 关系，继承主要是用来解决代码复用的问题。</p></li><li><p>多态<br>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p></li></ul><h3 id="面向对象-VS-面向过程"><a href="#面向对象-VS-面向过程" class="headerlink" title="面向对象 VS 面向过程"></a>面向对象 VS 面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个：</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h3 id="面向对象分析、设计与编程"><a href="#面向对象分析、设计与编程" class="headerlink" title="面向对象分析、设计与编程"></a>面向对象分析、设计与编程</h3><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。面向对象分析就是要搞清楚做什么，产出是详细的需求描述；面向对象设计就是要搞清楚怎么做，产出是类；面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul><li><p>划分职责进而识别出有哪些类<br>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p></li><li><p>定义类及其属性和方法<br>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p></li><li><p>定义类与类之间的交互关系<br>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。（需要注意聚合和组合的区别）</p></li><li><p>将类组装起来并提供执行入口<br>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p></li></ul><h3 id="接口-vs-抽象类"><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h3><p>可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p><p>接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？<br>实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h3 id="基于接口而非实现编程（即基于抽象而非实现编程）"><a href="#基于接口而非实现编程（即基于抽象而非实现编程）" class="headerlink" title="基于接口而非实现编程（即基于抽象而非实现编程）"></a>基于接口而非实现编程（即基于抽象而非实现编程）</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>组合相比继承有哪些优势？<br>继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。但是继承容易出现层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p>而通过组合、接口、委托三个技术就可以在实现继承功能的同时，解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p>如何判断该用组合还是继承？<br>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="贫血模型-VS-充血模型"><a href="#贫血模型-VS-充血模型" class="headerlink" title="贫血模型 VS 充血模型"></a>贫血模型 VS 充血模型</h3><p>对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。  而对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><h2 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h2><p><img src="/images/dp04.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f.jpeg"></p><h3 id="1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）"><a href="#1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）"></a>1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><h3 id="2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）"><a href="#2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）" class="headerlink" title="2.SOLID 原则：OCP 开闭原则（Open Closed Principle）"></a>2.SOLID 原则：OCP 开闭原则（Open Closed Principle）</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><p>两点要注意：</p><ul><li>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li><li>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li></ul><h3 id="3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）"><a href="#3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）"></a>3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>里式替换原则跟多态的区别：</p><ul><li>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</li><li>里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li></ul><h3 id="4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）"><a href="#4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）" class="headerlink" title="4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）"></a>4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。</p><ul><li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li><li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li><li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</li></ul><p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h3 id="5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）"><a href="#5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）" class="headerlink" title="5.DIP 依赖倒置原则 （Dependency Inversion Principle）"></a>5.DIP 依赖倒置原则 （Dependency Inversion Principle）</h3><p>依赖反转原则也叫作依赖倒置原则。主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h3 id="6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）"><a href="#6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）" class="headerlink" title="6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）"></a>6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）</h3><h4 id="Keep-It-Simple-and-Stupid"><a href="#Keep-It-Simple-and-Stupid" class="headerlink" title="Keep It Simple and Stupid"></a>Keep It Simple and Stupid</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段</p><p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p><ul><li>不要使用同事可能不懂的技术来实现代码；</li><li>不要重复造轮子，善于使用已经有的工具类库；</li><li>不要过度优化。</li></ul><h4 id="You-Ain’t-Gonna-Need-It"><a href="#You-Ain’t-Gonna-Need-It" class="headerlink" title="You Ain’t Gonna Need It"></a>You Ain’t Gonna Need It</h4><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h3 id="7-DRY-原则（Don’t-Repeat-Yourself）"><a href="#7-DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="7.DRY 原则（Don’t Repeat Yourself）"></a>7.DRY 原则（Don’t Repeat Yourself）</h3><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，</p><ul><li>功能语义不重复的代码，并不违反 DRY 原则。</li><li>实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。</li><li>代码执行重复也算是违反 DRY 原则。</li></ul><h3 id="8-LOD-迪米特法则（Law-of-Demeter）"><a href="#8-LOD-迪米特法则（Law-of-Demeter）" class="headerlink" title="8.LOD 迪米特法则（Law of Demeter）"></a>8.LOD 迪米特法则（Law of Demeter）</h3><p>迪米特法则的描述为：</p><ul><li>不该有直接依赖关系的类之间，不要有依赖；</li><li>有依赖关系的类之间，尽量只依赖必要的接口。</li></ul><p>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p><ul><li><p>高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</p></li><li><p>松耦合，指的是在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p></li></ul><h2 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h2><p><img src="/images/dp05.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a.jpeg"></p><h3 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1.重构概述"></a>1.重构概述</h3><h4 id="重构的目的：为什么重构（why）？"><a href="#重构的目的：为什么重构（why）？" class="headerlink" title="重构的目的：为什么重构（why）？"></a>重构的目的：为什么重构（why）？</h4><p>重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p><h4 id="重构的对象：重构什么（what）？"><a href="#重构的对象：重构什么（what）？" class="headerlink" title="重构的对象：重构什么（what）？"></a>重构的对象：重构什么（what）？</h4><p>可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p><ul><li>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</li><li></li><li>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</li></ul><h4 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><h4 id="重构的方法：如何重构（how）？"><a href="#重构的方法：如何重构（how）？" class="headerlink" title="重构的方法：如何重构（how）？"></a>重构的方法：如何重构（how）？</h4><ul><li><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。</p></li><li><p>小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p></li></ul><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><h4 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h4><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。这个“单元”一般是类或函数，而不是模块或者系统。</p><h4 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h4><p>单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。</p><h4 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h4><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。</p><p>对于单元测试，我们需要建立以下正确的认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低单元测试的质量要求；</li><li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li><li>写单元测试一般不需要了解代码的实现逻辑；</li><li>单元测试框架无法测试多半是代码的可测试性不好。</li></ul><h4 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h4><ul><li>写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。</li><li>国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，</li><li>没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</li></ul><h3 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3.代码的可测试性"></a>3.代码的可测试性</h3><h4 id="什么是代码的可测试性？"><a href="#什么是代码的可测试性？" class="headerlink" title="什么是代码的可测试性？"></a>什么是代码的可测试性？</h4><p>所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><h4 id="编写可测试性代码的最有效手段"><a href="#编写可测试性代码的最有效手段" class="headerlink" title="编写可测试性代码的最有效手段"></a>编写可测试性代码的最有效手段</h4><ul><li><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p></li><li><p>除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况</p></li></ul><h4 id="典型的、常见的测试不友好的代码（Anti-Patterns）"><a href="#典型的、常见的测试不友好的代码（Anti-Patterns）" class="headerlink" title="典型的、常见的测试不友好的代码（Anti-Patterns）"></a>典型的、常见的测试不友好的代码（Anti-Patterns）</h4><ul><li>代码中包含未决行为逻辑；</li><li>滥用可变全局变量；</li><li>滥用静态方法；</li><li>使用复杂的继承关系；</li><li>高度耦合的代码。</li></ul><h3 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h3><p>解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><h4 id="如何判断代码是否需要解耦？"><a href="#如何判断代码是否需要解耦？" class="headerlink" title="如何判断代码是否需要解耦？"></a>如何判断代码是否需要解耦？</h4><p>间接的衡量：</p><ul><li>比如改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动</li><li>代码的可测试性是否好等等</li></ul><h4 id="如何给代码进行解耦"><a href="#如何给代码进行解耦" class="headerlink" title="如何给代码进行解耦"></a>如何给代码进行解耦</h4><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。还有一些设计模式，比如观察者模式。</p><h3 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h3><p>持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><h4 id="命名与注释"><a href="#命名与注释" class="headerlink" title="命名与注释"></a>命名与注释</h4><ul><li><p>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</p></li><li><p>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p></li><li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。接口有两种命名方式。</p></li><li><p>一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</p></li><li><p>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p></li><li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</p></li></ul><h4 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h4><ul><li>将复杂的逻辑提炼拆分成函数和类；</li><li>通过拆分成多个函数的方式来处理参数过多的情况；</li><li>通过将参数封装为对象来处理参数过多的情况；</li><li>函数中不要使用参数来做代码执行逻辑的控制；</li><li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li><li>用字面常量取代魔法数；</li><li>利用解释性变量来解释复杂表达式。</li></ul><h4 id="统一代码风格、编码规范"><a href="#统一代码风格、编码规范" class="headerlink" title="统一代码风格、编码规范"></a>统一代码风格、编码规范</h4><p>最好能跟业内推荐的风格、开源项目的代码风格相一致，然后在公司内部形成统一，比如可以参照<br><a href="https://ucc-private-download.oss-cn-beijing.aliyuncs.com/66995068b45c4ebfa74afcfc2e76212c.pdf?Expires=1607054448&OSSAccessKeyId=LTAIvsP3ECkg4Nm9&Signature=KOnMQdpuOGJtZVeyIrGlDxkXIlU%3D" target="_blank" rel="noopener">阿里《Java开发手册（嵩山版）》</a></p><h4 id="阿里-Java开发手册（嵩山版）"><a href="#阿里-Java开发手册（嵩山版）" class="headerlink" title="阿里 Java开发手册（嵩山版）"></a>阿里 Java开发手册（嵩山版）</h4><p><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part4：规范与重构</title>
    <link href="https://crazyfzw.github.io/2020/10/07/design-pattern-refactoring/"/>
    <id>https://crazyfzw.github.io/2020/10/07/design-pattern-refactoring/</id>
    <published>2020-10-07T04:37:56.000Z</published>
    <updated>2021-01-02T07:49:57.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>理论一：什么情况下要重构？到底重构什么？又该如何重构？</h2><h3 id="1-重构的目的："><a href="#1-重构的目的：" class="headerlink" title="1. 重构的目的："></a>1. 重构的目的：</h3><p>为什么重构（why）？<br>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p><p>对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><a id="more"></a><h3 id="2-重构的对象："><a href="#2-重构的对象：" class="headerlink" title="2. 重构的对象："></a>2. 重构的对象：</h3><p>重构什么（what）？按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p><p>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</p><p>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p><h3 id="3-重构的时机："><a href="#3-重构的时机：" class="headerlink" title="3. 重构的时机："></a>3. 重构的时机：</h3><p>什么时候重构（when）？我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><p>平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><h3 id="4-重构的方法："><a href="#4-重构的方法：" class="headerlink" title="4. 重构的方法："></a>4. 重构的方法：</h3><p>如何重构（how）？大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p><p>而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p><p>idea 可以安装 Alibaba Java Coding Guidelines 来帮助解决一些规范的问题，重构解决一些低级别的错误<br><a href="https://www.cnblogs.com/DDgougou/p/9282554.html" target="_blank" rel="noopener">https://www.cnblogs.com/DDgougou/p/9282554.html</a></p><h3 id="评论区精彩评论"><a href="#评论区精彩评论" class="headerlink" title="评论区精彩评论"></a>评论区精彩评论</h3><h4 id="一个重构的案例（步骤）"><a href="#一个重构的案例（步骤）" class="headerlink" title="一个重构的案例（步骤）"></a>一个重构的案例（步骤）</h4><p>前段时间刚重构了一个功能模块。该模块可以说是祖传代码。里面堆砌着各种判断条件，就是所谓的箭头型代码。我接手这个功能重构的<br>1.把代码读一遍和跑一遍，理解里面的需求。尽量画一个流程图。<br>2.建立防护网。将需求拆分之后，针对每个拆分的业务点写单元测试。<br>4.开始重构，解耦逻辑，设计方法的时候尽量让职业单一，类与类之间尽量符合迪米特原则，有依赖关系的类尽量只依赖类的特定方法。我觉得比较基础也是比较重要一点。不要有重复代码。命名要规范，类的各个职业要清晰。重构过程中，其实也要时不时的识别代码的坏味道。尽然是重构，那么肯定要比不重构之前肯定要更好。<br>5.重构完成之后，通过防护网的测试。</p><h4 id="重构后的功能一定要可测试"><a href="#重构后的功能一定要可测试" class="headerlink" title="重构后的功能一定要可测试"></a>重构后的功能一定要可测试</h4><p>代码中的坏味道，好比人的头疼脑热。“小病”不管的话，迟早会发展成大病，需要动大手术，甚至病入膏肓。<br>实际中的一些体会：<br>一、在完成一个新需求时，在时间允许的情况下，会经常改进代码，使代码更优雅。<br>二、“重构不改变外部的可见行为“，引入自动化测试非常重要，国内有些团队可能做的不好。因为改动代码可能引入bug，如果没有自动化测试，测起来就会非常费劲，改动的结果不确定。如果测试不方便，谁会愿意修改之前work的代码呢？<br>三、持续集成、自动化测试、持续重构都是很好的工程实践。即使工作的项目中暂时没有使用，也应该有所了解。</p><h4 id="写单元测试很重要，谁写谁知道"><a href="#写单元测试很重要，谁写谁知道" class="headerlink" title="写单元测试很重要，谁写谁知道"></a>写单元测试很重要，谁写谁知道</h4><p>最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。</p><h2 id="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h2><p>什么是单元测试？为什么要写单元测试？如何编写单元测试？如何在团队中推行单元测试？</p><p>那如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合上一节课中我们对重构的定义。</p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p><p>我们常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><h3 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h3><p>写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 TDD 可落地执行的改进方案。</p><h4 id="1-单元测试能有效地帮你发现代码中的-bug"><a href="#1-单元测试能有效地帮你发现代码中的-bug" class="headerlink" title="1.单元测试能有效地帮你发现代码中的 bug"></a>1.单元测试能有效地帮你发现代码中的 bug</h4><p>坚持为自己提交的每一份代码，都编写完善的单元测试。可以减少很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，可以因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证代码质量的一个“杀手锏”，也是帮助拉开与其他人差距的一个“小秘密”。</p><h4 id="2-写单元测试能帮你发现代码设计上的问题"><a href="#2-写单元测试能帮你发现代码设计上的问题" class="headerlink" title="2.写单元测试能帮你发现代码设计上的问题"></a>2.写单元测试能帮你发现代码设计上的问题</h4><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p><h4 id="3-单元测试是对集成测试的有力补充"><a href="#3-单元测试是对集成测试的有力补充" class="headerlink" title="3.单元测试是对集成测试的有力补充"></a>3.单元测试是对集成测试的有力补充</h4><p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p><h4 id="4-写单元测试的过程本身就是代码重构的过程？"><a href="#4-写单元测试的过程本身就是代码重构的过程？" class="headerlink" title="4.写单元测试的过程本身就是代码重构的过程？"></a>4.写单元测试的过程本身就是代码重构的过程？</h4><p>设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p><h4 id="5-阅读单元测试能帮助你快速熟悉代码"><a href="#5-阅读单元测试能帮助你快速熟悉代码" class="headerlink" title="5.阅读单元测试能帮助你快速熟悉代码"></a>5.阅读单元测试能帮助你快速熟悉代码</h4><p>在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p><h4 id="6-单元测试是-TDD-可落地执行的改进方案"><a href="#6-单元测试是-TDD-可落地执行的改进方案" class="headerlink" title="6.单元测试是 TDD 可落地执行的改进方案"></a>6.单元测试是 TDD 可落地执行的改进方案</h4><p>单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点。</p><h3 id="如何编写单元测试"><a href="#如何编写单元测试" class="headerlink" title="如何编写单元测试"></a>如何编写单元测试</h3><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。这些框架提供了通用的执行流程（比如执行测试用例的 TestCaseRunner）和工具类库（比如各种 Assert 判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p><p>除此之外，对于单元测试，我们需要建立以下正确的认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低对单元测试代码质量的要求；</li><li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li><li>单元测试不要依赖被测代码的具体实现逻辑；</li><li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li></ul><h3 id="一个单元测试的例子"><a href="#一个单元测试的例子" class="headerlink" title="一个单元测试的例子"></a>一个单元测试的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Text &#123;</span><br><span class="line">  private String content;</span><br><span class="line"></span><br><span class="line">  public Text(String content) &#123;</span><br><span class="line">    this.content &#x3D; content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将字符串转化成数字，忽略字符串中的首尾空格；</span><br><span class="line">   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Integer toNumber() &#123;</span><br><span class="line">    if (content &#x3D;&#x3D; null || content.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略代码实现...</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要测试 一下Text 类中的 toNumber() 函数的正确性，应该如何编写单元测试呢？</p><p>写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p><h4 id="罗列出各种正常，异常，以及边界的测试用例"><a href="#罗列出各种正常，异常，以及边界的测试用例" class="headerlink" title="罗列出各种正常，异常，以及边界的测试用例"></a>罗列出各种正常，异常，以及边界的测试用例</h4><ul><li>如果字符串只包含数字：“123”，toNumber() 函数输出对应的整数：123。</li><li>如果字符串是空或者 null，toNumber() 函数返回：null。</li><li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数：123。</li><li>如果字符串包含多个首尾空格：“ 123 ”，toNumber() 返回对应的整数：123；</li><li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber() 返回 null；</li></ul><h4 id="将测试用例翻译成代码"><a href="#将测试用例翻译成代码" class="headerlink" title="将测试用例翻译成代码"></a>将测试用例翻译成代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Assert &#123;</span><br><span class="line">  public static void assertEquals(Integer expectedValue, Integer actualValue) &#123;</span><br><span class="line">    if (actualValue !&#x3D; expectedValue) &#123;</span><br><span class="line">      String message &#x3D; String.format(</span><br><span class="line">              &quot;Test failed, expected: %d, actual: %d.&quot;, expectedValue, actualValue);</span><br><span class="line">      System.out.println(message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static boolean assertNull(Integer actualValue) &#123;</span><br><span class="line">    boolean isNull &#x3D; actualValue &#x3D;&#x3D; null;</span><br><span class="line">    if (isNull) &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test failed, the value is not null:&quot; + actualValue);</span><br><span class="line">    &#125;</span><br><span class="line">    return isNull;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TextTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber() &#123;</span><br><span class="line">    Text text &#x3D; new Text(&quot;123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_nullorEmpty() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(null);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot; 123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot; 123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsMultiLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;  123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot;  123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsInvalidCharaters() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;123a4&quot;);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 4&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h3><ul><li>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；</li><li>另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</li></ul><h3 id="重度依赖数据库的业务代码如何做单元测试"><a href="#重度依赖数据库的业务代码如何做单元测试" class="headerlink" title="重度依赖数据库的业务代码如何做单元测试"></a>重度依赖数据库的业务代码如何做单元测试</h3><ul><li>涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</li><li>涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</li></ul><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.以前在开发中，没有写单元测试的意识。开发完功能后，直接去测试一个完整的流程。即前端发请求，服务端处理，看数据库数据。如果功能正确就过。这是从一个功能宏观去考虑测试。而单元测试是更细粒度的测试，它在保证各个“单元”都测试通过的情况下整个功能模块就测试通过了。这样的方式对于我们自己来说对代码可控粒度更细。更能比较清楚的理解某个“单元”在整个功能模块调用链路上的位置，承担什么职责，以及有什么行为。而不是一开始就站在模块宏观角度来思考。通过一个个单元测试的编写，将整个功能模块串联起来，最终达到整个功能模块的全局认知。 这也体现了任务分解的思想。通过单元测试，可以从另外一方面实现对已编写的代码的CodeReview，重新梳理流程。也为以后有重构需求打下基础。目前参与的项目中有单元测试，但是不够完备。可能由于某些原因（开发人员意识问题，团队对单元测试的执行落地程度不够等）。在写单元测试的过程中，遇到单元测试依赖数据库查询问题，因为存在多套环境，如开发环境，仿真环境，线上环境。对于依赖数据查询的单元测试，只能自己造假数据来解决。不知道还有什么好的解决办法。</p><p>作者回复：涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</p><p>2.如果到了具体的业务代码，该怎么写单元测试呢，单元测试正确标准是什么呢，以sql查询到的结果吗？</p><p>作者回复：涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</p><p>3.单元测试很重要，但是为什么大多人都会放弃？我个人觉得最主要的原因并不是代码量大，难以编写等，而是跑单元测试的次数少。很多单元测试都是为了写而写，写完一次可能都不去运行或者只偶尔运行一两次。如果是每次改完代码，都跑一遍单元测试，单元测试的效果会越来越显现。如果只是为了运行一两次或者干脆为了写而写，很容易就会放弃继续写单元测试。</p><p>作者回复：可以集成到代码管理仓库git中，强制跑单元测试成功之后才能提交</p><h2 id="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h2><p>写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。</p><h3 id="1-什么是代码的可测试性？"><a href="#1-什么是代码的可测试性？" class="headerlink" title="1. 什么是代码的可测试性？"></a>1. 什么是代码的可测试性？</h3><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><h3 id="2-编写可测试性代码的最有效手段"><a href="#2-编写可测试性代码的最有效手段" class="headerlink" title="2. 编写可测试性代码的最有效手段"></a>2. 编写可测试性代码的最有效手段</h3><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方</p><h3 id="3-常见的-Anti-Patterns"><a href="#3-常见的-Anti-Patterns" class="headerlink" title="3. 常见的 Anti-Patterns"></a>3. 常见的 Anti-Patterns</h3><p>常见的测试不友好的代码有下面这 5 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h3 id="4-mock-用一个“假”的服务替换真正的服务"><a href="#4-mock-用一个“假”的服务替换真正的服务" class="headerlink" title="4.mock 用一个“假”的服务替换真正的服务"></a>4.mock 用一个“假”的服务替换真正的服务</h3><p>单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><p>那如何来 mock 服务呢？mock 的方式主要有两种，手动 mock 和利用框架 mock。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private Long buyerId;</span><br><span class="line">  private Long sellerId;</span><br><span class="line">  private Long productId;</span><br><span class="line">  private String orderId;</span><br><span class="line">  private Long createTimestamp;</span><br><span class="line">  private Double amount;</span><br><span class="line">  private STATUS status;</span><br><span class="line">  private String walletTransactionId;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; ...get() methods...</span><br><span class="line">  </span><br><span class="line">  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) &#123;</span><br><span class="line">    if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;</span><br><span class="line">      this.id &#x3D; preAssignedId;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.id &#x3D; IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!this.id.startWith(&quot;t_&quot;)) &#123;</span><br><span class="line">      this.id &#x3D; &quot;t_&quot; + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">    this.buyerId &#x3D; buyerId;</span><br><span class="line">    this.sellerId &#x3D; sellerId;</span><br><span class="line">    this.productId &#x3D; productId;</span><br><span class="line">    this.orderId &#x3D; orderId;</span><br><span class="line">    this.status &#x3D; STATUS.TO_BE_EXECUTD;</span><br><span class="line">    this.createTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean execute() throws InvalidTransactionException &#123;</span><br><span class="line">    if ((buyerId &#x3D;&#x3D; null || (sellerId &#x3D;&#x3D; null || amount &lt; 0.0) &#123;</span><br><span class="line">      throw new InvalidTransactionException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    if (status &#x3D;&#x3D; STATUS.EXECUTED) return true;</span><br><span class="line">    boolean isLocked &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">      if (!isLocked) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; 锁定未成功，返回false，job兜底执行</span><br><span class="line">      &#125;</span><br><span class="line">      if (status &#x3D;&#x3D; STATUS.EXECUTED) return true; &#x2F;&#x2F; double check</span><br><span class="line">      long executionInvokedTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">      if (executionInvokedTimestamp - createdTimestap &gt; 14days) &#123;</span><br><span class="line">        this.status &#x3D; STATUS.EXPIRED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">      String walletTransactionId &#x3D; walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">      if (walletTransactionId !&#x3D; null) &#123;</span><br><span class="line">        this.walletTransactionId &#x3D; walletTransactionId;</span><br><span class="line">        this.status &#x3D; STATUS.EXECUTED;</span><br><span class="line">        return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.status &#x3D; STATUS.FAILED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">       RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction 类中的 execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。除此之外，代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。</p><p>1.当代码包含依赖第三方系统的RPC调用时怎么写 单元测试<br>我们通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。具体的代码实现如下所示。通过 mock 的方式，我们可以让 moveMoney() 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MockWalletRpcServiceOne extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return &quot;123bac&quot;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MockWalletRpcServiceTwo extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  &#x2F;&#x2F; 添加一个成员变量及其set方法</span><br><span class="line">  private WalletRpcService walletRpcService;</span><br><span class="line">  </span><br><span class="line">  public void setWalletRpcService(WalletRpcService walletRpcService) &#123;</span><br><span class="line">    this.walletRpcService &#x3D; walletRpcService;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 删除下面这一行代码</span><br><span class="line">    &#x2F;&#x2F; WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  &#x2F;&#x2F; 使用mock对象来替代真正的RPC服务</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当代码中包含一些不是我们维护的组件的调用时如何写单元测试</li></ol><p>如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。这样我们就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了。但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionLock &#123;</span><br><span class="line">  public boolean lock(String id) &#123;</span><br><span class="line">    return RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void unlock() &#123;</span><br><span class="line">    RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  private TransactionLock lock;</span><br><span class="line">  </span><br><span class="line">  public void setTransactionLock(TransactionLock lock) &#123;</span><br><span class="line">    this.lock &#x3D; lock;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; lock.lock();</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  </span><br><span class="line">  TransactionLock mockLock &#x3D; new TransactionLock() &#123;</span><br><span class="line">    public boolean lock(String id) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void unlock() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne());</span><br><span class="line">  transaction.setTransactionLock(mockLock);</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.依赖注入是提高代码可测试性的最有效的手段。</p><p>2.可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之</p><p>3、未决行为：例时间、随机数。将未决行为重新封装，测试时mock，使用匿名类。</p><h2 id="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h2><p>大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，今天我们重点讲解最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合。</p><h3 id="“解耦”为何如此重要？"><a href="#“解耦”为何如此重要？" class="headerlink" title="“解耦”为何如此重要？"></a>“解耦”为何如此重要？</h3><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><h3 id="如何判定代码是否需要“解耦”？"><a href="#如何判定代码是否需要“解耦”？" class="headerlink" title="如何判定代码是否需要“解耦”？"></a>如何判定代码是否需要“解耦”？</h3><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><h3 id="如何给代码“解耦”？"><a href="#如何给代码“解耦”？" class="headerlink" title="如何给代码“解耦”？"></a>如何给代码“解耦”？</h3><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p><h3 id="设计原则回顾"><a href="#设计原则回顾" class="headerlink" title="设计原则回顾"></a>设计原则回顾</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p><h4 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h4><p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p><h4 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h4><p>继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p><h2 id="理论五：让你最快速地改善代码质量的20条编程规范"><a href="#理论五：让你最快速地改善代码质量的20条编程规范" class="headerlink" title="理论五：让你最快速地改善代码质量的20条编程规范"></a>理论五：让你最快速地改善代码质量的20条编程规范</h2><h3 id="1-关于命名"><a href="#1-关于命名" class="headerlink" title="1. 关于命名"></a>1. 关于命名</h3><ul><li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li><li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</li><li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li></ul><h3 id="2-关于注释"><a href="#2-关于注释" class="headerlink" title="2. 关于注释"></a>2. 关于注释</h3><ul><li>关于注释注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li></ul><h3 id="3-关于代码风格"><a href="#3-关于代码风格" class="headerlink" title="3.关于代码风格"></a>3.关于代码风格</h3><h4 id="函数、类多大才合适？"><a href="#函数、类多大才合适？" class="headerlink" title="函数、类多大才合适？"></a>函数、类多大才合适？</h4><p>函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。</p><h4 id="一行代码多长最合适？"><a href="#一行代码多长最合适？" class="headerlink" title="一行代码多长最合适？"></a>一行代码多长最合适？</h4><p> 最好不要超过 IDE 显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h4 id="善用空行分割单元块"><a href="#善用空行分割单元块" class="headerlink" title="善用空行分割单元块"></a>善用空行分割单元块</h4><p>对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。</p><h4 id="四格缩进还是两格缩进？"><a href="#四格缩进还是两格缩进？" class="headerlink" title="四格缩进还是两格缩进？"></a>四格缩进还是两格缩进？</h4><p>我个人比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。</p><h4 id="大括号是否要另起一行？"><a href="#大括号是否要另起一行？" class="headerlink" title="大括号是否要另起一行？"></a>大括号是否要另起一行？</h4><p>我个人还是比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。6. 类中成员的排列顺序在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><h4 id="类中成员的排列顺序"><a href="#类中成员的排列顺序" class="headerlink" title="类中成员的排列顺序"></a>类中成员的排列顺序</h4><p>在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><h3 id="4-关于变成技巧"><a href="#4-关于变成技巧" class="headerlink" title="4.关于变成技巧"></a>4.关于变成技巧</h3><ul><li>将复杂的逻辑提炼拆分成函数和类。</li><li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li><li>函数中不要使用参数来做代码执行逻辑的控制。</li><li>函数设计要职责单一。移</li><li>除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li><li>用字面常量取代魔法数。</li><li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li></ul><p>代码示例<br>1.用解释性变量来解释复杂表达式，以此提高代码可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰</span><br><span class="line">boolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line">if (isSummer) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常量替代魔法数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return (3.1415) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常量替代魔法数字</span><br><span class="line">public static final Double PI &#x3D; 3.1415;</span><br><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.调整执行顺序来减少嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重构前的代码</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;</span><br><span class="line">    for (String str : strList) &#123;</span><br><span class="line">      if (str !&#x3D; null) &#123;</span><br><span class="line">        if (str.contains(substr)) &#123;</span><br><span class="line">          matchedStrings.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  for (String str : strList) &#123;</span><br><span class="line">    if (str !&#x3D; null) &#123;</span><br><span class="line">      if (str.contains(substr)) &#123;</span><br><span class="line">        matchedStrings.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-统一编码规范"><a href="#5-统一编码规范" class="headerlink" title="5.统一编码规范"></a>5.统一编码规范</h3><p>除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</p><h3 id="代码分析工具推荐"><a href="#代码分析工具推荐" class="headerlink" title="代码分析工具推荐"></a>代码分析工具推荐</h3><p>代码中的很多低级质量问题不需要人工去审查，java开发有很多现成的工具可以使用，比如：checkstyle，findbugs, pmd, jacaco, sonar等。</p><p>Checkstyle,findbugs,pmd是静态代码分析工具，通过分析源代码或者字节码，找出代码的缺陷，比如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。三者都可以集成到gradle等构建工具中。</p><p>Jacoco是一种单元测试覆盖率统计工具，也可以集成到gradle等构建工具中，可以生成漂亮的测试覆盖率统计报表，同时Eclipse提供了插件可以EclEmma可以直观的在IDE中查看单元测试的覆盖情况。</p><p>Sonar Sonar 是一个用于代码质量管理的平台。可以在一个统一的平台上显示管理静态分析，单元测试覆盖率等质量报告。</p><h2 id="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h2><h3 id="如何发现代码质量问题-常规checkList"><a href="#如何发现代码质量问题-常规checkList" class="headerlink" title="如何发现代码质量问题-常规checkList"></a>如何发现代码质量问题-常规checkList</h3><ul><li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li><li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li><li>设计模式是否应用得当？是否有过度设计？</li><li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li><li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li><li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li></ul><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2459" alt="041e22cac6ce2ba3481e246c119adfc9.jpeg"></p><h3 id="如何发现代码质量问题-业务需求checkList"><a href="#如何发现代码质量问题-业务需求checkList" class="headerlink" title="如何发现代码质量问题-业务需求checkList"></a>如何发现代码质量问题-业务需求checkList</h3><ul><li>代码是否实现了预期的业务需求？</li><li>逻辑是否正确？是否处理了各种异常情况？日</li><li>志打印是否得当？是否方便 debug 排查问题？</li><li>接口是否易用？是否支持幂等、事务等？</li><li>代码是否存在并发问题？是否线程安全？</li><li>性能是否有优化空间，比如，SQL、算法是否可以优化？</li><li>是否有安全漏洞？比如输入输出校验是否全面？</li><li><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2460" alt="9894233257994a69102afa960692ce98.jpeg"></li></ul><h3 id="一段有很多问题的ID生成器代码"><a href="#一段有很多问题的ID生成器代码" class="headerlink" title="一段有很多问题的ID生成器代码"></a>一段有很多问题的ID生成器代码</h3><p>为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。</p><p>借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在 Java 语言中，我们可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的 ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求 ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID 信息，我们就可以通过请求 ID 来搜索同一个请求的所有日志了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(IdGenerator.class);</span><br><span class="line"></span><br><span class="line">  public static String generate() &#123;</span><br><span class="line">    String id &#x3D; &quot;&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      if (tokens.length &gt; 0) &#123;</span><br><span class="line">        hostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      &#125;</span><br><span class="line">      char[] randomChars &#x3D; new char[8];</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line">      while (count &lt; 8) &#123;</span><br><span class="line">        int randomAscii &#x3D; random.nextInt(122);</span><br><span class="line">        if (randomAscii &gt;&#x3D; 48 &amp;&amp; randomAscii &lt;&#x3D; 57) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;0&#39; + (randomAscii - 48));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 65 &amp;&amp; randomAscii &lt;&#x3D; 90) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;A&#39; + (randomAscii - 65));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 97 &amp;&amp; randomAscii &lt;&#x3D; 122) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;a&#39; + (randomAscii - 97));</span><br><span class="line">          count++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      id &#x3D; String.format(&quot;%s-%d-%s&quot;, hostName,</span><br><span class="line">              System.currentTimeMillis(), new String(randomChars));</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h2><p>重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。</p><ul><li>第一轮重构：提高代码的可读性</li><li>第二轮重构：提高代码的可测试性</li><li>第三轮重构：编写完善的单元测试</li><li>第四轮重构：所有重构完成之后添加注释</li></ul><h3 id="第一轮重构：提高代码的可读性"><a href="#第一轮重构：提高代码的可读性" class="headerlink" title="第一轮重构：提高代码的可读性"></a>第一轮重构：提高代码的可读性</h3><p>首先，我们要解决最明显、最急需改进的代码可读性问题。具体有下面几点：</p><ul><li>hostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候；</li><li>将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数；</li><li>删除代码中的魔法数，比如，57、90、97、122；</li><li>将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数；</li><li>generate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化；对 IdGenerator 类重命名，并且抽象出对应的接口。</li></ul><p>第一轮重构后的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public interface IdGenerator &#123;</span><br><span class="line">  String generate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface LogTraceIdGenerator extends IdGenerator &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      return substrOfHostName;</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码使用举例</span><br><span class="line">LogTraceIdGenerator logTraceIdGenerator &#x3D; new RandomIdGenerator();</span><br></pre></td></tr></table></figure><h3 id="第二轮重构：提高代码的可测试性"><a href="#第二轮重构：提高代码的可测试性" class="headerlink" title="第二轮重构：提高代码的可测试性"></a>第二轮重构：提高代码的可测试性</h3><p>关于代码可测试性的问题，主要包含下面两个方面：</p><ul><li>generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性；</li><li>generate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好。</li></ul><p>对于第一点，我们已经在第一轮重构中解决了。我们将 RandomIdGenerator 类中的 generate() 静态函数重新定义成了普通函数。调用者可以通过依赖注入的方式，在外部创建好 RandomIdGenerator 对象后注入到自己的代码中，从而解决静态函数调用影响代码可测试性的问题。</p><p>对于第二点，我们需要在第一轮重构的基础之上再进行重构。</p><ul><li>从 getLastfieldOfHostName() 函数中，将逻辑比较复杂的那部分代码剥离出来，定义为 getLastSubstrSplittedByDot() 函数。因为 getLastfieldOfHostName() 函数依赖本地主机名，所以，剥离出主要代码之后这个函数变得非常简单，可以不用测试。我们重点测试 getLastSubstrSplittedByDot() 函数即可。</li><li>将 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 这两个函数的访问权限设置为 protected。这样做的目的是，可以直接在单元测试中通过对象来调用两个函数进行测试。</li><li>给 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 两个函数添加 Google Guava 的 annotation @VisibleForTesting。这个 annotation 没有任何实际的作用，只起到标识的作用，告诉其他人说，这两个函数本该是 private 访问权限的，之所以提升访问权限到 protected，只是为了测试，只能用于单元测试中。</li></ul><p>第二轮重构后代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三轮重构：编写完善的单元测试"><a href="#第三轮重构：编写完善的单元测试" class="headerlink" title="第三轮重构：编写完善的单元测试"></a>第三轮重构：编写完善的单元测试</h3><p>经过上面的重构之后，代码存在的比较明显的问题，基本上都已经解决了。我们现在为代码补全单元测试。RandomIdGenerator 类中有 4 个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String generate();</span><br><span class="line">private String getLastfieldOfHostName();</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String getLastSubstrSplittedByDot(String hostName);</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String generateRandomAlphameric(int length);</span><br></pre></td></tr></table></figure><p>在上一步重构中，为了提高代码的可测试性，我们已经将这两个部分代码跟不可控的组件（本机名、随机函数、时间函数）进行了隔离。所以，我们只需要设计完备的单元测试用例即可。具体的代码实现如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGeneratorTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1.field2.field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field3&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1#field2$field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1#field2#field3&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot_nullOrEmpty() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(null);</span><br><span class="line">    Assert.assertNull(actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(6);</span><br><span class="line">    Assert.assertNotNull(actualRandomString);</span><br><span class="line">    Assert.assertEquals(6, actualRandomString.length());</span><br><span class="line">    for (char c : actualRandomString.toCharArray()) &#123;</span><br><span class="line">      Assert.assertTrue((&#39;0&#39; &lt; c &amp;&amp; c &lt; &#39;9&#39;) || (&#39;a&#39; &lt; c &amp;&amp; c &lt; &#39;z&#39;) || (&#39;A&#39; &lt; c &amp;&amp; c &lt; &#39;Z&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理length&lt;&#x3D;0的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(0);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualRandomString);</span><br><span class="line"></span><br><span class="line">    actualRandomString &#x3D; idGenerator.generateRandomAlphameric(-1);</span><br><span class="line">    Assert.assertNull(actualRandomString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>注释不能太多，也不能太少，主要添加在类和函数上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Id Generator that is used to generate random IDs.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The IDs generated by this class are not absolutely unique,</span><br><span class="line"> * but the probability of duplication is very low.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate the random ID. The IDs may be duplicated only in extreme situation.</span><br><span class="line">   *</span><br><span class="line">   * @return an random ID</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the local hostname and</span><br><span class="line">   * extract the last field of the name string splitted by delimiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @return the last field of hostname. Returns null if hostname is not obtained.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the last field of &#123;@hostName&#125; splitted by delemiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @param hostName should not be null</span><br><span class="line">   * @return the last field of &#123;@hostName&#125;. Returns empty string if &#123;@hostName&#125; is empty string.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate random string which</span><br><span class="line">   * only contains digits, uppercase letters and lowercase letters.</span><br><span class="line">   *</span><br><span class="line">   * @param length should not be less than 0</span><br><span class="line">   * @return the random string. Returns empty string if &#123;@length&#125; is 0</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写 100 段凑活能用的代码，对你的代码能力提高更有帮助。</li><li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。</li><li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。</li><li>高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。</li></ul><h2 id="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h2><h3 id="1-返回错误码"><a href="#1-返回错误码" class="headerlink" title="1. 返回错误码"></a>1. 返回错误码</h3><p>C 语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而 Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><h3 id="2-返回-NULL-值"><a href="#2-返回-NULL-值" class="headerlink" title="2. 返回 NULL 值"></a>2. 返回 NULL 值</h3><p>在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的 NULL 值比返回异常更加合理。</p><h3 id="3-返回空对象"><a href="#3-返回空对象" class="headerlink" title="3. 返回空对象"></a>3. 返回空对象</h3><p>返回 NULL 值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用空集合替代NULL</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepo userRepo; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  </span><br><span class="line">  public List&lt;User&gt; getUsers(String telephonePrefix) &#123;</span><br><span class="line">   &#x2F;&#x2F; 没有查找到数据</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getUsers使用示例</span><br><span class="line">List&lt;User&gt; users &#x3D; userService.getUsers(&quot;189&quot;);</span><br><span class="line">for (User user : users) &#123; &#x2F;&#x2F;这里不需要做NULL值判断</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用空字符串替代NULL</span><br><span class="line">public String retrieveUppercaseLetters(String text) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果text中没有大写字母，返回空字符串，而非NULL值</span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; retrieveUppercaseLetters()使用举例</span><br><span class="line">String uppercaseLetters &#x3D; retrieveUppercaseLetters(&quot;wangzheng&quot;);</span><br><span class="line">int length &#x3D; uppercaseLetters.length();&#x2F;&#x2F; 不需要做NULL值判断 </span><br><span class="line">System.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);</span><br></pre></td></tr></table></figure><h3 id="4-抛出异常对象"><a href="#4-抛出异常对象" class="headerlink" title="4. 抛出异常对象"></a>4. 抛出异常对象</h3><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><h3 id="5-针对函数抛出异常的三种处理方式"><a href="#5-针对函数抛出异常的三种处理方式" class="headerlink" title="5.针对函数抛出异常的三种处理方式"></a>5.针对函数抛出异常的三种处理方式</h3><p>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。</p><h4 id="直接吞掉"><a href="#直接吞掉" class="headerlink" title="直接吞掉"></a>直接吞掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void func2() &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">    log.warn(&quot;...&quot;, e); &#x2F;&#x2F;吐掉：try-catch打印日志</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接往上抛出-（原封不动地-re-throw）"><a href="#直接往上抛出-（原封不动地-re-throw）" class="headerlink" title="直接往上抛出 （原封不动地 re-throw）"></a>直接往上抛出 （原封不动地 re-throw）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception1 &#123;&#x2F;&#x2F;原封不动的re-throw Exception1</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  func1();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包裹成新的异常抛出-re-throw"><a href="#包裹成新的异常抛出-re-throw" class="headerlink" title="包裹成新的异常抛出 re-throw"></a>包裹成新的异常抛出 re-throw</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception2 &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">   throw new Exception2(&quot;...&quot;, e); &#x2F;&#x2F; wrap成新的Exception2然后re-throw</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>实战二（下）：重构ID生成器项目中各函数的异常处理代码</h2><h3 id="异常处理代码重构"><a href="#异常处理代码重构" class="headerlink" title="异常处理代码重构"></a>异常处理代码重构</h3><p>重构之前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastFiledOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFiledOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() throws IdGenerationFailureException &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      substrOfHostName &#x3D; getLastFieldOfHostName();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      throw new IdGenerationFailureException(&quot;...&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFieldOfHostName() throws UnknownHostException&#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new UnknownHostException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    if (length &lt;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.在 generate() 函数中，我们需要捕获 UnknownHostException 异常，并重新包裹成新的异常 IdGenerationFailureException 往上抛出。之所以这么做，有下面三个原因。</p><ul><li>调用者在使用 generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的。也就说是，这是依赖抽象而非实现编程。</li><li>如果 generate() 函数直接抛出 UnknownHostException 异常，实际上是暴露了实现细节。从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常，暴露给更上层的代码，也就是调用 generate() 函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。</li><li>UnknownHostException 异常跟 generate() 函数，在业务概念上没有相关性。</li></ul><p>2.如果函数是 public 的，你无法掌控会被谁调用以及如何调用（有可能某个同事一时疏忽，传递进了 NULL 值，这种情况也是存在的），为了尽可能提高代码的健壮性，我们最好是在 public 函数中做 NULL 值或空字符串的判断。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>1.程序的 bug 往往都出现在一些边界条件和异常情况下，所以说，异常处理得好坏直接影响了代码的健壮性。</p><p>2.再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</p><p>3.内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</p><p>4.能用的代码和优质代码之间最大的区别就在于细节，这就是60分和100分的差别。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot;&gt;&lt;a href=&quot;#理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot; class=&quot;headerlink&quot; title=&quot;理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot;&gt;&lt;/a&gt;理论一：什么情况下要重构？到底重构什么？又该如何重构？&lt;/h2&gt;&lt;h3 id=&quot;1-重构的目的：&quot;&gt;&lt;a href=&quot;#1-重构的目的：&quot; class=&quot;headerlink&quot; title=&quot;1. 重构的目的：&quot;&gt;&lt;/a&gt;1. 重构的目的：&lt;/h3&gt;&lt;p&gt;为什么重构（why）？&lt;br&gt;对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。&lt;/p&gt;
&lt;p&gt;对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part3：设计原则</title>
    <link href="https://crazyfzw.github.io/2020/10/05/design-pattern-design-principle/"/>
    <id>https://crazyfzw.github.io/2020/10/05/design-pattern-design-principle/</id>
    <published>2020-10-05T04:37:56.000Z</published>
    <updated>2021-01-02T07:49:53.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计原则概述"><a href="#设计原则概述" class="headerlink" title="设计原则概述"></a>设计原则概述</h2><p>SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，SRP单一职责原则 Single Responsibility Principle； KISS保持简单 Keep It Simple and Stupid； YAGNI不需要原则 You Ain’t Gonna Need It ； DRY 不要重复原则 Don’t Repeat Yourself ； LOD 迪米特法则 Law of Demeter。</p><a id="more"></a><p>设计原则和思想比设计模式更加普适和重要。可以这样说，设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。掌握了代码的设计原则和思想，我们才能更清楚的了解，为什么要用某种设计模式，才能更恰到好处地应用设计模式。</p><h2 id="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h2><p>单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p><h3 id="1-如何理解单一职责原则（SRP）？"><a href="#1-如何理解单一职责原则（SRP）？" class="headerlink" title="1. 如何理解单一职责原则（SRP）？"></a>1. 如何理解单一职责原则（SRP）？</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h3 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2. 如何判断类的职责是否足够单一？"></a>2. 如何判断类的职责是否足够单一？</h3><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：类中的代码行数、函数或者属性过多；类依赖的其他类过多，或者依赖类的其他类过多；私有方法过多；比较难给类起一个合适的名字；类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3. 类的职责是否设计得越单一越好？"></a>3. 类的职责是否设计得越单一越好？</h3><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2 id="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h2><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试。</p><h3 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1.如何理解“对扩展开放、对修改关闭”？"></a>1.如何理解“对扩展开放、对修改关闭”？</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><h3 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2. 如何做到“对扩展开放、修改关闭”？"></a>2. 如何做到“对扩展开放、修改关闭”？</h3><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h4 id="通过多态实现"><a href="#通过多态实现" class="headerlink" title="通过多态实现"></a>通过多态实现</h4><p>例子：API 接口监控告警的代码</p><p>改造前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private AlertRule rule;</span><br><span class="line">  private Notification notification;</span><br><span class="line"></span><br><span class="line">  public Alert(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略AlertRule&#x2F;Notification属性和构造函数...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 改动一：添加参数timeoutCount</span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 改动二：添加接口超时处理逻辑</span><br><span class="line">    long timeoutTps &#x3D; timeoutCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">弊端：一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改</span><br></pre></td></tr></table></figure><p>使用多态改造后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private List&lt;AlertHandler&gt; alertHandlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public void addAlertHandler(AlertHandler alertHandler) &#123;</span><br><span class="line">    this.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    for (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class AlertHandler &#123;</span><br><span class="line">  protected AlertRule rule;</span><br><span class="line">  protected Notification notification;</span><br><span class="line">  public AlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void check(ApiStatInfo apiStatInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public TpsAlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    long tps &#x3D; apiStatInfo.getRequestCount()&#x2F; apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？具体的使用代码我也写在这里了。其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  public Alert getAlert() &#123; return alert; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 饿汉式单例</span><br><span class="line">  private static final ApplicationContext instance &#x3D; new ApplicationContext();</span><br><span class="line">  private ApplicationContext() &#123;</span><br><span class="line">    initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  public static ApplicationContext getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略设置apiStatInfo数据值的代码</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果这时需要添加其他规则警告，只需按如下进行改动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123; &#x2F;&#x2F; 代码未改动... &#125;</span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">  private long timeoutCount; &#x2F;&#x2F; 改动一：添加新字段</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AlertHandler &#123; &#x2F;&#x2F;代码未改动... &#125;</span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">&#x2F;&#x2F; 改动二：添加新的handler</span><br><span class="line">public class TimeoutAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;省略代码...&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    &#x2F;&#x2F; 改动三：注册handler</span><br><span class="line">    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他未改动代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略apiStatInfo的set字段代码</span><br><span class="line">    apiStatInfo.setTimeoutCount(289); &#x2F;&#x2F; 改动四：设置tiemoutCount值</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h4 id="通过接口实现"><a href="#通过接口实现" class="headerlink" title="通过接口实现"></a>通过接口实现</h4><p>例子通过 Kafka 来发送异步消息：</p><p>对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这一部分体现了抽象意识</span><br><span class="line">public interface MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class KafkaMessageQueue implements MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class RocketMQMessageQueue implements MessageQueue &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public interface MessageFromatter &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class JsonMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">public class ProtoBufMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private MessageQueue msgQueue; &#x2F;&#x2F; 基于接口而非实现编程</span><br><span class="line">  public Demo(MessageQueue msgQueue) &#123; &#x2F;&#x2F; 依赖注入</span><br><span class="line">    this.msgQueue &#x3D; msgQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; msgFormatter：多态、依赖注入</span><br><span class="line">  public void sendNotification(Notification notification, MessageFormatter msgFormatter) &#123;</span><br><span class="line">    &#x2F;&#x2F;...    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"><a href="#通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）" class="headerlink" title="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"></a>通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）</h4><h3 id="3-如何在项目中合理应用开闭原则？"><a href="#3-如何在项目中合理应用开闭原则？" class="headerlink" title="3.如何在项目中合理应用开闭原则？"></a>3.如何在项目中合理应用开闭原则？</h3><p>1.最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。这样可以避免过度设计。</p><p>2.代码的扩展性会跟可读性相冲突，很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p><h2 id="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h2><p>Liskov Substitution Principle</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。<br>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>中文描述：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><h3 id="里式替换原则的理解"><a href="#里式替换原则的理解" class="headerlink" title="里式替换原则的理解"></a>里式替换原则的理解</h3><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><h3 id="符合里式替换原则的代码示例"><a href="#符合里式替换原则的代码示例" class="headerlink" title="符合里式替换原则的代码示例"></a>符合里式替换原则的代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Transporter &#123;</span><br><span class="line">  private HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  public Transporter(HttpClient httpClient) &#123;</span><br><span class="line">    this.httpClient &#x3D; httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...use httpClient to send request</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SecurityTransporter extends Transporter &#123;</span><br><span class="line">  private String appId;</span><br><span class="line">  private String appToken;</span><br><span class="line"></span><br><span class="line">  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) &#123;</span><br><span class="line">    super(httpClient);</span><br><span class="line">    this.appId &#x3D; appId;</span><br><span class="line">    this.appToken &#x3D; appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(&quot;app-id&quot;, appId);</span><br><span class="line">      request.addPayload(&quot;app-token&quot;, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;    </span><br><span class="line">  public void demoFunction(Transporter transporter) &#123;    </span><br><span class="line">    Reuqest request &#x3D; new Request();</span><br><span class="line">    &#x2F;&#x2F;...省略设置request中数据值的代码...</span><br><span class="line">    Response response &#x3D; transporter.sendRequest(request);</span><br><span class="line">    &#x2F;&#x2F;...省略其他逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 里式替换原则</span><br><span class="line">Demo demo &#x3D; new Demo();</span><br><span class="line">demo.demofunction(new SecurityTransporter(&#x2F;*省略参数*&#x2F;););</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><h3 id="哪些代码违背了里式替换原则"><a href="#哪些代码违背了里式替换原则" class="headerlink" title="哪些代码违背了里式替换原则"></a>哪些代码违背了里式替换原则</h3><h4 id="1-子类违背父类声明要实现的功能"><a href="#1-子类违背父类声明要实现的功能" class="headerlink" title="1. 子类违背父类声明要实现的功能"></a>1. 子类违背父类声明要实现的功能</h4><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><h4 id="2-子类违背父类对输入、输出、异常的约定"><a href="#2-子类违背父类对输入、输出、异常的约定" class="headerlink" title="2. 子类违背父类对输入、输出、异常的约定"></a>2. 子类违背父类对输入、输出、异常的约定</h4><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h4 id="3-子类违背父类注释中所罗列的任何特殊说明"><a href="#3-子类违背父类注释中所罗列的任何特殊说明" class="headerlink" title="3. 子类违背父类注释中所罗列的任何特殊说明"></a>3. 子类违背父类注释中所罗列的任何特殊说明</h4><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><h3 id="判断子类的设计实现是否违背里式替换原则的小窍门"><a href="#判断子类的设计实现是否违背里式替换原则的小窍门" class="headerlink" title="判断子类的设计实现是否违背里式替换原则的小窍门"></a>判断子类的设计实现是否违背里式替换原则的小窍门</h3><p>拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p><h3 id="里式替换与多态的区别"><a href="#里式替换与多态的区别" class="headerlink" title="里式替换与多态的区别"></a>里式替换与多态的区别</h3><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</p><p>而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h2 id="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h2><h3 id="1-如何理解“接口隔离原则”"><a href="#1-如何理解“接口隔离原则”" class="headerlink" title="1.如何理解“接口隔离原则”"></a>1.如何理解“接口隔离原则”</h3><p>Interface Segregation Principle</p><h4 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 API 接口集合</h4><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>例子：服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">  boolean register(String cellphone, String password);</span><br><span class="line">  boolean login(String cellphone, String password);</span><br><span class="line">  UserInfo getUserInfoById(long id);</span><br><span class="line">  UserInfo getUserInfoByCellphone(String cellphone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RestrictedUserService &#123;</span><br><span class="line">  boolean deleteUserByCellphone(String cellphone);</span><br><span class="line">  boolean deleteUserById(long id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService, RestrictedUserService &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略实现代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 API 接口或函数</h4><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>比如一下代码 count() 函数功能不够单一，包含了很多不同的统计功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Statistics &#123;</span><br><span class="line">  private Long max;</span><br><span class="line">  private Long min;</span><br><span class="line">  private Long average;</span><br><span class="line">  private Long sum;</span><br><span class="line">  private Long percentile99;</span><br><span class="line">  private Long percentile999;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter等方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Statistics count(Collection&lt;Long&gt; dataSet) &#123;</span><br><span class="line">  Statistics statistics &#x3D; new Statistics();</span><br><span class="line">  &#x2F;&#x2F;...省略计算逻辑...</span><br><span class="line">  return statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Long max(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public Long min(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125; </span><br><span class="line">public Long average(Colletion&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#x2F;&#x2F; ...省略其他统计函数...</span><br></pre></td></tr></table></figure><h4 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h4><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>例子：我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    private ConfigSource configSource; &#x2F;&#x2F;配置中心（比如zookeeper）</span><br><span class="line">    private String address;</span><br><span class="line">    private int timeout;</span><br><span class="line">    private int maxTotal;</span><br><span class="line">    &#x2F;&#x2F;省略其他配置: maxWaitMillis,maxIdle,minIdle...</span><br><span class="line"></span><br><span class="line">    public RedisConfig(ConfigSource configSource) &#123;</span><br><span class="line">        this.configSource &#x3D; configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return this.address;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他get()、init()方法...</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">      &#x2F;&#x2F;从configSource加载配置到address&#x2F;timeout&#x2F;maxTotal...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br></pre></td></tr></table></figure><p>现在，有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。但是，因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。</p><p>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略其他属性和方法... &#125;</span><br><span class="line"></span><br><span class="line">public class ScheduledUpdater &#123;</span><br><span class="line">    private final ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    private long initialDelayInSeconds;</span><br><span class="line">    private long periodInSeconds;</span><br><span class="line">    private Updater updater;</span><br><span class="line"></span><br><span class="line">    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) &#123;</span><br><span class="line">        this.updater &#x3D; updater;</span><br><span class="line">        this.initialDelayInSeconds &#x3D; initialDelayInSeconds;</span><br><span class="line">        this.periodInSeconds &#x3D; periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">  ConfigSource configSource &#x3D; new ZookeeperConfigSource(&#x2F;*省略参数*&#x2F;);</span><br><span class="line">  public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">  public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">  public static final MySqlConfig mysqlConfig &#x3D; new MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater &#x3D; new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater &#x3D; new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，有一个新的监控需求，期望输出项目的配置信息到一个固定的 HTTP 地址，比如：<a href="http://127.0.0.1:2389/config" target="_blank" rel="noopener">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。</p><p>在原来代码的基础上拓展后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Viewer &#123;</span><br><span class="line">  String outputInPlainText();</span><br><span class="line">  Map&lt;String, String&gt; output();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater, Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig implements Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">  private String host;</span><br><span class="line">  private int port;</span><br><span class="line">  private Map&lt;String, List&lt;Viewer&gt;&gt; viewers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public SimpleHttpServer(String host, int port) &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">  </span><br><span class="line">  public void addViewers(String urlDirectory, Viewer viewer) &#123;</span><br><span class="line">    if (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    this.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void run() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    ConfigSource configSource &#x3D; new ZookeeperConfigSource();</span><br><span class="line">    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">    public static final MySqlConfig mysqlConfig &#x3D; new MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer &#x3D; new SimpleHttpServer(“127.0.0.1”, 2389);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则</p><h3 id="2-接口隔离原则与单一职责原则的区别"><a href="#2-接口隔离原则与单一职责原则的区别" class="headerlink" title="2.接口隔离原则与单一职责原则的区别"></a>2.接口隔离原则与单一职责原则的区别</h3><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2 id="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h2><h3 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h3><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><h3 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h3><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p>现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</p><h3 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h3><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>例子：<br>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</p><h2 id="理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？"><a href="#理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？"></a>理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？</h2><p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p><blockquote><p>Keep It Simple and Stupid.<br>Keep It Short and Simple.Keep<br>It Simple and Straightforward.</p></blockquote><p>KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。</p><h3 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h3><ul><li><p>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</p></li><li><p>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</p></li><li><p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p></li></ul><h3 id="YAGNI-原则"><a href="#YAGNI-原则" class="headerlink" title="YAGNI 原则"></a>YAGNI 原则</h3><blockquote><p>You Ain’t Gonna Need It。</p></blockquote><p>直译就是：你不会需要它,实际上，这条原则的核心思想就是：不要做过度设计。</p><p>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</p><p>比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h2 id="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h2><h3 id="DRY-原则（Don’t-Repeat-Yourself）"><a href="#DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="DRY 原则（Don’t Repeat Yourself）"></a>DRY 原则（Don’t Repeat Yourself）</h3><p>原则我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p><h3 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h3><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><h2 id="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h2><p>Law of Demeter</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p><p><strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</strong></p><h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><ol><li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</li></ol><h3 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2. 如何理解“迪米特法则”？"></a>2. 如何理解“迪米特法则”？</h3><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h3 id="3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"><a href="#3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？" class="headerlink" title="3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"></a>3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？</h3><p>目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。</p><h2 id="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h2><p>以 分兑换系统的开发实战 为例：</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"><a href="#1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中" class="headerlink" title="1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"></a>1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中</h4><p>你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。</p><h4 id="2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"><a href="#2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。" class="headerlink" title="2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"></a>2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</h4><p>用户用例有点儿类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。<br>比如，有关积分有效期的用户用例，我们可以进行如下的设计：</p><ul><li>用户在获取积分的时候，会告知积分的有效期；</li><li>用户在使用积分的时候，会优先使用快过期的积分；</li><li>用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；</li><li>用户在查询总可用积分的时候，会排除掉过期的积分。</li></ul><h4 id="3-大致梳理出需求功能点"><a href="#3-大致梳理出需求功能点" class="headerlink" title="3. 大致梳理出需求功能点"></a>3. 大致梳理出需求功能点</h4><ul><li>积分赚取和兑换规则</li><li>积分消费和兑换规则</li><li>积分及其明细查询</li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="1-合理地将功能划分到不同模块"><a href="#1-合理地将功能划分到不同模块" class="headerlink" title="1. 合理地将功能划分到不同模块"></a>1. 合理地将功能划分到不同模块</h4><p>除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>可以这样划分：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><h4 id="2-设计模块与模块之间的交互关系"><a href="#2-设计模块与模块之间的交互关系" class="headerlink" title="2. 设计模块与模块之间的交互关系"></a>2. 设计模块与模块之间的交互关系</h4><p>比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好</p><p>比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。</p><p>除此之外，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。</p><h4 id="3-设计模块的接口、数据库、业务模型"><a href="#3-设计模块的接口、数据库、业务模型" class="headerlink" title="3. 设计模块的接口、数据库、业务模型"></a>3. 设计模块的接口、数据库、业务模型</h4><p>务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p></li><li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p></li><li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p></li></ol><h2 id="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h2><p>我们平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）。</p><p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p><h3 id="针对积分系统，我们先来看，如何设计数据库。"><a href="#针对积分系统，我们先来看，如何设计数据库。" class="headerlink" title="针对积分系统，我们先来看，如何设计数据库。"></a>针对积分系统，我们先来看，如何设计数据库。</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2453" alt="e9562c46bcb8fc45634f0d870c4778c4.jpeg"></p><h3 id="如何设计积分系统的接口"><a href="#如何设计积分系统的接口" class="headerlink" title="如何设计积分系统的接口"></a>如何设计积分系统的接口</h3><p>为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2454" alt="7b9008f6bc107add2b21d3dba901deaf.jpeg"></p><h3 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h3><p>从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型，对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。</p><h3 id="为什么要分-MVC-三层开发？"><a href="#为什么要分-MVC-三层开发？" class="headerlink" title="为什么要分 MVC 三层开发？"></a>为什么要分 MVC 三层开发？</h3><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><h3 id="BO、VO、Entity-存在的意义是什么？"><a href="#BO、VO、Entity-存在的意义是什么？" class="headerlink" title="BO、VO、Entity 存在的意义是什么？"></a>BO、VO、Entity 存在的意义是什么？</h3><p>对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因。</p><p>1.VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。</p><p>2.VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</p><p>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</p><h3 id="VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set"><a href="#VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set" class="headerlink" title="VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set"></a>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</h3><ol><li><p>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</p></li><li><p>Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p></li></ol><h2 id="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看。</p><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要。</p><h4 id="1-功能性需求分析"><a href="#1-功能性需求分析" class="headerlink" title="1.功能性需求分析"></a>1.功能性需求分析</h4><ul><li>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。</li><li>统计信息的类型：max、min、avg、percentile、count、tps 等。</li><li>统计信息显示格式：Json、Html、自定义显示格式。</li><li>统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端</li></ul><p>借助设计产品的时候，经常用到的线框图，把最终数据的显示样式画出来<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2455" alt="f04b341ad5fda418ae24f166d0a4dde5.jpeg"></p><p>实际上，从线框图中，我们还能挖掘出了下面几个隐藏的需求。</p><ul><li>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</li><li>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 12 月 11 日 00 点到 12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等。</li><li>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件。</li></ul><h4 id="2-非功能性需求分析"><a href="#2-非功能性需求分析" class="headerlink" title="2.非功能性需求分析"></a>2.非功能性需求分析</h4><h5 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h5><p>在开发这样一个技术框架的时候，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是我们应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p><h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件</p><h5 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h5><p>要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。</p><h5 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h5><p>为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等。</p><h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p>借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础。</p><p>，我们可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以 JSON 的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多。</p><p>首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。在原型系统的代码实现中，我们可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。</p><p>最小原型的代码实现如下所示。其中，recordResponseTime() 和 recordTimestamp() 两个函数分别用来记录接口请求的响应时间和访问时间。startRepeatedReport() 函数以指定的频率统计数据并输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Metrics &#123;</span><br><span class="line">  &#x2F;&#x2F; Map的key是接口名称，value对应接口请求的响应时间或时间戳；</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; responseTimes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; timestamps &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">  public void recordResponseTime(String apiName, double responseTime) &#123;</span><br><span class="line">    responseTimes.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    responseTimes.get(apiName).add(responseTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void recordTimestamp(String apiName, double timestamp) &#123;</span><br><span class="line">    timestamps.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    timestamps.get(apiName).add(timestamp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startRepeatedReport(long period, TimeUnit unit)&#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : responseTimes.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiRespTimes &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;max&quot;, max(apiRespTimes));</span><br><span class="line">          stats.get(apiName).put(&quot;avg&quot;, avg(apiRespTimes));</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : timestamps.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiTimestamps &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;count&quot;, (double)apiTimestamps.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, period, unit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private double max(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">  private double avg(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Metrics metrics &#x3D; new Metrics();</span><br><span class="line">  </span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    metrics.startRepeatedReport(60, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void register(UserVo user) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;regsiter&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;register&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;login&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;login&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于最新的原型进一步考虑"><a href="#基于最新的原型进一步考虑" class="headerlink" title="基于最新的原型进一步考虑"></a>基于最新的原型进一步考虑</h3><p>图可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2456" alt="926561b82b49c937dcf4a2b9e6b35c16.jpeg"></p><p>把整个框架分为四个模块：数据采集、存储、聚合统计、显示。每个模块负责的工作简单罗列如下。</p><ul><li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。数据采集过程要高度容错，不能影响到接口本身的可用性。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，我们也要尽量考虑其易用性。</li><li>存储：负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程异步完成。</li><li>聚合统计：负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps 等。为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。</li><li>显示：负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等。</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol><li>对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。</li></ol><p>2.对于复杂框架的设计，很多人往往觉得无从下手。今天我们分享了几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p><p>3.面向对象分析、设计和实现的时候，我们讲到设计阶段最终输出的是类的设计，</p><h2 id="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h2><p>即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式。所以，我们应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0……版本中继续迭代优化。</p><ul><li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。</li><li>存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，我们暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行。</li><li>聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps。</li><li>显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔 n 秒统计显示上 m 秒的数据（比如，间隔 60s 统计上 60s 的数据）。邮件每日统计上日的数据。</li></ul><h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>先大致识别出下面几个接口或类：</p><ul><li>MetricsCollector 类负责提供 API，来采集接口请求的原始数据。我们可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个 MetricsCollector 的实现方式。</li><li>MetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来存储。</li><li>Aggregator 类负责根据原始数据计算统计数据。</li><li>ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，我们暂时还不能确定。</li></ul><h3 id="2-定义类及类与类之间的关系"><a href="#2-定义类及类与类之间的关系" class="headerlink" title="2. 定义类及类与类之间的关系"></a>2. 定义类及类与类之间的关系</h3><p>接下来就是定义类及属性和方法，定义类与类之间的关系：</p><p>大致地识别出几个核心的类之后，我的习惯性做法是，先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。在设计类、类与类之间交互的时候，我会不断地用之前学过的设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS 原则、DRY 原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。</p><p>MetricsCollector 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MetricsCollector &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125; &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetricsStorage、RedisMetricsStorage 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface MetricsStorage &#123;</span><br><span class="line">  void saveRequestInfo(RequestInfo requestInfo);</span><br><span class="line"></span><br><span class="line">  List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimeInMillis, long endTimeInMillis);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimeInMillis, long endTimeInMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisMetricsStorage implements MetricsStorage &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略属性和构造函数等...</span><br><span class="line">  @Override</span><br><span class="line">  public void saveRequestInfo(RequestInfo requestInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aggregator 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Aggregator &#123;</span><br><span class="line">  public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) &#123;</span><br><span class="line">    double maxRespTime &#x3D; Double.MIN_VALUE;</span><br><span class="line">    double minRespTime &#x3D; Double.MAX_VALUE;</span><br><span class="line">    double avgRespTime &#x3D; -1;</span><br><span class="line">    double p999RespTime &#x3D; -1;</span><br><span class="line">    double p99RespTime &#x3D; -1;</span><br><span class="line">    double sumRespTime &#x3D; 0;</span><br><span class="line">    long count &#x3D; 0;</span><br><span class="line">    for (RequestInfo requestInfo : requestInfos) &#123;</span><br><span class="line">      ++count;</span><br><span class="line">      double respTime &#x3D; requestInfo.getResponseTime();</span><br><span class="line">      if (maxRespTime &lt; respTime) &#123;</span><br><span class="line">        maxRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      if (minRespTime &gt; respTime) &#123;</span><br><span class="line">        minRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      sumRespTime +&#x3D; respTime;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      avgRespTime &#x3D; sumRespTime &#x2F; count;</span><br><span class="line">    &#125;</span><br><span class="line">    long tps &#x3D; (long)(count &#x2F; durationInMillis * 1000);</span><br><span class="line">    Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(RequestInfo o1, RequestInfo o2) &#123;</span><br><span class="line">        double diff &#x3D; o1.getResponseTime() - o2.getResponseTime();</span><br><span class="line">        if (diff &lt; 0.0) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">        &#125; else if (diff &gt; 0.0) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int idx999 &#x3D; (int)(count * 0.999);</span><br><span class="line">    int idx99 &#x3D; (int)(count * 0.99);</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      p999RespTime &#x3D; requestInfos.get(idx999).getResponseTime();</span><br><span class="line">      p99RespTime &#x3D; requestInfos.get(idx99).getResponseTime();</span><br><span class="line">    &#125;</span><br><span class="line">    RequestStat requestStat &#x3D; new RequestStat();</span><br><span class="line">    requestStat.setMaxResponseTime(maxRespTime);</span><br><span class="line">    requestStat.setMinResponseTime(minRespTime);</span><br><span class="line">    requestStat.setAvgResponseTime(avgRespTime);</span><br><span class="line">    requestStat.setP999ResponseTime(p999RespTime);</span><br><span class="line">    requestStat.setP99ResponseTime(p99RespTime);</span><br><span class="line">    requestStat.setCount(count);</span><br><span class="line">    requestStat.setTps(tps);</span><br><span class="line">    return requestStat;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestStat &#123;</span><br><span class="line">  private double maxResponseTime;</span><br><span class="line">  private double minResponseTime;</span><br><span class="line">  private double avgResponseTime;</span><br><span class="line">  private double p999ResponseTime;</span><br><span class="line">  private double p99ResponseTime;</span><br><span class="line">  private long count;</span><br><span class="line">  private long tps;</span><br><span class="line">  &#x2F;&#x2F;...省略getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsoleReporter、EmailReporterv 代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class ConsoleReporter &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">  public ConsoleReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 第4个代码逻辑：定时触发第1、2、3代码逻辑的执行；</span><br><span class="line">  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) &#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 第1个代码逻辑：根据给定的时间区间，从数据库中拉取数据；</span><br><span class="line">        long durationInMillis &#x3D; durationInSeconds * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          &#x2F;&#x2F; 第2个代码逻辑：根据原始数据，计算得到统计数据；</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第3个代码逻辑：将统计数据显示到终端（命令行或邮件）；</span><br><span class="line">        System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMillis + &quot;]&quot;);</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailReporter &#123;</span><br><span class="line">  private static final Long DAY_HOURS_IN_SECONDS &#x3D; 86400L;</span><br><span class="line"></span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private EmailSender emailSender;</span><br><span class="line">  private List&lt;String&gt; toAddresses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this(metricsStorage, new EmailSender(&#x2F;*省略参数*&#x2F;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.emailSender &#x3D; emailSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addToAddress(String address) &#123;</span><br><span class="line">    toAddresses.add(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startDailyReport() &#123;</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.DATE, 1);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">    calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">    calendar.set(Calendar.SECOND, 0);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">    Date firstTime &#x3D; calendar.getTime();</span><br><span class="line">    Timer timer &#x3D; new Timer();</span><br><span class="line">    timer.schedule(new TimerTask() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        long durationInMillis &#x3D; DAY_HOURS_IN_SECONDS * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: 格式化为html格式，并且发送邮件</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, firstTime, DAY_HOURS_IN_SECONDS * 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 将类组装起来并提供执行入口<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    MetricsStorage storage &#x3D; new RedisMetricsStorage();</span><br><span class="line">    ConsoleReporter consoleReporter &#x3D; new ConsoleReporter(storage);</span><br><span class="line">    consoleReporter.startRepeatedReport(60, 60);</span><br><span class="line"></span><br><span class="line">    EmailReporter emailReporter &#x3D; new EmailReporter(storage);</span><br><span class="line">    emailReporter.addToAddress(&quot;wangzheng@xzg.com&quot;);</span><br><span class="line">    emailReporter.startDailyReport();</span><br><span class="line"></span><br><span class="line">    MetricsCollector collector &#x3D; new MetricsCollector(storage);</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(100000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Review-设计与实现-以及问题分析"><a href="#Review-设计与实现-以及问题分析" class="headerlink" title="Review 设计与实现 以及问题分析"></a>Review 设计与实现 以及问题分析</h3><ul><li><p>Aggregator 类是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算。当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化。</p></li><li><p>ConsoleReporter、EmailReporterConsoleReporter 和 EmailReporter 中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 DRY 原则。而且整个类负责的事情比较多，职责不是太单一。特别是显示部分的代码，可能会比较复杂（比如 Email 的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好。</p></li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol><li><p>写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的 Unix 系统，第一版很简单、粗糙，代码不到 1 万行。所以，迭代思维很重要，不要刚开始就追求完美。</p></li><li><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计原则概述&quot;&gt;&lt;a href=&quot;#设计原则概述&quot; class=&quot;headerlink&quot; title=&quot;设计原则概述&quot;&gt;&lt;/a&gt;设计原则概述&lt;/h2&gt;&lt;p&gt;SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，SRP单一职责原则 Single Responsibility Principle； KISS保持简单 Keep It Simple and Stupid； YAGNI不需要原则 You Ain’t Gonna Need It ； DRY 不要重复原则 Don’t Repeat Yourself ； LOD 迪米特法则 Law of Demeter。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码</title>
    <link href="https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/"/>
    <id>https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/</id>
    <published>2020-10-03T15:37:56.000Z</published>
    <updated>2021-01-02T07:49:47.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h2><h3 id="1-什么是基于贫血模型的传统开发模式？"><a href="#1-什么是基于贫血模型的传统开发模式？" class="headerlink" title="1.什么是基于贫血模型的传统开发模式？"></a>1.什么是基于贫血模型的传统开发模式？</h3><p>像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo &#x3D; userService.getUserById(userId);</span><br><span class="line">    UserVo userVo &#x3D; [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity &#x3D; userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo &#x3D; [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-什么是基于充血模型的-DDD-开发模式？"><a href="#2-什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="2.什么是基于充血模型的 DDD 开发模式？"></a>2.什么是基于充血模型的 DDD 开发模式？</h3><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><h3 id="3-贫血模型-与-充血模型的代码模式区别"><a href="#3-贫血模型-与-充血模型的代码模式区别" class="headerlink" title="3.贫血模型 与 充血模型的代码模式区别"></a>3.贫血模型 与 充血模型的代码模式区别</h3><p>基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p><h3 id="4-为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#4-为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="4.为什么基于贫血模型的传统开发模式如此受欢迎？"></a>4.为什么基于贫血模型的传统开发模式如此受欢迎？</h3><ol><li><p>一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，基于贫血模型的传统开发模式简单够用</p></li><li><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p></li><li><p>思维已固化，转型有成本</p></li></ol><h3 id="5-什么时候该选择用贫血模型？什么时候该用充血模型？"><a href="#5-什么时候该选择用贫血模型？什么时候该用充血模型？" class="headerlink" title="5.什么时候该选择用贫血模型？什么时候该用充血模型？"></a>5.什么时候该选择用贫血模型？什么时候该用充血模型？</h3><p>基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><h2 id="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h2><h3 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h3><p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p><p><img src="/images/or01.jpg" alt="9e91377602ef154eaf866c7e9263a64a.jpeg"></p><h4 id="1-充值"><a href="#1-充值" class="headerlink" title="1.充值"></a>1.充值</h4><p>充值用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水</p><p><img src="/images/or02.jpg" alt="3915a6544403854d35678c81fe65f014.jpeg"></p><h4 id="2-支付"><a href="#2-支付" class="headerlink" title="2. 支付"></a>2. 支付</h4><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。<br><img src="/images/or03.jpg" alt="7eb44e2f8661d1c3debde85f79fb2c5e.jpeg"></p><h4 id="3-提现"><a href="#3-提现" class="headerlink" title="3. 提现"></a>3. 提现</h4><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。<br><img src="/images/or04.jpg" alt="66ede1de93d29b86a9194ea0f80d1e43.jpeg"></p><h4 id="4-查询余额"><a href="#4-查询余额" class="headerlink" title="4.查询余额"></a>4.查询余额</h4><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p><h4 id="5-查询交易流水"><a href="#5-查询交易流水" class="headerlink" title="5.查询交易流水"></a>5.查询交易流水</h4><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p><h4 id="钱包系统的设计思路-1"><a href="#钱包系统的设计思路-1" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h4><p>可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p><p><img src="/images/or05.jpg" alt="60d3cfec73986b52e3a6ef4fe147e562.jpeg"></p><p>以虚拟钱包的设计为例，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</p><p><img src="/images/or06.jpg" alt="d1a9aeb6642404f80a62293ab2e45630.jpeg"></p><p>充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？<br>虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p><p>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</p><p>可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p><p><img src="/images/or07.jpg" alt="fb356a2589a14f2f3440247e3c7a7718.jpeg"></p><h3 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h3><p>是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，省略了具体的代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VirtualWalletController &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123; ... &#125; &#x2F;&#x2F;查询余额</span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;出账</span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;入账</span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123; ...&#125; &#x2F;&#x2F;转账</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWalletBo &#123;&#x2F;&#x2F;省略getter&#x2F;setter&#x2F;constructor方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime;</span><br><span class="line">  private BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWalletBo getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWalletBo walletBo &#x3D; convert(walletEntity);</span><br><span class="line">    return walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    if (balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new NoSufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity &#x3D; new VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId &#x3D; transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    try &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; catch (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h3><p>跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。</p><p>把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWallet &#123; &#x2F;&#x2F; Domain领域模型(充血模型)</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime &#x3D; System.currentTimeMillis();;</span><br><span class="line">  private BigDecimal balance &#x3D; BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet(Long preAllocatedId) &#123;</span><br><span class="line">    this.id &#x3D; preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal balance() &#123;</span><br><span class="line">    return this.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(BigDecimal amount) &#123;</span><br><span class="line">    if (this.balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(BigDecimal amount) &#123;</span><br><span class="line">    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">      throw new InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    return wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    &#x2F;&#x2F;...跟基于贫血模型的传统开发模式的代码一样...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p><p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><h3 id="精彩评论：充血模型可以说是业务的精准抽象"><a href="#精彩评论：充血模型可以说是业务的精准抽象" class="headerlink" title="精彩评论：充血模型可以说是业务的精准抽象"></a>精彩评论：充血模型可以说是业务的精准抽象</h3><p>我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。</p><p>在维护性上来说，如果项目新进了开发人员，如果是贫血模型的service代码，无论代码如何清晰，注释如何完备，代码结构设计得如何优雅，都没有办法第一时间理解系统的核心业务逻辑，但是如果是充血模型，直接阅读充血模型的行为方法，起码能够很快理解70%左右的业务逻辑，因为充血模型可以说是业务的精准抽象，我想，这就是领域模型驱动能够达到”驱动”效果的由来吧。</p><h2 id="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"></a>实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>1.第一轮寄出分析：<br>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>2.第二轮优化分析<br>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的， 存在 重放攻击问题。我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>3.第三轮优化分析</p><p>4.第四轮优化分析</p><p><img src="/images/or08.jpg" alt="bde932c73c6636ad85380e4801dbfb60.jpeg"></p><p>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><p>开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p></li><li><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p></li></ol><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>3.针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.工作中遇到非crud的需求我就会想尽一切办法让他通用，基本需求分析和需求设计的时间占用百分之五十，开发和重构到自认为最优占用百分之五十。比如最简单的验证码功能，几乎每个项目都有，我就封装一套验证码服务，主要功能有你在配置文件里配置好需要被验证码拦截的路径，这里还要考虑到通配符，空格等等细节和可扩展的点，内置图片验证码，极验证，手机验证以及自定义验证码等等，总之我认为如果有机会遇到非crud的需求，一定要好好珍惜，好好把握，把他打造成属于自己的产品，这样会让自己下意识的去想尽一切办法把他做到最优，亲儿子一样的待遇，再也不会无脑cv</p><ol start="2"><li>一句话：使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进。<br>拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：</li><li>什么叫接口鉴权？搞清基本概念</li><li>接口鉴权最佳实践是什么？技术调研</li><li>appid和secret key从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。</li><li>appid secretkey存储在什么地方呢？数据存储</li><li>用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。</li><li>这个功能如何测试？提前想好如何测试</li><li>接口鉴权功能何时上线？估计工期</li><li>鉴权成功或失败返回码和信息定义？约定返回结果</li></ol><p>关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击。</p><ol start="3"><li>程序员十倍法则</li></ol><h2 id="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h2><p>向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><p>例子：我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p><p>1.把 URL、AppID、密码、时间戳拼接为一个字符串；<br>2.对字符串通过加密算法加密生成 token；<br>3.将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；<br>4.解析 URL，得到 token、AppID、时间戳等信息；<br>5.从存储中取出 AppID 和对应的密码；<br>6.根据时间戳判断 token 是否过期失效；<br>7.验证两个 token 是否匹配；</p><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><h3 id="2-定义类及其属性和方法"><a href="#2-定义类及其属性和方法" class="headerlink" title="2. 定义类及其属性和方法"></a>2. 定义类及其属性和方法</h3><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage</p><p>AuthToken 类相关的功能点有四个：</p><ul><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配。</li></ul><p><img src="/images/or09.jpg" alt="69c8954e0db1a4db99a6094ee359fc9b.jpeg"></p><p>Url 类相关的功能点有两个：</p><ul><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息。<br><img src="/images/or10.jpg" alt="1cc9b95e511bd49fbc23c00ac5c0fed6.jpeg"></li></ul><p>CredentialStorage 类相关的功能点有一个：</p><ul><li>从存储中取出 AppID 和对应的密码。</li></ul><p><img src="/images/or11.jpg" alt="3b6d2c0cadafa723e26cc032c29c8785.jpeg"></p><h3 id="3-定义类与类之间的交互关系"><a href="#3-定义类与类之间的交互关系" class="headerlink" title="3. 定义类与类之间的交互关系"></a>3. 定义类与类之间的交互关系</h3><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p><p>泛化（Generalization）可以简单理解为继承关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实现（Realization）一般是指接口和实现类之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>组合 （Composition）只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系强调部分与整体的关系，其中包括两种情况，关联性强（大雁与翅膀）的与关联性弱（学生与班级）的。（这里将将 UML 定义的 关联、聚合、组合 统一归类为组合）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">组合（Composition）：关联性强（大雁与翅膀）</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">聚合（Aggregation）：关联性弱（学生与班级）</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  public void func(B b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-将类组装起来并提供执行入口"><a href="#4-将类组装起来并提供执行入口" class="headerlink" title="4. 将类组装起来并提供执行入口"></a>4. 将类组装起来并提供执行入口</h3><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p><h3 id="评论区的代码实现参考"><a href="#评论区的代码实现参考" class="headerlink" title="评论区的代码实现参考"></a>评论区的代码实现参考</h3><p><a href="https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014</a></p><p><a href="https://gitee.com/MondayLiu/geek-design" target="_blank" rel="noopener">https://gitee.com/MondayLiu/geek-design</a></p><p><a href="https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth" target="_blank" rel="noopener">https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot;&gt;&lt;a href=&quot;#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot; class=&quot;headerlink&quot; title=&quot;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot;&gt;&lt;/a&gt;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&lt;/h2&gt;&lt;h3 id=&quot;1-什么是基于贫血模型的传统开发模式？&quot;&gt;&lt;a href=&quot;#1-什么是基于贫血模型的传统开发模式？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是基于贫血模型的传统开发模式？&quot;&gt;&lt;/a&gt;1.什么是基于贫血模型的传统开发模式？&lt;/h3&gt;&lt;p&gt;像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part1：面向对象-如何写出高质量的代码</title>
    <link href="https://crazyfzw.github.io/2020/10/01/design-pattern-object-oriented01/"/>
    <id>https://crazyfzw.github.io/2020/10/01/design-pattern-object-oriented01/</id>
    <published>2020-10-01T03:32:52.000Z</published>
    <updated>2021-01-02T07:49:40.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习设计模式的重要性"><a href="#学习设计模式的重要性" class="headerlink" title="学习设计模式的重要性"></a>学习设计模式的重要性</h2><h3 id="学习设计模式可以让读源码、框架事半功倍"><a href="#学习设计模式可以让读源码、框架事半功倍" class="headerlink" title="学习设计模式可以让读源码、框架事半功倍"></a>学习设计模式可以让读源码、框架事半功倍</h3><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p><a id="more"></a><h3 id="提高复杂代码的设计和开发能力"><a href="#提高复杂代码的设计和开发能力" class="headerlink" title="提高复杂代码的设计和开发能力"></a>提高复杂代码的设计和开发能力</h3><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p><h2 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h2><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h2 id="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h2><p><img src="/images/20201001.jpg" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p><ul><li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul><h2 id="面向对象编程的一些基础概念"><a href="#面向对象编程的一些基础概念" class="headerlink" title="面向对象编程的一些基础概念"></a>面向对象编程的一些基础概念</h2><ol><li><p>什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p></li><li><p>什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li><li><p>如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p></li><li><p>面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p></li><li><p>什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p></li></ol><h2 id="UML-图只要能表达出设计就可以了"><a href="#UML-图只要能表达出设计就可以了" class="headerlink" title="UML 图只要能表达出设计就可以了"></a>UML 图只要能表达出设计就可以了</h2><p>要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。</p><h2 id="封装、抽象、继承、多态-存在的意义"><a href="#封装、抽象、继承、多态-存在的意义" class="headerlink" title="封装、抽象、继承、多态 存在的意义"></a>封装、抽象、继承、多态 存在的意义</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据, 封装存在的意思，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。但是，过度的使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态特性能提高代码的可扩展性和复用性。除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><p>接下来，看个例子如何利用接口类来实现多态特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Iterator arrayIterator = <span class="keyword">new</span> Array();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    Iterator linkedListIterator = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。</p><p>具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。</p><p>我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p><p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p><h3 id="面向对象特性的-What-How-Why-模型总结"><a href="#面向对象特性的-What-How-Why-模型总结" class="headerlink" title="面向对象特性的 What/How/Why 模型总结"></a>面向对象特性的 What/How/Why 模型总结</h3><p>##封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。</p><p>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。</p><p>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。</p><p>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。</p><p>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。</p><h2 id="什么是面向过程编程？什么是面向过程编程语言？"><a href="#什么是面向过程编程？什么是面向过程编程语言？" class="headerlink" title="什么是面向过程编程？什么是面向过程编程语言？"></a>什么是面向过程编程？什么是面向过程编程语言？</h2><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>面向对象编程相比起面向过程编程的优势主要有三个。</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h2 id="怎么考虑选择使用面向过程语言还是面向对象语言？"><a href="#怎么考虑选择使用面向过程语言还是面向对象语言？" class="headerlink" title="怎么考虑选择使用面向过程语言还是面向对象语言？"></a>怎么考虑选择使用面向过程语言还是面向对象语言？</h2><p>使用任何一个编程语言编写的程序，最终执行上都要落实到CPU一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。<br>C语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C语言用数组char a[8]，经过编译以后变成了（基地址＋偏移量）的方式。对于CPU来说，没有运算比加法更快，它的执行效率的算法复杂度是O(1)的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C语言是极好的选择。<br>C语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了OOP等更“智能”的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节, 占用了更大的内存空间, 占用了更多的CPU运算。从这个角度看，OOP这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核600MHz为主流，运行Android系统点击一个界面需要2秒才能响应，那我们现在用的大部分手机程序绝对不是使用JAVA开发的，Android操作系统也不可能建立起这么大的生态。</p><h2 id="哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的？"></a>哪些代码设计看似是面向对象，实际是面向过程的？</h2><h3 id="1-滥用-getter、setter-方法"><a href="#1-滥用-getter、setter-方法" class="headerlink" title="1. 滥用 getter、setter 方法"></a>1. 滥用 getter、setter 方法</h3><p>面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p><p>在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</p><p>Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-滥用全局变量和全局方法"><a href="#2-滥用全局变量和全局方法" class="headerlink" title="2. 滥用全局变量和全局方法"></a>2. 滥用全局变量和全局方法</h3><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性</p><h3 id="3-定义数据和方法分离的"><a href="#3-定义数据和方法分离的" class="headerlink" title="3. 定义数据和方法分离的"></a>3. 定义数据和方法分离的</h3><p>这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的</p><h2 id="接口vs抽象类的区别？"><a href="#接口vs抽象类的区别？" class="headerlink" title="接口vs抽象类的区别？"></a>接口vs抽象类的区别？</h2><h3 id="1-抽象类的特性"><a href="#1-抽象类的特性" class="headerlink" title="1.抽象类的特性"></a>1.抽象类的特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">    doLog(level, message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, String filepath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.fileWriter = <span class="keyword">new</span> FileWriter(filepath); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MessageQueueLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）。</p></li><li><p>我抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作抽象方法。</p></li><li><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p></li></ul><h3 id="2-接口的特性"><a href="#2-接口的特性" class="headerlink" title="2.接口的特性"></a>2.接口的特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...鉴权逻辑..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...限流逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用Demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">  <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRpcRequest</span><span class="params">(RpcRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        filter.doFilter(req);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">      <span class="comment">// ...处理过滤结果...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略其他处理逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能包含属性（也就是成员变量）。</li><li>接口只能声明方法，方法不能包含代码实现。</li><li>类实现接口的时候，必须实现接口中声明的所有方法。</li></ul><h3 id="3-抽象类和接口的语法特性小结"><a href="#3-抽象类和接口的语法特性小结" class="headerlink" title="3.抽象类和接口的语法特性小结"></a>3.抽象类和接口的语法特性小结</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><h3 id="4-抽象类和接口的区别"><a href="#4-抽象类和接口的区别" class="headerlink" title="4.抽象类和接口的区别"></a>4.抽象类和接口的区别</h3><p>抽象类更多的是为了代码复用，多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。</p><p>而接口就更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。<br>你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><h3 id="5-什么时候该用抽象类？什么时候该用接口？"><a href="#5-什么时候该用抽象类？什么时候该用接口？" class="headerlink" title="5.什么时候该用抽象类？什么时候该用接口？"></a>5.什么时候该用抽象类？什么时候该用接口？</h3><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h2 id="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h2><h3 id="结合一个有关图片存储的实战案例"><a href="#结合一个有关图片存储的实战案例" class="headerlink" title="结合一个有关图片存储的实战案例"></a>结合一个有关图片存储的实战案例</h3><p>下面是 “基于实现的编程”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket代码逻辑...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...; <span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    AliyunImageStore imageStore = <span class="keyword">new</span> AliyunImageStore(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">    String accessToken = imageStore.generateAccessToken();</span><br><span class="line">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的问题分析：</p><ol><li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li></ol><p>2.封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。比如 generateAccessToken 这个特殊的方法就没必要暴露了</p><p>3.为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</p><p>改造成 “基于接口而非实现编程” 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span></span>;</span><br><span class="line">  <span class="function">Image <span class="title">download</span><span class="params">(String url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span>  </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">    <span class="comment">//...返回图片的url...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...;<span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    ImageStore imageStore = <span class="keyword">new</span> PrivateImageStore(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么基于接口而非实现编程？"><a href="#为什么基于接口而非实现编程？" class="headerlink" title="为什么基于接口而非实现编程？"></a>为什么基于接口而非实现编程？</h3><p>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性</p><h3 id="有必要为每个类都定义接口吗？"><a href="#有必要为每个类都定义接口吗？" class="headerlink" title="有必要为每个类都定义接口吗？"></a>有必要为每个类都定义接口吗？</h3><ol><li>视业务场景而定，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li><li>某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li></ol><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><ol start="2"><li>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</li></ol><p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2 id="为何说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#为何说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="为何说要多用组合少用继承？如何决定该用组合还是继承？"></a>为何说要多用组合少用继承？如何决定该用组合还是继承？</h2><h3 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h3><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。<br>比如继承<br><img src="/images/20201002.jpg" alt="3f99fa541e7ec7656a1dd35cc4f28bc6.jpeg"></p><h3 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h3><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><h3 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h3><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"><a href="#如何用组合、接口、委托三个技术手段来避免继承层级过多的问题" class="headerlink" title="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"></a>如何用组合、接口、委托三个技术手段来避免继承层级过多的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FlyAbility implements Flyable </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span>&#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> EggLayAbility eggLayAbility = <span class="keyword">new</span> EggLayAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习设计模式的重要性&quot;&gt;&lt;a href=&quot;#学习设计模式的重要性&quot; class=&quot;headerlink&quot; title=&quot;学习设计模式的重要性&quot;&gt;&lt;/a&gt;学习设计模式的重要性&lt;/h2&gt;&lt;h3 id=&quot;学习设计模式可以让读源码、框架事半功倍&quot;&gt;&lt;a href=&quot;#学习设计模式可以让读源码、框架事半功倍&quot; class=&quot;headerlink&quot; title=&quot;学习设计模式可以让读源码、框架事半功倍&quot;&gt;&lt;/a&gt;学习设计模式可以让读源码、框架事半功倍&lt;/h3&gt;&lt;p&gt;优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Java SPI 机制</title>
    <link href="https://crazyfzw.github.io/2019/08/24/java-spi/"/>
    <id>https://crazyfzw.github.io/2019/08/24/java-spi/</id>
    <published>2019-08-24T04:37:56.000Z</published>
    <updated>2021-01-02T07:53:23.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPI-可以用来做什么"><a href="#SPI-可以用来做什么" class="headerlink" title="# SPI 可以用来做什么"></a><a href="#SPI-可以用来做什么" title="# SPI 可以用来做什么"></a># SPI 可以用来做什么</h2><p>在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：</p><ol><li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li><li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。</li></ol><p>而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。</p><p>Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。</p><a id="more"></a><p>（大致原理就是：在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用 java.util.ServiceLoader 来加载具体的实现。）</p><p><img src="/images/2019082401.png" alt=""></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><a href="#使用场景" title="使用场景"></a>使用场景</h3><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：</p><ol><li><p>JDBC自动加载不同类型的数据库驱动， mysql-connector-java-xxx.jar</p></li><li><p>日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类</p></li><li><p>Dubbo中在Java SPI 的基础上做了加强， 实现了根据方法参数或者配置来决定该使用哪个扩展。比如LoadBalance 做到了根据调用者参数的指定来应用不同的负债均衡策略。</p></li></ol><h2 id="如何实现一个自定义-SPI"><a href="#如何实现一个自定义-SPI" class="headerlink" title="# 如何实现一个自定义 SPI"></a><a href="#如何实现一个自定义-SPI" title="# 如何实现一个自定义 SPI"></a># 如何实现一个自定义 SPI</h2><p>这里由于现实情况不同厂商的实现肯定是分开的，所以不同厂商我是建了不同的 maven-modules， 目录结果如下：</p><p><img src="/images/2019082402.png" alt=""></p><h3 id="1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来"><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" class="headerlink" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a>1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 建立连接</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span></span>;</span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><h3 id="2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" class="headerlink" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a>2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository</h3><p> MysqlRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mysql"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.mysql.MysqlRepository</span></pre></td></tr></table></figure><p>OracleRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Oracle"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span></pre></td></tr></table></figure><p>MongoRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mongo"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span></pre></td></tr></table></figure><h3 id="3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）"><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" class="headerlink" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a>3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）</h3><p>这里是invoker-test 模块的pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>interface-standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oracle-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure><h3 id="4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现"><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" class="headerlink" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a>4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line"></span><span class="line">        ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);</span><span class="line"></span><span class="line">        Iterator&lt;IRepository&gt; it = serviceLoader.iterator();</span><span class="line">        <span class="keyword">while</span> (it != <span class="keyword">null</span> &amp;&amp; it.hasNext())&#123;</span><span class="line">            IRepository repositoryService = it.next();</span><span class="line">            System.out.println(<span class="string">"class:"</span> + repositoryService.getClass().getName());</span><span class="line">            repositoryService.connect(<span class="string">"172.0.0.1:3306"</span>);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>运行效果图如下：</p><p><img src="/images/2019082403.png" alt=""></p><p><strong>调用主类无需修改代码，只需通过修改pom引入不同的依赖，就可以选择切换不同的实现。</strong></p><h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="# SPI 的优缺点"></a><a href="#SPI-的优缺点" title="# SPI 的优缺点"></a># SPI 的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><a href="#优点：" title="优点："></a>优点：</h3><ol><li>Java SPI的使用很简单。也做到了基本的加载扩展点的功能，可以使业务代码和组件代码脱耦，启用替换可插拔</li><li>拓展性好，在不修改原来代码的基础上，通过添加代码就可以拓展新的能力</li><li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便</li></ol><h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><a href="#不足：" title="不足："></a>不足：</h3><ol><li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li><li>不提供类似于Spring的IOC和AOP功能，扩展如果依赖其他的扩展，做不到自动注入和装配</li></ol><p>针对这些问题， Dubbo在原生  Java SPI 的基础上做了一些拓展。 可见参考文献[3][4]。</p><p>*<em>本文涉及的spi-demo源码地址： *</em><br><a href="https://github.com/crazyfzw/spi-demo.git" target="_blank" rel="noopener">https://github.com/crazyfzw/spi-demo.git</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://www.cnkirito.moe/spi/" target="_blank" rel="noopener">JAVA拾遗–关于SPI机制</a></p><p>[2]<a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">JDBC实现及 DriverManager 源码解析</a></p><p>[3]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">Dubbo可扩展机制实战</a></p><p>[4]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html" target="_blank" rel="noopener">Dubbo可扩展机制源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SPI-可以用来做什么&quot;&gt;&lt;a href=&quot;#SPI-可以用来做什么&quot; class=&quot;headerlink&quot; title=&quot;# SPI 可以用来做什么&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#SPI-可以用来做什么&quot; title=&quot;# SPI 可以用来做什么&quot;&gt;&lt;/a&gt;# SPI 可以用来做什么&lt;/h2&gt;&lt;p&gt;在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。&lt;/li&gt;
&lt;li&gt;作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。&lt;/p&gt;
&lt;p&gt;Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crazyfzw.github.io/categories/Java/"/>
    
    
      <category term="Java SPI" scheme="https://crazyfzw.github.io/tags/Java-SPI/"/>
    
  </entry>
  
  <entry>
    <title>慢谈 Redis 实现分布式锁 以及 Redisson 源码解析</title>
    <link href="https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/"/>
    <id>https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/</id>
    <published>2019-08-24T03:51:21.000Z</published>
    <updated>2021-01-02T07:54:31.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="# 产生背景"></a><a href="#产生背景" title="# 产生背景"></a># 产生背景</h2><blockquote><p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p></blockquote><p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p><p>随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p><a id="more"></a><h2 id="实现分布式锁的三种选择"><a href="#实现分布式锁的三种选择" class="headerlink" title="# 实现分布式锁的三种选择"></a><a href="#实现分布式锁的三种选择" title="# 实现分布式锁的三种选择"></a># 实现分布式锁的三种选择</h2><ul><li>基于数据库实现分布式锁*   基于zookeeper实现分布式锁</li><li>基于Redis缓存实现分布式锁</li></ul><p>以上三种方式都可以实现分布式锁，其中，从健壮性考虑， 用 zookeeper 会比用 Redis 实现更好，但从性能角度考虑，基于 Redis 实现性能会更好，如何选择，还是取决于业务需求。</p><h2 id="基于-Redis-实现分布式锁的三种方案"><a href="#基于-Redis-实现分布式锁的三种方案" class="headerlink" title="# 基于 Redis 实现分布式锁的三种方案"></a><a href="#基于-Redis-实现分布式锁的三种方案" title="# 基于 Redis 实现分布式锁的三种方案"></a># 基于 Redis 实现分布式锁的三种方案</h2><ul><li>用 Redis 实现分布式锁的正确姿势（实现一）</li><li>用 Redisson 实现分布式可重入锁（RedissonLock）（实现二）</li><li>用 Redisson 实现分布式锁(红锁 RedissonRedLock)（实现三）</li></ul><p><strong>本文主要探讨基于 Redis 实现分布式锁的方案，主要分析并对比了以上三种方案，并大致分析了 Redisson 的 RedissonLock 、 RedissonRedLock 源码。</strong></p><h2 id="分布式锁需满足四个条件"><a href="#分布式锁需满足四个条件" class="headerlink" title="# 分布式锁需满足四个条件"></a><a href="#分布式锁需满足四个条件" title="# 分布式锁需满足四个条件"></a># 分布式锁需满足四个条件</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li><li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li></ol><h2 id="用-Redis-实现分布式锁的正确姿势（实现一）"><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" class="headerlink" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a># 用 Redis 实现分布式锁的正确姿势（实现一）</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a><a href="#主要思路" title="主要思路"></a>主要思路</h3><p>通过 set key value px milliseconds nx 命令实现加锁， 通过Lua脚本实现解锁。核心实现命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁（unique_value可以是UUID等）</span></span><span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span><span class="line"></span><span class="line"><span class="comment">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span></span><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><span class="line"><span class="keyword">else</span></span><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><span class="line">end</span></pre></td></tr></table></figure><p>这种实现方式主要有以下几个要点：</p><ul><li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p></li><li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p></li><li><p>释放锁时要验证 value 值，防止误解锁；</p></li><li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p></li></ul><h3 id="完整代码实现如下："><a href="#完整代码实现如下：" class="headerlink" title="完整代码实现如下："></a><a href="#完整代码实现如下：" title="完整代码实现如下："></a>完整代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><span class="line"></span><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><span class="line"></span><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span><span class="line">        </span><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line"></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><a href="#加锁代码分析" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><a href="#解锁代码分析" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p><h3 id="这种方式仍存在单点风险"><a href="#这种方式仍存在单点风险" class="headerlink" title="这种方式仍存在单点风险"></a><a href="#这种方式仍存在单点风险" title="这种方式仍存在单点风险"></a>这种方式仍存在单点风险</h3><p><strong>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</strong></p><ol><li>客户端A从master获取到锁</li><li>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。</li><li>主从切换，slave节点被晋级为master节点</li><li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</li></ol><p><strong>所以在这种实现之下，不论Redis的部署架构是单机模式、主从模式、哨兵模式还是集群模式，都存在这种风险。因为Redis的主从同步是异步的。 运行的是，Redis 之父 antirez 提出了 redlock算法 可以解决这个问题。</strong></p><h2 id="Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" class="headerlink" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</h2><h3 id="什么是-Redisson"><a href="#什么是-Redisson" class="headerlink" title="什么是 Redisson"></a><a href="#什么是-Redisson" title="什么是 Redisson"></a>什么是 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><a href="#Redisson-分布式重入锁用法" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><span class="line">Config config = <span class="keyword">new</span> Config();</span><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><span class="line">RLock rLock = redissonClient.getLock(lockKey);</span><span class="line"><span class="keyword">try</span> &#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><span class="line">    <span class="keyword">if</span> (res) &#123;</span><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><span class="line">    &#125;</span><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><span class="line">    rLock.unlock();</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="加锁源码分析"><a href="#加锁源码分析" class="headerlink" title="加锁源码分析"></a><a href="#加锁源码分析" title="加锁源码分析"></a>加锁源码分析</h3><p><strong>1.通过 getLock 方法获取对象</strong></p><p><strong>org.redisson.Redisson#getLock()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     *  构造并返回一个 RedissonLock 对象 </span></span><span class="line"><span class="comment">     * commandExecutor: 与 Redis 节点通信并发送指令的真正实现。需要说明一下，CommandExecutor 实现是通过 eval 命令来执行 Lua 脚本</span></span><span class="line"><span class="comment">     * name: 锁的全局名称</span></span><span class="line"><span class="comment">     * id: Redisson 客户端唯一标识，实际上就是一个 UUID.randomUUID()</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name, id);</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>2.通过tryLock方法尝试获取锁</strong></p><p>tryLock方法里的调用关系大致如下：</p><p><img src="/images/2019041501.png" alt=""></p><p><strong>org.redisson.RedissonLock#tryLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">    <span class="comment">//取得最大等待时间</span></span><span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><span class="line">    <span class="comment">//记录下当前时间</span></span><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><span class="line">    <span class="comment">//取得当前线程id（判断是否可重入锁的关键）</span></span><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><span class="line">    <span class="comment">//1.尝试申请锁，返回还剩余的锁过期时间</span></span><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span><span class="line">    <span class="comment">//2.如果为空，表示申请锁成功</span></span><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">    &#125;</span><span class="line">    <span class="comment">//3.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span><span class="line">    time -= System.currentTimeMillis() - current;</span><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 通过 promise.trySuccess 设置异步执行的结果为null</span></span><span class="line"><span class="comment">         * Promise从Uncompleted--&gt;Completed ,通知 Future 异步执行已完成</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        acquireFailed(threadId);</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    current = System.currentTimeMillis();</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.订阅锁释放事件，并通过await方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：</span></span><span class="line"><span class="comment">     * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争</span></span><span class="line"><span class="comment">     * 当 this.await返回false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败</span></span><span class="line"><span class="comment">     * 当 this.await返回true，进入循环尝试获取锁</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><span class="line">    <span class="comment">//await 方法内部是用CountDownLatch来实现阻塞，获取subscribe异步执行的结果（应用了Netty 的 Future）</span></span><span class="line">    <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span><span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><span class="line">                    unsubscribe(subscribeFuture, threadId);</span><span class="line">                &#125;</span><span class="line">            &#125;);</span><span class="line">        &#125;</span><span class="line">        acquireFailed(threadId);</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">try</span> &#123;</span><span class="line">        <span class="comment">//计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败</span></span><span class="line">        time -= System.currentTimeMillis() - current;</span><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">            acquireFailed(threadId);</span><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 5.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁</span></span><span class="line"><span class="comment">         * 获取锁成功，则立马返回true，</span></span><span class="line"><span class="comment">         * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回false结束循环</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><span class="line">            <span class="comment">// 再次尝试申请锁</span></span><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span><span class="line">            <span class="comment">// 成功获取锁则直接返回true结束循环</span></span><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">//超过最大等待时间则返回false结束循环，获取锁失败</span></span><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">                acquireFailed(threadId);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            currentTime = System.currentTimeMillis();</span><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><span class="line">                <span class="comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span></span><span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="comment">//则就在wait time 时间范围内等待可以通过信号量</span></span><span class="line">                getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">//7.更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span></span><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">                acquireFailed(threadId);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><span class="line">        <span class="comment">//7.无论是否获得锁,都要取消订阅解锁消息</span></span><span class="line">        unsubscribe(subscribeFuture, threadId);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>其中 tryAcquire 内部通过调用 tryLockInnerAsync 实现申请锁的逻辑。申请锁并返回锁有效期还剩余的时间，如果为空说明锁未被其它线程申请则直接获取并返回，如果获取到时间，则进入等待竞争逻辑。</p><p><strong>org.redisson.RedissonLock#tryLockInnerAsync</strong></p><p><strong>加锁流程图：</strong><br><img src="/images/2019041502.png" alt=""></p><p><strong>实现源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><span class="line">              <span class="comment">// 1.如果缓存中的key不存在，则执行 hset 命令(hset key UUID+threadId 1),然后通过 pexpire 命令设置锁的过期时间(即锁的租约时间)</span></span><span class="line">              <span class="comment">// 返回空值 nil ，表示获取锁成功</span></span><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><span class="line">                  <span class="string">"return nil; "</span> +</span><span class="line">              <span class="string">"end; "</span> +</span><span class="line">               <span class="comment">// 如果key已经存在，并且value也匹配，表示是当前线程持有的锁，则执行 hincrby 命令，重入次数加1，并且设置失效时间</span></span><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><span class="line">                  <span class="string">"return nil; "</span> +</span><span class="line">              <span class="string">"end; "</span> +</span><span class="line">               <span class="comment">//如果key已经存在，但是value不匹配，说明锁已经被其他线程持有，通过 pttl 命令获取锁的剩余存活时间并返回，至此获取锁失败</span></span><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><span class="line">               <span class="comment">//这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span><span class="line">               Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key；</p></li><li><p>ARGV[1]就是internalLockLeaseTime，即锁的租约时间（持有锁的有效时间），默认30s；</p></li><li><p>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值 value，即UUID+threadId。</p></li></ul><h3 id="解锁源码分析"><a href="#解锁源码分析" class="headerlink" title="解锁源码分析"></a><a href="#解锁源码分析" title="解锁源码分析"></a>解锁源码分析</h3><p>unlock 内部通过 get(unlockAsync(Thread.currentThread().getId()))  调用 unlockInnerAsync 解锁。</p><p><strong>org.redisson.RedissonLock#unlock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><span class="line">    <span class="keyword">try</span> &#123;</span><span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span><span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span><span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="keyword">throw</span> e;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>get方法利用是 CountDownLatch 在异步调用结果返回前将当前线程阻塞，然后通过 Netty 的 FutureListener 在异步调用完成后解除阻塞，并返回调用结果。</p><p><strong>org.redisson.command.CommandAsyncService#get</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;   <span class="comment">//任务还没完成</span></span><span class="line">        <span class="comment">// 设置一个单线程的同步控制器</span></span><span class="line">        CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><span class="line">            <span class="comment">//操作完成时，唤醒在await()方法中等待的线程</span></span><span class="line">            l.countDown();</span><span class="line">        &#125;);</span><span class="line"></span><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                <span class="comment">//阻塞等待</span></span><span class="line">                l.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                interrupted = <span class="keyword">true</span>;</span><span class="line">                <span class="keyword">break</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><span class="line">            Thread.currentThread().interrupt();</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><span class="line">        <span class="keyword">return</span> future.getNow();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">throw</span> convertException(future);</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>org.redisson.RedissonLock#unlockInnerAsync</strong></p><p><strong>解锁流程图：</strong><br><img src="/images/2019041503.png" alt=""></p><p><strong>实现源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><span class="line">            <span class="comment">//如果分布式锁存在，但是value不匹配，表示锁已经被其他线程占用，无权释放锁，那么直接返回空值（解铃还须系铃人）</span></span><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><span class="line">                <span class="string">"return nil;"</span> +</span><span class="line">            <span class="string">"end; "</span> +</span><span class="line">             <span class="comment">//如果value匹配，则就是当前线程占有分布式锁，那么将重入次数减1</span></span><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><span class="line">             <span class="comment">//重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只能更新失效时间，还不能删除</span></span><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><span class="line">                <span class="string">"return 0; "</span> +</span><span class="line">            <span class="string">"else "</span> +</span><span class="line">             <span class="comment">//重入次数减1后的值如果为0，这时就可以删除这个KEY，并发布解锁消息，返回1</span></span><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><span class="line">                <span class="string">"return 1; "</span>+</span><span class="line">            <span class="string">"end; "</span> +</span><span class="line">            <span class="string">"return nil;"</span>,</span><span class="line">            <span class="comment">//这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="解锁消息处理"><a href="#解锁消息处理" class="headerlink" title="解锁消息处理"></a><a href="#解锁消息处理" title="解锁消息处理"></a>解锁消息处理</h3><p><strong>org.redisson.pubsub#onMessage</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_MESSAGE = <span class="number">0L</span>;</span><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long READ_UNLOCK_MESSAGE = <span class="number">1L</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockPubSub</span><span class="params">(PublishSubscribeService service)</span> </span>&#123;</span><span class="line">        <span class="keyword">super</span>(service);</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 判断是否是解锁消息</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span><span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span><span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span><span class="line">                runnableToExecute.run();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 释放一个信号量，唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            value.getLatch().release();</span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">                <span class="comment">/**</span></span><span class="line"><span class="comment">                 * 如果还有其他Listeners回调，则也唤醒执行</span></span><span class="line"><span class="comment">                 */</span></span><span class="line">                Runnable runnableToExecute = value.getListeners().poll();</span><span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span><span class="line">                    <span class="keyword">break</span>;</span><span class="line">                &#125;</span><span class="line">                runnableToExecute.run();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            value.getLatch().release(value.getLatch().getQueueLength());</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><a href="#总结对比" title="总结对比"></a>总结对比</h3><p>通过 Redisson 实现分布式可重入锁（实现二），比纯自己通过set key value px milliseconds nx +lua 实现（实现一）的效果更好些，虽然基本原理都一样，因为通过分析源码可知，RedissonLock<br>是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。   </p><p><strong>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</strong></p><p><strong>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</strong></p><h2 id="redlock算法"><a href="#redlock算法" class="headerlink" title="# redlock算法"></a><a href="#redlock算法" title="# redlock算法"></a># redlock算法</h2><p>Redis 官网对 redLock 算法的介绍大致如下：</p><blockquote><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">The Redlock algorithm</a></p></blockquote><p>在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p><ol><li><p>获取当前Unix时间，以毫秒为单位。</p></li><li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p></li><li><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p></li><li><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p></li></ol><h2 id="用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" class="headerlink" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</h2><p>这里以三个单机模式为例，需要特别注意的是他们完全互相独立，不存在主从复制或者其他集群协调机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span></pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><span class="line"></span><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><span class="line"></span><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><span class="line"></span><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span><span class="line"><span class="comment"> */</span></span><span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span><span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span><span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span><span class="line"></span><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span><span class="line"><span class="comment"> */</span></span><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><span class="line"></span><span class="line"><span class="keyword">try</span> &#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><span class="line">    <span class="keyword">if</span> (res) &#123;</span><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><span class="line">    &#125;</span><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><span class="line">    redLock.unlock();</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>最核心的变化就是需要构建多个 RLock ,然后根据多个 RLock 构建成一个 RedissonRedLock，因为 redLock 算法是建立在多个互相独立的 Redis 环境之上的（为了区分可以叫为 Redission node），Redission node 节点既可以是单机模式(single)，也可以是主从模式(master/salve)，哨兵模式(sentinal)，或者集群模式(cluster)。这就意味着，不能跟以往这样只搭建 1个 cluster、或 1个 sentinel 集群，或是1套主从架构就了事了，需要为 RedissonRedLock 额外搭建多几套独立的 Redission 节点。 比如可以搭建3个 或者5个 Redission节点，具体可看视资源及业务情况而定。</strong></p><p><strong>下图是一个利用多个 Redission node 最终 组成 RedLock分布式锁的例子，需要特别注意的是每个  Redission node 是互相独立的，不存在任何复制或者其他隐含的分布式协调机制。</strong></p><p><img src="/images/2019041504.png" alt=""><br><img src="/images/2019041505.png" alt=""></p><h2 id="Redisson-实现redlock算法源码分析（RedLock）"><a href="#Redisson-实现redlock算法源码分析（RedLock）" class="headerlink" title="# Redisson 实现redlock算法源码分析（RedLock）"></a><a href="#Redisson-实现redlock算法源码分析（RedLock）" title="# Redisson 实现redlock算法源码分析（RedLock）"></a># Redisson 实现redlock算法源码分析（RedLock）</h2><p><strong>加锁核心代码</strong></p><p> <strong>org.redisson.RedissonMultiLock#tryLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span><span class="line">101</span><span class="line">102</span><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span><span class="line">        remainTime = unit.toMillis(waitTime);</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 1\. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 2\. 遍历所有节点通过EVAL命令执行lua加锁</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span><span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><span class="line">        RLock lock = iterator.next();</span><span class="line">        <span class="keyword">boolean</span> lockAcquired;</span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><span class="line">                lockAcquired = lock.tryLock();</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><span class="line">            &#125;</span><span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span><span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span><span class="line">            unlockInner(Arrays.asList(lock));</span><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><span class="line">        &#125;</span><span class="line">        </span><span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             *4\. 如果获取到锁则添加到已获取锁集合中</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            acquiredLocks.add(lock);</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 5\. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span><span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span><span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span><span class="line">                <span class="keyword">break</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><span class="line">                unlockInner(acquiredLocks);</span><span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">                &#125;</span><span class="line">                failedLocksLimit = failedLocksLimit();</span><span class="line">                acquiredLocks.clear();</span><span class="line">                <span class="comment">// reset iterator</span></span><span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><span class="line">                    iterator.previous();</span><span class="line">                &#125;</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                failedLocksLimit--;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><span class="line">            time = System.currentTimeMillis();</span><span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><span class="line">                unlockInner(acquiredLocks);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span><span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><span class="line">            futures.add(future);</span><span class="line">        &#125;</span><span class="line">        </span><span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><span class="line">            rFuture.syncUninterruptibly();</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p><p>[2]<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Distributed locks with Redis 中文版</a></p><p>[3]<a href="https://redis.io/commands/set" target="_blank" rel="noopener">SET - Redis</a></p><p>[4]<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">EVAL command</a></p><p>[5] <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></p><p>[6]<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p><p>[7]<a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">Redlock实现分布式锁</a></p><p>[8]<a href="https://mp.weixin.qq.com/s/iaZcc7QGbGHkZkfLeYp1yg" target="_blank" rel="noopener">Redisson实现Redis分布式锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;产生背景&quot;&gt;&lt;a href=&quot;#产生背景&quot; class=&quot;headerlink&quot; title=&quot;# 产生背景&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#产生背景&quot; title=&quot;# 产生背景&quot;&gt;&lt;/a&gt;# 产生背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。&lt;/p&gt;
&lt;p&gt;随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="distributed" scheme="https://crazyfzw.github.io/categories/distributed/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
      <category term="Redisson" scheme="https://crazyfzw.github.io/tags/Redisson/"/>
    
  </entry>
  
  <entry>
    <title>订阅 Redis 的 key 过期事件实现动态定时任务</title>
    <link href="https://crazyfzw.github.io/2019/04/09/redis-keyspace-notifications/"/>
    <id>https://crazyfzw.github.io/2019/04/09/redis-keyspace-notifications/</id>
    <published>2019-04-09T15:27:52.000Z</published>
    <updated>2020-12-18T05:35:32.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a><a href="#一、需求" title="一、需求"></a>一、需求</h3><ol><li>设置了生存时间的Key，在过期时能不能有所提示？</li><li>如果能对过期Key有个监听，如何对过期Key进行一个回调处理？</li><li>如何使用 Redis 来实现定时任务？</li></ol><p>比如：</p><ul><li>处理订单过期自动取消，12306 购票系统超过30分钟没有成功支付的订单会被回收处理;</li><li>购买商品15天后默认好评；</li><li>外卖系统的送餐超时提醒；</li><li>客服与顾客聊天，客服超过多长时间没回复，系统给客服发一个提醒消息；<br>…</li></ul><a id="more"></a><p>这里的定时任务并不是  Crontab 这种如 <code>0 0 23 * * ?</code> (每日23点执行) 定死多长时间执行一次的， 而是某种特定动作触发创建的一个多长时间后执行的任务。比如有100个 用户触发了这个动作，那么就会创建100个定时任务，并且这100个任务由于触发创建的时间不同，执行的时间也很可能不在同一时间。</p><h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a><a href="#二、思路" title="二、思路"></a>二、思路</h3><p>在 Redis 的 2.8.0 版本之后，其推出了一个新的特性——键空间消息（Redis Keyspace Notifications），它配合 2.0.0 版本之后的 SUBSCRIBE 就能完成这个定时任务的操作了。</p><p><strong>Redis 的键空间通知支持  订阅指定 Key 的所有事件  与 订阅指定事件  两种方式。</strong></p><blockquote><p>Keyspace notifications are implemented sending two distinct type of events for every operation affecting the Redis data space. For instance a DEL operation targeting the key named mykey in database 0 will trigger the delivering of two messages, exactly equivalent to the following two PUBLISH commands:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH <strong>keyspace@0</strong>:mykey del</span><br><span class="line">PUBLISH <strong>keyevent@0</strong>:del mykey</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>通过 Redis 的键空间通知（keyspace notification）可以做到：下单时将订单 id 写入 redis，设置过期时间30分钟，利用 redis 键过期回调提醒，30分钟后可以在回调函数里检查订单状态，如果未支付，则进行处理。</strong></p><h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a><a href="#三、实现" title="三、实现"></a>三、实现</h3><h4 id="1-修改-redis-conf-开启redis-key过期提醒"><a href="#1-修改-redis-conf-开启redis-key过期提醒" class="headerlink" title="1. 修改 redis.conf 开启redis key过期提醒"></a><a href="#1-修改-redis-conf-开启redis-key过期提醒" title="1. 修改 redis.conf 开启redis key过期提醒"></a>1. 修改 redis.conf 开启redis key过期提醒</h4><blockquote><p>By default keyspace events notifications are disabled because while not very sensible the feature uses some CPU power. Notifications are enabled using the notify-keyspace-events of redis.conf or via the CONFIG SET.</p></blockquote><p>由于键空间通知比较耗CPU, 所以 Redis默认是关闭键空间事件通知的， 需要手动开启 notify-keyspace-events 后才启作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span></pre></td><td class="code"><pre><span class="line">K：keyspace事件，事件以__keyspace@&lt;db&gt;__为前缀进行发布；        </span><span class="line">E：keyevent事件，事件以__keyevent@&lt;db&gt;__为前缀进行发布；        </span><span class="line">g：一般性的，非特定类型的命令，比如del，expire，rename等；       </span><span class="line">$：String 特定命令；        </span><span class="line">l：List 特定命令；        </span><span class="line">s：Set 特定命令；        </span><span class="line">h：Hash 特定命令；        </span><span class="line">z：Sorted 特定命令；        </span><span class="line">x：过期事件，当某个键过期并删除时会产生该事件；        </span><span class="line">e：驱逐事件，当某个键因maxmemore策略而被删除时，产生该事件；        </span><span class="line">A：g$lshzxe的别名，因此”AKE”意味着所有事件。</span></pre></td></tr></table></figure><p><strong><code>notify-keyspace-events Ex</code> 表示开启键过期事件提醒</strong></p><h4 id="2-继承-JedisPubSub-实现一个消息监听器类"><a href="#2-继承-JedisPubSub-实现一个消息监听器类" class="headerlink" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a><a href="#2-继承-JedisPubSub-实现一个消息监听器类" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a>2. 继承 JedisPubSub 实现一个消息监听器类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><span class="line">    </span><span class="line">       <span class="comment">//message.toString()可以获取失效的key</span></span><span class="line">      String expiredKey = message.toString();</span><span class="line">      <span class="keyword">if</span>(expiredKey.startsWith(<span class="string">"key:prefix"</span>))&#123;</span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * TODO</span></span><span class="line"><span class="comment">             * 如果是自己想要监控的KEY, 则可以在这里处理业务</span></span><span class="line"><span class="comment">             */</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>由于每个key过期都会回调 onPMessage 方法， 所以不建议在 onPMessage  回调方法中直接处理业务， 这里可以通过 MQ 来做缓冲，在 onPMessage 中 把消息直接扔到 MQ 里， 然后再去监听队列消费消息处理具体的业务。</strong></p><p>改进版如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span><span class="line"></span><span class="line">    <span class="meta">@Resource</span></span><span class="line">    <span class="keyword">private</span> ICommonsMqService commonsMqService;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            commonsMqService.sendSingleMessageAsync(<span class="string">"REDIS_TIMEOUT_KEY_QUEUE"</span>, message);</span><span class="line">            logger.info(<span class="string">"发送支付超时MQ消息成功：&#123;&#125;"</span>,message);</span><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><span class="line">            logger.error(<span class="string">"发送支付超时MQ消息失败：&#123;&#125;"</span>,e.toString());</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><h4 id="3-订阅指定-db-的过期事件"><a href="#3-订阅指定-db-的过期事件" class="headerlink" title="3. 订阅指定 db 的过期事件"></a><a href="#3-订阅指定-db-的过期事件" title="3. 订阅指定 db 的过期事件"></a>3. 订阅指定 db 的过期事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><span class="line"><span class="meta">@Order</span>(value = <span class="number">4</span>)</span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberRedisKeyTimeout</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SubscriberRedisKeyTimeout.class);</span><span class="line"></span><span class="line">    <span class="meta">@Resource</span></span><span class="line">    RedisKeyExpiredListener redisKeyExpiredListener;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><span class="line"></span><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span><span class="line">        Jedis jedis = pool.getResource();</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 订阅线程：接收消息</span></span><span class="line"><span class="comment">         * 由于订阅者（subscriber）在进入订阅状态后会阻塞线程，</span></span><span class="line"><span class="comment">         * 因此新起一个线程（new Thread()）作为订阅线程</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><span class="line">                <span class="keyword">try</span> &#123;</span><span class="line">                    logger.info(<span class="string">"Subscribing. This thread will be blocked."</span>);</span><span class="line">                    <span class="comment">//使用subscriber订阅 db0上的key过期事件消息，这一句之后，线程进入订阅模式，阻塞。</span></span><span class="line">                     jedis.subscribe(redisKeyExpiredListener, <span class="string">"__keyevent@0__:expired"</span>);</span><span class="line">     </span><span class="line">                    <span class="comment">//当unsubscribe()方法被调用时，才执行以下代码</span></span><span class="line">                    logger.info(<span class="string">"Subscription ended."</span>);</span><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">                    logger.error(<span class="string">"Subscribing failed."</span>, e);</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;).start();</span><span class="line"></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a><a href="#4-测试" title="4. 测试"></a>4. 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJedisExpipreNotice</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span><span class="line">        Jedis jedis = pool.getResource();</span><span class="line"></span><span class="line">        jedis.setex(<span class="string">"REDIS:EXPIPRE:NOTICE:TEST"</span>,<span class="number">5</span>, <span class="string">"测试键过期事件回调"</span>);</span><span class="line"></span><span class="line">    &#125;</span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><p>5秒后控制台打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">2019-03-26 17:35:44.248  INFO 20464 --- [ Thread-127] c.p.c.r.b.r.RedisKeyExpiredListener  : 发送聊天会话超时MQ消息成功：REDIS:EXPIPRE:NOTICE:TEST</span></pre></td></tr></table></figure><h3 id="四、-subscribe-psubscibe-的区别"><a href="#四、-subscribe-psubscibe-的区别" class="headerlink" title="四、 subscribe/psubscibe 的区别"></a><a href="#四、-subscribe-psubscibe-的区别" title="四、 subscribe/psubscibe 的区别"></a>四、 subscribe/psubscibe 的区别</h3><p>Redis 提供了 publish 和  subscribe/psubscibe 指令来实现发布/订阅模型，发布和订阅的目标称为通道(channel)。 subscribe/psubscribe 了一个或多个通道的客户端，可以收到其他客户端向这个通道publish的消息。subscribe和psubscribe的区别是，前者指定具体的通道名称，而后者可以指定一个正则表达式，匹配这个表达式的通道都被订阅。</p><p><img src="/images/20190327.svg" alt=""></p><p>上图展示了一个带有频道和模式的例子， 其中 <code>tweet.shop.*</code>  模式匹配了 <code>tweet.shop.kindle</code> 频道和 <code>tweet.shop.ipad</code> 频道， 并且有不同的客户端分别用 psubscibe 订阅它们三个：当有信息发送到 <code>tweet.shop.kindle</code> 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅 <code>tweet.shop.*</code>  模式的 client123 和 client256。</p><h3 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a><a href="#五、参考文献" title="五、参考文献"></a>五、参考文献</h3><p>[1]<a href="https://redis.io/topics/pubsub" target="_blank" rel="noopener">Redis Pub/Sub</a></p><p>[2]<a href="https://redis.io/topics/notifications" target="_blank" rel="noopener">Redis Keyspace Notifications</a></p><p>[3]<a href="https://my.oschina.net/itblog/blog/601284?p=1" target="_blank" rel="noopener">Redis的Pub/Sub模式</a></p><p>[4]<a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noopener">Redis设计与实现第一版-订阅与发布</a></p><p>[5]<a href="https://www.cnblogs.com/tinywan/p/5903988.html" target="_blank" rel="noopener">Redis实践操作之—— keyspace notification（键空间通知</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、需求&quot;&gt;&lt;a href=&quot;#一、需求&quot; class=&quot;headerlink&quot; title=&quot;一、需求&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#一、需求&quot; title=&quot;一、需求&quot;&gt;&lt;/a&gt;一、需求&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置了生存时间的Key，在过期时能不能有所提示？&lt;/li&gt;
&lt;li&gt;如果能对过期Key有个监听，如何对过期Key进行一个回调处理？&lt;/li&gt;
&lt;li&gt;如何使用 Redis 来实现定时任务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理订单过期自动取消，12306 购票系统超过30分钟没有成功支付的订单会被回收处理;&lt;/li&gt;
&lt;li&gt;购买商品15天后默认好评；&lt;/li&gt;
&lt;li&gt;外卖系统的送餐超时提醒；&lt;/li&gt;
&lt;li&gt;客服与顾客聊天，客服超过多长时间没回复，系统给客服发一个提醒消息；&lt;br&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
      <category term="Pub/Sub" scheme="https://crazyfzw.github.io/tags/Pub-Sub/"/>
    
      <category term="Redis Keyspace Notifications" scheme="https://crazyfzw.github.io/tags/Redis-Keyspace-Notifications/"/>
    
  </entry>
  
  <entry>
    <title>夯实基础 1：ArrayList、Vector、LinkedList 的区别</title>
    <link href="https://crazyfzw.github.io/2018/08/30/the-diff-ArrayList-Vector-LinkedList/"/>
    <id>https://crazyfzw.github.io/2018/08/30/the-diff-ArrayList-Vector-LinkedList/</id>
    <published>2018-08-30T14:43:48.000Z</published>
    <updated>2020-12-06T16:28:21.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、集合框架层次结构"><a href="#一、集合框架层次结构" class="headerlink" title="一、集合框架层次结构"></a>一、集合框架层次结构</h2><p>ArrayList、Vector、LinkedList 这三者都是集合框架中的 List，所以要弄清楚它们之间的区别与联系，最好先对集合框架类的层级有个整体直观的认识。</p><p>下面是集合框架的简要类图：</p><p><img src="/images/2018083001.png" alt=""></p><p>从上图可以看到，Collection接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><a id="more"></a><ul><li><p>List，有序集合，列表中的元素可重复，它提供了方便的访问、插入、删除等操作。</p></li><li><p>Set，Set是不允许元素重复的，这是和List最明显的区别，也就是不存在两个equals返回true的情况。广泛用于需要保证元素唯一的场合。</p></li><li><p>Queue/Deque ，则是Java提供的标准队列结构的实现，除了集合的基本功能，它还支持类似 先入先出（FIFO ，First-in-First-Out)储后入先出（LIFO，Last-In-First-Out)等特定行 为。这里不包括 BlockingQueue ，因为通常是并发编程杨合，所以被放置在并发包里。</p></li></ul><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如AbstractList就集中了各种List操作的 通用部分。这些集合不是完全孤立的，比如，LinkedList本身，既是List，也是 Deque。</p><h2 id="二、ArrayList、Vector、LinkedList"><a href="#二、ArrayList、Vector、LinkedList" class="headerlink" title="二、ArrayList、Vector、LinkedList"></a>二、ArrayList、Vector、LinkedList</h2><p>下面可以看一个简化版的类图：</p><p><img src="/images/2018083002.png" alt=""></p><p>从上图可以看到 ArrayList、Vector、LinkedList 三者都实现了List 接口。因此，它们在功能及用法上都非常的相似，比如都提供按照索引位置进行取值、添加、删除操作，都提供了迭代器用于遍历元素等功能。它们之间的主要区别，来源于底层实现上的不同，所以在行为、性能、线程安全性上有所差别。</p><ul><li>ArrayList 是一个可改变大小的动态数组，随着元素的添加，会动态的增加容量，因为ArrayList本质上就是一个数组，所以内部的元素可以直接通过get与set方法进行访问。需要注意的是，ArrayList 本身不是线程安全的，所以与Vector 相比，不存在同步的开销，性能上好很多。</li></ul><ul><li><p>Vector 和ArrayList类似，不同的是在方法的前面加了synchronized，因此Vector 是线程安全的。<br>如果你的程序本身是线程安全的（即不存在多个线程之间共享同一个集合/对象），那么不建议选择Vector ，毕竟同步是有额外开销的。</p></li><li><p>LinkedList 是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。 LinkedList 还实现了 Queue 接口，该接口比List提供了更多的方法,包括 offer()、peek()、poll()等。LinkedList本身，既是List，也是 Deque。</p></li></ul><h2 id="三、性能比较"><a href="#三、性能比较" class="headerlink" title="三、性能比较"></a>三、性能比较</h2><p>下面写个例子对比下 ArrayList、LinkedList 在访问、添加、删除元素方面的差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ArrayList add</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">arrayList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"ArrayList  add: "</span> + duration);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// LinkedList add</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">linkedList.add(i);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"LinkedList add: "</span> + duration);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList get</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">arrayList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"ArrayList  get: "</span> + duration);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// LinkedList get</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"LinkedList get: "</span> + duration);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList remove</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">arrayList.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"ArrayList  remove: "</span> + duration);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// LinkedList remove</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">linkedList.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"LinkedList remove: "</span> + duration);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在JDK1.7 中的运行效果如下所示：</p><p><img src="/images/2018083003.png" alt=""></p><p><strong>小结：</strong><br>可以看到，ArrayList 在访问元素比 LinkedList 好，单在添加、删除元素方面 LinkedList 性能更好。 </p><h2 id="四、不同容器适合的场景-如何考虑选择"><a href="#四、不同容器适合的场景-如何考虑选择" class="headerlink" title="四、不同容器适合的场景(如何考虑选择)"></a>四、不同容器适合的场景(如何考虑选择)</h2><ul><li>Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会先对较差，比如我们在中间插入一个元素，需要移动后续的所有元素。</li><li>LinkedList 进行节点的插入、删除却要高效的多，但随机访问性能却要比动态数组慢。</li></ul><p>所以在开发的过程中，应考虑对应的功能是偏向于插入、删除、还是随机访问比较多，来进行针对性的选择。<strong>如果是插入、删除比较频繁，则选用 LinkedList ；如果随机性访问多，则选择动态数组（Vector 和 ArrayList），然后再结合是否需要线程安全来进一步选择，如果需要线程安全则使用Vector，如果不需要线程安全，则选择 ArrayList 。</strong></p><h2 id="五、Vector和ArrayList-的扩容机制"><a href="#五、Vector和ArrayList-的扩容机制" class="headerlink" title="五、Vector和ArrayList 的扩容机制"></a>五、Vector和ArrayList 的扩容机制</h2><p>Vector和ArrayList在随着元素的添加，当数组满时，会请求更大的空间，创建新数组，并拷贝原有数组数据。区别的是，Vector 每次扩容时增加1倍，而ArrayList则是增加 50%。如下面的代码所示：</p><p><strong>Vector 的 grow 源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *这里可以看到，如果在构造 Vector 的时候指定了 步长 capacityIncrement ，</span></span><br><span class="line"><span class="comment">     *则在原容量基础上增加指定步长，否则增加1倍原容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList 的 grow 源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="comment">//这里可以看到在原容量的基础上再增加 原容量的一半。</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最佳实践：</strong><br>值得注意的是，动态扩容会创建新数组，并拷贝原有数组数据到新的数组，所以每次扩容都会带来一定的开销。而默认情况下 ArrayList 和 Vector 的初始容量非常小，在JDK1.7 中默认是10，所以JDK提供了构造函数，支持在创建动态数组的时候指定数组的初始容量。所以<strong>如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销。</strong></p><p><strong>ArrayList 的 相应的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Vector 的 相应的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * capacity increment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment"> *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， 创建 ArrayList 和 Vector 时，都可以指定数组的初始容量，并且 Vector  还可以指定数组每次扩容的增量。</p><p>下面写个例子测试对比一下使用默认初始容量与指定初始初始容量的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayList1 add</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">arrayList1.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"arrayList1  add: "</span> + duration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayList2 add</span></span><br><span class="line"><span class="keyword">long</span> startTime2 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">arrayList2.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime2 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration2 = endTime2 - startTime2;</span><br><span class="line">System.out.println(<span class="string">"arrayList2  add: "</span> + duration2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下所示： </p><p><img src="/images/2018083004.png" alt=""></p><p>可以看到，如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销，效果还是比较明显的。</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">关于Java集合的小抄</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、集合框架层次结构&quot;&gt;&lt;a href=&quot;#一、集合框架层次结构&quot; class=&quot;headerlink&quot; title=&quot;一、集合框架层次结构&quot;&gt;&lt;/a&gt;一、集合框架层次结构&lt;/h2&gt;&lt;p&gt;ArrayList、Vector、LinkedList 这三者都是集合框架中的 List，所以要弄清楚它们之间的区别与联系，最好先对集合框架类的层级有个整体直观的认识。&lt;/p&gt;
&lt;p&gt;下面是集合框架的简要类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018083001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，Collection接口是所有集合的根，然后扩展开提供了三大类集合，分别是：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JDK" scheme="https://crazyfzw.github.io/categories/JDK/"/>
    
    
      <category term="集合" scheme="https://crazyfzw.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="夯实基础" scheme="https://crazyfzw.github.io/tags/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ArrayList" scheme="https://crazyfzw.github.io/tags/ArrayList/"/>
    
      <category term="Vector" scheme="https://crazyfzw.github.io/tags/Vector/"/>
    
      <category term="LinkedList" scheme="https://crazyfzw.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Redis 开发与运维 4：Redis 集群的搭建与运维</title>
    <link href="https://crazyfzw.github.io/2018/08/24/redis-cluster-setup-and-operation/"/>
    <id>https://crazyfzw.github.io/2018/08/24/redis-cluster-setup-and-operation/</id>
    <published>2018-08-24T12:34:01.000Z</published>
    <updated>2021-01-02T07:53:16.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>集群的搭建可以分为以节点准备、节点握手、分配槽三个步骤。</p><h3 id="节点准备"><a href="#节点准备" class="headerlink" title="节点准备"></a>节点准备</h3><p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让 Redis 运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下。</p><a id="more"></a><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信，达到感知对方的过程。<br>我们只需要在集群内任意节点上执行 cluster meet 命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6381</span><br></pre></td></tr></table></figure><h3 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h3><p>Redis集群把所有的数据映射到16384个槽中。每个 key 会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5641&#125;</span><br></pre></td></tr></table></figure><h2 id="二、用-redis-trib-rb-搭建集群"><a href="#二、用-redis-trib-rb-搭建集群" class="headerlink" title="二、用 redis-trib.rb 搭建集群"></a>二、用 redis-trib.rb 搭建集群</h2><p>虽然手动搭建集群可以让我们了解集群建立的流程和细节，单当节点多时，手动搭建比较繁琐，并且容易出错，所以生产环境推荐使用 redis-trib.rb 集群管理工具进行搭建。 redis-trib.rb 提供了集群的创建、检查、修复、均衡等命令行工具，输入 redis-trib.rb 命令可以查看到具体的参数用法。</p><p>这里用3台机器，每个机器上安装4个节点，总共12个节点，按1主1从组成集群。</p><table><thead><tr><th align="center">服务器</th><th align="center">节点实例端口</th></tr></thead><tbody><tr><td align="center">10.2.8.94</td><td align="center">7000,7001,7002,7003</td></tr><tr><td align="center">10.2.8.95</td><td align="center">7004,7005,7006,7007</td></tr><tr><td align="center">10.2.8.96</td><td align="center">7008,7009,7010,7011</td></tr></tbody></table><p><strong>准备节点</strong></p><p>下面以一台服务器为例，安装4个节点，其余2台机器也采用同样的方式进行安装。</p><h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#service iptables stop #关闭防火墙</span><br><span class="line">#service iptables status #查看状态</span><br></pre></td></tr></table></figure><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"># wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.3.tar.gz #下载安装包</span><br><span class="line"># tar -xf redis-3.2.3.tar.gz #解压安装包</span><br><span class="line"># ln -s redis-3.2.3 redis #建立软链接,方便以后升级维护</span><br><span class="line"># cd redis</span><br><span class="line"># make &amp;&amp; make install </span><br><span class="line"># cd src</span><br><span class="line"># .&#x2F;redis-cli -v #验证安装是否成功</span><br><span class="line"># export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure><p>这一步可以参考我的上一篇博客：<a href="https://crazyfzw.github.io/2018/08/10/Redis%20%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4%202%EF%BC%9ARedis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A-Redis-shell-%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Redis环境搭建及Redis shell的使用</a></p><h3 id="安装-redis-trib-rb-工具"><a href="#安装-redis-trib-rb-工具" class="headerlink" title="安装 redis-trib.rb 工具"></a>安装 redis-trib.rb 工具</h3><p>redis-trib.rb 是采用Ruby实现的Redis集群管理工具。内部通过Cluster相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用前需要安装Ruby环境。注意由于我们用redis-trib.rb 在一台服务器上就可以操作整个集群了，所以只需要挑选一台服务器安装既可，不需要每天服务器都安装。</p><h4 id="1）安装Ruby"><a href="#1）安装Ruby" class="headerlink" title="1）安装Ruby"></a>1）安装Ruby</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 local]# wget https:&#x2F;&#x2F;cache.ruby-lang.org&#x2F;pub&#x2F;ruby&#x2F;2.3&#x2F;ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# tar -xf ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# ln -s ruby-2.3.1 ruby</span><br><span class="line">[root@gdyt-wbredis01 local]# cd ruby</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;configure</span><br><span class="line">[root@gdyt-wbredis01 ruby]# make &amp;&amp; make install</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;ruby  -v</span><br><span class="line">ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-linux]</span><br><span class="line"></span><br><span class="line">[root@gdyt-wbredis01 ruby]# export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:&#x2F;usr&#x2F;local&#x2F;ruby:&#x2F;usr&#x2F;local&#x2F;ruby&#x2F;bin:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure><h4 id="2）安装-rubygem-redis-依赖。"><a href="#2）安装-rubygem-redis-依赖。" class="headerlink" title="2）安装 rubygem redis 依赖。"></a>2）安装 rubygem redis 依赖。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ruby]# gem sources --add https:&#x2F;&#x2F;ruby.taobao.org&#x2F; --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]#  gem sources -l</span><br><span class="line">https:&#x2F;&#x2F;ruby.taobao.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]# gem install redis</span><br></pre></td></tr></table></figure><p>安装好后执行 redis-trib.rb 命令确认是否安装成功。</p><p><img src="/images/2018082404.png" alt=""></p><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="1）创建集群配置文件夹"><a href="#1）创建集群配置文件夹" class="headerlink" title="1）创建集群配置文件夹"></a>1）创建集群配置文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mkdir &#x2F;etc&#x2F;redis&#x2F;redis_cluster -p</span><br></pre></td></tr></table></figure><h4 id="2）创建多个实例目录"><a href="#2）创建多个实例目录" class="headerlink" title="2）创建多个实例目录"></a>2）创建多个实例目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 redis_cluster]# mkdir 7000 7001 7002 7003</span><br><span class="line">[root@gdyt-wbredis01 redis_cluster]# ls -l</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7000</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7001</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7002</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7003</span><br></pre></td></tr></table></figure><h4 id="3）-配置文件"><a href="#3）-配置文件" class="headerlink" title="3） 配置文件"></a>3） 配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7000&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7001&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7002&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bind 10.2.8.94 #绑定本机IP</span><br><span class="line">daemonize yes #后台运行</span><br><span class="line">pidfile  &#x2F;var&#x2F;run&#x2F;redis_7000.pid #PID文件</span><br><span class="line">port  7000 #监听端口</span><br><span class="line">cluster-enabled yes #开启集群</span><br><span class="line">cluster-config-file  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;nodes-7000.conf #实例节点配置</span><br><span class="line">cluster-node-timeout 5000 #集群通信超时</span><br><span class="line">appendonly yes #AOF日志开启写</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">cluster-require-full-coverage no #设置为no主节点故障时，不会影响其他节点的可用性</span><br></pre></td></tr></table></figure><h4 id="4）用配置文件启动各个节点"><a href="#4）用配置文件启动各个节点" class="headerlink" title="4）用配置文件启动各个节点"></a>4）用配置文件启动各个节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7004&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7005&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7006&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7007&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7008&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7009&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7010&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7011&#x2F;redis.conf</span><br></pre></td></tr></table></figure><h4 id="5）配置集群-At-least-6-nodes-are-required-至少需要6个节点"><a href="#5）配置集群-At-least-6-nodes-are-required-至少需要6个节点" class="headerlink" title="5）配置集群(At least 6 nodes are required., 至少需要6个节点)"></a>5）配置集群(At least 6 nodes are required., 至少需要6个节点)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]#redis-trib.rb create  --replicas  1  10.2.8.94:7000  10.2.8.94:7001  10.2.8.94:7002  10.2.8.94:7003  10.2.8.95:7004  10.2.8.95:7005 10.2.8.95:7006 10.2.8.95:7007 10.2.8.96:7008 10.2.8.96:7009 10.2.8.96:7010 10.2.8.96:7011</span><br></pre></td></tr></table></figure><p><strong>其中 –replicas 后面的 数字 表示给每个主节点配备几个从节点，这里需要特别注意的是，redis-trib.rb会重新排序列表顺序，来确定主从角色，尽可能的保证主从节点不分配在统一机器下。</strong></p><p><img src="/images/2018082401.png" alt=""></p><p>可以用 redis-trib.rb 的 info 或 check 来查看或检查集群的信息</p><p><img src="/images/2018082402.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-trib.rb check 10.2.8.94:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.2.8.94:7001)</span><br><span class="line">S: 84923706efb5d77511707b8f74abd3f57d3c26a9 10.2.8.94:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b5819808aa06db5ada355e111dda2a129aa3597c</span><br><span class="line">M: 1c864de9ba655958f0ceae2363acfc298d5039e8 10.2.8.96:7009</span><br><span class="line">   slots:13653-16383 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 07a32cf512dd04a9ead49cc7dc1ce6c087c799a5 10.2.8.94:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8c141a332d7bc488ac9236a778791f6b80aec1e3</span><br><span class="line">M: 8c141a332d7bc488ac9236a778791f6b80aec1e3 10.2.8.95:7004</span><br><span class="line">   slots:2731-5460 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 4eeb5d5207f599a7469dd8f031517ae7b69be126 10.2.8.94:7003</span><br><span class="line">   slots:5461-8191 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3 10.2.8.95:7006</span><br><span class="line">   slots:0-2730 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 107fc0afc81a5c1c3a72e72dc0a9832bb543ed13 10.2.8.96:7011</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed</span><br><span class="line">S: 4ba0b34eb289ac7d5222e0e1f55a461ebdc97d66 10.2.8.94:7000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3</span><br><span class="line">M: 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed 10.2.8.95:7005</span><br><span class="line">   slots:10923-13652 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e33c091a22ba1963ad6f17ee4fb8b11b405e553d 10.2.8.96:7008</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 4eeb5d5207f599a7469dd8f031517ae7b69be126</span><br><span class="line">S: 306ac97503a76b662fe5a6515f699e8c47f9f219 10.2.8.95:7007</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1c864de9ba655958f0ceae2363acfc298d5039e8</span><br><span class="line">M: b5819808aa06db5ada355e111dda2a129aa3597c 10.2.8.96:7010</span><br><span class="line">   slots:8192-10922 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h4 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h4><p>通过 -c 参数进入集群模式进行验证后， 在任意一台服务器连接任意实例端口操作数据，将会自动在片区进行操作。</p><p><img src="/images/2018082403.png" alt=""></p><p>至此，整个集群已经配置完成了。</p><h2 id="三、设置密码"><a href="#三、设置密码" class="headerlink" title="三、设置密码"></a>三、设置密码</h2><p>vi /etc/redis/redis_cluster/7000/redis.conf</p><p>在文件末尾加入。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masterauth &quot;crazyfzw&quot;</span><br><span class="line">requirepass &quot;crazyfzw&quot;</span><br></pre></td></tr></table></figure><p>按照同样的方法给集群的所有节点设置相同的密码（一定要相同），然后通过配置文件重新启动所有服务就可以了。</p><p><strong>设置密码后的注意事项：</strong></p><p>需要注意的是设置密码后，执行 redis-cli 连接的时候需要一定要指定密码，否则无法执行任何命令，会报错(error) NOAUTH Authentication required.，如下图：</p><p><img src="/images/2018082405.png" alt=""></p><p>正确的操作应该这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 10.2.8.94 -p 7000 -a yourpass</span><br></pre></td></tr></table></figure><p>*<em>设置密码后 redis-trib.rb 工具将会无法使用，执行相关命令会报错： *</em></p><p><img src="/images/2018082406.png" alt=""></p><p>解决办法：修改 client.rb 的中的密码。（tip: 可以通过find命令找到文件所在的目录）</p><p><img src="/images/2018082407.png" alt=""></p><h2 id="四、优化系统"><a href="#四、优化系统" class="headerlink" title="四、优化系统"></a>四、优化系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">#TCP监听队列值</span><br><span class="line">net.core.somaxconn &#x3D; 2048</span><br><span class="line">#内存分配策略，选择1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何；</span><br><span class="line">#默认0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程</span><br><span class="line">vm.overcommit_memory &#x3D; 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用配置生效</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Redis不使用透明大页</span><br><span class="line">#加入开机启动</span><br><span class="line"># vi  &#x2F;etc&#x2F;rc.local</span><br><span class="line">echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</span><br><span class="line">&#96;&#96;</span><br></pre></td></tr></table></figure><h2 id="五、创建方便运维的脚本"><a href="#五、创建方便运维的脚本" class="headerlink" title="五、创建方便运维的脚本"></a>五、创建方便运维的脚本</h2><p>一般我们出于对成本的考虑，我们会在一台服务器上装几个节点， 所以一旦集群出现故障，需要重启时，需要分别执行命令去启动几个节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>特别是生产故障时，这种做法非常不方便，所以可以自己写个 shell 脚本，<br>方便日后在一台机器上通过一个命令就可以管理这台机器上的所有节点。</p><p>编写脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 55 25</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Redis实例集群服务启动和停止脚本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">公共参数</span></span><br><span class="line">REDIS_BIN="/usr/local/redis/src/"</span><br><span class="line">LOCAL_IP=`ip addr | grep "inet" | grep  -v "inet6" | awk -F ' ' '&#123;print $2&#125;' | awk -F '/' '&#123;print $1&#125;' | grep -v "127.0.0.1"` #如果IP有多个,需要指定IP</span><br><span class="line">PORT_LIST="7000 7001 7002 7003" #端口需要根据实际情况定义,每个端口使用空格隔开</span><br><span class="line">CONFIG_DIR="/etc/redis/redis_cluster"</span><br><span class="line">PASSWORD="yourpassword"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">if [ ! -f "$CONFIG_DIR/$port/redis.conf" ]</span><br><span class="line">then</span><br><span class="line">echo "$CONFIG_DIR/$port/redis.conf is not exist!"</span><br><span class="line">exit 2</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH=$REDIS_BIN:$PATH</span><br><span class="line"></span><br><span class="line">function status()&#123;</span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">pid=`ps aux |  grep -v grep  | grep "redis-server $LOCAL_IP:$port" | awk -F ' ' '&#123;print $2&#125;'`</span><br><span class="line">if [ ! -z "$pid" ]</span><br><span class="line">then</span><br><span class="line">echo "redis process [$pid] $LOCAL_IP:$port is run.."</span><br><span class="line">else</span><br><span class="line">echo "redis process [$pid] $LOCAL_IP:$port not run.."</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start()&#123;</span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">redis-server $CONFIG_DIR/$port/redis.conf </span><br><span class="line">done</span><br><span class="line">status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop()&#123;</span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">redis-cli -h $LOCAL_IP -p $port -a $PASSWORD shutdown</span><br><span class="line">done</span><br><span class="line">status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">start)</span><br><span class="line">echo "start redis.."</span><br><span class="line">start</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo "stop redis.."</span><br><span class="line">stop</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">echo "redis status.."</span><br><span class="line">status</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">echo "restart redis.."</span><br><span class="line">echo "stop redis.."</span><br><span class="line">stop</span><br><span class="line">echo "start redis.."</span><br><span class="line">start</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo $"Usage: $0 &#123;start|stop|status|restart&#125;"</span><br><span class="line">exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>注册服务，并设置成开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@gdyt-wbredis01 init.d]# ls -l &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">-rwxr-xr-x 1 root root 1506 8月  17 09:47 &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig --add redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig on redis-server</span><br></pre></td></tr></table></figure><p><strong>使用脚本进行启动，停止，重启 redis 服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server start #启动</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server status #状态</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server stop #停止</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server restart #重启</span><br></pre></td></tr></table></figure><p><img src="/images/2018082408.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;集群的搭建可以分为以节点准备、节点握手、分配槽三个步骤。&lt;/p&gt;
&lt;h3 id=&quot;节点准备&quot;&gt;&lt;a href=&quot;#节点准备&quot; class=&quot;headerlink&quot; title=&quot;节点准备&quot;&gt;&lt;/a&gt;节点准备&lt;/h3&gt;&lt;p&gt;Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让 Redis 运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 开发与运维 3：Redis 的Java 客户端 Jedis</title>
    <link href="https://crazyfzw.github.io/2018/08/12/redis-java-client-Jedis/"/>
    <id>https://crazyfzw.github.io/2018/08/12/redis-java-client-Jedis/</id>
    <published>2018-08-12T04:51:57.000Z</published>
    <updated>2021-01-02T07:53:01.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Jedis 是 Redis 官方推荐的 Java 连接开发工具。Jedis 是一个非常小但又功能健全的 java 客户端。Jedis 是开源的，目前最新版本是 2.9.0 , 兼容 redis 2.8.x 和 3.x.x.版本，Github 地址： <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></p><a id="more"></a><p><strong>Jedis 提供了哪些支持？</strong></p><ul><li>排序</li><li>连接操作</li><li>支持 redis 所有 value 操作相关的命令</li><li>支持 redis 提供的五种数据结构及相关命令</li><li>事物 (Transactions)</li><li>Pipelining</li><li>发布/订阅 Publish/Subscribe</li><li>连接池 (Connection pooling)</li><li>分片 (Sharding )</li><li>Lua 脚本</li><li>集群 (Redis Cluster)</li><li>Persistence control commands</li><li>Remote server control commands</li></ul><h2 id="二、获取-Jedis"><a href="#二、获取-Jedis" class="headerlink" title="二、获取 Jedis"></a>二、获取 Jedis</h2><p>通过 maven 配置依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、Jedis-直连-Redis"><a href="#三、Jedis-直连-Redis" class="headerlink" title="三、Jedis 直连 Redis"></a>三、Jedis 直连 Redis</h2><p>直连方式每次都会新建 TCP 连接，使用后再断开连接，对于频繁访问 Redis 的场景显然不是高效的使用方式。生产环境不推荐使用这种方式。</p><p><img src="/images/2018081301.png" alt=""></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//生成一个Jedis对象，这个对象负责和指定Redis实例进行通信</span></span><br><span class="line">    jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后通过 jedis 对象就可以调用 redis 支持的命令了，比如</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完之后关闭连接</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际项目推荐使用 try catch finally 的形式来进行代码的书写：一方面可以在 Jedis 出现异常的时候（本身是网络操作），将异常进行捕获或者抛出；另一个方面无论执行成功或者失败，将 Jedis 连接关闭掉。</p><p>创建 Jedis 时，还可以调用以下构造函数，指定 客户端连接超时时间、客户端读写超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> soTimeout);</span><br></pre></td></tr></table></figure><h2 id="四、Jedis-连接池方式"><a href="#四、Jedis-连接池方式" class="headerlink" title="四、Jedis 连接池方式"></a>四、Jedis 连接池方式</h2><p>所有Jedis对象预先放在池子中（JedisPool），每次要连接 Redis，只需要在池子中借，用完了在归还给连接池。生产环境一般都使用这种方式。</p><p><img src="/images/2018081302.png" alt=""></p><p>Jedis提供了 JedisPool 这个类作为对 Jedis 的连接，同时使用了 Apache 的通用对象池工具 common-pool2 作为资源的管理工具。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.common-pool2 连接池配置</span></span><br><span class="line">GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"><span class="comment">//可以根据需要设置相关属性</span></span><br><span class="line">poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">poolConfig.setMaxIdle(<span class="number">50</span>);</span><br><span class="line">poolConfig.setMinIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.初始化Jedis连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure><p>此时，获取 Jedis 对象不再是直接生成一个 Jedis 对象进行直连，而是从连接池直接获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//从连接池借用 jedis 对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完后归还连接池</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上代码有点需要注意的是：使用 JedisPool 的时候，jedis.close() 不是关闭连接，而是表示归还连接池。</p><p>看下 Jedis 对 close方法的实现就很清楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client.isBroken()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnBrokenResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Jedis 对于 close 的实现，会先通过 dataSource 是否为 null 判断是否是使用连接池，若是，则调用归还资源函数，否则才真正执行关闭连接的操作。</p><p><strong>GenericObjectPoolConfig 的重要属性如下图所示：</strong><br><img src="/images/2018081303.jpg" alt=""></p><h2 id="五、Jedis直连方式和连接池方式对比"><a href="#五、Jedis直连方式和连接池方式对比" class="headerlink" title="五、Jedis直连方式和连接池方式对比"></a>五、Jedis直连方式和连接池方式对比</h2><blockquote><p>You shouldn’t use the same instance from different threads because you’ll have strange errors. And sometimes creating lots of Jedis instances is not good enough because it means lots of sockets and connections, which leads to strange errors as well. A single Jedis instance is not threadsafe! To avoid these problems, you should use JedisPool, which is a threadsafe pool of network connections. You can use the pool to reliably create several Jedis instances, given you return the Jedis instance to the pool when done. This way you can overcome those strange errors and achieve great performance.</p></blockquote><p>单个Jedis对象是线程不安全的，我们不应该在多个线程中使用共用同一个Jedis对象，然而，如果通过直连方式创建多个Jedis对象，又意味着会创建大量的socket以及TCP连接，带来大量的开销。为了避免这个问题，Jedis 为我们提供了一个线程安全的线程池JedisPool，通过连接池的方式，可以预先可靠地创建好多个Jedis连接对象，然后每次需要的时候就从Jedis连接池借用，使用完之后归还即可。这种方式提供了更大的安全性以及灵活性，所以，生产环境推荐使用连接池方式。</p><table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">直连</td><td align="center">简单方便，适用于少量长期连接的场景</td><td align="center">1）存在每次新建/关闭 TCP 连接开销<br/> 2）资源无法控制，可能会出现连接泄露  <br/> 3）Jedis对象线程不安全</td></tr><tr><td align="center">连接池</td><td align="center">1）无需每次连接都生成Jedis对象，降低开销<br/>2）使用连接池的方式控制和保护资源的使用</td><td align="center">相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规则不合理也会出现问题</td></tr></tbody></table><h2 id="六、Pipelining"><a href="#六、Pipelining" class="headerlink" title="六、Pipelining"></a>六、Pipelining</h2><blockquote><p>Sometimes you need to send a bunch of different commands. A very cool way to do that, and have better performance than doing it the naive way, is to use pipelining. This way you send commands without waiting for response, and you actually read the responses at the end, which is faster.</p></blockquote><p>Redis 支持 Pipelining 特性，Pipeline在某些场景下非常有用，比如有时想批量提交多个命令，而且他们对相应结果没有互相依赖，而且对结果响应也无需立即获得，那么久可以利用 Pipelining 实现这种批量处理，一次性发送多条命令并在执行完后一次性将结果返回。pipeline通过减少客户端与redis的通信次数来实现降低往返延时时间。过程大致如下：</p><p><img src="/images/2018081304.jpg" alt=""></p><p><strong>通过Jedis使用 Pipelining 的示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pipeline p = jedis.pipelined();</span><br><span class="line">p.set(<span class="string">"fool"</span>, <span class="string">"bar"</span>); </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">1</span>, <span class="string">"barowitch"</span>);  </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barinsky"</span>);</span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barikoviev"</span>);</span><br><span class="line">Response&lt;String&gt; pipeString = p.get(<span class="string">"fool"</span>);</span><br><span class="line">Response&lt;Set&lt;String&gt;&gt; sose = p.zrange(<span class="string">"foo"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">p.sync(); </span><br><span class="line"><span class="keyword">int</span> soseSize = sose.get().size();</span><br><span class="line">Set&lt;String&gt; setBack = sose.get();</span><br></pre></td></tr></table></figure><h2 id="七、发布-订阅（Publish-Subscribe）"><a href="#七、发布-订阅（Publish-Subscribe）" class="headerlink" title="七、发布/订阅（Publish/Subscribe）"></a>七、发布/订阅（Publish/Subscribe）</h2><p>Redis 通过 PUBLISH、SUBSCRIBE 等命令实现了订阅与发布模式，Redis 的 SUBSCRIBE 命令可以让客户端订阅任意数量的频道，每当有新信息 发布到被订阅的频道时， 信息就会被发送给所有订阅指定频道的客户端。</p><p>整个模型过程如下图所示：</p><p><img src="/images/2018081305.png" alt=""></p><p>上图展示了频道 channel1 ，以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系，当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端。</p><p><strong>使用场景：</strong></p><p>Publish/Subscribe 是目前广泛使用的通信模型，有很多的使用场景，比如内容订阅的的场；<br>；比如分布式架构中实现读写分离的场景，在写入的过程中，就可以使用redis发布订阅，使得写入值及时发布到各个读的程序中，保证数据的完整一致性。场景还有很多，有待挖掘。</p><p><strong>在 Jedis 使用 Publish/Subscribe 的示例，可以参考：</strong><a href="https://www.cnblogs.com/xinde123/p/8489054.html" target="_blank" rel="noopener">java实现 redis的发布订阅（简单易懂）</a></p><h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><p>[1] 《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://github.com/xetorthio/jedis/wiki/Getting-started" target="_blank" rel="noopener">Jedis WiKi</a><br>[3] <a href="https://xetorthio.github.io/jedis/" target="_blank" rel="noopener">Jedis API</a><br>[4] <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis 源码</a><br>[5] <a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html#id2" target="_blank" rel="noopener">订阅与发布</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Jedis 是 Redis 官方推荐的 Java 连接开发工具。Jedis 是一个非常小但又功能健全的 java 客户端。Jedis 是开源的，目前最新版本是 2.9.0 , 兼容 redis 2.8.x 和 3.x.x.版本，Github 地址： &lt;a href=&quot;https://github.com/xetorthio/jedis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xetorthio/jedis&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
      <category term="Jedis" scheme="https://crazyfzw.github.io/tags/Jedis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 开发与运维 2：Redis环境搭建及Redis shell的使用</title>
    <link href="https://crazyfzw.github.io/2018/08/10/redis-shell/"/>
    <id>https://crazyfzw.github.io/2018/08/10/redis-shell/</id>
    <published>2018-08-10T14:46:11.000Z</published>
    <updated>2021-01-02T07:55:57.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、版本选择"><a href="#一、版本选择" class="headerlink" title="一、版本选择"></a>一、版本选择</h2><blockquote><p>Redis 借鉴了 Linux 操作系统对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2、4.0）。当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。所以我们在生产环境通常选取偶数版本的 Redis。</p></blockquote><a id="more"></a><p>生产环境推荐选用偶数版本，推荐从 2.6、2.8、3.0、3.2 、4.0 这几个重大版本中选。几个版本的区别可参考 <a href="https://www.cnblogs.com/yangmingxianshen/p/8043851.html" target="_blank" rel="noopener">Redis重大版本</a></p><h2 id="二、安装-Redis"><a href="#二、安装-Redis" class="headerlink" title="二、安装 Redis"></a>二、安装 Redis</h2><p>进入 /usr/local 目录</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/2018081101.png" alt=""></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/2018081102.png" alt=""></p><h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p>建立一个名叫 redis 的软链接指向 redis-4.0.0 目录，这样做是为了不把 redis 目录固定在指定版本上，有利于Redis未来版本升级，算是安装软件的一种好习惯。（类型window 系统的快捷方式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s redis-4.0.0 redis</span><br></pre></td></tr></table></figure><p><img src="/images/2018081103.png" alt=""></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="/images/2018081104.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="/images/2018081105.png" alt=""></p><p>make install 会将 Redis 的相关运行文件放到 /usr/local/bin/ 下，这样就可以在任意目录下执行 Redis 的命令了。</p><p><img src="/images/2018081106.png" alt=""></p><p>查看 redis 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -v</span><br></pre></td></tr></table></figure><p>显示如下，说明已经安装成功啦。</p><p><img src="/images/2018081107.png" alt=""></p><p><strong>小结：</strong><br>整个安装过程其实非常简单，总共6步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ tar xzf redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ ln -s redis-4.0.0 redis</span><br><span class="line"></span><br><span class="line">$ cd redis</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><h2 id="三、配置、-启动、-操作、-关闭-Redis"><a href="#三、配置、-启动、-操作、-关闭-Redis" class="headerlink" title="三、配置、 启动、 操作、 关闭 Redis"></a>三、配置、 启动、 操作、 关闭 Redis</h2><p>前面已经提到 使用 make install 安装 Redis 之后，src和/usr/local/bin目录下多了几个以redis开头可执行文件，我们称之为RedisShell，这些可执行文件可以做很多事情，比如可以启动和停止Redis、可以检测和修复Redis的持久化文件，还可以检测Redis的性能。 下面是是我们最常用到的 Redis shell 说明：</p><table><thead><tr><th align="center">可执行文件</th><th align="center">作用描述</th></tr></thead><tbody><tr><td align="center">redis-server</td><td align="center">启动 Redis</td></tr><tr><td align="center">redis-cli</td><td align="center">Redis 命令行客户端</td></tr><tr><td align="center">redis-benchmark</td><td align="center">Redis 基准测试工具</td></tr><tr><td align="center">redis-check-aof</td><td align="center">Redis AOF 持久化文件检测和修复工具</td></tr><tr><td align="center">redis-check-dump</td><td align="center">Redis RDB 持久化文件检测和修复工具</td></tr><tr><td align="center">redis-sentinel</td><td align="center">启动 Redis Sentinel</td></tr></tbody></table><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动 Redis 服务的方法有三种，分别是：默认配置启动、运行配置启动、配置文件启动。生产环境推荐用配置文件启动，因为这种方式提供了更大的灵活性。</p><p>下面分别介绍下三种启动方式：</p><p><strong>默认配置启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>直接启动无法自定义配置，生产环境应该避免使用这种方式启动 Redis 服务。</p><p><strong>运行配置启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --configKey1 configValue1 --configKey2 configValue2 ...</span><br></pre></td></tr></table></figure><p>比如要指定端口（注： Redis 的默认端口是 6379），可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure><p><strong>配置文件启动（生产环境推荐使用这种方式）</strong></p><p>通常我们会在一台机器上启动多台 Redis，并且将配置管理在集中目录下，习惯性的做法是把 Redis安装目录下的 redis.conf 拷贝到  /opt/redis/ 下，然后作为模板根据需要修改。</p><p>然后通过指定该配置文件启动 Redis 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server  &#x2F;opt&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p><img src="/images/2018081108.png" alt=""></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作是通过 Redis命令行客户端来完成，有两种方式，一种是交互方式，一种是命令方式，推荐使用交互方式。</p><p>在用 redis-cli 连接 Redis服务之前，可以先用 ps -ef |grep redis 看redis是否在服务，以及查看对应的 ip 端口信息。</p><p><img src="/images/2018081109.png" alt=""></p><p><strong>交互方式（推荐使用这种方式）</strong><br>通过 redis-cli -h{host}- p{port} 的方式连接到Redis服务，之后所有的操作都是通过交互的方式实现，不需要再执行redis-cli了。</p><p><img src="/images/2018081110.png" alt=""></p><p><strong>命令方式</strong><br>用 redis-cli -h{host} -p{port} {command} 直接得到命令的返回结果。</p><p><img src="/images/2018081111.png" alt=""></p><h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p><img src="/images/2018081112.png" alt=""></p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、版本选择&quot;&gt;&lt;a href=&quot;#一、版本选择&quot; class=&quot;headerlink&quot; title=&quot;一、版本选择&quot;&gt;&lt;/a&gt;一、版本选择&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 借鉴了 Linux 操作系统对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2、4.0）。当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。所以我们在生产环境通常选取偶数版本的 Redis。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 开发与运维 1：聊聊 Redis</title>
    <link href="https://crazyfzw.github.io/2018/08/01/talk-about-redis/"/>
    <id>https://crazyfzw.github.io/2018/08/01/talk-about-redis/</id>
    <published>2018-08-01T12:51:03.000Z</published>
    <updated>2021-01-02T07:53:38.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的数据都放到内存中，因此 Redis 速度很快。除此之外，Redis 还提供了 持久化、主从复制、集群 以及以下几点功能：</p><ul><li>提供了键过期功能，可以用来实现缓存。</li><li>提供了发布订阅功能，可以用来实现消息系统。</li><li>支持 Lua 脚本功能，可以根据需要定制自己的 Redis 命令。</li><li>提供了简单的事务功能， 能在一定程度上保证事物特性。</li><li>提供了流水线（Pipeline）功能， 客户端可以将一批命令一次性传到 Redis，从而减少网络的开销。</li></ul><a id="more"></a><p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。redisObject 最主要的信息如图所示：</p><p><img src="/images/20180808000.png" alt=""></p><p>其中 type 代表一个 value 对象具体是何种数据类型，encoding 是不同数据类型在redis内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int。</p><h2 id="二、Redis提供的五种数据结构"><a href="#二、Redis提供的五种数据结构" class="headerlink" title="二、Redis提供的五种数据结构"></a>二、Redis提供的五种数据结构</h2><p><strong>五种数据结构：</strong></p><table><thead><tr><th align="center">数据类型</th><th align="center">可以存储的值</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td></tr><tr><td align="center">HASH</td><td align="center">包含键值对的无序散列表</td><td align="center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td></tr><tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td></tr></tbody></table><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>字符串类型是 Redis 最基础的数结构。首先键都是字符串类型， 而且其他几种数据结构 都是 在字符串类型基础上构建的。</p><p><img src="/images/2018080801.svg" alt=""></p><p>上图是string 在 redis 中的宏观样子，它的数据结构如下图所示：</p><p><img src="/images/2018080802.png" alt=""></p><p><strong>常用命令</strong></p><p>每种数据类型对应的命令都非常多，以下只列举 string 比较常用的命令，方便日后查看：</p><table><thead><tr><th align="center">命令</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">set</td><td align="center">set key value</td><td align="center">设置指定 key 的值</td></tr><tr><td align="center">get</td><td align="center">get key</td><td align="center">获取指定 key 的值</td></tr><tr><td align="center">del</td><td align="center">del key</td><td align="center">删除指定 key 的值</td></tr><tr><td align="center">setex</td><td align="center">setex key seconds value</td><td align="center">设置健并指定多少秒后过期</td></tr><tr><td align="center">setnx</td><td align="center">setnx key value</td><td align="center">只有当 key 不存在时才设置成功(setnx 可以作为分布式锁 的一种实现方案)</td></tr><tr><td align="center">mset</td><td align="center">mset key1 value1 key2 value2 …</td><td align="center">批量设置多个 key-value 对</td></tr><tr><td align="center">mget</td><td align="center">mget key1 key2 key3 …</td><td align="center">批量获取多个 key 的值</td></tr><tr><td align="center">incr</td><td align="center">incr key</td><td align="center">对值做自增操作</td></tr></tbody></table><p><strong>mset、mget 等批量操作可以减少网络传输的次数，从而可以提高效率。</strong></p><p>下面简单使用下一些命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>string 的典型使用场景：</strong></p><ul><li>缓存功能</li><li>计数</li><li>共享 Session</li><li>限速</li></ul><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>哈希类型是指键值本身又是一个键值对结构，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;&#123;&#123; field1， value1&#125;，...&#123; fieldN， valueN&#125;&#125;</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/images/2018080804.svg" alt=""></p><p>下图是字符串和哈希类型的对比：</p><p><img src="/images/2018080803.png" alt=""></p><p><strong>常用命令</strong></p><p>以下只列举 hash 比较常用的命令，方便日后查看：</p><table><thead><tr><th align="center">命令</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">hset</td><td align="center">hset key field value</td><td align="center">将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td align="center">hget</td><td align="center">hget key field</td><td align="center">获取存储在哈希表中指定字段的值</td></tr><tr><td align="center">hdel</td><td align="center">hdel key field1 field2 …</td><td align="center">删除一个或者多个 field</td></tr><tr><td align="center">hlen</td><td align="center">hlen key</td><td align="center">计算 field 个数</td></tr><tr><td align="center">hmset</td><td align="center">hmset key field value field1 field2 …</td><td align="center">批量设置一个key中的多个字段</td></tr><tr><td align="center">hmget</td><td align="center">hmget key field field1 field2 …</td><td align="center">批量获取一个key中的多个字段</td></tr><tr><td align="center">hexists</td><td align="center">hexists key field</td><td align="center">判断 key 中是否存在某个 field</td></tr><tr><td align="center">hkeys</td><td align="center">hkeys key</td><td align="center">获取指定 key 中的所有 field</td></tr><tr><td align="center">hvals</td><td align="center">hvals key</td><td align="center">获取指定 key 中的所有 value</td></tr><tr><td align="center">hgetall</td><td align="center">hgetall key</td><td align="center">获取指定 key 中的所有 field-value</td></tr></tbody></table><p><strong>在使用 hgetall 时， 如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果只需要获取部分 field，可以使用 hmget，如果一定要获取全部 field-value，可以使用 hscan 命令，该命令会渐进式遍历哈希类型。</strong></p><p>下面简单使用下一些命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure><p><strong>hash 的典型使用场景：</strong><br>比如缓存用户信息。每个用户属性使用一对field-value，但是只用一个键保存。如下图所示：</p><p><img src="/images/2018080805.png" alt=""></p><p>优点：简单直观，如果使用合理可以减少内存空间的使用。</p><p>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>列表类型是用来存储多个有序的字符串，支持两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p><p><img src="/images/2018080806.svg" alt=""></p><p>下图为列表两端插入和弹出操作，a、b、c、d、e五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element），一个列表最多可以存储232-1个元素。</p><p><img src="/images/2018080807.png" alt=""></p><p><strong>常用命令</strong></p><p>以下只列举 list 比较常用的命令，方便日后查看：</p><table><thead><tr><th align="center">命令</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">rpush</td><td align="center">rpush key value1 value2 …</td><td align="center">从右边插入一个或多个元素</td></tr><tr><td align="center">lpush</td><td align="center">lpush key value1 value2 …</td><td align="center">从左边插入一个或多个元素</td></tr><tr><td align="center">linsert</td><td align="center">linsert key before</td><td align="center">在 pivot 前或者后插入一个新元素 value</td></tr><tr><td align="center">lrange</td><td align="center">lrange key start end</td><td align="center">获取指定索引范围内的所有元素，索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N。 lrange key 0 -1  表示从左到右获取列表的所有元素</td></tr><tr><td align="center">lindex</td><td align="center">lindex key index</td><td align="center">获取列表指定索引下标的元素，lindex key -1 表示获取列表的最后一个元素</td></tr><tr><td align="center">llen</td><td align="center">llen key</td><td align="center">获取列表长度</td></tr><tr><td align="center">lpop</td><td align="center">lpop key</td><td align="center">从列表左侧弹窗元素</td></tr><tr><td align="center">rpop</td><td align="center">rpop key</td><td align="center">从列表右侧弹出元素</td></tr><tr><td align="center">lrem</td><td align="center">lrem key count value</td><td align="center">当 count&gt;0 , 从左到右，删除count个值等于 value的元素；当 count&lt;0，从右到左，删除count的绝对值个值等于value的元素；当 count=0，删除所有值等于 value的元素</td></tr><tr><td align="center">ltrim</td><td align="center">ltrim key start end</td><td align="center">只保留key 从start 到end 的元素</td></tr><tr><td align="center">lset</td><td align="center">lset key index newValue</td><td align="center">修改指定索引小标的元素</td></tr></tbody></table><p>下面简单使用下一些命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure><p><strong>list 的典型使用场景：</strong></p><ul><li>消息队列</li><li>文章列表</li></ul><p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·lpush+lpop&#x3D;Stack（栈）</span><br><span class="line">·lpush+rpop&#x3D;Queue（队列）</span><br><span class="line">·lpsh+ltrim&#x3D;CappedCollection（有限集合）</span><br><span class="line">·lpush+ brpop&#x3D; Message Queue（消息队列）</span><br></pre></td></tr></table></figure><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>集合类型也是用来保存多个的字符串元素，但和列表类型不同的是，集合中的元素是无序并且不可重复的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p><p><img src="/images/2018080809.svg" alt=""></p><p><img src="/images/2018080808.png" alt=""></p><p><strong>常用命令</strong></p><p>以下只列举 set 比较常用的命令，方便日后查看：</p><table><thead><tr><th align="center">命令</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">sadd</td><td align="center">sadd key value1 value2 …</td><td align="center">添加一个或多个元素</td></tr><tr><td align="center">srem</td><td align="center">srem key value1 value2 …</td><td align="center">删除一个或多个元素</td></tr><tr><td align="center">scard</td><td align="center">scard key</td><td align="center">计算元素个数</td></tr><tr><td align="center">sismember</td><td align="center">sismember key element</td><td align="center">判断元素是否在集合中，返回1表示存在，0 表示不存在</td></tr><tr><td align="center">srandmember</td><td align="center">srandmember key count</td><td align="center">随机从集合返回count个元素，count 不写默认为1</td></tr><tr><td align="center">spop</td><td align="center">spop key</td><td align="center">从集合随机弹出元素</td></tr><tr><td align="center">smembers</td><td align="center">smembers key</td><td align="center">获取所有元素</td></tr><tr><td align="center">sinter</td><td align="center">sinter key1 key2 …</td><td align="center">求多个集合的交集</td></tr><tr><td align="center">suinon</td><td align="center">suinon key1 key2 …</td><td align="center">求多个集合的并集</td></tr><tr><td align="center">sdiff</td><td align="center">sdiff key1 key2 …</td><td align="center">求多个集合的差集</td></tr><tr><td align="center">sinterstore</td><td align="center">sinterstore key key1 key2 …</td><td align="center">求多个集合的交集并保存到key中</td></tr><tr><td align="center">suinonstore</td><td align="center">suinonstore key key1 key2 …</td><td align="center">求多个集合的并集并保存到key中</td></tr><tr><td align="center">sdiffstore</td><td align="center">sdiffstore key key1 key2 …</td><td align="center">求多个集合的差集并保存到key中</td></tr></tbody></table><p><strong>smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p><p>下面简单使用下一些命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure><p><strong>set 的典型使用场景：</strong></p><ul><li>sadd=Tagging（标签）</li><li>spop/srandmember=Randomitem（生成随机数，比如抽奖）</li><li>sadd+sinter=SocialGraph（社交需求）</li></ul><p>标签（tag）是集合类型一个比较典型的使用场景。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签。</p><h3 id="ZSET（sorted-set）"><a href="#ZSET（sorted-set）" class="headerlink" title="ZSET（sorted set）"></a>ZSET（sorted set）</h3><p>有序集合，保留了集合元素不可重复的特性，并在集合的基础上增加了元素排序功能。需要注意的是，它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。有序集合还提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p><p><img src="/images/20180808010.svg" alt=""></p><p>下图是一个有序集合的例子，该有序集合包含kris、mike、frank、tim、martin、tom，它们的分数分别是1、91、200、220、250、251。</p><p><img src="/images/20180808011.png" alt=""></p><p><strong>常用命令</strong></p><p>以下只列举 zset 比较常用的命令，方便日后查看：</p><table><thead><tr><th align="center">命令</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">zadd</td><td align="center">zadd key score member [score member …]</td><td align="center">向有序集合添加一个或多个成员以及分数，或者更新已存在成员的分数</td></tr><tr><td align="center">zcard</td><td align="center">zcard key</td><td align="center">计算成员个数</td></tr><tr><td align="center">zscore</td><td align="center">zscore key member</td><td align="center">计算某个成员的分数，存在则返回分数，否则返回 nil</td></tr><tr><td align="center">zrank</td><td align="center">zrank key element</td><td align="center">返回分数从低到高的排名</td></tr><tr><td align="center">zrevrank</td><td align="center">zrevrank key count</td><td align="center">返回分数从高到低的排名</td></tr><tr><td align="center">zrem</td><td align="center">zrem member [member …]</td><td align="center">删除一个或多个成员</td></tr><tr><td align="center">zincrby</td><td align="center">zincrby key increment member</td><td align="center">给key中的member 增加 increment 分</td></tr><tr><td align="center">zrange</td><td align="center">sinter key1 key2 …</td><td align="center">求多个集合的交集</td></tr><tr><td align="center">zremrangebyscore</td><td align="center">zremrangebyscore key min max</td><td align="center">删除指定分数范围的成员</td></tr></tbody></table><p><strong>zset 同样可以计算集合的交、并、差，以上没有一一列举</strong></p><p>下面简单使用下一些命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure><p><strong>zset 的典型使用场景：</strong></p><p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p><p>以点赞数位例，主要需要实现以下4个功能</p><ul><li>添加用户赞数</li><li>取消用户赞数</li><li>展示获取赞数最多的十个用户</li><li>展示用户信息以及用户分数</li></ul><h2 id="三、Redis的使用场景"><a href="#三、Redis的使用场景" class="headerlink" title="三、Redis的使用场景"></a>三、Redis的使用场景</h2><p>由于 redis 支持多种数据类型，所以适用场景也非常多。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>对于热点数据，缓存的价值非常大。例如，分类栏目(读频率高)等。可以将这些热点数据放到内存中，通过设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 </p><h3 id="共享Session（会话缓存）"><a href="#共享Session（会话缓存）" class="headerlink" title="共享Session（会话缓存）"></a>共享Session（会话缓存）</h3><p>在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息。比如我们公司就使用Redis共享Session来实现单点登录。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>数据统计的需求非常普遍，通过原子递增保持计数。例如，应用数、资源数、点赞数、收藏数、分享数等。这种高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作。</p><h3 id="排行榜以及热门列表"><a href="#排行榜以及热门列表" class="headerlink" title="排行榜以及热门列表"></a>排行榜以及热门列表</h3><p>例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：比如按照时间、播放量、点击率、点赞数等。可以利用有序集合 zset 实现。</p><h3 id="社交列表"><a href="#社交列表" class="headerlink" title="社交列表"></a>社交列表</h3><p>社交属性相关的列表信息，例如，用户点赞列表、用户分享列表、用户收藏列表、用户关注列表、用户粉丝列表等，使用 Hash 类型数据结构是个不错的选择。</p><h3 id="记录用户判定信息"><a href="#记录用户判定信息" class="headerlink" title="记录用户判定信息"></a>记录用户判定信息</h3><p>记录一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否评论分享等。</p><h3 id="交集、并集和差集"><a href="#交集、并集和差集" class="headerlink" title="交集、并集和差集"></a>交集、并集和差集</h3><p>在某些场景中，例如社交场景，通过交集、并集和差集运算，可以非常方便地实现共同好友，共同关注，共同偏好等社交关系。</p><h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>例如验证码只有60秒有效期，超过时间无法使用，或者基于 Oauth2 的 Token 只能在 5 分钟内使用一次，超过时间也无法使用。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中list的数据结构实现是双向链表，所以非常适合应用于消息队列（生产者/消费者模型）。 生产者利用 lpush 命令将数据添加到链表头部，消费者通过 brpop（右端阻塞弹出） 命令将元素从链表尾部取出。并且可以保证消息的有序性。比如可以用这种方式让多个应用更新最新的内容。</p><p>不过最好还是用 RabbitMQ 等市面上成熟的消息队列中间件。</p><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>由于Redis的单线程命令处理机制，如果有多个客户端同时执行 setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2 id="四、Redis的数据淘汰策略-内存淘汰机制"><a href="#四、Redis的数据淘汰策略-内存淘汰机制" class="headerlink" title="四、Redis的数据淘汰策略(内存淘汰机制)"></a>四、Redis的数据淘汰策略(内存淘汰机制)</h2><h3 id="内存淘汰的过程"><a href="#内存淘汰的过程" class="headerlink" title="内存淘汰的过程"></a>内存淘汰的过程</h3><p>首先，客户端发起了需要申请更多内存的命令（如set）。</p><p>然后，Redis检查内存使用情况，如果已使用的内存大于 maxmemory 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p><p>最后，如果上面都没问题，则这个命令执行成功。</p><h3 id="8-种淘汰策略"><a href="#8-种淘汰策略" class="headerlink" title="8 种淘汰策略"></a>8 种淘汰策略</h3><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持以下6种策略：</p><table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">noeviction</td><td align="center">当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td align="center">allkeys-lfu</td><td align="center">从所有键中驱逐使用频率最少的键</td></tr><tr><td align="center">volatile-lfu</td><td align="center">从已设置过期时间的数据集中挑选使用频率最少的键</td></tr></tbody></table><p>需要注意的是：作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><h3 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h3><p>下面看看几种策略的适用场景</p><p>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。</p><p>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</p><p>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。</p><p><strong>推荐用法：</strong><br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h3 id="如何配置最大内存及淘汰策略"><a href="#如何配置最大内存及淘汰策略" class="headerlink" title="如何配置最大内存及淘汰策略"></a>如何配置最大内存及淘汰策略</h3><p>我们通过配置redis.conf中的 maxmemory 这个值来开启内存淘汰功能，以及配置淘汰策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 100000</span><br><span class="line"></span><br><span class="line">#设置淘汰策略</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>需要注意的是，maxmemory 为0的时候表示我们对Redis的内存使用没有限制。</p><p>此外，redis支持动态改配置，无需重启。</p><p>设置最大内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory 100000</span><br></pre></td></tr></table></figure><p>设置淘汰策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><h2 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h2><p>Redis支持RDB和AOF两种持久化机制，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化，从而能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p><h3 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据生成快照（Snapshot）以紧凑压缩的二级制文件格式保存到硬盘。</p><p>触发RDB持久化过程分为手动触发和自动触发。手动触发分别对应save和bgsave命令，其中save存在阻塞问题，基本已经废弃，Redis内部所有的涉及RDB的操作都采用bgsave的方式。执行save 或 bgsave 将在 redis 安装目录中创建dump.rdb （可配置）文件,如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</p><p>可以在redis.conf中做一些 RDB 相关的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 快照的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 存放快照的目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"># 在进行镜像备份时,是否进行压缩。</span><br><span class="line"># yes：压缩，但是需要一些cpu的消耗。</span><br><span class="line"># no：不压缩，需要更多的磁盘空间。</span><br><span class="line">rdbcompression yes</span><br><span class="line">#900秒后且至少1个key发生变化时创建快照  </span><br><span class="line">save 900 1  </span><br><span class="line">#300秒后且至少10个key发生变化时创建快照  </span><br><span class="line">save 300 10  </span><br><span class="line">#60秒后且至少10000个key发生变化时创建快照  </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><strong>RDB的优点：</strong></p><ul><li><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p></li><li><p>Redis加载RDB恢复数据远远快于AOF的方式。</p></li></ul><p><strong>RDB的缺点：</strong></p><ul><li><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p></li><li><p>一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。例如，每隔30分钟或者更长的时间来创建一次快照，Redis停止工作时（例如意外断电）就可能丢失这30分钟的数据。</p></li><li><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p></li></ul><h3 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h3><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过 appendfilename 配置设置，默认文件名是 appendonly.aof。保存路径同 RDB 持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。如下图所示：</p><p><img src="/images/20180808012.png" alt=""></p><p>AOF 工作流程 ：</p><p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p><p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p><p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p><p><strong>下面分别讲下每个过程：</strong></p><h4 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h4><p>AOF命令写入是吧文本协议格式的内容追加到缓存区。</p><p>如以下 set hello world 命令的文本协议格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></table></figure><p><strong>采用文本协议格式的原因：</strong><br>文本协议具有可读性，方便直接修改和处理。同时还可以避免二次开销。</p><p><strong>先写入缓存区而不是直接写入硬盘的原因：</strong><br>如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p><h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。Redis支持三种不同的缓冲区同步文件策略如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，影响 Redis 的高性能，一般不推荐使用。</span><br><span class="line"># appendfsync always </span><br><span class="line"></span><br><span class="line">#完全依赖操作系统的写入，一般为30秒左右一次，性能最好但是数据安全性无法保证，不被推荐。</span><br><span class="line"># appendfsync no  </span><br><span class="line"></span><br><span class="line">#每秒钟强制写入磁盘一次，兼顾性能和数据安全性，在性能和持久化方面做了很好的折中，理论上只有在系统突然宕机的情况下丢失1秒的数据。是受推荐的方式。</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p><p>重写的过程主要做了一下事情：</p><p>1）进程内已经超时的数据不再写入文件。</p><p>2）旧的AOF文件中的无效命令不再写入，如delkey1、hdelkey2、sremkeys、seta111、seta222 等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p><p>3）多条写命令可以合并为一个，如：lpushlista、lpushlistb、lpushlistc可以转化为：lpushlistabc。</p><p>具体的重写流程如下图所示：</p><p><img src="/images/20180808013.png" alt=""></p><p>可以通过下面配置设置什么时候开启自动重写：</p><p>AOF重写过程可以手动触发（直接调用bgrewriteaof命令）和自动触发：根据配置的auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># AOF文件名  </span><br><span class="line">appendfilename appendonly.aof </span><br><span class="line"></span><br><span class="line">#当进程中BGSAVE或BGREWRITEAOF命令正在执行时不阻止主进程中的fsync()调用（默认为no，当存在延迟问题时需调整为yes）  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">#当AOF增长率为100%且达到了64mb时开始自动重写AOF  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h3 id="重启加载-数据恢复"><a href="#重启加载-数据恢复" class="headerlink" title="重启加载(数据恢复)"></a>重启加载(数据恢复)</h3><p>RDB 和 AOF 文件都可以用于服务器重启时的数据恢复。</p><p>下图为 Redis 持久化文件加载流程(即重启阶段恢复数据的流程)：</p><p><img src="/images/20180808014.png" alt=""></p><p>流程说明：</p><p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p><p>2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p><p>3）加载AOF/RDB文件成功 后，Redis 启动成功。 </p><p>4）AOF/RDB文件存在错误时，Redis 启动失败并打印错误信息。</p><h2 id="六、Redis-为什么速度快"><a href="#六、Redis-为什么速度快" class="headerlink" title="六、Redis 为什么速度快"></a>六、Redis 为什么速度快</h2><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p><ul><li><p>纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒。</p></li><li><p>Redis采用了单线程设计，单线程避免了线程切换和竞态产生消耗。</p></li><li><p>Redis采用了非阻塞I/O模型，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p></li><li><p>Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p></li></ul><h2 id="七、Redis-为什么采用单线程"><a href="#七、Redis-为什么采用单线程" class="headerlink" title="七、Redis 为什么采用单线程"></a>七、Redis 为什么采用单线程</h2><p>Redis 为什么采用单线程设计，主要原因如下：</p><ul><li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li><li>采用单线程设计，可以极大简化数据结构和算法的实现，使代码更清晰，处理逻辑更简单。</li><li>单线程避免了不必要的线程切换和竞态产生消耗。</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，不会出现死锁而导致的性能消耗。</li></ul><p>采用单线程设计也有一个弊端，就是无法发挥多核CPU性能，如果某个命令执行过长，会造成其他命令的阻塞。</p><p>解决的办法是，通过在一个多核的机器上部署多个redis实例，组成master-master，master-slave的形式，实现读写分离。把耗时的读命令完全可以放到slave中来解决。</p><h2 id="八、Redis的内部结构"><a href="#八、Redis的内部结构" class="headerlink" title="八、Redis的内部结构"></a>八、Redis的内部结构</h2><p>Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p><p>可以通过阅读 <a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a> 来学习。<br>还可以参考下 <a href="http://zhangtielei.com/posts/server.html" target="_blank" rel="noopener">Redis内部数据结构详解</a> 系列博客</p><h2 id="九、Redis-集群方案与实现"><a href="#九、Redis-集群方案与实现" class="headerlink" title="九、Redis 集群方案与实现"></a>九、Redis 集群方案与实现</h2><p>后面会单独写篇文章讲 Redis 的 复制、哨兵、集群。</p><h2 id="十、Redis-与-Memcached-的差异"><a href="#十、Redis-与-Memcached-的差异" class="headerlink" title="十、Redis 与 Memcached 的差异"></a>十、Redis 与 Memcached 的差异</h2><p>Redis 和 Memcache 都是基于内存的数据存储系统。Redis是一个开源的key-value存储系统，而Memcached是高性能分布式内存缓存服务。那么Redis 与 Memcached 之间有什么区别呢？</p><p>Redis的作者Salvatore Sanfilippo曾经对这两种基于内存的数据存储系统进行过比较：</p><ul><li><p>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p></li><li><p>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p></li><li><p>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p></li></ul><h3 id="数据类型支持不同"><a href="#数据类型支持不同" class="headerlink" title="数据类型支持不同"></a>数据类型支持不同</h3><p>Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。</p><p>Memcached仅支持简单的key-value结构的数据记录。</p><h3 id="内存管理机制不同"><a href="#内存管理机制不同" class="headerlink" title="内存管理机制不同"></a>内存管理机制不同</h3><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p><p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。</p><p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题，但是它最大的缺点就是会导致空间浪费，因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><h3 id="数据持久化支持"><a href="#数据持久化支持" class="headerlink" title="数据持久化支持"></a>数据持久化支持</h3><p>Redis支持内存数据的持久化，而且提供了RDB快照和AOF日志两种主要的持久化策略。</p><p>memcached是不支持数据持久化操作的。</p><h3 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h3><p>Redis 本身提供了 Cluster，引入Master节点和Slave节点，支持在服务器端构建分布式存储。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><h2 id="十一、参考文献"><a href="#十一、参考文献" class="headerlink" title="十一、参考文献"></a>十一、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://redislabs.com/community/ebook/" target="_blank" rel="noopener">《Redis IN ACTION》</a> ah L. Carlson<br>[3] <a href="http://blog.720ui.com/columns/redis_action_all/" target="_blank" rel="noopener">Redis实战 文集</a><br>[4] <a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis应用场景</a><br>[5] <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考</a><br>[6] <a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述Redis和Memcached的差异</a><br>[7] <a href="https://www.zhihu.com/question/19645807" target="_blank" rel="noopener">MongoDB 或者 redis 可以替代 memcached 吗?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的数据都放到内存中，因此 Redis 速度很快。除此之外，Redis 还提供了 持久化、主从复制、集群 以及以下几点功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了键过期功能，可以用来实现缓存。&lt;/li&gt;
&lt;li&gt;提供了发布订阅功能，可以用来实现消息系统。&lt;/li&gt;
&lt;li&gt;支持 Lua 脚本功能，可以根据需要定制自己的 Redis 命令。&lt;/li&gt;
&lt;li&gt;提供了简单的事务功能， 能在一定程度上保证事物特性。&lt;/li&gt;
&lt;li&gt;提供了流水线（Pipeline）功能， 客户端可以将一批命令一次性传到 Redis，从而减少网络的开销。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据存储 3：分库与分表</title>
    <link href="https://crazyfzw.github.io/2018/07/29/database-sharding/"/>
    <id>https://crazyfzw.github.io/2018/07/29/database-sharding/</id>
    <published>2018-07-29T13:14:31.000Z</published>
    <updated>2021-01-02T07:54:08.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、分库与分表是为了解决什么问题（目的）"><a href="#一、分库与分表是为了解决什么问题（目的）" class="headerlink" title="一、分库与分表是为了解决什么问题（目的）"></a>一、分库与分表是为了解决什么问题（目的）</h2><p>随着业务的增长，表数据的增加，查询一次所消耗的时间会变得越来越长，甚至会造成数据库的单点压力。当数据库已经成为系统性能的瓶颈，这时，通过分库分表，可以减小数据库的单库单表负担，提高查询性能，缩短查询时间，从而提升系统的响应速度。</p><a id="more"></a><h2 id="二、分库分表方案应该尽量避免的两个问题"><a href="#二、分库分表方案应该尽量避免的两个问题" class="headerlink" title="二、分库分表方案应该尽量避免的两个问题"></a>二、分库分表方案应该尽量避免的两个问题</h2><ol><li>数据迁移</li><li>热点数据</li></ol><h2 id="三、垂直拆分"><a href="#三、垂直拆分" class="headerlink" title="三、垂直拆分"></a>三、垂直拆分</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块以及表的相关性来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</p><p>比如以一个订单系统吧为例：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。如下图：</p><p><img src="/images/2018073001.png" alt=""></p><p><strong>小结：</strong></p><p>数据库的 CPU、内存、磁盘 IO 、连接资源、网络带宽都是有限的，所以单个物理机上容易出现资源竞争和性能瓶颈。通过垂直分库，一方面，可以解决数据库单点压力过大的问题，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。另一方面，数据库层面的拆分们也有利于我们针对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。因此，垂直分库是大型分布式系统中优化数据库架构的重要手段。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>垂直分表在日常开发和设计中比较常见。垂直拆分，其实就是“大表拆小表”，把表的列字段进行拆分，即一张字段比较多的表拆分为多张表，这样使得行数据变小。一方面，可以减少客户端程序和数据库之间的网络传输的字节数，因为生产环境共享同一个网络带宽，随着并发查询的增多，有可能造成带宽瓶颈从而造成阻塞。另一方面，一个数据块能存放更多的数据，在查询时就会减少 I/O 次数。</p><p>通常就是建立“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：</p><p><img src="/images/2018073002.png" alt=""></p><p><strong>拆分策略：</strong></p><ol><li><p>将不常用的字段单独拆分到另外一张扩展表，例如前面讲解到的用户家庭地址，这个字段是可选字段，在数据库操作的时候除了个人信息外，并不需要经常读取或是更改这个字段的值。</p></li><li><p>将大文本的字段单独拆分到另外一张扩展表，例如 BLOB 和 TEXT 字符串类型的字段，以及 TINYBLOB、 MEDIUMBLOB、 LONGBLOB、 TINYTEXT、 MEDIUMTEXT、 LONGTEXT字符串类型。这样可以减少客户端程序和数据库之间的网络传输的字节数。</p></li><li><p>将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。举个例子，假设用户表的设计中，还存在“最后登录时间”字段，每次用户登录时会被更新。这张用户表会存在频繁的更新操作，此外，每次更新时会导致该表的查询缓存被清空。所以，可以把这个字段放到另一个表中，这样查询缓存会增加很多性能。对于需要经常关联查询的字段，建议放在同一张表中。不然在联合查询的情况下，会带来数据库额外压力。</p></li></ol><p><strong>小结：</strong></p><p>拆分字段的操作应该在数据库表设计阶段就做好。尽量避免在发展过程中做垂直分表，因为做字段拆分后，需要改以前的映射实体以及查询语句，会额外带来一定的成本和风险。</p><h2 id="四、水平拆分"><a href="#四、水平拆分" class="headerlink" title="四、水平拆分"></a>四、水平拆分</h2><p>垂直拆分只是解决了单库压力的问题。依然可能存在单表数据量过大影响查询性能的问题。若确实存在，则这时就应该考虑水平拆分。</p><p>水平分表也称为横向分表，是一种把单表按某个规则把数据分散到多个表的拆分方式，以此来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。</p><p>如下图所示：比如：把单表1亿数据按某个规则拆分，分别存储到10个相同结果的表，每个表的数据是1千万，拆分出来的表，可以综合实际情况考虑是放在同一个库中，还是分别放至到不同数据库中，即同时进行水平拆库操作，如下图所示：</p><p><img src="/images/2018073003.png" alt=""></p><p><strong>水平分表策略</strong></p><p>常见的水平分表策略归纳起来，可以总结为随机分表和连续分表两种情况。例如，取模切分、Hash切分就属于随机分表，而按时间维度切分、ID 范围切分则属于连续分表。</p><h3 id="连续切分（范围切分）"><a href="#连续切分（范围切分）" class="headerlink" title="连续切分（范围切分）"></a>连续切分（范围切分）</h3><p>连续分表可以快速定位到表进行高效查询，大多数情况下，可以有效避免跨表查询。如果想扩展，只需要添加额外的分表就可以了，无需对其他分表的数据进行数据迁移。但是，连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。</p><p>比如按照时间区间或ID区间来切分：</p><p><img src="/images/2018073004.png" alt=""></p><p>优点：单表大小可控，天然水平扩展。<br>缺点：无法解决集中写入瓶颈的问题，可能存在热点数据问题。</p><h3 id="随机切分（Hash切分、取模切分）"><a href="#随机切分（Hash切分、取模切分）" class="headerlink" title="随机切分（Hash切分、取模切分）"></a>随机切分（Hash切分、取模切分）</h3><p>随机分表是遵循规则策略进行写入与读取，而不是真正意义上的随机。通常，采用取模分表或者自定义 Hash 分表的方式进行水平拆分。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。此外，随机分表比较容易面临跨表查询的复杂问题。</p><p>比如以下取模切分：</p><p><img src="/images/2018073005.png" alt=""></p><p>后面这里需要再结合案例展开详细写。</p><p>优点：不存在热点数据问题，不存在几种写入瓶颈问题。<br>缺点：再次扩展难度增大，需要迁移旧数据。</p><p><strong>小结：</strong></p><p>水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，通常做法是把拆分后的表放到不同的库中。但这也涉及一个成本问题，需要综合考虑实际的访问量、并发数、未来可预见的一段时间的业务增长量、以及成本。</p><p>水平拆分可以降低单表数据量，让每个单表的数据量保持在一定范围内，从而提升单表读写性能。但水平拆分后，同一业务数据分布在不同的表或库中，可能需要把单表事务改成跨表事务，需要转变数据统计方式等。</p><h2 id="五、垂直水平拆分混合"><a href="#五、垂直水平拆分混合" class="headerlink" title="五、垂直水平拆分混合"></a>五、垂直水平拆分混合</h2><p>垂直水平拆分，是综合了垂直和水平拆分方式的一种混合方式。首先，按业务及表的相关性垂直分库（垂直切分），划分出不同的库，然后再挑选出数据量大、增长迅猛的表进行水平分表（水平切分）。</p><p>比如针对一个订单系统的垂直水平拆分如下：</p><p><img src="/images/2018073006.png" alt=""></p><p><strong>小结：</strong></p><p>需要注意的是，水平拆分的表需要放到不同的数据库才能减少数据库的但点压力，但是考虑到成本和后期的管理维护问题，现实情况，往往不会弄单库单表的情况（除非真的必要）。</p><p>为了提示机器的利用率，在水平切分完成后可再进行一次“反向的Merge”,即：将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个分片放到同一个数据库上，在逻辑上它们依然是独立的分片，有各自的主表，并且提升了数据库服务器的利用率。</p><p>整个过程可以参考下图：</p><p><img src="/images/2018073007.png" alt=""></p><h2 id="六、分库分表实践案例"><a href="#六、分库分表实践案例" class="headerlink" title="六、分库分表实践案例"></a>六、分库分表实践案例</h2><p>下面是唯品会以及美团点评对订单系统的分库分表，个人觉得比较有参考意义。具体详情可参考原文。</p><h3 id="唯品会的订单分库分表实践总结以及关键步骤"><a href="#唯品会的订单分库分表实践总结以及关键步骤" class="headerlink" title="唯品会的订单分库分表实践总结以及关键步骤"></a>唯品会的订单分库分表实践总结以及关键步骤</h3><p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p><h3 id="大众点评订单系统分库分表实践"><a href="#大众点评订单系统分库分表实践" class="headerlink" title="大众点评订单系统分库分表实践"></a>大众点评订单系统分库分表实践</h3><p>原文地址：<a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p><h3 id="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"><a href="#阿里一种可以避免数据迁移的分库分表scale-out扩容方式" class="headerlink" title="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"></a>阿里一种可以避免数据迁移的分库分表scale-out扩容方式</h3><p>文章地址：<a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p><br/>## 七、分库分表带来的问题以及对应的解决办法<h3 id="1-表关联问题（跨库-Join）"><a href="#1-表关联问题（跨库-Join）" class="headerlink" title="1. 表关联问题（跨库 Join）"></a>1. 表关联问题（跨库 Join）</h3><p>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。</p><p>基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。所以，在设计及拆分阶段应尽量避免出现跨库Join（将那些存在关联关系的表记录存放在同一个分片上）。若开发过程中还是出现了需要跨库查询的场景，则可以通过在程序中进行拼装解决（二次查询或者通过RPC调用来得到关联的数据,然后再进行拼装）。</p><p><strong>下面，提供几种跨库J oin的解决思路：</strong></p><p><strong>ER分片</strong><br>在关系型数据库中，表之间往往存在一些关联的关系。如果我们可以先确定好关联关系，在设计或拆分阶将那些存在关联关系的表记录存放在同一个分片上，那么就能很好的避免跨分片 join 问题。</p><p><strong>通过全局表进行规避</strong></p><p>比如“数据字典表”，这种系统中的所有模块都可能会用到的表，这类数据通常也很少发生修改（甚至几乎不会），也不用太担心“一致性”问题。所以可以将这类表在每个数据库中均保存一份，以此来了避免跨库join查询。这种表，可以称之为全局表。</p><p><strong>通过反范式化设计进行规避</strong></p><p>可以通过个别字段的冗余来避免跨库join查询，这是一种典型的反范式设计。</p><p>举个电商业务中很简单的场景：</p><p>“订单表”中保存 “卖家Id” 的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。单这也存在一个问题，比如卖家修改了Name之后，是否需要在订单信息中同步更新呢？</p><p>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。另一方面，这种方式存在数据一致性问题，如果业务对数据一致性强要求，那就需要通过额外的手段来保证（比如可以借助数据库中的触发器或者在业务代码层面去保证）。</p><p><strong>通过在系统层二次查询组装解决</strong></p><p>可以在程序中通过或者通过RPC调用来得到关联的数据，从而避免跨库join查询。需要特别注意的是，这里的二次查询或者通过RPC调用最好不要放在循环中去执行，否则效率会很低，甚至会严重影响系统的性能。</p><p>通常的做法是把循环调用改成一次调用，一次取出所有关联的数据，然后再进行组装。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> QuestionResponse <span class="title">GetOrderList</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">QuestionResponse response = <span class="keyword">new</span> QuestionResponse();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基本结构集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Order&gt; result =  orderServer.getOrderList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Long&gt; productIds = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line"><span class="keyword">for</span> (Order order : result) &#123;</span><br><span class="line">productIds.add(order.getProductId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入关联数据的ID集合，一次查询出所有关联数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Product&gt; productList =  productServer.getOrderList(productIds);</span><br><span class="line"><span class="keyword">for</span> (Order order : result) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配数据，并赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setResult(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>简单字段组装的情况下，我们只需要先获取“主表”数据，然后再根据关联关系，调用其他模块的组件或服务来获取依赖的其他字段（如例中依赖的用户信息），最后将数据进行组装。</p><p>通常，我们都会通过缓存来避免频繁RPC通信和数据库查询的开销。</p><h3 id="2-分页与排序问题（limit、order-by）"><a href="#2-分页与排序问题（limit、order-by）" class="headerlink" title="2. 分页与排序问题（limit、order by）"></a>2. 分页与排序问题（limit、order by）</h3><p>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p><p>如下图所示取第一页数：</p><p><img src="/images/2018073008.png" alt=""></p><p>上图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：</p><p><img src="/images/2018073009.png" alt=""></p><p>那为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差（典型的大分页问题，比如搜索引擎结果页中，越往后翻响应越慢）。</p><h3 id="3-跨分片的函数处理-Count、Max、Min、Sum"><a href="#3-跨分片的函数处理-Count、Max、Min、Sum" class="headerlink" title="3. 跨分片的函数处理(Count、Max、Min、Sum)"></a>3. 跨分片的函数处理(Count、Max、Min、Sum)</h3><p>在使用Max、Min、Sum、Count之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：</p><p><img src="/images/2018073010.png" alt=""></p><h3 id="4-分布式事务问题"><a href="#4-分布式事务问题" class="headerlink" title="4. 分布式事务问题"></a>4. 分布式事务问题</h3><p>按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。以往在代码中通过spring注解简单配置就能实现事务，现在则需要花很大的成本去保证一致性。后面会单独写一篇文章展开讲。</p><h3 id="5-分布式全局唯一ID"><a href="#5-分布式全局唯一ID" class="headerlink" title="5. 分布式全局唯一ID"></a>5. 分布式全局唯一ID</h3><p><a href="https://crazyfzw.github.io/2018/07/21/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-2%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/#more">分布式系统全局唯一ID生成方案</a></p><h2 id="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"><a href="#八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）" class="headerlink" title="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"></a>八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）</h2><p>分库与分表主要用于应对当前互联网常见的两个场景：海量数据和高并发。但是分库分表同时也提高了系统的复杂度以及维护成本。分库与分表是一把双刃剑，因此，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑通过分库与分表提高系统的性能。</p><p>一般表数据在1000W以内都不需要考虑分表。分库分表时应考虑尽可能考虑可预见的几年内业务的增长，对数据库服务器的QPS、连接数、容量等做合理评估和规划。</p><h2 id="九、分库分表后如何迁移数据"><a href="#九、分库分表后如何迁移数据" class="headerlink" title="九、分库分表后如何迁移数据"></a>九、分库分表后如何迁移数据</h2><p>对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</p><h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><p>[1] <a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p><p>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p><p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486426&idx=1&sn=20e965a30c59613b5b11e42e004d2445&chksm=96c9bdbaa1be34ac8d25637272287da249fe2cb804315e2fc73f87d770dd7a41fdb286fa114e&scene=27#wechat_redirect" target="_blank" rel="noopener">分库分表的几种常见形式以及可能遇到的难题</a></p><p>[4] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486422&idx=1&sn=f6dd2a02c96bc3467de83bb34c87fe64&chksm=96c9bdb6a1be34a0e5c218d4143a05d04404d1515a972b642c447967847c3dac58eb59f4742f&scene=27#wechat_redirect" target="_blank" rel="noopener">水平分库分表的关键步骤以及可能遇到的问题</a></p><p>[5] <a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p><p>[6] <a href="http://jm.taobao.org/%2F2017%2F01%2F19%2F20170119%2F" target="_blank" rel="noopener">阿里巴巴分布式数据库服务DRDS研发历程</a></p><p>[7] <a href="https://help.aliyun.com/product/29657.html?spm=a2c4g.11186623.6.540.43ee6b20kxutaK" target="_blank" rel="noopener">阿里的分布式数据库DRDS</a></p><p>[8] <a href="https://juejin.im/post/5992b2f8f265da3e185eb75d" target="_blank" rel="noopener">贝聊通过DRDS实现亿级数据库分库分表实践</a></p><p>[9] <a href="http://blog.720ui.com/2017/mysql_core_08_multi_db_table/" target="_blank" rel="noopener">分库与分表设计</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、分库与分表是为了解决什么问题（目的）&quot;&gt;&lt;a href=&quot;#一、分库与分表是为了解决什么问题（目的）&quot; class=&quot;headerlink&quot; title=&quot;一、分库与分表是为了解决什么问题（目的）&quot;&gt;&lt;/a&gt;一、分库与分表是为了解决什么问题（目的）&lt;/h2&gt;&lt;p&gt;随着业务的增长，表数据的增加，查询一次所消耗的时间会变得越来越长，甚至会造成数据库的单点压力。当数据库已经成为系统性能的瓶颈，这时，通过分库分表，可以减小数据库的单库单表负担，提高查询性能，缩短查询时间，从而提升系统的响应速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RDBMS" scheme="https://crazyfzw.github.io/categories/RDBMS/"/>
    
    
      <category term="RDBMS" scheme="https://crazyfzw.github.io/tags/RDBMS/"/>
    
      <category term="分库分表" scheme="https://crazyfzw.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据存储 2：分布式系统全局唯一ID生成方案</title>
    <link href="https://crazyfzw.github.io/2018/07/21/unique-id-generate/"/>
    <id>https://crazyfzw.github.io/2018/07/21/unique-id-generate/</id>
    <published>2018-07-20T16:32:50.000Z</published>
    <updated>2021-01-02T07:53:56.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近在 ifeve.com 看到这么一个面试题 “<a href="http://ifeve.com/question/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%9C%89%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%B2%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%8C%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82/" target="_blank" rel="noopener">京东面试题 – 有一个生成唯一串的需求，并发请求量非常大，该如何实现？</a>”。在现实开发中，这也是必须要考虑到的一个点。比如分库分表后主键采用什么策略生成？在分布式系统中如何生成唯一ID标识？</p><a id="more"></a><p>从业务上来说，常见的如订单号，支付单号等，都需要唯一 ID 做标识，简单的数据库递增是不能满足的，因为这样既会显得不专业，也会不安全，比如你的竞争对手可以今天中午12点下个单记录下订单号，明天中午12点再下个单，通过对比2个订单号大概计算出你们的订单量，这是非常可怕的事情。</p><p><strong>那么，业务系统对ID号有哪些要求呢？</strong></p><ol><li><p>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p></li><li><p>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，是用B+tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。针对这点，后面根据索引原理展开讲一下。</p></li><li><p>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</p></li><li><p>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p></li></ol><p><strong>这里结合索引原理展开讲下为什么ID需要趋势递增</strong><br>InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用选用趋势递增的ID作为主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。如下图所示：</p><p><img src="/images/2018072401.png" alt=""></p><p>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。否则，如使用身份证号或学号等无序的数作为主键，则每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动大量数据，从而降低写入数据的性能。如下图所示：</p><p><img src="/images/2018072402.png" alt=""></p><h2 id="二、Twitter的snowflake方案"><a href="#二、Twitter的snowflake方案" class="headerlink" title="二、Twitter的snowflake方案"></a>二、Twitter的snowflake方案</h2><p>snowflake 是 Twitter 开源的分布式ID生成算法，是一种划分命名空间来生成ID的一种算法，结果是一个long型的ID。其核心思想是：把64-bit分别划分成多段。如下图所示：<br><img src="/images/2018072301.png" alt=""></p><p>其中，41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给数据中心(IDC)，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p><p>这种方式的优缺点是：</p><p><strong>优点：</strong></p><ul><li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li><li>可以根据自身业务特性分配bit位，非常灵活。</li></ul><p><strong>缺点：</strong></p><p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p><p>具体实现的代码可以参看：<a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">https://github.com/twitter/snowflake</a>，遗憾的是 snowflake 已经不再维护，但是还是可以下载  snowflake-2010 tag , 下载的版本是用 scala 实现的。我们可以根据思想，自己用java语言实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==============================Fields===========================================</span></span><br><span class="line">    <span class="comment">/** 开始时间截 (2010/11/4 9:42:54) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdFactory</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Test=============================================</span></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IdFactory idFactory = <span class="keyword">new</span> IdFactory(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//传入工作ID (0~31),数据中心ID (0~31)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idFactory.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、Flicker-团队的数据库生成方案"><a href="#三、Flicker-团队的数据库生成方案" class="headerlink" title="三、Flicker 团队的数据库生成方案"></a>三、Flicker 团队的数据库生成方案</h2><p>在分布式系统中，为了解决单点故障问题、单点IO性能问题，在分布式系统中，我们的数据库服务器往往也不只一台，那么在多台数据库服务器的情况下如何生成符合要求的ID呢？Flickr团队在2010年撰文介绍的一种主键生成策略(<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>)。这种方案的思想是给不同的机器设置不同的初始值，相同的步长。</p><p>比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 2</span><br></pre></td></tr></table></figure><p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p><p><img src="/images/2018072302.png" alt=""></p><p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p><ul><li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。机器多的时候要扩容十分复杂。</li><li>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li><li>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li></ul><h2 id="四、美团的Leaf-segment数据库方案"><a href="#四、美团的Leaf-segment数据库方案" class="headerlink" title="四、美团的Leaf-segment数据库方案"></a>四、美团的Leaf-segment数据库方案</h2><p>Leaf-segment 在使用数据库的方案上做了优化，利用proxy server批量获取，每次获取一段IDs(step决定大小)，然后把这段IDs作为id池缓存起来使用。用完之后再去数据库获取新的号段，从而大大的减轻数据库的压力。解决了原方案每次获取ID都得读写一次数据库，造成数据库压力大的问题。Leaf-segment的总体架构如下：</p><p><img src="/images/2018072303.png" alt=""></p><p>这种模式有以下优缺点：</p><p><strong>优点：</strong></p><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><p><strong>缺点：</strong></p><ul><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li><li>DB宕机会造成整个系统不可用。</li></ul><p>Leaf-segment 后2点缺点，Leaf-segment做了双buffer优化，以及“一主两从”的高可用容灾。</p><h2 id="五、美团的Leaf-snowflake方案"><a href="#五、美团的Leaf-snowflake方案" class="headerlink" title="五、美团的Leaf-snowflake方案"></a>五、美团的Leaf-snowflake方案</h2><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID等生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是非常可怕的。针对这一问题，美团点评提供了 Leaf-snowflake 方案，用于满足对这种安全性有要求的场景。</p><p><img src="/images/2018072304.png" alt=""></p><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。相比 snowflake，Leaf-snowflake做了以下2点优化：</p><ol><li>使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID，一定程度的提高系统的伸缩性和容错性。</li><li>解决时钟回拨会可能导致生成重复的ID号的问题。</li></ol><p>Leaf-snowflake 的架构图如下：</p><p><img src="/images/2018072305.png" alt=""></p><p><strong>Leaf-snowflake是按照下面几个步骤启动的：</strong></p><ol><li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li><li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li><li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li></ol><h2 id="六、微信的序列号生成器seqsvr"><a href="#六、微信的序列号生成器seqsvr" class="headerlink" title="六、微信的序列号生成器seqsvr"></a>六、微信的序列号生成器seqsvr</h2><p>seqsvr 是微信的一个高可用、高可靠的序列号生成器，利用生成的序列号，实现终端与后台的数据增量同步机制。这套同步机制仍然在消息收发、朋友圈通知、好友数据更新等需要数据同步的地方发挥着核心的作用。seqsvr的架构可以分为两层，即StoreSvr和AllocSvr（存储层和缓存中间层）。</p><p>架构图如下：</p><p><img src="/images/2018072306.png" alt=""></p><p>seqsvr 的设计考虑有其殊性，比如按用户id进行切分。但是其实现还有一些容灾设计事非常值得参考的。</p><p>具体细节及演进过程可看 <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/</a></p><h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>[1] <a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter snowflake</a></p><p>[2] <a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a></p><p>[3] <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">微信序列号生成器架构设计及演变</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;最近在 ifeve.com 看到这么一个面试题 “&lt;a href=&quot;http://ifeve.com/question/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%9C%89%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%B2%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%8C%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;京东面试题 – 有一个生成唯一串的需求，并发请求量非常大，该如何实现？&lt;/a&gt;”。在现实开发中，这也是必须要考虑到的一个点。比如分库分表后主键采用什么策略生成？在分布式系统中如何生成唯一ID标识？&lt;/p&gt;
    
    </summary>
    
    
      <category term="RDBMS" scheme="https://crazyfzw.github.io/categories/RDBMS/"/>
    
    
      <category term="唯一ID" scheme="https://crazyfzw.github.io/tags/%E5%94%AF%E4%B8%80ID/"/>
    
  </entry>
  
  <entry>
    <title>数据存储 1：数据库索引的原理及使用策略</title>
    <link href="https://crazyfzw.github.io/2018/07/18/RDBMS-INDEX/"/>
    <id>https://crazyfzw.github.io/2018/07/18/RDBMS-INDEX/</id>
    <published>2018-07-18T13:05:05.000Z</published>
    <updated>2021-01-02T07:53:51.032Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时最经常用到的索引。</p><a id="more"></a><h2 id="一、数据库索引的原理"><a href="#一、数据库索引的原理" class="headerlink" title="一、数据库索引的原理"></a>一、数据库索引的原理</h2><blockquote><p>这部分内容主要来源于互联网上关于索引的主流文章，本人在理解的基础上梳理整合成本部分内容，当是个人的一篇学习笔记，参考的文章可见参考文献一栏。</p></blockquote><h3 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助数据库高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>说白了，索引就是一种可以应用高效查询算法的数据结构。</p><p>之所以要建立索引，其实就是为了构建一种数据结构，然后可以在上面应用一种高效的查询算法，最终提高数据的查询速度。</p><p>所以在讲索引的数据结构之前不妨先了解下比较常见的查询算法及其所要求的特定数据结构。</p><h3 id="2-常见的查询算法"><a href="#2-常见的查询算法" class="headerlink" title="2. 常见的查询算法"></a>2. 常见的查询算法</h3><h4 id="2-1-顺序查找（linear-search-）"><a href="#2-1-顺序查找（linear-search-）" class="headerlink" title="2.1 顺序查找（linear search ）"></a>2.1 顺序查找（linear search ）</h4><p>最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量大时效率极低。 </p><p>数据结构：有序或无序队列 </p><p>复杂度：O(n) </p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-二分查找（binary-search）"><a href="#2-2-二分查找（binary-search）" class="headerlink" title="2.2 二分查找（binary search）"></a>2.2 二分查找（binary search）</h4><p>比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 </p><p>数据结构：有序数组 </p><p>复杂度：O(logn) </p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-二叉排序树查找"><a href="#2-3-二叉排序树查找" class="headerlink" title="2.3 二叉排序树查找"></a>2.3 二叉排序树查找</h4><p>二叉排序树的特点是：</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>它的左、右子树也分别为二叉排序树。</p><p>搜索的原理：</p><p>若b是空树，则搜索失败，否则;</p><p>若x等于b的根节点的数据域之值，则查找成功；否则：</p><p>若x小于b的根节点的数据域之值，则搜索左子树；否则：</p><p>查找右子树。</p><p>数据结构：二叉排序树 </p><p>时间复杂度： O(log2N)</p><h4 id="2-4-索引是为了应用某种高级查找算法而建立的一种数据结构："><a href="#2-4-索引是为了应用某种高级查找算法而建立的一种数据结构：" class="headerlink" title="2.4 索引是为了应用某种高级查找算法而建立的一种数据结构："></a>2.4 索引是为了应用某种高级查找算法而建立的一种数据结构：</h4><p>稍微分析以上查找算法会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上。但是数据库存储的数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h3 id="3-多叉平衡查找树（B-tree-和-B-Tree）"><a href="#3-多叉平衡查找树（B-tree-和-B-Tree）" class="headerlink" title="3. 多叉平衡查找树（B-tree 和 B+Tree）"></a>3. 多叉平衡查找树（B-tree 和 B+Tree）</h3><p>上面讲到了二叉树，它的搜索时间复杂度为O(log2N)，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p><h4 id="3-1-B-Tree"><a href="#3-1-B-Tree" class="headerlink" title="3.1 B-Tree"></a>3.1 B-Tree</h4><blockquote><p>具体讲解之前，有一点，再次强调下：B-树，也就是B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解，有人可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree指的就是B树。特此说明。</p></blockquote><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。</p><p>下图是一个B-Tree示例：</p><p><img src="/images/2018071801.png" alt="image"></p><p>那么B-Tree是满足下列条件的数据结构：</p><p>d为大于1的一个正整数，称为B-Tree的度。</p><p>h为一个正整数，称为B-Tree的高度。</p><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p><p>所有叶节点具有相同的深度，等于树高h。</p><p>key和指针互相间隔，节点两端是指针。</p><p>一个节点中的key从左到右非递减排列。</p><p>所有节点组成树结构。</p><p>每个指针要么为null，要么指向另外一个节点。</p><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">     <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     foreach(node.key)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">  &#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，这也是索引会降低增删改数据性能的原因。</p><h4 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B+Tree"></a>3.2 B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><p>每个节点的指针上限为2d而不是2d+1。</p><p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而 B 树的叶子节点并没有包括全部需要查找的信息)</p><p>内节点不存储data，只存储key；叶子节点不存储指针。所有的内节点点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的内节点也包含需要查找的有效信息)</p><p>下图是一个简单的B+Tree示意</p><p><img src="/images/2018071802.png" alt="image"></p><h3 id="4-为什么索引用B-Tree实现"><a href="#4-为什么索引用B-Tree实现" class="headerlink" title="4. 为什么索引用B+Tree实现"></a>4. 为什么索引用B+Tree实现</h3><p>这里必须强调的是，数据库索引实际上用的是带有顺序的B+Tree。在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 </p><p>如下图所示：</p><p><img src="/images/2018071803.png" alt="image"></p><p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能。如图如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h4 id="4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？"><a href="#4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？" class="headerlink" title="4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？"></a>4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？</h4><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><h4 id="4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？"><a href="#4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？" class="headerlink" title="4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？"></a>4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？</h4><p>B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmax&#x3D;floor(pagesize&#x2F;(keysize+datasize+pointsize))</span><br></pre></td></tr></table></figure><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p>因为B+Tree 的内节点只存储只存储key，不存储Data，所以出度越大，索引性能越好。</p><h3 id="5-B-Tree-的查找过程"><a href="#5-B-Tree-的查找过程" class="headerlink" title="5. B+Tree 的查找过程"></a>5. B+Tree 的查找过程</h3><p>B-树和B+树查找过程基本一致。</p><p>下面以 B+Tree 树的数据结构举例说下查找过程：</p><p><img src="/images/20180718.jpg" alt="image"></p><p>如上图 B + Tree 的数据结构。是由一个一个的磁盘块组成的树形结构，每个磁盘块由数据项和指针组成。所有的数据都是存放在叶子节点，非叶子节点不存放数据。</p><p><strong>查找过程：</strong><br>以磁盘块1为例，指针 P1 表示小于17的磁盘块，P2 表示在 17~35 之间的磁盘块，P3 则表示大于35的磁盘块。</p><p>比如要查找数据项99，首先将磁盘块1 load 到内存中，发生 1 次 IO。接着通过二分查找发现 99 大于 35，所以找到了 P3 指针。通过P3 指针发生第二次 IO 将磁盘块4加载到内存。再通过二分查找发现大于87，通过 P3 指针发生了第三次 IO 将磁盘块11 加载到内存。最后再通过一次二分查找找到了数据项99。</p><p>由此可见，如果一个几百万的数据查询只需要进行三次 IO 即可找到数据，那么整个效率将是非常高的。</p><p>观察树的结构，发现查询需要经历几次 IO 是由树的高度来决定的，而树的高度又由磁盘块，数据项的大小决定的。</p><p>磁盘块越大，数据项越小那么数的高度就越低。这也就是为什么索引字段要尽可能小的原因。</p><h3 id="6-MySQL索引实现"><a href="#6-MySQL索引实现" class="headerlink" title="6. MySQL索引实现"></a>6. MySQL索引实现</h3><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h4 id="6-1-MyISAM索引实现"><a href="#6-1-MyISAM索引实现" class="headerlink" title="6.1 MyISAM索引实现"></a>6.1 MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，这种索引方式称称为“非聚集索引”。</p><p>下图是MyISAM索引的原理图：</p><p><img src="/images/2018071804.png" alt="image"></p><p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="/images/2018071805.png" alt="image"></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="6-2-InnoDB索引实现"><a href="#6-2-InnoDB索引实现" class="headerlink" title="6.2 InnoDB索引实现"></a>6.2 InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。键值的逻辑顺序决定了表中相应行的物理顺序，这种索引方式称称为“聚集索引”。</p><p>如下图所示：<br><img src="/images/2018071806.png" alt="image"></p><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="/images/2018071807.png" alt="image"></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><h3 id="7-聚集索引与非聚集索引的区别"><a href="#7-聚集索引与非聚集索引的区别" class="headerlink" title="7. 聚集索引与非聚集索引的区别"></a>7. 聚集索引与非聚集索引的区别</h3><p>前面已经通过MySQL索引实现中已经讲到InnoDB索引实现用的是“聚集索引”，而MyISAM索引实现的实现用的是“非聚集索引”，那么 聚集索引与非聚集索引到底有什么区别呢？</p><p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</strong></p><h4 id="7-1-聚集索引"><a href="#7-1-聚集索引" class="headerlink" title="7.1 聚集索引"></a>7.1 聚集索引</h4><p>聚集索引表记录的排列顺序与索引的排列顺序一致</p><p><strong>优点：</strong>查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。</p><p><strong>缺点：</strong>对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，从而降低了执行速度。</p><h4 id="7-2-非聚集索引"><a href="#7-2-非聚集索引" class="headerlink" title="7.2 非聚集索引"></a>7.2 非聚集索引</h4><p>叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p><p><strong>优点：</strong>对数据更新影响较小。</p><p><strong>缺点：</strong>聚集索引检索效率比聚集索引低,必须先查到查到每一项数据对应的页码，然后再根据页码查到具体内容。</p><h4 id="7-3-如何选择使用聚集索引或非聚集索引（很重要）："><a href="#7-3-如何选择使用聚集索引或非聚集索引（很重要）：" class="headerlink" title="7.3 如何选择使用聚集索引或非聚集索引（很重要）："></a>7.3 如何选择使用聚集索引或非聚集索引（很重要）：</h4><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>应</td><td>应</td></tr><tr><td>返回某范围内的数据</td><td>应</td><td>不应</td></tr><tr><td>一个或极少不同值</td><td>不应</td><td>不应</td></tr><tr><td>小数目的不同值</td><td>应</td><td>不应</td></tr><tr><td>大数目的不同值</td><td>不应</td><td>应</td></tr><tr><td>频繁更新的列</td><td>不应</td><td>应</td></tr><tr><td>外键列</td><td>应</td><td>应</td></tr><tr><td>主键列</td><td>应</td><td>应</td></tr><tr><td>频繁修改索引列</td><td>不应</td><td>应</td></tr></tbody></table><h2 id="二、如何设计索引"><a href="#二、如何设计索引" class="headerlink" title="二、如何设计索引"></a>二、如何设计索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，数据库在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p><h3 id="1-一般两种情况下不建议建索引："><a href="#1-一般两种情况下不建议建索引：" class="headerlink" title="1. 一般两种情况下不建议建索引："></a>1. 一般两种情况下不建议建索引：</h3><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index Selectivity &#x3D; 字段对应不重复的值 &#x2F; 表总记录数</span><br></pre></td></tr></table></figure><p>显然选择性的取值范围为(0, 1]，值越大，即选择性越高的索引价值越大，这是由B+Tree的性质决定的。</p><p>例如，可以应用求一个字段的Selectivity，判断是否有必要给这个这个字段加索引，以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0000 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><h3 id="2-设计索引一般需要考虑以下3点："><a href="#2-设计索引一般需要考虑以下3点：" class="headerlink" title="2. 设计索引一般需要考虑以下3点："></a>2. 设计索引一般需要考虑以下3点：</h3><ol><li>看数据量，根据记录数，看是否有建索引的必要；</li><li>根据计算字段的索引选择性判断给某个字段加索引是否比较有价值；</li><li>看能否使用前缀索引取代全列索引，综合考虑索引选择性与key的长度，做个折中，尽可能使得前缀索引的选择性接近全列索引，同时又减段索引key的长度，从而减少了索引文件的大小和维护开销。</li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引建上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Table1</span><br><span class="line">ADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br></pre></td></tr></table></figure><p>性能的提升是显著的，查询速度提高了120多倍。</p><p>有一点需要注意的是：前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><h2 id="三、索引使用的注意事项-策略及优化"><a href="#三、索引使用的注意事项-策略及优化" class="headerlink" title="三、索引使用的注意事项(策略及优化)"></a>三、索引使用的注意事项(策略及优化)</h2><p>并不是建立索引就能显著提高查询速度，在索引的使用过程中，存在一些使用细节和注意事项，因为稍不留心，就可能导致在查询过程中索引失效。</p><p>一下列举一些需要注意的事项：</p><h3 id="1-不要在列上使用函数"><a href="#1-不要在列上使用函数" class="headerlink" title="1. 不要在列上使用函数"></a>1. 不要在列上使用函数</h3><p>不要在列上使用函数，这将导致索引失效而进行全表扫描。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where year(publish_time) &lt; 2018</span><br></pre></td></tr></table></figure><p>应改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where publish_time &lt; &#39;2018-01-01&#39;</span><br></pre></td></tr></table></figure><h3 id="2-不要在列上进行计算"><a href="#2-不要在列上进行计算" class="headerlink" title="2. 不要在列上进行计算"></a>2. 不要在列上进行计算</h3><p>不要在列上进行运算，这也将导致索引失效而进行全表扫描。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id &#x2F; 100 &#x3D; 1</span><br></pre></td></tr></table></figure><p>应改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id &#x3D; 1 * 100</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免使用-或-not-in或-lt-gt-等否定操作符"><a href="#3-尽量避免使用-或-not-in或-lt-gt-等否定操作符" class="headerlink" title="3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符"></a>3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</h3><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt;操作符，<br>这些负向查询也会导致索引失效而进行全表扫描。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where id not in (1,3,4);</span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where id in (2,5,6);</span><br></pre></td></tr></table></figure><h3 id="4-尽量避免使用-or-来连接条件"><a href="#4-尽量避免使用-or-来连接条件" class="headerlink" title="4. 尽量避免使用 or 来连接条件"></a>4. 尽量避免使用 or 来连接条件</h3><p>应该尽量避免在 where 子句中使用 or来连接条件，因为这会导致索引失效而进行全表扫描。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id&#x3D; 1 or id &#x3D;2</span><br></pre></td></tr></table></figure><p>应改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id in(1,2)</span><br></pre></td></tr></table></figure><h3 id="5-字段的默认值不要为-null"><a href="#5-字段的默认值不要为-null" class="headerlink" title="5. 字段的默认值不要为 null"></a>5. 字段的默认值不要为 null</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。</p><p>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p><h3 id="6-不要让数据库帮我们做隐式类型转换"><a href="#6-不要让数据库帮我们做隐式类型转换" class="headerlink" title="6. 不要让数据库帮我们做隐式类型转换"></a>6. 不要让数据库帮我们做隐式类型转换</h3><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where telno&#x3D;1888888888</span><br></pre></td></tr></table></figure><p>这样虽然可以查出数据，但是会导致全表扫描。</p><p>应改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where telno&#x3D;&#39;1888888888&#39;</span><br></pre></td></tr></table></figure><h3 id="7-前导模糊查询会导致索引失效"><a href="#7-前导模糊查询会导致索引失效" class="headerlink" title="7. 前导模糊查询会导致索引失效"></a>7. 前导模糊查询会导致索引失效</h3><p>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。</p><h3 id="8-数据区分不明显的不建议创建索引"><a href="#8-数据区分不明显的不建议创建索引" class="headerlink" title="8. 数据区分不明显的不建议创建索引"></a>8. 数据区分不明显的不建议创建索引</h3><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段</p><h3 id="9-可以用复合索引替代多个单列索引"><a href="#9-可以用复合索引替代多个单列索引" class="headerlink" title="9. 可以用复合索引替代多个单列索引"></a>9. 可以用复合索引替代多个单列索引</h3><p>MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。</p><p>假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：</p><p>select * from news where news_year = 2017 and news_month = 1<br>事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。</p><h3 id="10-覆盖索引的好处"><a href="#10-覆盖索引的好处" class="headerlink" title="10. 覆盖索引的好处"></a>10. 覆盖索引的好处</h3><p>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p><h3 id="11-范围查询对多列查询的影响"><a href="#11-范围查询对多列查询的影响" class="headerlink" title="11. 范围查询对多列查询的影响"></a>11. 范围查询对多列查询的影响</h3><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</p><p>举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：</p><p>select * from news where publish_time &gt;= ‘2017-01-02’ and publish_time &lt;= ‘2017-01-08’ and enable = 1<br>这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。</p><p>对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。</p><p>例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where news_weekth &#x3D; 1 and enable &#x3D; 1</span><br></pre></td></tr></table></figure><p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。</p><h3 id="12-复合索引（联合索引）"><a href="#12-复合索引（联合索引）" class="headerlink" title="12. 复合索引（联合索引）"></a>12. 复合索引（联合索引）</h3><p>首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：</p><p>第一个字段一定是有序的<br>当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>4</td><td>2</td></tr><tr><td>1</td><td>1</td><td>4</td></tr><tr><td>2</td><td>3</td><td>5</td></tr><tr><td>2</td><td>4</td><td>4</td></tr><tr><td>2</td><td>4</td><td>6</td></tr><tr><td>2</td><td>5</td><td>5</td></tr></tbody></table><p>其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。</p><h3 id="13-复合索引的最左前缀原理"><a href="#13-复合索引的最左前缀原理" class="headerlink" title="13. 复合索引的最左前缀原理"></a>13. 复合索引的最左前缀原理</h3><p>在复合索引的基础上，再来详细介绍一下联合索引的查询。还是复合索引中的例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：</p><p>以下的查询方式都可以用到索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a&#x3D;1；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</span><br></pre></td></tr></table></figure><p>上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。</p><p>如果查询语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a&#x3D;1 and c&#x3D;3； 那么只会用到索引a。</span><br></pre></td></tr></table></figure><p>如果查询语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and c&#x3D;3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。</span><br></pre></td></tr></table></figure><p>如果用到了最左前缀，但是顺序颠倒会用到索引吗？</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and a&#x3D;1；</span><br><span class="line">select * from table where b&#x3D;2 and a&#x3D;1 and c&#x3D;3；</span><br></pre></td></tr></table></figure><p>如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。</p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1] MySQL索引背后的数据结构及算法原理 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>[2] 从B树、B+树、B* 树谈到 R树 <a href="https://blog.csdn.net/v_july_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6530142</a><br>[3] 聚集索引和非聚集索引 <a href="https://www.cnblogs.com/aspnethot/articles/1504082.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspnethot/articles/1504082.html</a><br>[4] 你知道数据库索引的工作原理吗？<a href="http://www.ituring.com.cn/article/986" target="_blank" rel="noopener">http://www.ituring.com.cn/article/986</a><br>[5] 如何设计索引 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/" target="_blank" rel="noopener">http://blog.720ui.com/2017/mysql_core_03_how_use_index/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时最经常用到的索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RDBMS" scheme="https://crazyfzw.github.io/categories/RDBMS/"/>
    
    
      <category term="索引" scheme="https://crazyfzw.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="RDBMS" scheme="https://crazyfzw.github.io/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 7 ：JVM监控与调优</title>
    <link href="https://crazyfzw.github.io/2018/07/18/jvm-gc-optimize/"/>
    <id>https://crazyfzw.github.io/2018/07/18/jvm-gc-optimize/</id>
    <published>2018-07-18T03:24:10.000Z</published>
    <updated>2020-12-28T17:02:33.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Java所提倡的自动内存管理最终可以归结为自动的解决两个问题：给对象分配内存以及回收分配给对象的内存，对JVM参数进行合理的设置, 可以提升GC的效率，从而提升系统的性能。</p><a id="more"></a><h2 id="二、JVM监控与性能分析工具"><a href="#二、JVM监控与性能分析工具" class="headerlink" title="二、JVM监控与性能分析工具"></a>二、JVM监控与性能分析工具</h2><p><img src="/images/jvmgctool.png" alt="JVM性能分析工具"></p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p><p>命令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [option] [hostid]</span><br></pre></td></tr></table></figure><p>jps option参数：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID,省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是Jar包，输出Jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时JVM参数</td></tr></tbody></table><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>[option] : 操作参数</li><li>LVMID : 本地虚拟机进程ID</li><li>[interval] : 连续输出的时间间隔</li><li>[count] : 连续输出的次数</li></ul><p>Jstat option参数:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间以及类装载所消耗的时间</td></tr><tr><td>-gc</td><td>监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代GC状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p><p>命令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br></pre></td></tr></table></figure><p>jinfo option 参数:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-flag</td><td>输出指定args参数的值</td></tr><tr><td>-flags</td><td>不需要args参数，输出所有JVM参数的值</td></tr><tr><td>-sysprops</td><td>输出系统属性，等同于System.getProperties()</td></tr></tbody></table><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure><p>jmap option参数:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转储快照。格式为：-dump:[live, ]format=b,file=filename,其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等待Finalizer县城执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br></pre></td></tr></table></figure><p>jstack option 参数：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><h2 id="三、JVM-参数调优"><a href="#三、JVM-参数调优" class="headerlink" title="三、JVM 参数调优"></a>三、JVM 参数调优</h2><p>Java所提倡的自动内存管理最终可以归结为自动的解决两个问题：给对象分配内存以及回收分配给对象的内存，对JVM参数进行合理的设置, 可以提升GC的效率，从而提升系统的性能。</p><h3 id="GC优化的两个目的："><a href="#GC优化的两个目的：" class="headerlink" title="GC优化的两个目的："></a>GC优化的两个目的：</h3><h4 id="将进入老年代的对象数量降到最低"><a href="#将进入老年代的对象数量降到最低" class="headerlink" title="将进入老年代的对象数量降到最低"></a>将进入老年代的对象数量降到最低</h4><p>除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。</p><h4 id="减少Full-GC的执行时间"><a href="#减少Full-GC的执行时间" class="headerlink" title="减少Full GC的执行时间"></a>减少Full GC的执行时间</h4><p>Full GC的执行时间比Young GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。如果通过减小老年代内存来减少Full GC时间，可能会引起OutOfMemoryError或者导致Full GC的频率升高。另外，如果通过增加老年代内存来降低Full GC的频率，Full GC的时间可能因此增加。因此，你需要把老年代的大小设置成一个“合适”的值。</p><h3 id="GC调优的主要参数"><a href="#GC调优的主要参数" class="headerlink" title="GC调优的主要参数"></a>GC调优的主要参数</h3><p>JVM内存各个代的大小，会直接影响 Yong GC 和 Full GC 触发的时机和触发的频率。在代大小的调优上，最关键的参数为：</p><table><thead><tr><th>类型</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>堆内存大小</td><td>-Xms -Xmx</td><td>-Xms是启动JVM时堆内存的大小，-Xmn是堆内存的最大限制。通常设置为相同的值，避免运行时要不断的扩展JVM空间，造成性能上的损失</td></tr><tr><td>新生代空间大小</td><td>-Xmn</td><td>新生代大小 如：-Xmn256m 设置JVM的新生代内存大小（－Xmn 是将NewSize与MaxNewSize设为一致。 256m）</td></tr><tr><td></td><td>-XX:NewRatio</td><td>新生代和老年代的内存比，如:NewRatio等于2，则新生代:老年代=1:2，因此，NewRatio的值设置得越大，则老年代空间越大，新生代空间越小。</td></tr><tr><td></td><td>-XX:SurvivorRatio</td><td>新生代中 Eden区和Survivor区的内存比例，默认为 8</td></tr><tr><td>年龄设置</td><td>-XX:MaxTenuringThreshold</td><td>对象经历多少次 Yong GC 后 进入 Old Space. 默认 15</td></tr></tbody></table><blockquote><p>在进行GC优化时最常用的参数是-Xms,-Xmx和-XX:NewRatio。-Xms和-Xmx参数通常是必须的，所以NewRatio的值将对GC性能产生重要的影响。有些人可能会问如何设置永久代内存大小，你可以用-XX:PermSize和-XX:MaxPermSize参数来设置方法区的大小，但是要记住，只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。</p></blockquote><ol><li><p>避免新生代设置过小</p><ul><li>Yong GC 频率过高，Yong GC 的对象会过早进入老年代，若此时进入老年代的对象大于老年代剩余空间，将会触发 Full GC</li><li>可能导致Yong GC 的对象直接进入老年代，若此时进入老年代的对象大于老年代剩余空间，将会触发 Full GC</li></ul></li><li><p>避免新生代设置过大</p><ul><li>Old Space 变小， Full GC频繁发生</li><li>Yong GC 耗时大幅度增长</li></ul></li><li><p>避免 Survivor区过小/过大</p><ul><li><p>调大 SurvivorRatio 值， 即 Eden 空间变大，Survivor 空间变小， Yong GC 的频率会下降，但如有 Yong GC 后的对象没有被回收且大于 Survivor 空间，则会直接放入 Old Space, 引发 Full GC 的频率提高</p></li><li><p>调小 SurvivorRatio 值， 即 Eden 空间变小， Yong GC 频繁发生。 Survicor 空间变大， 可以存储更多存货的对象，减少直接进入Old Space 的几率</p></li></ul></li><li><p>适当设置新生代对象的存活周期，可充分的回收对象，避免对象进入 Old Space</p></li></ol><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>《深入理解Java虚拟机》 – 周志明 第4章<br><a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">6个JDK命令行工具的使用</a><br><a href="http://www.ityouknow.com/jvm/2017/09/29/How-to-optimize-Java-GC.html" target="_blank" rel="noopener">如何优化 Java GC </a><br><a href="https://cloud.tencent.com/developer/article/1513803" target="_blank" rel="noopener">JVM 内存区域大小参数设置</a><br><a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">Jvm 系列(四):Jvm 调优-命令篇</a><br><a href="http://www.ityouknow.com/jvm/2017/09/19/GC-tuning.html" target="_blank" rel="noopener">Java 服务 GC 参数调优案例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Java所提倡的自动内存管理最终可以归结为自动的解决两个问题：给对象分配内存以及回收分配给对象的内存，对JVM参数进行合理的设置, 可以提升GC的效率，从而提升系统的性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://crazyfzw.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://crazyfzw.github.io/tags/JVM/"/>
    
      <category term="垃圾回收机制" scheme="https://crazyfzw.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
