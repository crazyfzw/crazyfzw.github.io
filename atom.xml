<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Crazyfzw&#39;s blog</title>
  
  <subtitle>Return to base, step by step.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crazyfzw.github.io/"/>
  <updated>2021-02-05T14:43:26.872Z</updated>
  <id>https://crazyfzw.github.io/</id>
  
  <author>
    <name>crazyfzw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解HTTP-笔记Part3-HTTPS 是如何保证安全的</title>
    <link href="https://crazyfzw.github.io/2021/01/15/network-https/"/>
    <id>https://crazyfzw.github.io/2021/01/15/network-https/</id>
    <published>2021-01-15T02:11:23.000Z</published>
    <updated>2021-02-05T14:43:26.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。</p><h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><p>HTTP 主要有这些不足：</p><ul><li>通信使用明文（不加密），内容可能会被窃听 </li><li>不验证通信方的身份，因此有可能遭遇伪装 </li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><a id="more"></a><h3 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h3><p>按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。互联网上的任何角落都存在通信内容被窃听的风险。比如通过一些抓包（Packet Capture）或嗅探器（Sniffer）工具就可以做到。</p><p><img src="/images/https01.jpg" alt="6b37d53e8b2d30b341a56ee540162081.png"></p><p>在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。主要有：</p><ul><li>通信的加密</li><li>内容的加密</li></ul><p><strong>HTTPS使用的是基于通信的加密：</strong><br>HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。</p><p>用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。<br><img src="/images/https02.jpg" alt="f29ebfdcc4eb596df5774c7dec659a55.png"></p><h3 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="headerlink" title="不验证通信方的身份就可能遭遇伪装"></a>不验证通信方的身份就可能遭遇伪装</h3><p>HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服 务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的 返回到实际提出请求的客户端”等类似问题。</p><p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方。</p><p><strong>HTTPS 使用证书认证解决：</strong><br>虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。 SSL不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。</p><p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是 实际存在的。另外，伪造证书从技术角度来说是异常困难的一件 事。所以只要能够确认通信方（服务器或客户端）持有的证书， 即可判断通信方的真实意图。</p><p><img src="/images/https03.jpg" alt="021d2057f281786e9e5daa60bbfec876.png"></p><p>通过使用证书，以证明通信方就是意料中的服务器。这对使用者 个人来讲，也减少了个人信息泄露的危险性。<br>另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。</p><h3 id="无法证明报文完整性，可能已遭篡改"><a href="#无法证明报文完整性，可能已遭篡改" class="headerlink" title="无法证明报文完整性，可能已遭篡改"></a>无法证明报文完整性，可能已遭篡改</h3><p>由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响 应送出之后直到对方接收之前的这段时间内，即使请求或响应的 内容遭到篡改，也没有办法获悉。</p><p>换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请 求 / 响应是前后相同的。</p><p><img src="/images/https04.jpg" alt="b9bbcdb56bcbdd16898d93bcd12b1b01.png"></p><p>下图展示了请求或响应在传输途中，遭攻击者拦截并篡改内容的攻 击称为中间人攻击（Man-in-the-Middle attack，MITM）。<br><img src="/images/https05.jpg" alt="2228ded1cd82921a11fc47a9b28da5b0.png"></p><p>如何防止篡改 ：为了有效防止这些弊端，有必要使用 HTTPS。SSL提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。</p><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP + 加密 + 认证 + 完整性保护 = HTTPS"></a>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h2><h3 id="HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS"><a href="#HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS" class="headerlink" title="HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS"></a>HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</h3><p>如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页 面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。</p><p>另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。 并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。</p><p>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p><p><img src="/images/https06.jpg" alt="d71490900f503bfc915297821faa1b01.png"></p><h3 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h3><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代 替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通 信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL协议这层外壳的 HTTP。</p><p><img src="/images/https07.jpg" alt="3eb49e7dddbff7b67865dc0546ea41e6.png"></p><p>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是 当今世界上应用最为广泛的网络安全技术。</p><h3 id="HTTPS-的混合加密机制"><a href="#HTTPS-的混合加密机制" class="headerlink" title="HTTPS 的混合加密机制"></a>HTTPS 的混合加密机制</h3><h4 id="对称加密的困境（共享密钥加密）"><a href="#对称加密的困境（共享密钥加密）" class="headerlink" title="对称加密的困境（共享密钥加密）"></a>对称加密的困境（共享密钥加密）</h4><p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。<br><img src="/images/https08.jpg" alt="6ac421ed0cc663daed9783ae8d1cf6d3.png"></p><p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能 安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥 就可会落入攻击者之手，同时也就失去了加密的意义。另外还得 设法安全地保管接收到的密钥。</p><p><img src="/images/https09.jpg" alt="b98093c01ae7a6cefe6d6be5472c44a4.png"></p><h4 id="非对称加密（使用两把密钥的公开密钥加密）"><a href="#非对称加密（使用两把密钥的公开密钥加密）" class="headerlink" title="非对称加密（使用两把密钥的公开密钥加密）"></a>非对称加密（使用两把密钥的公开密钥加密）</h4><p>公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。顾名思 义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发 布，任何人都可以获得。</p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进 行加密处理，对方收到被加密的信息后，再使用自己的私有密钥 进行解密。利用这种方式，不需要发送用来解密的私有密钥，也 不必担心密钥被攻击者窃听而盗走。</p><p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难 的，因为解密过程就是在对离散对数进行求值，这并非轻而易举 就能办到。目前的技术来看是不太现实的。</p><p><img src="/images/https10.jpg" alt="947d42482a812114fd923e406313e0a9.png"></p><h4 id="HTTPS-采用混合加密机制"><a href="#HTTPS-采用混合加密机制" class="headerlink" title="HTTPS 采用混合加密机制"></a>HTTPS 采用混合加密机制</h4><p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。</p><p>所以应充分利用两者各自的优势，将多种方法组合起来用于通 信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交 换报文阶段则使用共享密钥加密方式。<br><img src="/images/https11.jpg" alt="ecf567e4ed94c88015b15da12ae1f795.png"></p><h4 id="使用第三方证书证明公开密钥的正确性"><a href="#使用第三方证书证明公开密钥的正确性" class="headerlink" title="使用第三方证书证明公开密钥的正确性"></a>使用第三方证书证明公开密钥的正确性</h4><p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明 公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器 建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原 本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真 正的公开密钥已经被攻击者替换掉了。</p><p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br><img src="/images/https12.jpg" alt="718add0e21ec8d13733c4914cb593217.png"></p><h3 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a>HTTPS 的安全通信机制</h3><p>HTTPS 的通信步骤：</p><p><img src="/images/https13.jpg" alt="bf06e5bab8abb99d51c4467619bf3809.png"></p><p>下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥 证书（服务器证书）建立 HTTPS 通信的整个过程。</p><p><img src="/images/https14.jpg" alt="a4b148ffec2b4e5397c7cee0a45fe254.png"></p><h3 id="HTTPS-存在的两个问题"><a href="#HTTPS-存在的两个问题" class="headerlink" title="HTTPS 存在的两个问题"></a>HTTPS 存在的两个问题</h3><p>HTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度会变慢。SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p><ul><li><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL通信， 因此整体上处理通信量不可避免会增加。</p></li><li><p>另一点是 SSL必须进行加密处理。在服务器和客户端都需要进行 加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地 消耗服务器和客户端的硬件资源，导致负载增强。</p></li></ul><p><img src="/images/https15.jpg" alt="7ec2314eaa63ea695e2d3decbdd88289.png"></p><h3 id="为什么不一直使用-HTTPS"><a href="#为什么不一直使用-HTTPS" class="headerlink" title="为什么不一直使用 HTTPS"></a>为什么不一直使用 HTTPS</h3><p>既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS ？</p><ul><li><p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平 摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息 等敏感数据时，才利用 HTTPS 加密通信。</p></li><li><p>特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们 所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都 进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资 源。</p></li><li><p>除此之外，想要节约购买证书的开销也是原因之一。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认 证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。&lt;/p&gt;
&lt;h2 id=&quot;HTTP-的缺点&quot;&gt;&lt;a href=&quot;#HTTP-的缺点&quot; class=&quot;headerlink&quot; title=&quot;HTTP 的缺点&quot;&gt;&lt;/a&gt;HTTP 的缺点&lt;/h2&gt;&lt;p&gt;HTTP 主要有这些不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听 &lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装 &lt;/li&gt;
&lt;li&gt;无法证明报文的完整性，所以有可能已遭篡改&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-笔记Part2-HTTP协议基础</title>
    <link href="https://crazyfzw.github.io/2021/01/10/network-http/"/>
    <id>https://crazyfzw.github.io/2021/01/10/network-http/</id>
    <published>2021-01-10T12:21:59.000Z</published>
    <updated>2021-02-05T14:42:57.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-1-1-支持的方法"><a href="#HTTP-1-1-支持的方法" class="headerlink" title="HTTP 1.1 支持的方法"></a>HTTP 1.1 支持的方法</h2><p><img src="/images/http01.jpg" alt="6bcbfb290291e747e4fcf6e0815e1169.png"></p><a id="more"></a><h2 id="从HTTP1-0-的短连接-到-HTTP1-1-的长连接的改进"><a href="#从HTTP1-0-的短连接-到-HTTP1-1-的长连接的改进" class="headerlink" title="从HTTP1.0 的短连接 到 HTTP1.1 的长连接的改进"></a>从HTTP1.0 的短连接 到 HTTP1.1 的长连接的改进</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p><img src="/images/http02.jpg" alt="51d56b10fe3dc71ad57f654396b65ab9.png"></p><p><img src="/images/http03.jpg" alt="853aeec78dfd44c1175614da0b358601.png"></p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="/images/http04.jpg" alt="595411c9d411abf2bff6245a0ae67978.png"></p><p>图：持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互</p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。</p><p>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接， 但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客 户端也需要支持持久连接。</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><p><img src="/images/http05.jpg" alt="ba1a756470a99f25c7f433a45d71d8fe.png"></p><h3 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管 理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已 登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次 请求报文中附加参数来管理登录状态。</p><p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。</p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。</p><p><img src="/images/http06.jpg" alt="545faee9fd9d4965197252c0a1d54fa3.png"><br><img src="/images/http07.jpg" alt="ed90b8868b3d92230eeda16aff8a6cd9.png"><br><img src="/images/http08.jpg" alt="cd9931bb7ed9e660a4858dde8d52ea65.png"></p><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文 本。</p><p>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的 空行（CR+LF）来划分。通常，并不一定要有报文主体。</p><p><img src="/images/http09.jpg" alt="5e7517ef6041fb689b2965c220328cf4.png"></p><h3 id="请求报文及响应的报文的结构"><a href="#请求报文及响应的报文的结构" class="headerlink" title="请求报文及响应的报文的结构"></a>请求报文及响应的报文的结构</h3><p><img src="/images/http10.jpg" alt="572bb8e4599687b7be9e9331cb8bea7c.png"></p><p><img src="/images/http11.jpg" alt="990a34bee6ce463370de62e8645fe1ab.png"></p><ul><li>请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。 </li><li>状态行： 包含表明响应结果的状态码，原因短语和 HTTP 版本。 </li><li>首部字段： 包含表示请求和响应的各种条件和属性的各类首部，一般有4种首部：通用首部、请求首部、响应首部和实体首部。</li><li>其他可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。</li></ul><h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多 的 CPU 等资源。</p><h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP 压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。</p><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p><p><img src="/images/http12.jpg" alt="43e129c7d778ac8e8641e0151d9042fb.png"></p><p>常用的内容编码有以下几种：</p><ul><li>gzip（GNU zip） </li><li>compress（UNIX 系统的标准压缩） </li><li>deflate（zlib） </li><li>identity（不进行编码）</li></ul><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前， 浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成 多块，能够让浏览器逐步显示页面。</p><p>这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。</p><p><img src="/images/http13.jpg" alt="d37222e9b2090552c1ce600c6956381d.png"></p><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。</p><p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编 码前的实体主体。 </p><p>HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一 个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢 复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求（Range Request）。对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="/images/http14.jpg" alt="60bacebe3f75e349407ab97f06627fa4.png"></p><h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商（Content Negotiation）。</p><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字 符集、编码方式等作为判断的基准。</p><p><img src="/images/http15.jpg" alt="16bc7cccdf52b0b46b108f703a961e8c.png"></p><p>包含在请求报文中的某些首部字段（如下）就是判断的基准：</p><ul><li>Accept </li><li>Accept-Charset 57</li><li>Accept-Encoding </li><li>Accept-Language </li><li>Content-Language</li></ul><h2 id="响应结果中的-HTTP-状态码"><a href="#响应结果中的-HTTP-状态码" class="headerlink" title="响应结果中的 HTTP 状态码"></a>响应结果中的 HTTP 状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。</p><p><img src="/images/http16.jpg" alt="a75d79c4a178769f59484bd0f5e24e49.png"></p><p>状态码如 200 OK，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。</p><p><img src="/images/http17.jpg" alt="c1b775e6005549323c69de278815da75.png"></p><h2 id="参与HTTP协作的代理、网关、隧道"><a href="#参与HTTP协作的代理、网关、隧道" class="headerlink" title="参与HTTP协作的代理、网关、隧道"></a>参与HTTP协作的代理、网关、隧道</h2><p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发 的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p><ul><li><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时 也接收服务器返回的响应并转发给客户端。</p></li><li><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请 求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客 户端可能都不会察觉，自己的通信目标是一个网关。</p></li><li><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方 通信连接的应用程序。</p></li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务 器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。</p><p><img src="/images/http18.jpg" alt="a5dc9d090d5754ba4caf0559d48da46f.png"></p><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽 的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一 种是是否会修改报文。</p><ul><li><p>缓存代理：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本 （缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获 取资源，而是将之前缓存的资源作为响应返回。</p></li><li><p>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 （Transparent Proxy）。反之，对报文内容进行加工的代理被称为非 透明代理。</p></li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提 供非 HTTP 协议服务。 </p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL语句查询数据。另外，在 Web 购物网站上进行信用卡结算时， 网关可以和信用卡结算系统联动。</p><p>下图为 ：利用网关可以由 HTTP 请求转化为其他协议通信<br><img src="/images/http19.jpg" alt="09053cfafe5a1827864cbe34e9f9e7c4.png"></p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。 </p><p>隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><p><img src="/images/http20.jpg" alt="4c4f74bec17ecdaab64f788bc17f081a.png"></p><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><h3 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存 可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话 说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因 此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处 理相同的请求了。（这样也是 CDN加速的原理）</p><p><img src="/images/http21.jpg" alt="0eff3a6e5576989627e0f7c2df923ce8.png"></p><h3 id="客户端本地的缓存"><a href="#客户端本地的缓存" class="headerlink" title="客户端本地的缓存"></a>客户端本地的缓存</h3><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件 （Temporary Internet File）。</p><p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直 接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务 器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。<br><img src="/images/http22.jpg" alt="0dae39c791cabbd7bf2727424a23bea8.png"></p><h3 id="缓存的有效性"><a href="#缓存的有效性" class="headerlink" title="缓存的有效性"></a>缓存的有效性</h3><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请 求。因为这关系到被缓存资源的有效性问题。</p><p>当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会 演变成返回更新前的“旧”资源了。</p><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源 服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从 源服务器上获取“新”资源。</p><p><img src="/images/http23.jpg" alt="debe1a7d52a77b7cdec54715f908936f.png"></p><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><h3 id="HTTP-报文首部"><a href="#HTTP-报文首部" class="headerlink" title="HTTP 报文首部"></a>HTTP 报文首部</h3><p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客 户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等 部分构成。</p><p><img src="/images/http24.jpg" alt="113d79bdfbb4033e1c51d67a30a3dd41.png"></p><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、 HTTP 首部字段 3 部分构成。</p><p><img src="/images/http25.jpg" alt="c872b7def402b79cc06884520effc6e7.png"></p><h3 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h3><p>HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之 间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首 部字段，它能起到传递额外重要信息的作用。 </p><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的 语言、认证信息等内容。</p><p><img src="/images/http26.jpg" alt="c66887f3345cc9b032aec80caf6cafa2.png"></p><h3 id="HTTP-1-1-首部字段一览"><a href="#HTTP-1-1-首部字段一览" class="headerlink" title="HTTP/1.1 首部字段一览"></a>HTTP/1.1 首部字段一览</h3><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><p><img src="/images/http27.jpg" alt="2c3d0f3d4fa22cb5ee92fd54f08bbed1.png"></p><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><p><img src="/images/http28.jpg" alt="b967c5e5a793a444341d2c66944ab7ae.png"></p><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><p><img src="/images/http29.jpg" alt="f34520980b65f81d3f11dd56b84a60df.png"></p><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><p><img src="/images/http30.jpg" alt="886b39f9c93f116d55dca0a16dd55f90.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-1-1-支持的方法&quot;&gt;&lt;a href=&quot;#HTTP-1-1-支持的方法&quot; class=&quot;headerlink&quot; title=&quot;HTTP 1.1 支持的方法&quot;&gt;&lt;/a&gt;HTTP 1.1 支持的方法&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/http01.jpg&quot; alt=&quot;6bcbfb290291e747e4fcf6e0815e1169.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-笔记Part1-网络基础 TCP/IP协议</title>
    <link href="https://crazyfzw.github.io/2021/01/05/network-tcp-ip/"/>
    <id>https://crazyfzw.github.io/2021/01/05/network-tcp-ip/</id>
    <published>2021-01-05T12:41:58.000Z</published>
    <updated>2021-02-05T14:54:47.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP/IP 的分层管理"></a>TCP/IP 的分层管理</h2><p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分 为以下 5 层：应用层、传输层、网络层和数据链路层、物理层。</p><ul><li><p>应用层决定了向用户提供应用服务时通信的活动。 TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。 HTTP 协议也处于该层。</p></li><li><p>传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。 </p></li><li><p>网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。 </p></li><li><p>数据链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接</p></li><li><p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p></li></ul><p><img src="/images/tcp01.jpg" alt="bc6f6efadbc09277c27adb63c25488b8.png"></p><a id="more"></a><h2 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h2><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。 </p><p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p><p>没有人能够全面掌握互联网中的传输状况，在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，该快递公司的集散中心检查货物的送达地址，明 确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会 判断是否能送到对方的家中。</p><p><img src="/images/tcp02.jpg" alt="5ebcba0b2f3f7c174223302170da1ca9.png"></p><h2 id="负责确保可靠性的TCP协议"><a href="#负责确保可靠性的TCP协议" class="headerlink" title="负责确保可靠性的TCP协议"></a>负责确保可靠性的TCP协议</h2><p>TCP 位于传输层，提供可靠的字节流服务。字节流服务（Byte Stream Service）是指，为了方便传输，将大 块数据分割成以报文段（segment）为单位的数据包进行管理。而可 靠的传输服务是指，能够把数据准确可靠地传给对方。一句话总结， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 （three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</p><p>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。 </p><p>1.发送端首先发送一个带 SYN 标志的数据包给对方。<br>2.接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。<br>3.最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。</p><p><img src="/images/tcp03.jpg" alt="3cd443ef2c1f09292c76c6e80a55b5bf.png"></p><p><img src="/images/tcp04.jpg" alt="432cfe300a67ad6815466d20b82dd679.png"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="第2次握手传回了ACK，为什么还要传回SYN？"><a href="#第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN？"></a>第2次握手传回了ACK，为什么还要传回SYN？</h4><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/tcp05.jpg" alt="8835c4a98822d6be00f8a3b715266010.png"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><p>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送<br>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1<br>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><blockquote><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p></blockquote><h3 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP,UDP 协议的区别"></a>TCP,UDP 协议的区别</h3><p><img src="/images/tcp06.jpg" alt="0f8383d9096e716fc902f387f9b68340.jpeg"></p><ul><li><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p></li><li><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p></li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li>拥塞控制： 当网络拥塞时，减少数据的发送。</li><li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h2 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h2><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的 协议。它提供域名到 IP 地址之间的解析服务。</p><p>域名比较符合人类的记忆习惯，但是计算机擅长的事处理一长串数字，为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。<br><img src="/images/tcp07.jpg" alt="cafb08dffe4bb76605f978a0c24c4591.png"></p><h2 id="浏览器发起一次HTTP请求的过程"><a href="#浏览器发起一次HTTP请求的过程" class="headerlink" title="浏览器发起一次HTTP请求的过程"></a>浏览器发起一次HTTP请求的过程</h2><p>HTTP 协议密不可分的 TCP/IP 协议族中的各种协议后，我 们再通过这张图来了解下 IP 协议、TCP 协议和 DNS 服务在使用 HTTP 协议的通信过程中各自发挥了哪些作用。<br><img src="/images/tcp08.jpg" alt="ff02ba4adb98a2f775f2fb5df65027da.png"></p><p>总体来说分为以下几个过程:<br>DNS解析<br>TCP连接<br>发送HTTP请求<br>服务器处理请求并返回HTTP报文<br>浏览器解析渲染页面<br>连接结束</p><p><img src="/images/tcp09.jpg" alt="9f64eefe063fd9172e4c058ad5526bea.jpeg"></p><h2 id="URI-和-URL-的区别"><a href="#URI-和-URL-的区别" class="headerlink" title="URI 和 URL 的区别"></a>URI 和 URL 的区别</h2><p>URL是 URI 的子集：</p><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>种 URI 例子：<br><img src="/images/tcp10.jpg" alt="91d7701617707c06cedb99fab37c10dc.png"></p><p><img src="/images/tcp11.jpg" alt="01cba208c2949959a49cad40e5d636e4.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a><br><a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">计算机网络基础</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP-的分层管理&quot;&gt;&lt;a href=&quot;#TCP-IP-的分层管理&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 的分层管理&quot;&gt;&lt;/a&gt;TCP/IP 的分层管理&lt;/h2&gt;&lt;p&gt;TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分 为以下 5 层：应用层、传输层、网络层和数据链路层、物理层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;应用层决定了向用户提供应用服务时通信的活动。 TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。 HTTP 协议也处于该层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/tcp01.jpg&quot; alt=&quot;bc6f6efadbc09277c27adb63c25488b8.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://crazyfzw.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-ReentrantLock</title>
    <link href="https://crazyfzw.github.io/2020/12/10/reentrantLock/"/>
    <id>https://crazyfzw.github.io/2020/12/10/reentrantLock/</id>
    <published>2020-12-10T12:41:58.000Z</published>
    <updated>2021-01-23T09:12:42.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全的实现方法概述"><a href="#线程安全的实现方法概述" class="headerlink" title="线程安全的实现方法概述"></a>线程安全的实现方法概述</h2><p>线程安全的实现方法，可以分为 阻塞同步，非阻塞同步，无同步方案三大类：</p><p><img src="/images/reen01.jpg" alt="58567e99523dabb30de128bae6916038.png"></p><p>其中阻塞同步最基本的两个实现手段就是通过 synchronized 或 ReentrantLock 关键字。这篇文章主要记录下 RentrantLock 的源码实现。</p><p>ReentrantLock 是基于 抽象类 AbstractQueuedSynchronizer 实现的，AQS内部使用了一个volatile的变量state 来作为资源的标识，并提供了一些模版方法，ReentrantLock 通过实现 AQS 的 tryAcquire 实现获取锁的逻辑。</p><a id="more"></a><h2 id="ReentrantLock-的锁类型"><a href="#ReentrantLock-的锁类型" class="headerlink" title="ReentrantLock 的锁类型"></a>ReentrantLock 的锁类型</h2><p>ReentrantLock 分为公平锁和非公平锁，可以通过构造方法来指定具体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-使用示例模版"><a href="#ReentrantLock-使用示例模版" class="headerlink" title="ReentrantLock 使用示例模版"></a>ReentrantLock 使用示例模版</h2><p>通常的使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do bussiness</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock-的源码实现"><a href="#ReentrantLock-的源码实现" class="headerlink" title="ReentrantLock 的源码实现"></a>ReentrantLock 的源码实现</h2><h3 id="公平锁的实现"><a href="#公平锁的实现" class="headerlink" title="公平锁的实现"></a>公平锁的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ReentrantLock 的lock 方法，其实是通过调用 AQS 提供的模版方法 acquire 来获取独占锁的。</p><p>AbstractQueuedSynchronizer 的模版方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过  中的 acquire() 获取独占资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试获取锁的细节，留给子类去实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>ReentrantLock 的 tryAcquire实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//判断 AQS 中的 state 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果AQS的队列中没有其他线程，则尝试获取锁（公平锁才有判断这个）</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果statc 不等于0，即锁以及被获取了，这里则进行释放重入的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 ReentrantLock 中判断锁是否被获取，是通过 state 来判断的， state =0 则表示目前没有其他线程获得锁，当前线程就可以尝试获取锁；state 大于0 则表示锁已经被占用，则判断占用锁的线程是否就是当前线程，如果是当前线程，则 state +1， 表示重入数 +1。</p><p>注意:尝试之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中是否有其他线程，如果有则不会尝试获取锁(获取公平锁才有这个判断)。</p><p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p><h4 id="获取锁失败则添加到队列中"><a href="#获取锁失败则添加到队列中" class="headerlink" title="获取锁失败则添加到队列中"></a>获取锁失败则添加到队列中</h4><p>如果 tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程包装为一个Node节点写入队列中（AQS 中的双端队列是由 Node 节点组成的双向链表实现的）。其中传入的参数代表要插入的Node是独占式的。</p><p>入队的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成该线程对应的Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将Node插入队列中</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS尝试，如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋CAS插入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先判断队列是否为空，不为空时则将封装好的 Node 利用 CAS 写入队尾，如果出现并发写入失败就需要调用 enq(node); 来写入了。在enq中通过 自旋加上 CAS 来保证写入队列成功。</p><h4 id="挂起等待线程"><a href="#挂起等待线程" class="headerlink" title="挂起等待线程"></a>挂起等待线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记等待过程中是否中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 开始自旋，要么获取锁，要么中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点,双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功，头指针移动到当前node</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会根据 node.predecessor() 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取锁成功后将。node 节点设置成头节点。</p><p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 waitStatus 状态来处理(shouldParkAfterFailedAcquire(p, node))。</p><p>waitStatus 用于记录当前节点的状态，如节点取消、节点等待等。</p><p>shouldParkAfterFailedAcquire(p, node) 返回当前线程是否需要挂起，如果需要则调用 parkAndCheckInterrupt()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非公平锁的实现"><a href="#非公平锁的实现" class="headerlink" title="非公平锁的实现"></a>非公平锁的实现</h3><p>公平锁和非公平锁的主要差异在于实现上：公平锁会先判断队列中是否已经有在排队的线程，如果有则自觉加入到队列尾排队，而非公平锁则不会有此顾忌，非公平锁的实现上是抢占模式的，线程一进来就会先尝试获取锁，不需要考虑先来后到之类的规则。</p><p>非公平锁与公平锁获取的差异：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要一个重要的区别是在尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有 !hasQueuedPredecessors() 判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>公平锁和非公平锁的释放流程都是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 state 减到 0 才认为完全释放锁。释放之后需要调用 unparkSuccessor(h) 来唤醒被挂起的线程。</p><h3 id="公平锁与非公平锁小结"><a href="#公平锁与非公平锁小结" class="headerlink" title="公平锁与非公平锁小结"></a>公平锁与非公平锁小结</h3><p>非公平锁的效率会被公平锁更高。因为公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁的实现上是抢占模式的，线程一进来就会先尝试获取锁，没有先来后到的规则限制。</p><h2 id="ReentrantLock-与-synchronized-的一个对比（怎么选择）"><a href="#ReentrantLock-与-synchronized-的一个对比（怎么选择）" class="headerlink" title="ReentrantLock 与 synchronized 的一个对比（怎么选择）"></a>ReentrantLock 与 synchronized 的一个对比（怎么选择）</h2><p>synchronized 与 ReentrantLock 都是可重入的，但相比于 synchronized，ReentrantLock增加了一些高级的功能，主要有以下三项：等待可中断，可实现公平锁，以及锁可以绑定多个条件。</p><ul><li><p>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以放弃等待，该为处理其他事情，可中断特性对于处理执行时间非常长的同步块很有帮助。</p></li><li><p>公平锁是指多个线程等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁上非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p></li><li><p>锁绑定多个条件是指 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()、notify() 和 notifyAll() 方法只可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则可以通过多次调用 newCondition() 方法实现。</p></li></ul><p><strong>通过互斥同步来实现线程安全时，如果需要用到上述功能，则选用 ReentrantLock。如果不需要上面的功能则选用synchronized。因为性能方面，JDK1.6 发布后，synchronized 与 ReentrantLock 的性能方面已经基本上没什么差异了，并且JVM 更倾向于优化改进更偏向于原生的 synchronized。</strong></p><p>HotSpot 虚拟机团队在 JDK1.6 开始，已对synchronized 进行了多种锁优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、和偏向锁等。这些技术都是为了在线程之间优先以更高效的方式决绝竞争问题，从而提供程序的执行效率。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>《深入理解Java虚拟机》</li><li><a href="https://crossoverjie.top/2018/01/25/ReentrantLock/" target="_blank" rel="noopener">ReentrantLock 实现原理</a></li><li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全的实现方法概述&quot;&gt;&lt;a href=&quot;#线程安全的实现方法概述&quot; class=&quot;headerlink&quot; title=&quot;线程安全的实现方法概述&quot;&gt;&lt;/a&gt;线程安全的实现方法概述&lt;/h2&gt;&lt;p&gt;线程安全的实现方法，可以分为 阻塞同步，非阻塞同步，无同步方案三大类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/reen01.jpg&quot; alt=&quot;58567e99523dabb30de128bae6916038.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中阻塞同步最基本的两个实现手段就是通过 synchronized 或 ReentrantLock 关键字。这篇文章主要记录下 RentrantLock 的源码实现。&lt;/p&gt;
&lt;p&gt;ReentrantLock 是基于 抽象类 AbstractQueuedSynchronizer 实现的，AQS内部使用了一个volatile的变量state 来作为资源的标识，并提供了一些模版方法，ReentrantLock 通过实现 AQS 的 tryAcquire 实现获取锁的逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-ThreadLocal</title>
    <link href="https://crazyfzw.github.io/2020/11/25/threadlocal/"/>
    <id>https://crazyfzw.github.io/2020/11/25/threadlocal/</id>
    <published>2020-11-25T02:42:55.000Z</published>
    <updated>2021-01-14T11:05:23.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal-用来解决什么"><a href="#ThreadLocal-用来解决什么" class="headerlink" title="ThreadLocal 用来解决什么"></a>ThreadLocal 用来解决什么</h2><p>如果一段代码中所需要的数据必须与其他代码共享，并且共享数据的代码能保证在同一个线程中执行，那我们就可以通过ThreadLocal 来把共享数据的可见范围限制在同一个线程之内，这样的好处是，不需要同步也能保证线程之间不出现数据争用问题。</p><p>变量既需要在方法或类之间共享，又期望在线程间隔离的场景，就非常适合使用 ThreadLocal 来实现。</p><a id="more"></a><p>常见场景：</p><ul><li>大部分使用消息队列的模式，如 “生产者-消费者“模式，都会将消息的消费过程尽量在一个线程中消费完，比如在经典Web交互模式中“一个请求对应一个服务器线程”的这种方式</li><li>还有像线程内上线文管理器、数据库连接等可以用到 ThreadLocal</li><li>比如用来存储用户 Session。Session 的特性很适合 ThreadLocal ，因为 Session 之前当前会话周期内有效，会话结束便销毁。如果单纯的理解一个用户的一次会话对应服务端一个独立的处理线程，那用 ThreadLocal 在存储 Session ,简直是再合适不过了。但是例如 tomcat 这类的服务器软件都是采用了线程池技术的，并不是严格意义上的一个会话对应一个线程。并不是说这种情况就不适合 ThreadLocal 了，而是要在每次请求进来时先清理掉之前的 Session ，一般可以用拦截器、过滤器来实现。</li></ul><h2 id="ThreadLocal-的使用案例"><a href="#ThreadLocal-的使用案例" class="headerlink" title="ThreadLocal 的使用案例"></a>ThreadLocal 的使用案例</h2><p>案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadlocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ThreadLocal对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Boolean&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并赋初值 (通过initialValue方法)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; mLocal = ThreadLocal.withInitial(() -&gt; <span class="string">"init value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mThreadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">            mLocal.set(Thread.currentThread().getName() + <span class="string">"A"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"# "</span> + mThreadLocal.get() + <span class="string">"#"</span> + mLocal.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"Thread#1"</span>) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mThreadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">                    mLocal.set(<span class="keyword">this</span>.getName() + <span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"# "</span> + mThreadLocal.get() + <span class="string">"#"</span> + mLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"Thread#2"</span>) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mLocal.set(<span class="keyword">this</span>.getName() + <span class="string">"C"</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"# "</span> + mThreadLocal.get() + mLocal.get());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mThreadLocal.remove();</span><br><span class="line">            mLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/threadlocal01.jpeg" alt="b6196d00cfc59354331d1d8331d24073.png"></p><h2 id="ThreadLocal-的原理"><a href="#ThreadLocal-的原理" class="headerlink" title="ThreadLocal 的原理"></a>ThreadLocal 的原理</h2><p>每一个线程的 Thread 对象中都有一个 自己的 ThreadLocalMap 对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 键值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的threadLocalHashCode 值， 使用这个值就可以在线程 K-V 键值对 中查找对应的本地线程变量。(ThreadLocalMap 由 Thread 维护，从而使得每个Thread 只能访问自己的 Map, 所以不存在数据争用问题)</p><p>ThreadLoal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对ThreadLocal&lt; String &gt;而言即为 String 类型变量），在不同的 Thread 中有不同的副本（实际是不同的实例，后文会详细阐述）。这里有几点需要注意：</p><ul><li>每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题，所以也不需要同步的措施</li></ul><p>下面的图片来源于 <a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">http://www.jasongj.com/java/threadlocal/</a><br><img src="/images/threadlocal02.jpeg" alt="e32f66e757201462c069951ee91ca32d.png"></p><h2 id="ThreadLocal-的源码分析"><a href="#ThreadLocal-的源码分析" class="headerlink" title="ThreadLocal 的源码分析"></a>ThreadLocal 的源码分析</h2><p>ThreadLocal 的主要方法是：get()、set()、remove()</p><h3 id="Thread-与-ThreadLocal-与-ThreadLocalMap-的结构关系"><a href="#Thread-与-ThreadLocal-与-ThreadLocalMap-的结构关系" class="headerlink" title="Thread 与 ThreadLocal  与 ThreadLocalMap 的结构关系"></a>Thread 与 ThreadLocal  与 ThreadLocalMap 的结构关系</h3><p>Thread 内部维护了一个 ThreadLocalMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap是ThreadLocal的一个内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用</span></span><br><span class="line">   <span class="comment">//（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ThreadLocalMap 的初始容量，必须为2的倍数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// resized时候需要的table</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table中的entry个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩容数值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal#set"></a>ThreadLocal#set</h3><p>首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个 ThreadLocalMap 类对应的 get()、set() 方法。例如下面的 set 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">// 根据当前线程的对象获取其内部Map</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="comment">// 注释1</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用 ThreadLocal 的 set 方法时，首先获取到了当前线程，然后获取当前线程维护的 ThreadLocalMap 对象，最后在 ThreadLocalMap 实例中添加上。如果 ThreadLocalMap 实例不存在则初始化并赋初始值。</p><p>这里看到 set 方法的第一个参数是 this ，this即指的是当前的 ThreadLocal 对象，会看上看的代码就是指的 mLocal 这个对象。而在 ThreadLocalMap 的 set 方法中会根据当前 ThreadLocal 对象实例，做一些操作和判断，最终实现赋值操作（具体参考源码）。</p><h3 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal#get"></a>ThreadLocal#get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取Thread对象t</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取t中的map</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以说，<strong>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是一个中间工具，传递了变量值。</strong></p><h2 id="ThreadLocal-使用的时候需要特别的内存泄漏问题"><a href="#ThreadLocal-使用的时候需要特别的内存泄漏问题" class="headerlink" title="ThreadLocal 使用的时候需要特别的内存泄漏问题"></a>ThreadLocal 使用的时候需要特别的内存泄漏问题</h2><h3 id="内存泄漏问题分析"><a href="#内存泄漏问题分析" class="headerlink" title="内存泄漏问题分析"></a>内存泄漏问题分析</h3><p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap 中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ThreadLocalMap 的初始容量，必须为2的倍数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// resized时候需要的table</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table中的entry个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩容数值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。所以在使用完 ThreadLocal 之后一定要手动调用 remove() 方法。不然极有可能会导致内存泄漏。</p><h3 id="典型使用方式："><a href="#典型使用方式：" class="headerlink" title="典型使用方式："></a>典型使用方式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例通常总是以静态字段初始化如下</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结强调"><a href="#总结强调" class="headerlink" title="总结强调"></a>总结强调</h2><ul><li>使用完 ThreadLocal ，最好手动调用 remove() 方法，例如上面说到的 Session 的例子，如果不在拦截器或过滤器中处理，不仅可能出现内存泄漏问题，而且会影响业务逻辑；</li><li>使用 ThreadLocal 的时候，最好要声明为静态的；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">正确理解Thread Local的原理与适用场景</a><br>2.<a href="https://www.cnblogs.com/fengzheng/p/8690253.html" target="_blank" rel="noopener">ThreadLocal 原理和使用场景分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal-用来解决什么&quot;&gt;&lt;a href=&quot;#ThreadLocal-用来解决什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 用来解决什么&quot;&gt;&lt;/a&gt;ThreadLocal 用来解决什么&lt;/h2&gt;&lt;p&gt;如果一段代码中所需要的数据必须与其他代码共享，并且共享数据的代码能保证在同一个线程中执行，那我们就可以通过ThreadLocal 来把共享数据的可见范围限制在同一个线程之内，这样的好处是，不需要同步也能保证线程之间不出现数据争用问题。&lt;/p&gt;
&lt;p&gt;变量既需要在方法或类之间共享，又期望在线程间隔离的场景，就非常适合使用 ThreadLocal 来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-阻塞队列BlockingQueue</title>
    <link href="https://crazyfzw.github.io/2020/11/20/concurrent-blocking-queue/"/>
    <id>https://crazyfzw.github.io/2020/11/20/concurrent-blocking-queue/</id>
    <published>2020-11-20T12:42:55.000Z</published>
    <updated>2021-01-19T03:52:40.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h2><p>在生产者-消费者模式中，为了使生产者消费者解藕，需要一个存放元素的容器，使生产者可以只关心往队列里添加元素下，消费者只关系从队列中取出元素进程处理。</p><p>而且这个队列必须要满足两点：</p><ul><li>线程安全</li><li>缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者</li></ul><p>JDK 为此设计了 阻塞队列(BlockingQueue)，并提供了几个基于 BlockingQueue 接口 实现的一些线程安全的阻塞队列。</p><a id="more"></a><h2 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法:"></a>BlockingQueue的操作方法:</h2><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th>功能分类</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><ul><li><p>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</p></li><li><p>返回特殊值：插入方法会返回是否成功，成功则返回 true。移除方法，则是从队列里拿出一个元素，如果没有则返回 null</p></li><li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到拿到数据，或者- 响应中断退出。当队列空时，消费者线程试图从队列里 take 元素，队列也会阻塞消费者线程，直到队列可用。</p></li><li><p>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</p></li></ul><p>需要特别注意的是：</p><ul><li>不能往阻塞队列中插入null,会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><h2 id="JDK-提供的阻塞队列"><a href="#JDK-提供的阻塞队列" class="headerlink" title="JDK 提供的阻塞队列"></a>JDK 提供的阻塞队列</h2><p>JDK 定义了 BlockingQueue 接口，并在Java util.concurrent 下提供了一些实现类。</p><p><img src="/images/bq01.jpg" alt="0aa769cbe5c1e7beb7730c803df1285f.png"></p><p>JDK7 主要提供了 7 个阻塞队列，分别是：</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li></ul><p>根据是否是有界，是否有加锁，数据结构，汇总表格如下：</p><table><thead><tr><th>阻塞队列</th><th>有界性</th><th>锁</th><th>数据结构</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded</td><td>加锁</td><td>arraylist</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded</td><td>加锁</td><td>linkedlist</td></tr><tr><td>LinkedBlockingDeque</td><td>optionally-bounded</td><td>加锁</td><td>linkedlist</td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>无锁(CAS实现)</td><td>linkedlist</td></tr><tr><td>PriorityBlockingQueue</td><td>unbounded</td><td>加锁</td><td>heap</td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁</td><td>heap</td></tr></tbody></table><h2 id="阻塞队列的实现原理-以-ArrayBlockingQueue-为例子"><a href="#阻塞队列的实现原理-以-ArrayBlockingQueue-为例子" class="headerlink" title="阻塞队列的实现原理 以 ArrayBlockingQueue 为例子"></a>阻塞队列的实现原理 以 ArrayBlockingQueue 为例子</h2><p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p><p>构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    &#x2F;&#x2F;..省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">     &#x2F;&#x2F;..省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                      Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     &#x2F;&#x2F;..省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是非公平锁。Collection 可以传入最初包含的元素的集合。</p><p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器 Condition，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p><p>下面是初始化代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数据元素数组</span><br><span class="line">final Object[] items;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个待取出元素索引</span><br><span class="line">int takeIndex;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个待添加元素索引</span><br><span class="line">int putIndex;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;元素个数</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内部锁</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费者监视器 Condition for waiting takes </span><br><span class="line">private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产者监视器 Condition for waiting puts </span><br><span class="line">private final Condition notFull; </span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    this(capacity, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed)</span><br><span class="line"> * capacity and the specified access policy.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @param fair if &#123;@code true&#125; then queue accesses for threads blocked</span><br><span class="line"> *        on insertion or removal, are processed in FIFO order;</span><br><span class="line"> *        if &#123;@code false&#125; the access order is unspecified.</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items &#x3D; new Object[capacity];</span><br><span class="line">    lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">    notEmpty &#x3D; lock.newCondition();</span><br><span class="line">    notFull &#x3D;  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 操作的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    &#x2F;&#x2F; 1.自旋拿锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 2.判断队列是否满了</span><br><span class="line">        while (count &#x3D;&#x3D; items.length)</span><br><span class="line">            &#x2F;&#x2F; 2.1如果满了，阻塞该线程，并标记为notFull线程，</span><br><span class="line">            &#x2F;&#x2F; 等待notFull的唤醒，唤醒之后继续执行while循环。</span><br><span class="line">            notFull.await(); &#x2F;&#x2F;底层是通过LockSupport.park 调用 UNSAFE.park() 实现</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 3.如果没有满，则进入队列</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入队并通过 notEmpty.signal() 唤醒一个消费者线程</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; assert items[putIndex] &#x3D;&#x3D; null;</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    items[putIndex] &#x3D; x;</span><br><span class="line">    if (++putIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        putIndex &#x3D; 0;</span><br><span class="line">    count++;</span><br><span class="line">    &#x2F;&#x2F; 4 唤醒一个等待的线程</span><br><span class="line">    notEmpty.signal();  &#x2F;&#x2F;底层是通过LockSupport.unpark 调用 UNSAFE.unpark(thread) 实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结put的流程：</p><ol><li><p>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p></li><li><p>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</p></li><li><p>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p></li><li><p>唤醒一个标记为notEmpty（消费者）的线程。</p></li></ol><p>take操作的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">       &#x2F;&#x2F;用while 而不用 if 是为了唤醒后重新判断一次，避免count状态发生变化</span><br><span class="line">        while (count &#x3D;&#x3D; 0)       </span><br><span class="line">            notEmpty.await(); &#x2F;&#x2F;底层是通过LockSupport.park 调用 UNSAFE.park() 实现</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从队列取出一个元素并通过 notFull.signal 唤醒生产者线程</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; assert items[takeIndex] !&#x3D; null;</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x &#x3D; (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] &#x3D; null;</span><br><span class="line">    if (++takeIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        takeIndex &#x3D; 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs !&#x3D; null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); &#x2F;&#x2F;底层是通过LockSupport.unpark 调用 UNSAFE.unpark(thread) 实现</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p><ol><li><p>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p></li><li><p>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</p></li></ol><p>3.如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p><ol start="4"><li>唤醒一个标记为notFull（生产者）的线程。</li></ol><p>需要注意：</p><ol><li><p>put和take操作都需要先获取锁，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</p></li><li><p>就算拿到锁了之后，也不一定会顺利进行put/take操作，需要判断队列是否可用（是否满/空），如果不可用，则会被阻塞，并释放锁。</p></li><li><p>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，依然需要拿到锁才能继续往下执行，否则，自旋拿锁</p></li><li><p>await 前面用while 而不用 if 是为了唤醒后重新判断一次，避免count状态发生变化。这里是有讲究的，因为这个线程被唤醒后条件里的值很可能已经改变了，不再满足了，如果用 if，线程唤醒后会根据程序计数器的记录直接执行if后面的逻辑，而用while 可以确保再判断一次。</p></li></ol><p>通过上面代码可以看到， put, take 内部是用在没有成功之前是会一直阻塞的。下面看下 offer 和 poll 对比下</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the tail of this queue if it is</span><br><span class="line"> * possible to do so immediately without exceeding the queue&#39;s capacity,</span><br><span class="line"> * returning &#123;@code true&#125; upon success and &#123;@code false&#125; if this queue</span><br><span class="line"> * is full.  This method is generally preferable to method &#123;@link #add&#125;,</span><br><span class="line"> * which can fail to insert an element only by throwing an exception.</span><br><span class="line"> *</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; items.length)</span><br><span class="line">            return false; </span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count &#x3D;&#x3D; 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看到 通过 offer 方法插入的话是会立马返回结果  true / false, 而通过 poll 从队列删除元素 成功会直接返回元素对象， 失败会返回 null.</p><h2 id="案例：实现一个简单的在生产者消费者模型"><a href="#案例：实现一个简单的在生产者消费者模型" class="headerlink" title="案例：实现一个简单的在生产者消费者模型"></a>案例：实现一个简单的在生产者消费者模型</h2><p>通过 ArrayBlockingQueue 实现一个最简单的在生产者-消费者模型：</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueueDemo &#123;</span><br><span class="line">    private int queueSize &#x3D; 10;</span><br><span class="line">    private ArrayBlockingQueue&lt;Integer&gt; queue &#x3D; new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayBlockingQueueDemo test &#x3D; new ArrayBlockingQueueDemo();</span><br><span class="line">        Producer producer &#x3D; test.new Producer();</span><br><span class="line">        Consumer consumer &#x3D; test.new Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void consume() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    Thread.sleep(new Random().nextInt(2000));</span><br><span class="line">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot; + queue.size() + &quot;个元素&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Producer extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void produce() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot; + (queueSize - queue.size()));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/images/bq02.jpg" alt="157e3e8fd16022e3003be6f8e750f981.png"></p><h2 id="高并发下无界队列容易产生OOM问题"><a href="#高并发下无界队列容易产生OOM问题" class="headerlink" title="高并发下无界队列容易产生OOM问题"></a>高并发下无界队列容易产生OOM问题</h2><p>队列按实现可以分为有界队列，与无界队列。在高并发环境，生产者的生产速度往往比消费者速度快很多，如果使用无界队列，队列无限扩大，容易吃掉内存导致 OOM。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>案例：在高并发环境下使用无界队列 ConcurrentLinkedQueue，生产者速度比消费者速度快，导致OOM。用 Jprofiler 分析dump下来的内存镜像如下所示。</p><p><img src="/images/bq03.jpg" alt="5c104305c6715eb84ee00d4b51584101.png"></p><p>看下 ConcurrentLinkedQueue 的 offer 方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the tail of this queue.</span><br><span class="line"> * As the queue is unbounded, this method will never return &#123;@code false&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    for (Node&lt;E&gt; t &#x3D; tail, p &#x3D; t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q &#x3D; p.next;</span><br><span class="line">        if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; p is last node</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Successful CAS is the linearization point</span><br><span class="line">                &#x2F;&#x2F; for e to become an element of this queue,</span><br><span class="line">                &#x2F;&#x2F; and for newNode to become &quot;live&quot;.</span><br><span class="line">                if (p !&#x3D; t) &#x2F;&#x2F; hop two nodes at a time</span><br><span class="line">                    casTail(t, newNode);  &#x2F;&#x2F; Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p &#x3D;&#x3D; q)</span><br><span class="line">            &#x2F;&#x2F; We have fallen off list.  If tail is unchanged, it</span><br><span class="line">            &#x2F;&#x2F; will also be off-list, in which case we need to</span><br><span class="line">            &#x2F;&#x2F; jump to head, from which all live nodes are always</span><br><span class="line">            &#x2F;&#x2F; reachable.  Else the new tail is a better bet.</span><br><span class="line">            p &#x3D; (t !&#x3D; (t &#x3D; tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            &#x2F;&#x2F; Check for tail updates after two hops.</span><br><span class="line">            p &#x3D; (p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到由于是没有限制的，offer 的结果永远都是成功的，这样队列就会无限扩张而吃掉内存，导致OOM。</p><h3 id="在JDK提供的线程安全的内置队列分类"><a href="#在JDK提供的线程安全的内置队列分类" class="headerlink" title="在JDK提供的线程安全的内置队列分类"></a>在JDK提供的线程安全的内置队列分类</h3><table><thead><tr><th>队列</th><th>有界性</th><th>锁</th><th>数据结构</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded</td><td>加锁</td><td>arraylist</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded</td><td>加锁</td><td>linkedlist</td></tr><tr><td>LinkedBlockingDeque</td><td>optionally-bounded</td><td>加锁</td><td>linkedlist</td></tr><tr><td>ConcurrentLinkedQueue</td><td>unbounded</td><td>无锁(CAS实现)</td><td>linkedlist</td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>无锁(CAS实现)</td><td>linkedlist</td></tr><tr><td>PriorityBlockingQueue</td><td>unbounded</td><td>加锁</td><td>heap</td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁</td><td>heap</td></tr></tbody></table><p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p><p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p><p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。<strong>在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue</strong></p><p><strong>总结：在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列推荐使用在ArrayBlockingQueue</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://concurrent.redspider.group/article/03/13.html" target="_blank" rel="noopener">阻塞队列</a><br>2.<a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">聊聊并发（七）——Java中的阻塞队列</a><br>3.<a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">高性能队列——Disruptor</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;阻塞队列的由来&quot;&gt;&lt;a href=&quot;#阻塞队列的由来&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列的由来&quot;&gt;&lt;/a&gt;阻塞队列的由来&lt;/h2&gt;&lt;p&gt;在生产者-消费者模式中，为了使生产者消费者解藕，需要一个存放元素的容器，使生产者可以只关心往队列里添加元素下，消费者只关系从队列中取出元素进程处理。&lt;/p&gt;
&lt;p&gt;而且这个队列必须要满足两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDK 为此设计了 阻塞队列(BlockingQueue)，并提供了几个基于 BlockingQueue 接口 实现的一些线程安全的阻塞队列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-ThreadPoolExecutor</title>
    <link href="https://crazyfzw.github.io/2020/11/13/concurrent-thread-pool-executor/"/>
    <id>https://crazyfzw.github.io/2020/11/13/concurrent-thread-pool-executor/</id>
    <published>2020-11-13T13:43:25.000Z</published>
    <updated>2021-01-09T15:30:14.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><blockquote><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><a id="more"></a><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="方式一：通过-Executor-框架的工具类-Executors-来实现："><a href="#方式一：通过-Executor-框架的工具类-Executors-来实现：" class="headerlink" title="方式一：通过 Executor 框架的工具类 Executors 来实现："></a>方式一：通过 Executor 框架的工具类 Executors 来实现：</h3><p>主要是通过下面个方法：</p><ul><li><p>newFixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p></li><li><p>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p></li><li><p>newCachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p></li><li><p>newScheduledThreadPool：调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p></li></ul><h3 id="方式二：直接通过-ThreadPoolExecutor-来实现-（推荐使用这种）"><a href="#方式二：直接通过-ThreadPoolExecutor-来实现-（推荐使用这种）" class="headerlink" title="方式二：直接通过 ThreadPoolExecutor 来实现 （推荐使用这种）"></a>方式二：直接通过 ThreadPoolExecutor 来实现 （推荐使用这种）</h3><p><img src="/images/tp01.jpg" alt="59cd25bb4a864c8906c0b85a74dafbba.jpeg"></p><h3 id="《阿里-Java-开发手册》中关于线程以及线程池的使用有两个强制建议："><a href="#《阿里-Java-开发手册》中关于线程以及线程池的使用有两个强制建议：" class="headerlink" title="《阿里 Java 开发手册》中关于线程以及线程池的使用有两个强制建议："></a>《阿里 Java 开发手册》中关于线程以及线程池的使用有两个强制建议：</h3><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</li></ul><p><img src="/images/tp02.jpg" alt="10e9feb4c6cddfcee5cd9cc09e3f1951.png"></p><p><strong>我们在项目中最好还是直接ThreadPoolExecutor，并且 Executors 也是在ThreadPoolExecutor 的基础上做了一层封装，所以很有必要学习下 ThreadPoolExecutor 的工作原理以及几个重要的参数设置。</strong></p><h2 id="ThreadPoolExecutor构造方法及几个重要参数"><a href="#ThreadPoolExecutor构造方法及几个重要参数" class="headerlink" title="ThreadPoolExecutor构造方法及几个重要参数"></a>ThreadPoolExecutor构造方法及几个重要参数</h2><p>一共有四个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; 五个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-1</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-2</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 七个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p><ul><li><p>int corePoolSize：该线程池中核心线程数最大值</p><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote></li><li><p>int maximumPoolSize：该线程池中线程总数最大值</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote></li><li><p>long keepAliveTime：非核心线程闲置超时时长</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p></blockquote></li><li><p>TimeUnit unit：keepAliveTime的单位</p><blockquote><p>TimeUnit是一个枚举类型 ，包括以下属性：<br>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000<br>MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</p></blockquote></li><li><p>BlockingQueue workQueue： 阻塞队列，维护着等待执行的 Runnable 任务对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用的几个阻塞队列：</span><br><span class="line"></span><br><span class="line">- LinkedBlockingQueue</span><br><span class="line">链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line"></span><br><span class="line">- ArrayBlockingQueue</span><br><span class="line">数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line"></span><br><span class="line">- SynchronousQueue</span><br><span class="line">同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line"></span><br><span class="line">- DelayQueue</span><br><span class="line">延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure></li></ul><p>还有两个非必须的参数:</p><ul><li><p>ThreadFactory threadFactory :<br>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略属性</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s &#x3D; System.getSecurityManager();</span><br><span class="line">        group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix &#x3D; &quot;pool-&quot; +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            &quot;-thread-&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RejectedExecutionHandler handler：饱和策略<br>拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</span><br></pre></td></tr></table></figure><p>当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。</p></li></ul><h2 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a>一个简单的线程池 Demo</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutorDemo &#123;</span><br><span class="line">    private static final int CORE_POOL_SIZE &#x3D; 5;</span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 10;</span><br><span class="line">    private static final int QUEUE_CAPACITY &#x3D; 100;</span><br><span class="line">    private static final Long KEEP_ALIVE_TIME &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    static class MyRunnable implements Runnable &#123;</span><br><span class="line">        private String command;</span><br><span class="line">        public MyRunnable(String s) &#123;</span><br><span class="line">            this.command &#x3D; s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; Start. Time &#x3D; &quot; + new Date());</span><br><span class="line">            processCommand();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; End. Time &#x3D; &quot; + new Date());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void processCommand() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return this.command;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用阿里巴巴推荐的创建线程池的方式</span><br><span class="line">        &#x2F;&#x2F;通过ThreadPoolExecutor构造函数自定义参数创建</span><br><span class="line">        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">            Runnable worker &#x3D; new MyRunnable(&quot;&quot; + i);</span><br><span class="line">            &#x2F;&#x2F;执行Runnable</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;终止线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        while (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/images/tp03.jpg" alt="3feae6853d5148f6246658398db6ce0a.png"></p><h2 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h2><p>处理任务的核心方法是execute，我们看看 JDK 1.8 源码中ThreadPoolExecutor是如何处理线程任务的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><br><span class="line">   private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK 1.8 </span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();   </span><br><span class="line">    int c &#x3D; ctl.get();&#x2F;&#x2F;&#x2F;&#x2F; ctl 中保存的线程池当前的一些状态信息</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       if (addWorker(command, true))</span><br><span class="line">           return;</span><br><span class="line">       c &#x3D; ctl.get(); </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 2.1 二次检查线程池的状态，如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            &#x2F;&#x2F; 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br><span class="line">    &#x2F;&#x2F; 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor execute的整个处理过程如下图所示：<br><img src="/images/tp04.jpg" alt="cfa38f8aebb0f43f2017e674077a219b.png"></p><p>总结一下处理流程有下面几个步骤：</p><ol><li><p>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。</p></li><li><p>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</p></li><li><p>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。</p></li><li><p>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.《并发编程的艺术》<br>2. <a href="http://concurrent.redspider.group/article/03/12.html" target="_blank" rel="noopener">线程池原理</a><br>3. <a href="https://blog.csdn.net/programmer_at/article/details/79799267" target="_blank" rel="noopener">java线程池实现原理与源码分析（jdk1.8）</a><br>4. <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br>5. <a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">聊聊并发（三）——JAVA线程池的分析和使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-AQS及通信工具类</title>
    <link href="https://crazyfzw.github.io/2020/11/08/concurrent-aqs/"/>
    <id>https://crazyfzw.github.io/2020/11/08/concurrent-aqs/</id>
    <published>2020-11-08T13:13:33.000Z</published>
    <updated>2021-01-23T07:43:48.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-简介"><a href="#AQS-简介" class="headerlink" title="AQS 简介"></a>AQS 简介</h3><p>AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器，从字面意思上理解:</p><ul><li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li><li>队列：使用先进先出（FIFO）队列存储数据；</li><li>同步：实现了同步的功能。</li></ul><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们常用到的同步类 ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><a id="more"></a><p><img src="/images/aqs01.jpg" alt="e8860a5e5c273c648ff38504afa98c63.png"></p><p>AQS 采用了模版方法实现，子类只需要根据需要去实现自己关心的protected 方法即可造出符合我们自己需求的同步器。</p><h3 id="AQS-的数据结构"><a href="#AQS-的数据结构" class="headerlink" title="AQS 的数据结构"></a>AQS 的数据结构</h3><p>AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改版state的protected方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final int getState() &#123;</span><br><span class="line">    return this.state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    this.state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return STATE.compareAndSet(this, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种叫做均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。</p><p>而AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。但它并不是直接储存线程，而是储存拥有线程的Node节点。其数据结构如图：</p><p><img src="/images/aqs02.jpg" alt="e3144b5ad4ae0bf1b473687efa2d487e.png"></p><h3 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h3><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li><li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</li></ul><p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在共享模式下等待</span><br><span class="line">    static final Node SHARED &#x3D; new Node();</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在独占模式下等待</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）已被取消</span><br><span class="line">    static final int CANCELLED &#x3D; 1; </span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span><br><span class="line">    static final int SIGNAL &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）在等待某一条件</span><br><span class="line">    static final int CONDITION &#x3D; -2;</span><br><span class="line">    &#x2F;*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*&#x2F;</span><br><span class="line">    static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 等待状态，取值范围，-3，-2，-1，0，1</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev; &#x2F;&#x2F; 前驱结点</span><br><span class="line">    volatile Node next; &#x2F;&#x2F; 后继结点</span><br><span class="line">    volatile Thread thread; &#x2F;&#x2F; 结点对应的线程</span><br><span class="line">    Node nextWaiter; &#x2F;&#x2F; 等待队列里下一个等待条件的结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断共享模式的方法</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">        this.nextWaiter &#x3D; mode;</span><br><span class="line">        this.thread &#x3D; thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其它方法忽略，可以参考具体的源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS里面的addWaiter私有方法</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用了Node的这个构造函数</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 其它代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。</p><h3 id="AQS的主要方法源码解析"><a href="#AQS的主要方法源码解析" class="headerlink" title="AQS的主要方法源码解析"></a>AQS的主要方法源码解析</h3><h4 id="使用模版方法定好算法骨架"><a href="#使用模版方法定好算法骨架" class="headerlink" title="使用模版方法定好算法骨架"></a>使用模版方法定好算法骨架</h4><p>AQS的设计是基于模板方法模式的，AQS主要定义了下面几个模版方法来获取资源：</p><ul><li>acquire ：独占模式，不可中断</li><li>acquireInterruptibly：独占模式，可中断（在线程中断时可能会抛出InterruptedException）</li><li>acquireShared：共享模式，不可中断</li><li>acquireSharedInterruptibly：共享模式，可中断 （在线程中断时可能会抛出InterruptedException）</li></ul><p>下面以 acquire 为例看下AQS的模版方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取独占资源</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自旋不间断的从等待队列用头节点尝试获取资源（独占方式）</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;留给子类去实现</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">  throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，AQS 已经定义好对应的获取锁的代码模版(算法骨架)，子类可以根据需要去实现对应的方法即可，比如 Semaphore 只需要实现 tryAcquire 即可。通过使用模版方法，让AQS实现基本功能的同时又保持了良好的扩展性。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;留给子类去实现</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">      throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的方法（似的用法在 AbstractList的addall实现。提供默认的方法method1…method4方法，每个方法直接抛出异常，使用模板方法的时候强制重写用到的method方法，用不到的method不用重写。）</p><p>AQS 预留给子类进行扩展的方法主要有下面几个：</p><ul><li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p></li><li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p></li><li><p>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p></li><li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p></li><li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></li></ul><p>子类根据需要去实现即可。</p><h4 id="以独占方式获取资源为例"><a href="#以独占方式获取资源为例" class="headerlink" title="以独占方式获取资源为例"></a>以独占方式获取资源为例</h4><p><strong>AQS获取资源的流程：</strong><br><img src="/images/aqs03.jpg" alt="a7f37bf6e341e74f6c60d06c511aa2ca.png"></p><p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p><p>如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 生成该线程对应的Node节点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 将Node插入队列中</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F; 使用CAS尝试，如果成功就返回</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自旋CAS插入等待队列</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p><p>现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 标记是否成功拿到资源</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 标记等待过程中是否中断过</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 开始自旋，要么获取锁，要么中断</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取当前节点的前驱节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点,双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位）</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取锁成功，头指针移动到当前node</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，shouldParkAfterFailedAcquire代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取头结点的节点状态</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    &#x2F;&#x2F; 说明头结点处于唤醒状态， waitStatus为-1，表示线程已经准备好了，就等资源释放了。</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        return true; </span><br><span class="line">    &#x2F;&#x2F; 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环向前查找取消节点，把取消节点从队列中剔除</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置前任节点等待状态为SIGNAL</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire流程如下：<br><img src="/images/aqs.png" alt=""></p><h4 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果状态是负数，尝试把它设置为0</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    &#x2F;&#x2F; 得到头结点的后继结点head.next</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    &#x2F;&#x2F; 如果这个后继结点为空或者状态大于0</span><br><span class="line">    &#x2F;&#x2F; 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 等待队列中所有还有用的结点，都向前移动</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果后继结点不为空，</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h2><p>我们常用到的通信工具类主要都是依靠借助AQS实现的（如semaphore、CountDownLatch、CyclicBarrier），实现的方式就是前面所说的根据需要去实现AQS预留的一些拓展方法：</p><p>AQS 预留给子类进行扩展的方法主要有下面几个：</p><ul><li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p></li><li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p></li><li><p>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p></li><li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p></li><li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></li></ul><p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p><p><img src="/images/aqs33.jpg" alt="4d7f25b785c31cfd82f66d85270a98be.png"></p><h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><h4 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h4><p>Java提供了经典信号量Semaphore的实现，它通过控制一定数量的许可（permit）的方式，来达到限制通用资源访问的目的。Semaphore往往用于资源有限的场景中，用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。例如：控制并发的线程数。</p><p>可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>比如：控制并发的线程数</p><p>比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。</p><p>比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Semaphore是通过一个计数器(记录许可证的数量)来实现的：<br>1.线程通过acquire()方法获取许可证(计数器的值减1)，只有获取到许可证才可以继续执行下去，否则阻塞当前线程。<br>2.线程通过release()方法归还许可证(计数器的值加1)。<br>3.如果许可证减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p><p>常用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">acquire()  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line"></span><br><span class="line">acquire(int permits)  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断、或超时之前线程一直处于阻塞状态。</span><br><span class="line">    </span><br><span class="line">acquireUninterruptibly() </span><br><span class="line">获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。</span><br><span class="line">    </span><br><span class="line">tryAcquire()</span><br><span class="line">尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。</span><br><span class="line"></span><br><span class="line">tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。</span><br><span class="line"></span><br><span class="line">release()</span><br><span class="line">释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br><span class="line"></span><br><span class="line">hasQueuedThreads()</span><br><span class="line">等待队列里是否还存在等待线程。</span><br><span class="line"></span><br><span class="line">getQueueLength()</span><br><span class="line">获取等待队列里阻塞的线程数。</span><br><span class="line"></span><br><span class="line">drainPermits()</span><br><span class="line">清空令牌把可用令牌数置为0，返回清空令牌的数量。</span><br><span class="line">The </span><br><span class="line">availablePermits()</span><br><span class="line">返回可用的令牌数量。</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1、假如有一个落魄的停车场只能容纳3辆车。<br>2、当一辆车进入停车场后，显示牌的剩余车位数 -1.<br>3、每有一辆车驶出停车场后，显示牌的剩余车位 +1。<br>4、停车场剩余车位不足时，车辆只能在外面等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    static class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private int value;</span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        public MyThread(int value, Semaphore semaphore) &#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.semaphore &#x3D; semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire(); &#x2F;&#x2F; 获取permit</span><br><span class="line"></span><br><span class="line">                System.out.println(String.format(&quot;车辆 粤A***%d 驶入, 还剩%d个车位，还有%d个车辆在等待&quot;,</span><br><span class="line">                        value, semaphore.availablePermits(), semaphore.getQueueLength()));</span><br><span class="line">                &#x2F;&#x2F; 睡眠随机时间，打乱释放顺序</span><br><span class="line">                Random random &#x3D; new Random();</span><br><span class="line">                Thread.sleep(random.nextInt(1000));</span><br><span class="line">                System.out.println(String.format(&quot;车辆 粤A%d 已经驶出&quot;, value));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally&#123;</span><br><span class="line">                semaphore.release(); &#x2F;&#x2F; 释放permit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(3);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(new MyThread(i, semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/aqs04.jpg" alt="7edc671804e6e24a7bdde6803dc0b005.png"></p><p>结果分析：最开始是A<strong><em>3, A</em></strong>0, A<strong><em>4 这辆车获得了资源车位，而其它车辆进入了等待队列。然后当A</em></strong>0辆驶出释放车位后，在排队的车辆粤A***2才得以获取了刚释放的车位。</p><p>总结：Semaphore往往用于资源有限的场景中，去限制线程的数量。最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;非公平的构造函数</span><br><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过fair参数决定公平性</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore有两个构造函数：</p><ul><li><p>参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。</p></li><li><p>fair，用于指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列排队。</p></li></ul><p>acquire源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">        FairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                if (hasQueuedPredecessors())</span><br><span class="line">                    return -1;</span><br><span class="line">                int available &#x3D; getState();</span><br><span class="line">                int remaining &#x3D; available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果remaining &lt;0 即获取许可后，许可数小于0，则获取失败，在doAcquireSharedInterruptibly方法中线程会将自身阻塞，然后入列。</p><p>release源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();</span><br><span class="line">        int next &#x3D; current + releases;</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow</span><br><span class="line">           throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看出释放许可就是将AQS中state的值加1。然后通过doReleaseShared唤醒等待队列的第一个节点。可以看出Semaphore使用的是AQS的共享模式，等待队列中的第一个节点，如果第一个节点成功获取许可，又会唤醒下一个节点，以此类推。</p><h3 id="CountDownLatch（倒计数门闸锁）"><a href="#CountDownLatch（倒计数门闸锁）" class="headerlink" title="CountDownLatch（倒计数门闸锁）"></a>CountDownLatch（倒计数门闸锁）</h3><h4 id="功能概述-1"><a href="#功能概述-1" class="headerlink" title="功能概述"></a>功能概述</h4><p>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。</p><p>CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>主任务开始之前的一些前期准备工作：<br>在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等</p><p>倒数计时器：<br>比如：一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。 只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。<br>它可以使得点火线程，等待所有检查线程全部完工后，再执行</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为需要等待线程的数量。</p><ul><li>主线程调用CountDownLatch的await()方法会阻塞当前线程(即:主线程在闭锁上等待)，直到计数器的值为0</li><li>当一个工作线程完成了自己的任务后，调用CountDownLatch的countDown()方法，计数器的值就会减1。</li><li>当计数器值为0时，说明所有的工作线程都执行完了，此时，在闭锁上等待的主线程就可以恢复执行任务。</li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p> 使用 CountDownLatch实现在游戏开始前的前置任务，任务完成后游戏自动开始，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，游戏才开始</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义前置任务线程</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, CountDownLatch countDownLatch) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Random random &#x3D; new Random();</span><br><span class="line">                Thread.sleep(random.nextInt(1000));</span><br><span class="line">                System.out.println(task + &quot; - 任务完成&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 假设有三个模块需要加载</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 主任务</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;等待数据加载...&quot;);</span><br><span class="line">                System.out.println(String.format(&quot;还有%d个前置任务&quot;, countDownLatch.getCount()));</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(&quot;数据加载完成，正式开始游戏！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 前置任务</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, countDownLatch)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, countDownLatch)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/aqs05.jpg" alt="2e7ccffac954ad808ddd0725b65bfaff.png"></p><p>总结：CountDownLatch这个类的作用是，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。比如某个线程A等待若干个其他线程执行完任务之后，它才执行。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>常用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; 构造方法：</span><br><span class="line">public CountDownLatch(int count)</span><br><span class="line"></span><br><span class="line">public void await() &#x2F;&#x2F; 等待</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) &#x2F;&#x2F; 超时等待</span><br><span class="line">public void countDown() &#x2F;&#x2F; count - 1</span><br><span class="line">public long getCount() &#x2F;&#x2F; 获取当前还有多少count</span><br></pre></td></tr></table></figure><p>await方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg); &#x2F;&#x2F;doAcquireSharedInterruptibly 主要实现线程的入列与阻塞</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); &#x2F;&#x2F;主要实现唤醒第一个节点，第一个节点有会唤醒第二个节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier-（可重用的倒计数栅栏）"><a href="#CyclicBarrier-（可重用的倒计数栅栏）" class="headerlink" title="CyclicBarrier （可重用的倒计数栅栏）"></a>CyclicBarrier （可重用的倒计数栅栏）</h3><h4 id="功能概述-2"><a href="#功能概述-2" class="headerlink" title="功能概述"></a>功能概述</h4><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>和CountDownLatch相似，也是等待某些线程都做完以后再执行。</p><p>与CountDownLatch区别是：<br>前面提到了CountDownLatch一旦计数值count被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障，使计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批1 0个线程后，计数器就会归零，然后接着凑齐下一批10个线程。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>CyclicBarrier：一组线程互相等待，当它们都达到各自await()指定的barrier时，它们再同时继续执行各自下面的代码。</p><p>经典使用场景是公交发车，比如每辆公交车只要上满 4 个人就发车，后面来的人都会排队依次遵循相应的标准。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量,在CyclicBarrier的内部定义了一个Lock对象（使用ReentrantLock来实现的），每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待。如果是，执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回。</p><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>案例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    static class TaskThread extends Thread &#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        public TaskThread(CyclicBarrier barrier) &#123;</span><br><span class="line">            this.barrier &#x3D; barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 到达栅栏 A 就位&quot;);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 走出栅栏 A&quot;);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 到达栅栏 B&quot;);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 走出栅栏 B&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int threadNum &#x3D; 3;</span><br><span class="line">        CyclicBarrier barrier &#x3D; new CyclicBarrier(threadNum, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 人员就位到齐设备自动打开栅栏&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            new TaskThread(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/aqs06.jpg" alt="283e5359775239b91165d4c52187cc04.png"></p><p>结果分析：<br>一开始选手到达栅栏A后会被阻塞，待选手都到齐后，栅栏A会自动打开，所有选手同时执行 barrier.await() 的动作，然后优先到达栅栏B后又会被阻塞，待选手都到达栅栏B后，栅栏B会自动打开，所有选手同时执行后面的动作</p><p>案例二：如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; 假设总共三个关卡</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Random random &#x3D; new Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                    System.out.println(String.format(&quot;关卡%d的任务%s完成&quot;, i, task));</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                cyclicBarrier.reset(); &#x2F;&#x2F; 重置屏障</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;本关卡所有前置任务完成，开始游戏...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/aqs07.jpg" alt="b24501a2fa80be6bc622f7485fc85dfa.png"></p><p>前面提到了CountDownLatch一旦计数值count被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障。</p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br><span class="line">public int getParties() &#123;</span><br><span class="line">    return parties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction这个Runnable对象，方便处理更复杂的业务场景。</p><p>await源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); &#x2F;&#x2F; cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dowait源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        final Generation g &#x3D; generation;</span><br><span class="line"> </span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int index &#x3D; --count;</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; tripped</span><br><span class="line">            boolean ranAction &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command &#x3D; barrierCommand;</span><br><span class="line">                if (command !&#x3D; null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction &#x3D; true;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos &#x3D; trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not</span><br><span class="line">                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to</span><br><span class="line">                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">            if (g !&#x3D; generation)</span><br><span class="line">                return index;</span><br><span class="line"> </span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当最后一个线程到达屏障点，也就是执行dowait方法时，会在return 0 返回之前调用finally块中的breakBarrier方法。</p><p>breakBarrier源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken &#x3D; true;</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CycliBarrier对象可以重复使用，重用之前应当调用CyclicBarrier对象的reset方法。<br>reset源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void reset() &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        breakBarrier();   &#x2F;&#x2F; break the current generation</span><br><span class="line">        nextGeneration(); &#x2F;&#x2F; start a new generation</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结对比Semaphore、CountDownLatch、CyclicBarrier"><a href="#总结对比Semaphore、CountDownLatch、CyclicBarrier" class="headerlink" title="总结对比Semaphore、CountDownLatch、CyclicBarrier"></a>总结对比Semaphore、CountDownLatch、CyclicBarrier</h3><ul><li><p>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p></li><li><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待。CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用。</p></li><li><p>CyclicBarrier和CoutDownLatch的底层实现也存在一点区别，CountDownLatch底层是直接通过组合一个继承了AQS的同步组件来实现的，而CyclicBarrier并没有直接借助AQS的同步组件，而是通过组合ReentrantLock这把锁来实现的（ReentrantLock的底层实现依然使用的AQS来实现的，归根结底，CyclicBarrier的底层实现也是AQS）。<br>由于CyclicBarrier是使用ReentrantLock来实现的，因此它有个属性是lock。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/98593407" target="_blank" rel="noopener">Semaphore 使用及原理</a><br><a href="https://www.cnblogs.com/nullzx/p/5270233.html" target="_blank" rel="noopener">Java并发包中Semaphore的工作原理、源码分析及使用示例</a><br><a href="http://concurrent.redspider.group/article/02/10.html" target="_blank" rel="noopener">CAS与原子操作</a><br><a href="http://concurrent.redspider.group/article/03/17.html" target="_blank" rel="noopener">通信工具类</a><br><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;h3 id=&quot;AQS-简介&quot;&gt;&lt;a href=&quot;#AQS-简介&quot; class=&quot;headerlink&quot; title=&quot;AQS 简介&quot;&gt;&lt;/a&gt;AQS 简介&lt;/h3&gt;&lt;p&gt;AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器，从字面意思上理解:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；&lt;/li&gt;
&lt;li&gt;队列：使用先进先出（FIFO）队列存储数据；&lt;/li&gt;
&lt;li&gt;同步：实现了同步的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们常用到的同步类 ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-非阻塞同步-CAS</title>
    <link href="https://crazyfzw.github.io/2020/11/03/concurrent-cas/"/>
    <id>https://crazyfzw.github.io/2020/11/03/concurrent-cas/</id>
    <published>2020-11-03T14:26:13.000Z</published>
    <updated>2021-01-17T08:02:48.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="乐观锁与悲观锁的概念"><a href="#乐观锁与悲观锁的概念" class="headerlink" title="乐观锁与悲观锁的概念"></a>乐观锁与悲观锁的概念</h2><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><p>悲观锁：<br>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。互斥同步锁就属于悲观锁，比如， synchronized. 与 ReentrantLock.</p><p>乐观锁：<br>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。</p><a id="more"></a><p><strong>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</strong></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步是阻塞同步，这是一种悲观的并发策略，总是认为只要不加锁那就肯定会出现问题，无论共享数据是否真多会出现竞争，它都要进行加锁。</p><p>而随着硬件指令集的发展，CAS得与实现，做法是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）</p><p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。所以这里的预期值E本质上指的是“旧值”</p><p>以一个简单的例子来解释这个过程：<br>1.如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6;<br>2.我们使用CAS来做这个事情；<br>3.首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6；<br>4.如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。</p><p>在这个例子中，i就是V，5就是E，6就是N。</p><p>那有没有可能我在判断了i为5之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？<br>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p><p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。CAS 常常会搭配自旋使用</p><h2 id="Java实现CAS的原理-Unsafe类"><a href="#Java实现CAS的原理-Unsafe类" class="headerlink" title="Java实现CAS的原理 - Unsafe类"></a>Java实现CAS的原理 - Unsafe类</h2><p>CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。</p><p>在Java中，有一个Unsafe类，它在sun.misc包中。它里面是一些native方法，其中就有几个关于CAS的：</p><p>JDK1.7中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset,</span><br><span class="line">                                                 Object expected,</span><br><span class="line">                                                 Object x);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,</span><br><span class="line">                                               long expected,</span><br><span class="line">                                               long x);</span><br></pre></td></tr></table></figure><p>在 JDK11 中，则改成一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetInt(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line"> @HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure><p>可以看出两个版本都是 native 的，Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的X86下主要是通过cmpxchgl这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用lock指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同。</p><h2 id="JDK提供的原子操作类-AtomicInteger源码简析"><a href="#JDK提供的原子操作类-AtomicInteger源码简析" class="headerlink" title="JDK提供的原子操作类-AtomicInteger源码简析"></a>JDK提供的原子操作类-AtomicInteger源码简析</h2><p>由于 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器 BootStrap ClassLoader 加载的 Class 才能访问它)，所以，JDK给我们提供了一些原子类的Java API来间接使用它，这些原子工具类在java.util.concurrent.atomic包下面。在JDK 11中，有如下17个类：<br><img src="/images/cas01.jpg" alt="f0f475e608bc2a584e4d6214bab2b4d0.png"></p><p>从名字就可以看得出来这些类大概的用途：</p><p>原子更新基本类型<br>原子更新数组<br>原子更新引用<br>原子更新字段（属性）</p><p>这里我们以AtomicInteger类的getAndAdd(int delta)方法为例，来看看Java是如何实现原子操作的。</p><p>先看看这个方法的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return U.getAndAddInt(this, VALUE, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v &#x3D; getIntVolatile(o, offset);对象o是this，也就是一个AtomicInteger对象。然后offset是一个常量VALUE。这个常量是在AtomicInteger类中声明的：</span><br><span class="line">    &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @HotSpotIntrinsicCandidate</span><br><span class="line">    public final boolean weakCompareAndSetIntRelease(Object o, long offset, int expected, int x) &#123;</span><br><span class="line">        return this.compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @HotSpotIntrinsicCandidate</span><br><span class="line">    public final native boolean compareAndSetInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>所以其实AtomicInteger类的getAndAdd(int delta)方法最终其实是调用的我们之前说到了CAS native方法来来实现的：对象o是this，也就是一个AtomicInteger对象。然后offset是对象字段偏移量。是通过 U.objectFieldOffset(AtomicInteger.class, “value”) 取得的。</p><p>CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。这里使用的是do-while循环。这种循环不多见，它的目的是保证循环体内的语句至少会被执行一遍。这样才能保证return 的值v是我们期望的值。 </p><p>而在JDk1.8 之前，比如JDK1.7中说通过for循环实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;JDK1.7中</span><br><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;openjdk-mirror&#x2F;jdk7u-jdk&#x2F;blob&#x2F;master&#x2F;src&#x2F;share&#x2F;classes&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;atomic&#x2F;AtomicInteger.java</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Atomically adds the given value to the current value.</span><br><span class="line">     *</span><br><span class="line">     * @param delta the value to add</span><br><span class="line">     * @return the previous value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current &#x3D; get();</span><br><span class="line">            int next &#x3D; current + delta;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，两个版本最终其实是调用的我们之前说到了CAS native方法。那为什么要经过一层weakCompareAndSetInt呢？</p><blockquote><p>而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p></blockquote><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><h3 id="ABA问题及解决"><a href="#ABA问题及解决" class="headerlink" title="ABA问题及解决"></a>ABA问题及解决</h3><p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。</p><p>AtomicStampedReference类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">        expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">        ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">          newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它通控制变量的把那本来保证CAS的正确性，不过目前来说这个功能比较鸡肋，因为大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，该用传统的互斥同步可能会比原子类更高效。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。</p><blockquote><p>解决思路是让JVM支持处理器提供的pause指令：<br>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多</p></blockquote><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>有两种解决方案：</p><ul><li><p>使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</p></li><li><p>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;乐观锁与悲观锁的概念&quot;&gt;&lt;a href=&quot;#乐观锁与悲观锁的概念&quot; class=&quot;headerlink&quot; title=&quot;乐观锁与悲观锁的概念&quot;&gt;&lt;/a&gt;乐观锁与悲观锁的概念&lt;/h2&gt;&lt;p&gt;锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。&lt;/p&gt;
&lt;p&gt;悲观锁：&lt;br&gt;悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。互斥同步锁就属于悲观锁，比如， synchronized. 与 ReentrantLock.&lt;/p&gt;
&lt;p&gt;乐观锁：&lt;br&gt;乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。&lt;/p&gt;
&lt;p&gt;由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程-基础篇</title>
    <link href="https://crazyfzw.github.io/2020/11/01/concurrent-base/"/>
    <id>https://crazyfzw.github.io/2020/11/01/concurrent-base/</id>
    <published>2020-11-01T12:24:10.000Z</published>
    <updated>2021-01-17T08:03:14.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程基本概念"><a href="#进程与线程基本概念" class="headerlink" title="进程与线程基本概念"></a>进程与线程基本概念</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>在现代操作系统中，进程是操作系统进行资源分配的基本单位(内存地址、文件 I/O 等)，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。</p><p>线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p><a id="more"></a><h3 id="图解进程和线程的关心"><a href="#图解进程和线程的关心" class="headerlink" title="图解进程和线程的关心"></a>图解进程和线程的关心</h3><p><img src="/images/con01.jpg" alt="6dfd0cc256d503449d4eb2c27d727e4c.png"></p><p><a href="https://crazyfzw.github.io/2018/07/11/jvm-memory-division/">Java 虚拟机 3：Java内存模型-内存区域划分以及对象创建的过程</a></p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。</p><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p>举例说明 线程 A - B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.先挂起线程A，将其在cpu中的状态保存在内存中。</span><br><span class="line">2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</span><br><span class="line">3.当B执行完，根据程序计数器中指向的位置恢复线程A。</span><br></pre></td></tr></table></figure><p>上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>并发：一个时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行</p><p>并行：一个时间段和时间点上都有多个线程或进程在执行。<br>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p><h2 id="Java多线程入门类和接口"><a href="#Java多线程入门类和接口" class="headerlink" title="Java多线程入门类和接口"></a>Java多线程入门类和接口</h2><p>JDK提供了Thread类和Runnable接口来让我们实现自己的“线程”类。</p><ul><li>继承Thread类，并重写run方法；</li><li>实现Runnable接口的run方法；</li></ul><p>使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p><p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;MyThread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread myThread &#x3D; new MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程并进入就绪状态(Ready)，然后等到这个线程第一次得到时间片时再自动调用run()方法。</p><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<br>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>接着我们来看一下Runnable接口(JDK 1.8 +)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Runnable是一个函数式接口，这意味着我们可以使用Java 8的函数式编程来简化代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static class MyThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;MyThread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new MyThread()).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Java 8 函数式编程，可以省略MyThread类</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Java 8 匿名内部类&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h3><p>使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p><p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的是，Callable提供的方法是有返回值的，而且支持泛型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看一个简单的使用demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义Callable</span><br><span class="line">class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计算需要一秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        Task task &#x3D; new Task();</span><br><span class="line">        Future&lt;Integer&gt; result &#x3D; executor.submit(task);</span><br><span class="line">        &#x2F;&#x2F; 注意调用get方法会阻塞当前线程，直到得到结果。</span><br><span class="line">        &#x2F;&#x2F; 所以实际编码中建议使用可以设置超时时间的重载get方法。</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future接口只有几个比较简单的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract interface Future&lt;V&gt; &#123;</span><br><span class="line">    public abstract boolean cancel(boolean paramBoolean);</span><br><span class="line">    public abstract boolean isCancelled();</span><br><span class="line">    public abstract boolean isDone();</span><br><span class="line">    public abstract V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    public abstract V get(long paramLong, TimeUnit paramTimeUnit)</span><br><span class="line">            throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类来供我们使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义Callable，与上面一样</span><br><span class="line">class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计算需要一秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new Task());</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java中用ThreadGroup来表示线程组，我们可以使用线程组对线程进行批量控制。</p><p>ThreadGroup和Thread的关系就如同他们的字面意思一样简单粗暴，每个Thread必然存在于一个ThreadGroup中，Thread不能独立于ThreadGroup存在。执行main()方法线程的名字是main，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。</p><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p><p>ThreadGroup源码中的成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadGroup implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    private final ThreadGroup parent; &#x2F;&#x2F; 父亲ThreadGroup</span><br><span class="line">    String name; &#x2F;&#x2F; ThreadGroupr 的名称</span><br><span class="line">    int maxPriority; &#x2F;&#x2F; 线程最大优先级</span><br><span class="line">    boolean destroyed; &#x2F;&#x2F; 是否被销毁</span><br><span class="line">    boolean daemon; &#x2F;&#x2F; 是否守护线程</span><br><span class="line">    boolean vmAllowSuspension; &#x2F;&#x2F; 是否可以中断</span><br><span class="line"></span><br><span class="line">    int nUnstartedThreads &#x3D; 0; &#x2F;&#x2F; 还未启动的线程</span><br><span class="line">    int nthreads; &#x2F;&#x2F; ThreadGroup中线程数目</span><br><span class="line">    Thread threads[]; &#x2F;&#x2F; ThreadGroup中的线程</span><br><span class="line"></span><br><span class="line">    int ngroups; &#x2F;&#x2F; 线程组数目</span><br><span class="line">    ThreadGroup groups[]; &#x2F;&#x2F; 线程组数组</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 私有构造函数</span><br><span class="line">    private ThreadGroup() &#123; </span><br><span class="line">        this.name &#x3D; &quot;system&quot;;</span><br><span class="line">        this.maxPriority &#x3D; Thread.MAX_PRIORITY;</span><br><span class="line">        this.parent &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认是以当前ThreadGroup传入作为parent  ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。</span><br><span class="line">    public ThreadGroup(String name) &#123;</span><br><span class="line">        this(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    public ThreadGroup(ThreadGroup parent, String name) &#123;</span><br><span class="line">        this(checkParentAccess(parent), parent, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有构造函数，主要的构造函数</span><br><span class="line">    private ThreadGroup(Void unused, ThreadGroup parent, String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.maxPriority &#x3D; parent.maxPriority;</span><br><span class="line">        this.daemon &#x3D; parent.daemon;</span><br><span class="line">        this.vmAllowSuspension &#x3D; parent.vmAllowSuspension;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">        parent.add(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程组的常用方法：</p><p>1.获取当前的线程组名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup().getName()</span><br></pre></td></tr></table></figure><p>2.复制线程组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前的线程组</span><br><span class="line">ThreadGroup threadGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line">&#x2F;&#x2F; 复制一个线程组到一个线程数组（获取Thread信息）</span><br><span class="line">Thread[] threads &#x3D; new Thread[threadGroup.activeCount()];</span><br><span class="line">threadGroup.enumerate(threads);</span><br></pre></td></tr></table></figure><p>3.线程组统一异常处理示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadGroupDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadGroup threadGroup1 &#x3D; new ThreadGroup(&quot;group1&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 继承ThreadGroup并重新定义以下方法</span><br><span class="line">            &#x2F;&#x2F; 在线程成员抛出unchecked exception</span><br><span class="line">            &#x2F;&#x2F; 会执行此方法</span><br><span class="line">            public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">                System.out.println(t.getName() + &quot;: &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个线程是threadGroup1的一员</span><br><span class="line">        Thread thread1 &#x3D; new Thread(threadGroup1, new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; 抛出unchecked异常</span><br><span class="line">                throw new RuntimeException(&quot;测试异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>Java中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级是多少还是由操作系统决定。</p><p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p><p><img src="/images/con02.jpg" alt="f8c98e1047e8c73aed81e2072d12de98.png"></p><p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    &#x2F;&#x2F; 先验证优先级的合理性</span><br><span class="line">    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if((g &#x3D; getThreadGroup()) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span><br><span class="line"></span><br><span class="line">        if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line"></span><br><span class="line">            newPriority &#x3D; g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority &#x3D; newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法Thread类的setPriority()来设定线程的优先级示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a &#x3D; new Thread();</span><br><span class="line">        System.out.println(&quot;我是默认线程优先级：&quot;+a.getPriority());</span><br><span class="line">        Thread b &#x3D; new Thread();</span><br><span class="line">        b.setPriority(10);</span><br><span class="line">        System.out.println(&quot;我是设置过的线程优先级：&quot;+b.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">我是默认线程优先级：5</span><br><span class="line">我是设置过的线程优先级：10</span><br></pre></td></tr></table></figure><p>Java中的优先级来说不是特别的可靠，Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。</p><h2 id="Java线程的状态及主要转化方法"><a href="#Java线程的状态及主要转化方法" class="headerlink" title="Java线程的状态及主要转化方法"></a>Java线程的状态及主要转化方法</h2><h3 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h3><p>线程的状态在 JDK 1.5 之后以枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态包括(Running 和 Ready），表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；</li><li>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul><p>Thread.State 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEW,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 就绪状态（包括Running 和 Ready），表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span><br><span class="line">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span><br><span class="line">     * 使用 synchronized 标记的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BLOCKED,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span><br><span class="line">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span><br><span class="line">     * Object.notify() 或 Object.notifyAll()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span><br><span class="line">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span><br><span class="line">     * Thread.join(long timeout) 就会进入此状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 终止状态，表示线程已经执行完成</span><br><span class="line">     *&#x2F;</span><br><span class="line">     TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/con03.jpg" alt="2deb191023e464dd5ba70eb99517638c.png"></p><h3 id="BLOCKED-和-WAITING-的区别"><a href="#BLOCKED-和-WAITING-的区别" class="headerlink" title="BLOCKED 和 WAITING 的区别"></a>BLOCKED 和 WAITING 的区别</h3><p>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别:</p><ul><li><p>BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；</p></li><li><p>而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</p></li></ul><h3 id="调用-start-和-run-启动线程的区别"><a href="#调用-start-和-run-启动线程的区别" class="headerlink" title="调用 start() 和 run() 启动线程的区别"></a>调用 start() 和 run() 启动线程的区别</h3><ul><li><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法.</p></li><li><p>它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p></li></ul><p>Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态验证，不等于 NEW 的状态会抛出异常</span><br><span class="line">    if (threadStatus !&#x3D; 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line">    &#x2F;&#x2F; 通知线程组，此线程即将启动</span><br><span class="line">    group.add(this);</span><br><span class="line">    boolean started &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started &#x3D; true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> &#x2F;&#x2F; 忽略其他方法......</span><br><span class="line">  private Runnable target;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      if (target !&#x3D; null) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="Thread常用方法-join-和-yield-的区别"><a href="#Thread常用方法-join-和-yield-的区别" class="headerlink" title="Thread常用方法 join() 和 yield() 的区别"></a>Thread常用方法 join() 和 yield() 的区别</h3><ul><li><p>join()：使当前线程等待另一个线程执行完毕或超时之后再继续执行，内部调用的是Object类的wait方法实现的，比如：在一个线程中调用other.join()，这时候当前线程会让出执行权给other线程，直到other线程执行完或者过了超时时间之后再继续执行当前线程：</p></li><li><p>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用，使同优先级或更高优先级的线程有执行的机会,yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。不可靠，因为线程调度器不一定会采纳 yield() 出让 CPU 时间片的建议</p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>内部调用的是Object类的wait方法实现的, 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 超时时间不能小于 0</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 等于 0 表示无限等待，直到线程执行完为之</span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断子线程 (其他线程) 为活跃线程，则一直等待</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环判断</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在未使用 join() 时，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExampleWithJoin &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 6; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;子线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start(); &#x2F;&#x2F; 开启线程</span><br><span class="line">        &#x2F;&#x2F;thread.join(2000);  &#x2F;&#x2F; 等待子线程先执行 2 秒钟</span><br><span class="line">        thread.join();&#x2F;&#x2F;等待子线程先执行完毕后再执行</span><br><span class="line">        &#x2F;&#x2F; 主线程执行</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;主线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/con04.jpg" alt="30d3b398722f5e62800047c5ce503c2e.png"></p><p>从结果可以看出，在未使用 join() 时主子线程会交替执行。</p><p>然后我们再把 join() 方法加入到代码中，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExampleWithJoin &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 6; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;子线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start(); &#x2F;&#x2F; 开启线程</span><br><span class="line">        thread.join();&#x2F;&#x2F;等待子线程先执行完毕后再执行</span><br><span class="line">        &#x2F;&#x2F;thread.join(2000); &#x2F;&#x2F;则等待子线程先执行 2 秒钟</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 主线程执行</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;主线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/con05.jpg" alt="3b1ec400424c5999a335a6ebcfd8c76d.png"></p><p>从执行结果可以看出，加 join() 方法之后，主线程会先等子线程执行完之后才继续执行。</p><p>如果使用 thread.join(2000)，则运行结果如下<br><img src="/images/con06.jpg" alt="02a269c85a34854ff450c3e09dc6b94f.png"></p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用，使同优先级或更高优先级的线程有执行的机会,yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。不可靠，因为线程调度器不一定会采纳 yield() 出让 CPU 时间片的建议</p><p>Thread 的源码可以知道 yield() 为本地方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure><p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p><p>比如我们执行这段包含了 yield() 方法的代码，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExampleWithYield &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; +</span><br><span class="line">                            Thread.currentThread().getName() + &quot; I：&quot; + i);</span><br><span class="line">                    if (i &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                        Thread.yield();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 &#x3D; new Thread(runnable, &quot;T1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(runnable, &quot;T2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/con07.jpg" alt="7c3a9142eed1a56119c7b89c29d0e098.png"><br><img src="/images/con08.jpg" alt="30433da2def8bbfb044770a14b24fd3a.png"></p><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为 yield() 执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU时间片的建议。</p><h2 id="Java线程间的通信方式"><a href="#Java线程间的通信方式" class="headerlink" title="Java线程间的通信方式"></a>Java线程间的通信方式</h2><ul><li>锁与同步</li><li>等待/通知机制 Java多线程的等待/通知机制是基于Object类的wait()方法和notify(), notifyAll()方法来实现的。</li><li>信号量 JDK提供了一个类似于“信号量”功能的类Semaphore</li><li>管道 基于“管道流”的通信方式。JDK提供了PipedWriter、 PipedReader、 PipedOutputStream、 PipedInputStream。</li><li>ThreadLocal类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程与线程基本概念&quot;&gt;&lt;a href=&quot;#进程与线程基本概念&quot; class=&quot;headerlink&quot; title=&quot;进程与线程基本概念&quot;&gt;&lt;/a&gt;进程与线程基本概念&lt;/h2&gt;&lt;h3 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别&quot;&gt;&lt;/a&gt;进程与线程的区别&lt;/h3&gt;&lt;p&gt;在现代操作系统中，进程是操作系统进行资源分配的基本单位(内存地址、文件 I/O 等)，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。&lt;/p&gt;
&lt;p&gt;线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrent" scheme="https://crazyfzw.github.io/categories/Concurrent/"/>
    
    
      <category term="concurrent" scheme="https://crazyfzw.github.io/tags/concurrent/"/>
    
      <category term="并发" scheme="https://crazyfzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part7：设计模式与范式-行为型</title>
    <link href="https://crazyfzw.github.io/2020/10/15/design-pattern-behavioral-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/15/design-pattern-behavioral-pattern/</id>
    <published>2020-10-15T01:17:50.000Z</published>
    <updated>2021-01-02T07:50:20.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式-详解各种应用场景下观察者模式的不同实现方式"><a href="#观察者模式-详解各种应用场景下观察者模式的不同实现方式" class="headerlink" title="观察者模式 详解各种应用场景下观察者模式的不同实现方式"></a>观察者模式 详解各种应用场景下观察者模式的不同实现方式</h2><p>（Observer Design Pattern）</p><h3 id="观察者模式的原理"><a href="#观察者模式的原理" class="headerlink" title="观察者模式的原理"></a>观察者模式的原理</h3><p>观察者模式（Observer Design Pattern） 也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：</p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p></blockquote><p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p><a id="more"></a><h3 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h3><p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：</p><ul><li>有同步阻塞的实现方式  </li><li>也有异步非阻塞的实现方式；</li><li>有进程内的实现方式，也有跨进程的实现方式。</li></ul><p>其中，进程内的观察者模式： </p><ol><li>可以通过handleRequest中创建新的线程代码的方式实现异步非阻塞的观察者模式 </li><li>更优雅的实现方式：基于 Google Guava EventBus 框架的设计思想去实现观察者模式</li></ol><p>跨进程的观察者模式（跨系统）：<br>基于消息队列（Message Queue）来实现。</p><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>根据不同的应用场景和需求，有完全不同的实现方式。<br>下面给出一种最经典的实现方式代码模版样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">  void registerObserver(Observer observer);</span><br><span class="line">  void removeObserver(Observer observer);</span><br><span class="line">  void notifyObservers(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">  void update(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">  private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerObserver(Observer observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void removeObserver(Observer observer) &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notifyObservers(Message message) &#123;</span><br><span class="line">    for (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverOne implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverTwo implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ConcreteSubject subject &#x3D; new ConcreteSubject();</span><br><span class="line">    subject.registerObserver(new ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(new ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(new Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a>观察者模式的应用场景</h3><p>观察者主要目的是将观察者与被观察者的代码解耦，观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><h3 id="以用户注册成功后需要发放优惠券等操作为例"><a href="#以用户注册成功后需要发放优惠券等操作为例" class="headerlink" title="以用户注册成功后需要发放优惠券等操作为例"></a>以用户注册成功后需要发放优惠券等操作为例</h3><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们需要做下面几件事：</p><ol><li>发放优惠券</li><li>发送欢迎邮件<br>…</li></ol><p>一开始最简单的代码说这样的， 但是存在一个问题， 比如后面需要添加更多的动作，或者把发放优惠券改成发放体验金，就需要频繁改动 register()函数的代码，违反开闭原则。</p><p>这时候如果应用  观察者模式 重构上述代码，则会让代码的拓展性和维护性变得很好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public interface RegObserver &#123;</span><br><span class="line">  void handleRegSuccess(long userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver implements RegObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver implements RegObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改</span><br><span class="line">  public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    for (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</p><h3 id="对比一下“生产者-消费者”模型和观察者模式的区别和联系"><a href="#对比一下“生产者-消费者”模型和观察者模式的区别和联系" class="headerlink" title="对比一下“生产者 - 消费者”模型和观察者模式的区别和联系"></a>对比一下“生产者 - 消费者”模型和观察者模式的区别和联系</h3><p>发布订阅和生产消费模型最大的区别在于：发布者（可观测对象）是知道订阅者（观察对象）的存在，因为它需要遍历订阅列表去发布事件；而生产消费模型因为有中间消息代理的存在，生产者和消费者完全不知道对方的存在，完全解耦</p><h3 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h3><h4 id="Google-Guava-EventBus"><a href="#Google-Guava-EventBus" class="headerlink" title="Google Guava EventBus"></a>Google Guava EventBus</h4><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p><p>用法示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  private EventBus eventBus;</span><br><span class="line">  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式</span><br><span class="line">    eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞模式</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRegObservers(List&lt;Object&gt; observers) &#123;</span><br><span class="line">    for (Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>EventBus、AsyncEventBus：Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。</li><li>register() 函数：EventBus 类提供了 register() 函数用来注册观察者。</li><li>unregister() 函数：从 EventBus 中删除某个观察者</li><li>post() 函数：EventBus 类提供了 post() 函数，用来给观察者发送消息。</li></ul><h4 id="手把手实现一个-EventBus-框架-1"><a href="#手把手实现一个-EventBus-框架-1" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2474" alt="ce842666fa3dc92bb8f4f2d8e75d12c6.jpeg"></p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2475" alt="bf7ef52a40b1e35b18f369265caca645.jpeg"></p><p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p><p>整个小框架的代码实现包括 5 个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。具体代码在《设计模式之美》 第57讲。<br><a href="https://time.geekbang.org/column/article/211239" target="_blank" rel="noopener">https://time.geekbang.org/column/article/211239</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><p>2.具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><p>3.观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><h2 id="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"><a href="#模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用" class="headerlink" title="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"></a>模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用</h2><p>Template Method Design Pattern</p><h3 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h3><p>模板模式，全称是模板方法设计模式，在 GoF 的《设计模式》一书中，它是这么定义的：</p><blockquote><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p></blockquote><p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>一个简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method1();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method2();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo &#x3D; ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><p>templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活。</p><h3 id="模板模式作的作用"><a href="#模板模式作的作用" class="headerlink" title="模板模式作的作用"></a>模板模式作的作用</h3><p>常用在框架开发中，通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。除此之外，模板模式还可以起到代码复用的作用。</p><h4 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h4><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p><h5 id="1-Java-InputStream-对模板模式的应用"><a href="#1-Java-InputStream-对模板模式的应用" class="headerlink" title="1.Java InputStream 对模板模式的应用"></a>1.Java InputStream 对模板模式的应用</h5><p>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。</p><p>下面以 InputStream 为例， read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    if (b &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;</span><br><span class="line">      throw new IndexOutOfBoundsException();</span><br><span class="line">    &#125; else if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int c &#x3D; read();</span><br><span class="line">    if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] &#x3D; (byte)c;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (; i &lt; len ; i++) &#123;</span><br><span class="line">        c &#x3D; read();</span><br><span class="line">        if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] &#x3D; (byte)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public abstract int read() throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ByteArrayInputStream extends InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public synchronized int read() &#123;</span><br><span class="line">    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Java-AbstractList-对模版模式的应用"><a href="#2-Java-AbstractList-对模版模式的应用" class="headerlink" title="2.Java AbstractList 对模版模式的应用"></a>2.Java AbstractList 对模版模式的应用</h5><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。相当于强制了子类必须重写add方法才能使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    boolean modified &#x3D; false;</span><br><span class="line">    for (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h4><h5 id="1-Java-Servlet-对模版模式的应用"><a href="#1-Java-Servlet-对模版模式的应用" class="headerlink" title="1.Java Servlet 对模版模式的应用"></a>1.Java Servlet 对模版模式的应用</h5><p>HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><p>HttpServlet 的 service() 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    if (!(req instanceof HttpServletRequest &amp;&amp;</span><br><span class="line">            res instanceof HttpServletResponse)) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; (HttpServletRequest) req;</span><br><span class="line">    response &#x3D; (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">            &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            if (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[1];</span><br><span class="line">        errArgs[0] &#x3D; method;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面看下 基于 Servlet 来开发一个Web项目的 hello world:</strong></p><p>如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    this.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(&quot;Hello World.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外,还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><h5 id="2-JUnit-TestCase"><a href="#2-JUnit-TestCase" class="headerlink" title="2.JUnit TestCase"></a>2.JUnit TestCase</h5><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</p><p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。TestCase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TestCase extends Assert implements Test &#123;</span><br><span class="line">  public void runBare() throws Throwable &#123;</span><br><span class="line">    Throwable exception &#x3D; null;</span><br><span class="line">    setUp();</span><br><span class="line">    try &#123;</span><br><span class="line">      runTest();</span><br><span class="line">    &#125; catch (Throwable running) &#123;</span><br><span class="line">      exception &#x3D; running;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">      &#125; catch (Throwable tearingDown) &#123;</span><br><span class="line">        if (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception !&#x3D; null) throw exception;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Sets up the fixture, for example, open a network connection.</span><br><span class="line">  * This method is called before a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void setUp() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Tears down the fixture, for example, close a network connection.</span><br><span class="line">  * This method is called after a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void tearDown() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式与Callback回调函数有何区别和联系？"></a>模板模式与Callback回调函数有何区别和联系？</h3><h4 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h4><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><h4 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。在一些框架、类库、组件等的设计中经常会用到。</p><p>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p><h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p><h5 id="一个经典的回调回调代码样例"><a href="#一个经典的回调回调代码样例" class="headerlink" title="一个经典的回调回调代码样例"></a>一个经典的回调回调代码样例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface ICallback &#123;</span><br><span class="line">  void methodToCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BClass &#123;</span><br><span class="line">  public void process(ICallback callback) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    BClass b &#x3D; new BClass();</span><br><span class="line">    b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象</span><br><span class="line">      @Override</span><br><span class="line">      public void methodToCallback() &#123;</span><br><span class="line">        System.out.println(&quot;Call back me.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p><h5 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h5><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。</p><p>JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class="line"> return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class="line"> Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class="line"> if (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class="line">   ResultSet rs &#x3D; null;</span><br><span class="line">   try &#123;</span><br><span class="line">    rs &#x3D; stmt.executeQuery(sql);</span><br><span class="line">    ResultSet rsToUse &#x3D; rs;</span><br><span class="line">    if (nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">     rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return rse.extractData(rsToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">    JdbcUtils.closeResultSet(rs);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String getSql() &#123;</span><br><span class="line">   return sql;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return execute(new QueryStatementCallback());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line"></span><br><span class="line"> Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());</span><br><span class="line"> Statement stmt &#x3D; null;</span><br><span class="line"> try &#123;</span><br><span class="line">  Connection conToUse &#x3D; con;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;</span><br><span class="line">    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class="line">   conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">  &#125;</span><br><span class="line">  stmt &#x3D; conToUse.createStatement();</span><br><span class="line">  applyStatementSettings(stmt);</span><br><span class="line">  Statement stmtToUse &#x3D; stmt;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">   stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  T result &#x3D; action.doInStatement(stmtToUse);</span><br><span class="line">  handleWarnings(stmt);</span><br><span class="line">  return result;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (SQLException ex) &#123;</span><br><span class="line">  &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock</span><br><span class="line">  &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  stmt &#x3D; null;</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">  con &#x3D; null;</span><br><span class="line">  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> finally &#123;</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h5><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button button &#x3D; (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    System.out.println(&quot;I am clicked.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。</p><h4 id="回调函数的区别和联系"><a href="#回调函数的区别和联系" class="headerlink" title="回调函数的区别和联系"></a>回调函数的区别和联系</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p><p>组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li></ul><p>小结：</p><ul><li><p>共同点：<br>回调函数跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。</p></li><li><p>不同点：<br>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p></li></ul><h2 id="策略模式-如何避免冗长的if-else-switch分支判断代码？"><a href="#策略模式-如何避免冗长的if-else-switch分支判断代码？" class="headerlink" title="策略模式 如何避免冗长的if-else/switch分支判断代码？"></a>策略模式 如何避免冗长的if-else/switch分支判断代码？</h2><p>Strategy Design Pattern</p><h3 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h3><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p><h3 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h3><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><ul><li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li><li>策略的创建由工厂类来完成，封装策略创建的细节。</li><li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li></ul><h4 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h4><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">  void algorithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h4><p>策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p><p>如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的。则可以事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(&quot;A&quot;, new ConcreteStrategyA());</span><br><span class="line">    strategies.put(&quot;B&quot;, new ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return strategies.get(type);</span><br></pre></td></tr></table></figure><p>如果策略是由状态的，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，则可以按下面传统的方式创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type.equals(&quot;A&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyA();</span><br><span class="line">    &#125; else if (type.equals(&quot;B&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3.策略的使用"></a>3.策略的使用</h4><p>策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p><p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略接口：EvictionStrategy</span><br><span class="line">&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span><br><span class="line">&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory</span><br><span class="line"></span><br><span class="line">public class UserCache &#123;</span><br><span class="line">  private Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  public UserCache(EvictionStrategy eviction) &#123;</span><br><span class="line">    this.eviction &#x3D; eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略 </span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; null;</span><br><span class="line">    Properties props &#x3D; new Properties();</span><br><span class="line">    props.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));</span><br><span class="line">    String type &#x3D; props.getProperty(&quot;eviction_type&quot;);</span><br><span class="line">    evictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略 (在种事先需要知道使用哪种策略，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。)</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用策略模式组合工厂模式避免分支判断"><a href="#利用策略模式组合工厂模式避免分支判断" class="headerlink" title="利用策略模式组合工厂模式避免分支判断"></a>利用策略模式组合工厂模式避免分支判断</h3><p>下面是一种非常常见的 if-else 场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    double discount &#x3D; 0.0;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125;</span><br><span class="line">    return discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。重构代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略的定义</span><br><span class="line">public interface DiscountStrategy &#123;</span><br><span class="line">  double calDiscount(Order order);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的创建</span><br><span class="line">public class DiscountStrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的使用</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    return discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。总结下本质，就是是借助“查表法”，根据 type查表来替代根据 type 分支判断。</p><h3 id="如何实现一个支持给不同大小文件排序的小程序？"><a href="#如何实现一个支持给不同大小文件排序的小程序？" class="headerlink" title="如何实现一个支持给不同大小文件排序的小程序？"></a>如何实现一个支持给不同大小文件排序的小程序？</h3><p>案例：写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。</p><p>最小原型原则，先实现个最基础的版本，然后再在这个基础上进行迭代优化。</p><p>1.0 版本的思路：将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      quickSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      externalSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      concurrentExternalSort(filePath);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      mapreduceSort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void quickSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 快速排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void externalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void concurrentExternalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 多线程外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void mapreduceSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用MapReduce多机排序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SortingTool &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Sorter sorter &#x3D; new Sorter();</span><br><span class="line">    sorter.sortFile(args[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行拆分重构,版本2.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public interface ISortAlg &#123;</span><br><span class="line">  void sort(String filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QuickSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcurrentExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapReduceSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SortAlgFactory &#123;</span><br><span class="line">  private static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    algs.put(&quot;QuickSort&quot;, new QuickSort());</span><br><span class="line">    algs.put(&quot;ExternalSort&quot;, new ExternalSort());</span><br><span class="line">    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());</span><br><span class="line">    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ISortAlg getSortAlg(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return algs.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg;</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写完全没问题。但如果特别想将 if-else 分支判断移除掉，可以进一步优化<br>出下面。 </p><p>3.0版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line">  private static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg &#x3D; null;</span><br><span class="line">    for (AlgRange algRange : algs) &#123;</span><br><span class="line">      if (algRange.inRange(fileSize)) &#123;</span><br><span class="line">        sortAlg &#x3D; algRange.getAlg();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class AlgRange &#123;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line">    private ISortAlg alg;</span><br><span class="line"></span><br><span class="line">    public AlgRange(long start, long end, ISortAlg alg) &#123;</span><br><span class="line">      this.start &#x3D; start;</span><br><span class="line">      this.end &#x3D; end;</span><br><span class="line">      this.alg &#x3D; alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ISortAlg getAlg() &#123;</span><br><span class="line">      return alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean inRange(long size) &#123;</span><br><span class="line">      return size &gt;&#x3D; start &amp;&amp; size &lt; end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重构后，把可变的部分隔离到了策略工厂类和 Sorter 类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</strong></p><p>有没办法在添加新策略的时候避免对策略工厂类的修改呢？ </p><p>具体是这么做的：可以通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。</p><p>一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h2 id="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"><a href="#职责链模式：框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"></a>职责链模式：框架中常用的过滤器、拦截器是如何实现的？</h2><p>模板模式、策略模式、职责链模式 这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h3 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h3><p>Chain Of Responsibility Design Pattern</p><blockquote><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><h4 id="实现方式一举例：-基于抽象类实现"><a href="#实现方式一举例：-基于抽象类实现" class="headerlink" title="实现方式一举例：(基于抽象类实现)"></a>实现方式一举例：(基于抽象类实现)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor &#x3D; successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void handle() &#123;</span><br><span class="line">    boolean handled &#x3D; doHandle();</span><br><span class="line">    if (successor !&#x3D; null &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract boolean doHandle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head &#x3D; null;</span><br><span class="line">  private Handler tail &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">      head &#x3D; handler;</span><br><span class="line">      tail &#x3D; handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head !&#x3D; null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式二举例：（基于接口实现）"><a href="#实现方式二举例：（基于接口实现）" class="headerlink" title="实现方式二举例：（基于接口实现）"></a>实现方式二举例：（基于接口实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled &#x3D; handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。</p><h3 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h3><h4 id="实现可灵活扩展算法的敏感信息过滤框架"><a href="#实现可灵活扩展算法的敏感信息过滤框架" class="headerlink" title="实现可灵活扩展算法的敏感信息过滤框架"></a>实现可灵活扩展算法的敏感信息过滤框架</h4><p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface SensitiveWordFilter &#123;</span><br><span class="line">  boolean doFilter(Content content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SexyWordFilter implements SensitiveWordFilter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean doFilter(Content content) &#123;</span><br><span class="line">    boolean legal &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="line"></span><br><span class="line">public class SensitiveWordFilterChain &#123;</span><br><span class="line">  private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addFilter(SensitiveWordFilter filter) &#123;</span><br><span class="line">    this.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.</span><br><span class="line">  public boolean filter(Content content) &#123;</span><br><span class="line">    for (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      if (!filter.doFilter(content)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();</span><br><span class="line">    filterChain.addFilter(new AdsWordFilter());</span><br><span class="line">    filterChain.addFilter(new SexyWordFilter());</span><br><span class="line">    filterChain.addFilter(new PoliticalWordFilter());</span><br><span class="line"></span><br><span class="line">    boolean legal &#x3D; filterChain.filter(new Content());</span><br><span class="line">    if (!legal) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不发表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 发表</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>职责链模式降低了代码的复杂性：<br>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p><p>职责链模式让代码满足开闭原则，提高了代码的扩展性：<br>当需要添加新的过滤算法进来的时候，只需要新添加一个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。</p><p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</p><h3 id="框架中常用的过滤器、拦截器是如何实现的？"><a href="#框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="框架中常用的过滤器、拦截器是如何实现的？"></a>框架中常用的过滤器、拦截器是如何实现的？</h3><p>责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。</p><h4 id="Servlet-Filter-对职责链模式对应用"><a href="#Servlet-Filter-对职责链模式对应用" class="headerlink" title="Servlet Filter 对职责链模式对应用"></a>Servlet Filter 对职责链模式对应用</h4><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。</p><p>Servlet Filter 的工作原理<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2478" alt="3296abd63a61ebdf4eff3a6530979e21.jpeg"></p><h5 id="项目中该如何使用-Servlet-Filter-呢"><a href="#项目中该如何使用-Servlet-Filter-呢" class="headerlink" title="项目中该如何使用 Servlet Filter 呢?"></a>项目中该如何使用 Servlet Filter 呢?</h5><p>如下面的代码示例所示，添加一个过滤器，我们只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; 在创建Filter时自动调用，</span><br><span class="line">    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在销毁Filter时自动调用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在web.xml配置文件中如下配置：</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><h5 id="Servlet-Filter-的底层实现"><a href="#Servlet-Filter-的底层实现" class="headerlink" title="Servlet Filter 的底层实现"></a>Servlet Filter 的底层实现</h5><p>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。</p><p>Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final class ApplicationFilterChain implements FilterChain &#123;</span><br><span class="line">  private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter</span><br><span class="line">  private int n; &#x2F;&#x2F;filter的个数</span><br><span class="line">  private ApplicationFilterConfig[] filters;</span><br><span class="line">  private Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">    if (pos &lt; n) &#123;</span><br><span class="line">      ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br><span class="line">      Filter filter &#x3D; filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, this);&#x2F;&#x2F;这行就是递归调用了我们客户端自定义的Filter的方法</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; filter都处理完毕后，执行servlet</span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFilter(ApplicationFilterConfig filterConfig) &#123;</span><br><span class="line">    for (ApplicationFilterConfig filter:filters)</span><br><span class="line">      if (filter&#x3D;&#x3D;filterConfig)</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">    if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容</span><br><span class="line">      ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, 0, newFilters, 0, n);</span><br><span class="line">      filters &#x3D; newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] &#x3D; filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationFilterChain 的实现主要是 在FilterChai 的 doFilter 方法里面 递归调用。Filter 的  doFilter 方法。</p><h4 id="Spring-Interceptor-对职责链模式对应用"><a href="#Spring-Interceptor-对职责链模式对应用" class="headerlink" title="Spring Interceptor 对职责链模式对应用"></a>Spring Interceptor 对职责链模式对应用</h4><p>Spring Interceptor，翻译成中文就是拦截器。与 Servlet Filter 一样，都可以实现对 HTTP 请求进行拦截处理。</p><p>Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2477" alt="febaa9220cb9ad2f0aafd4e5c3c19868.jpeg"></p><p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p><h5 id="项目中该如何实现-Spring-Interceptor呢？"><a href="#项目中该如何实现-Spring-Interceptor呢？" class="headerlink" title="项目中该如何实现 Spring Interceptor呢？"></a>项目中该如何实现 Spring Interceptor呢？</h5><p>LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 继续后续的处理</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;这里总是被执行.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h5 id="Spring-Interceptor-的底层实现"><a href="#Spring-Interceptor-的底层实现" class="headerlink" title="Spring Interceptor 的底层实现"></a>Spring Interceptor 的底层实现</h5><p>andlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"> private final Object handler;</span><br><span class="line"> private HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, null);</span><br><span class="line">     return false;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">   throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    try &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">    &#125; catch (Throwable ex2) &#123;</span><br><span class="line">     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？"><a href="#AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？" class="headerlink" title="AOP、Servlet Filter、Spring Interceptor 该怎么选择？"></a>AOP、Servlet Filter、Spring Interceptor 该怎么选择？</h3><p>其实要实现一个鉴权的过滤器，通过以上3种方式都是可以去实现的，然而从粒度，场景，和方式上边有有所区别，主要采取用哪个，还是有业务来决定去用，没有统一的参考标准。比如要对所有的web接口，进行统一的权限处理，不需要区分动作，写或者读，所有一视同仁，这种情况下，servlet的更加适合。针对一些存在状态的，比如做一些统一的去参数转换，cookie转uid之类，以及通用检验uid是否符合当前权限，则很用mvc较好，而aop粒度就可以分的更加细致了，在一些更新需要，查询不需要的，如分控，日志记录等，就比较适合。</p><p>三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li><p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p></li><li><p>通过 Servlet Filter、Spring Interceptor 两个实际的例子，展示了在框架开发中职责链模式具体是怎么应用的。可以看到，职责链模式除了上面介绍的两种经典实现外，在实际使用中代码还是笔记灵活的，代码实现会根据不同的需求有所变化。</p></li></ul><h2 id="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"><a href="#状态模式：游戏、工作流引擎中常用的状态机是如何实现的？" class="headerlink" title="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"></a>状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</h2><p>Finite State Machine</p><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p><h3 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h3><p>状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>举例说明比如：马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2479" alt="5aa0310b9b3ea08794cfc2f376c8f96c.jpeg"></p><h3 id="举例说明状态及的三种实现方式"><a href="#举例说明状态及的三种实现方式" class="headerlink" title="举例说明状态及的三种实现方式"></a>举例说明状态及的三种实现方式</h3><h4 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SUPER;</span><br><span class="line">      this.score +&#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.CAPE;</span><br><span class="line">      this.score +&#x3D; 200;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.FIRE;</span><br><span class="line">      this.score +&#x3D; 300;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    if (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 100;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 200;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 300;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。</p><h4 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2480" alt="4f4ea3787bd955918578181e18173491.jpeg"></p><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public enum Event &#123;</span><br><span class="line">  GOT_MUSHROOM(0),</span><br><span class="line">  GOT_CAPE(1),</span><br><span class="line">  GOT_FIRE(2),</span><br><span class="line">  MET_MONSTER(3);</span><br><span class="line"></span><br><span class="line">  private int value;</span><br><span class="line"></span><br><span class="line">  private Event(int value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  private static final State[][] transitionTable &#x3D; &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private static final int[][] actionTable &#x3D; &#123;</span><br><span class="line">          &#123;+100, +200, +300, +0&#125;,</span><br><span class="line">          &#123;+0, +200, +300, -100&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -200&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -300&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void executeEvent(Event event) &#123;</span><br><span class="line">    int stateValue &#x3D; currentState.getValue();</span><br><span class="line">    int eventValue &#x3D; event.getValue();</span><br><span class="line">    this.currentState &#x3D; transitionTable[stateValue][eventValue];</span><br><span class="line">    this.score +&#x3D; actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h4><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p><p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。</p><p>IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public interface IMario &#123; &#x2F;&#x2F;所有状态类的接口</span><br><span class="line">  State getName();</span><br><span class="line">  &#x2F;&#x2F;以下是定义的事件</span><br><span class="line">  void obtainMushRoom();</span><br><span class="line">  void obtainCape();</span><br><span class="line">  void obtainFireFlower();</span><br><span class="line">  void meetMonster();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SmallMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SmallMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SuperMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SuperMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SuperMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SmallMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略CapeMario、FireMario类...</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; new SmallMario(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    this.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    this.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    this.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    this.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setScore(int score) &#123;</span><br><span class="line">    this.score &#x3D; score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setCurrentState(IMario currentState) &#123;</span><br><span class="line">    this.currentState &#x3D; currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式的代码实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。</p><p>针对这个问题，可以在接口和实现类中间加一层抽象类解决此问题，抽象类实现状态接口，状态类继承抽象类，只需要重写需要的方法即可。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h4 id="状态机的三个组成-状态、事件、动作"><a href="#状态机的三个组成-状态、事件、动作" class="headerlink" title="状态机的三个组成 状态、事件、动作"></a>状态机的三个组成 状态、事件、动作</h4><p>状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><h4 id="状态的三种实现方式的使用场景"><a href="#状态的三种实现方式的使用场景" class="headerlink" title="状态的三种实现方式的使用场景"></a>状态的三种实现方式的使用场景</h4><ul><li><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p></li><li><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p></li><li><p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p></li></ul><h2 id="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"><a href="#迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？" class="headerlink" title="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"></a>迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？</h2><p>Iterator Design Pattern</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p><p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p><h3 id="自己如何开发一个迭代器"><a href="#自己如何开发一个迭代器" class="headerlink" title="自己如何开发一个迭代器"></a>自己如何开发一个迭代器</h3><p>定义接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 接口定义方式一</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口定义方式二 (Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据)</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  E next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">  &#x2F;&#x2F;...省略其他接口函数...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用迭代器有哪些优势？"><a href="#使用迭代器有哪些优势？" class="headerlink" title="使用迭代器有哪些优势？"></a>使用迭代器有哪些优势？</h3><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p><ul><li><p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</p></li><li><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</p></li><li><p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p></li></ul><h3 id="遍历集合的同时，为什么不能增删集合元素？"><a href="#遍历集合的同时，为什么不能增删集合元素？" class="headerlink" title="遍历集合的同时，为什么不能增删集合元素？"></a>遍历集合的同时，为什么不能增删集合元素？</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor &lt; arrayList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;a&quot;);</span><br><span class="line">    names.add(&quot;b&quot;);</span><br><span class="line">    names.add(&quot;c&quot;);</span><br><span class="line">    names.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(&quot;a&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到第 57 行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2482" alt="d86223f2b0f996ebb2b21e5abbeceae9.jpeg"></p><p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><p>Visitor Design Pattern</p><blockquote><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p></blockquote><p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><h3 id="访问者模式实现举例"><a href="#访问者模式实现举例" class="headerlink" title="访问者模式实现举例"></a>访问者模式实现举例</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2483" alt="c42c636c5384da5bd5343618305db865.jpeg"></p><p>设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath &#x3D; filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line"></span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Extractor extractor &#x3D; new Extractor();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor &#x3D; new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h2 id="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"><a href="#备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？" class="headerlink" title="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"></a>备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？</h2><p>Memento Design Pattern</p><h3 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h3><p>备忘录模式，也叫快照（Snapshot）模式</p><blockquote><p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p></blockquote><p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h2 id="命令模式：如何利用命令模式实现一个手游后端架构？"><a href="#命令模式：如何利用命令模式实现一个手游后端架构？" class="headerlink" title="命令模式：如何利用命令模式实现一个手游后端架构？"></a>命令模式：如何利用命令模式实现一个手游后端架构？</h2><p>Command Design Pattern</p><blockquote><p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p></blockquote><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2 id="解释器模式：如何设计实现一个自定义接口告警规则功能？"><a href="#解释器模式：如何设计实现一个自定义接口告警规则功能？" class="headerlink" title="解释器模式：如何设计实现一个自定义接口告警规则功能？"></a>解释器模式：如何设计实现一个自定义接口告警规则功能？</h2><p>解释器模式的英文翻译是 Interpreter Design Pattern</p><blockquote><p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p></blockquote><p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h2 id="中介模式：什么时候用中介模式？什么时候用观察者模式？"><a href="#中介模式：什么时候用中介模式？什么时候用观察者模式？" class="headerlink" title="中介模式：什么时候用中介模式？什么时候用观察者模式？"></a>中介模式：什么时候用中介模式？什么时候用观察者模式？</h2><p>中介模式的英文翻译是 Mediator Design Pattern。</p><h3 id="中介模式的原理与实现"><a href="#中介模式的原理与实现" class="headerlink" title="中介模式的原理与实现"></a>中介模式的原理与实现</h3><blockquote><p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p></blockquote><p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2502" alt="4376d541bf17a029f37aa76009ef3a9f.jpeg"></p><h3 id="中介模式与观察者模式的区别"><a href="#中介模式与观察者模式的区别" class="headerlink" title="中介模式与观察者模式的区别"></a>中介模式与观察者模式的区别</h3><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式-详解各种应用场景下观察者模式的不同实现方式&quot;&gt;&lt;a href=&quot;#观察者模式-详解各种应用场景下观察者模式的不同实现方式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式 详解各种应用场景下观察者模式的不同实现方式&quot;&gt;&lt;/a&gt;观察者模式 详解各种应用场景下观察者模式的不同实现方式&lt;/h2&gt;&lt;p&gt;（Observer Design Pattern）&lt;/p&gt;
&lt;h3 id=&quot;观察者模式的原理&quot;&gt;&lt;a href=&quot;#观察者模式的原理&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的原理&quot;&gt;&lt;/a&gt;观察者模式的原理&lt;/h3&gt;&lt;p&gt;观察者模式（Observer Design Pattern） 也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。&lt;/p&gt;
&lt;p&gt;一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part6：设计模式与范式-结构型</title>
    <link href="https://crazyfzw.github.io/2020/10/09/design-pattern-structural-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/09/design-pattern-structural-pattern/</id>
    <published>2020-10-09T14:37:56.000Z</published>
    <updated>2021-01-02T07:50:11.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>Proxy Design Pattern</p><a id="more"></a><h3 id="代理模式的原理与实现"><a href="#代理模式的原理与实现" class="headerlink" title="代理模式的原理与实现"></a>代理模式的原理与实现</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><h3 id="代理模式的具体实现"><a href="#代理模式的具体实现" class="headerlink" title="代理模式的具体实现"></a>代理模式的具体实现</h3><h4 id="1-让代理类和原始类实现同样的接口"><a href="#1-让代理类和原始类实现同样的接口" class="headerlink" title="1.让代理类和原始类实现同样的接口"></a>1.让代理类和原始类实现同样的接口</h4><p>如果原始类已经定义了接口，则代理类实现与原始类同样的接口</p><p>案例代码（收集接口的请求信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserController &#123;</span><br><span class="line">  UserVo login(String telephone, String password);</span><br><span class="line">  UserVo register(String telephone, String password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController implements IUserController &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略login逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略register逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserControllerProxy implements IUserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line">  private UserController userController;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy(UserController userController) &#123;</span><br><span class="line">    this.userController &#x3D; userController;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 委托</span><br><span class="line">    UserVo userVo &#x3D; userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="line">&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="line">IUserController userController &#x3D; new UserControllerProxy(new UserController());</span><br></pre></td></tr></table></figure><h4 id="2-让代理类继承原始类的方法来实现代理模式"><a href="#2-让代理类继承原始类的方法来实现代理模式" class="headerlink" title="2.让代理类继承原始类的方法来实现代理模式"></a>2.让代理类继承原始类的方法来实现代理模式</h4><p>如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class UserControllerProxy extends UserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">UserController userController &#x3D; new UserControllerProxy();</span><br></pre></td></tr></table></figure><h4 id="两种实现方式的对比"><a href="#两种实现方式的对比" class="headerlink" title="两种实现方式的对比"></a>两种实现方式的对比</h4><ul><li><p>组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。</p></li><li><p>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。</p></li></ul><h3 id="动态代理的原理与实现"><a href="#动态代理的原理与实现" class="headerlink" title="动态代理的原理与实现"></a>动态代理的原理与实现</h3><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。</p><p>所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。</p><p>代码例子：（收集所有类的接口请求信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</span><br><span class="line">public class MetricsCollectorProxy &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public MetricsCollectorProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object createProxy(Object proxiedObject) &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);</span><br><span class="line">    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    public DynamicProxyHandler(Object proxiedObject) &#123;</span><br><span class="line">      this.proxiedObject &#x3D; proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">      long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      Object result &#x3D; method.invoke(proxiedObject, args);</span><br><span class="line">      long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();</span><br><span class="line">      RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MetricsCollectorProxy使用举例</span><br><span class="line">MetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();</span><br><span class="line">IUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</span><br></pre></td></tr></table></figure><p><strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</strong></p><h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><h4 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1. 业务系统的非功能性需求开发"></a>1. 业务系统的非功能性需求开发</h4><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><h4 id="2-代理模式在-RPC中的应用"><a href="#2-代理模式在-RPC中的应用" class="headerlink" title="2. 代理模式在 RPC中的应用"></a>2. 代理模式在 RPC中的应用</h4><p>RPC 框架也可以看作一种代理模式，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><h4 id="3-代理模式在缓存中的应用"><a href="#3-代理模式在缓存中的应用" class="headerlink" title="3. 代理模式在缓存中的应用"></a>3. 代理模式在缓存中的应用</h4><p>比如我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p><p>最简单的实现方法就是给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p><p>如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p><h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，只需要简单了解，见到能认识就可以。</p><h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：</p><blockquote><p>Decouple an abstraction from its implementation so that the two can vary independently。</p></blockquote><p>翻译成中文就是：将抽象和实现解耦，让它们可以独立变化。<br>弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p><p>还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><h3 id="JDBC利用桥接模式优雅实现数据库切换"><a href="#JDBC利用桥接模式优雅实现数据库切换" class="headerlink" title="JDBC利用桥接模式优雅实现数据库切换"></a>JDBC利用桥接模式优雅实现数据库切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序</span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;</span><br><span class="line">Connection con &#x3D; DriverManager.getConnection(url);</span><br><span class="line">Statement stmt &#x3D; con.createStatement()；</span><br><span class="line">String query &#x3D; &quot;select * from test&quot;;</span><br><span class="line">ResultSet rs&#x3D;stmt.executeQuery(query);</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">  rs.getString(1);</span><br><span class="line">  rs.getInt(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。</p><p>先看下 com.mysql.jdbc.Driver 的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">  static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Construct a new driver and register it with DriverManager</span><br><span class="line">   * @throws SQLException if a database error occurs.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Driver() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; Required for Class.forName().newInstance()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。</p><ul><li>第一件事情是要求 JVM 查找并加载指定的 Driver 类</li><li>第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</li></ul><p>Drivermanage代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line">  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;</span><br><span class="line">    if (driver !&#x3D; null) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(new DriverInfo(driver));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Connection getConnection(String url, String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2470" alt="812234b0717043a67c2d62ea8e783b40.jpeg"></p><p>JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p><h3 id="如何实现支持不同类型和渠道的消息推送系统？"><a href="#如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="如何实现支持不同类型和渠道的消息推送系统？"></a>如何实现支持不同类型和渠道的消息推送系统？</h3><p>一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>有两个维度，一个是不同规则，一个是不同渠道。</p><p>先看下最简单直接的代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public enum NotificationEmergencyLevel &#123;</span><br><span class="line">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Notification &#123;</span><br><span class="line">  private List&lt;String&gt; emailAddresses;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line">  private List&lt;String&gt; wechatIds;</span><br><span class="line"></span><br><span class="line">  public Notification() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public void setEmailAddress(List&lt;String&gt; emailAddress) &#123;</span><br><span class="line">    this.emailAddresses &#x3D; emailAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTelephones(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setWechatIds(List&lt;String&gt; wechatIds) &#123;</span><br><span class="line">    this.wechatIds &#x3D; wechatIds;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void notify(NotificationEmergencyLevel level, String message) &#123;</span><br><span class="line">    if (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...自动语音电话</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发微信</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p><p>按这个思路，对代码进行重构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public interface MsgSender &#123;</span><br><span class="line">  void send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TelephoneMsgSender implements MsgSender &#123;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line"></span><br><span class="line">  public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void send(String message) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WechatMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Notification &#123;</span><br><span class="line">  protected MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">  public Notification(MsgSender msgSender) &#123;</span><br><span class="line">    this.msgSender &#x3D; msgSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract void notify(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SevereNotification extends Notification &#123;</span><br><span class="line">  public SevereNotification(MsgSender msgSender) &#123;</span><br><span class="line">    super(msgSender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notify(String message) &#123;</span><br><span class="line">    msgSender.send(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UrgencyNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class NormalNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class TrivialNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>桥接看着就像是面向接口编程这一原则的原旨—将实现与抽象分离。</p><p>多个纬度独立变化那个解释倒是比较容易理解。文中举的警报的例子很贴切。紧急程度和警报的方式可以是两个不同的纬度。可以有不同的组合方式。</p><p>这与slf4j这一日志门面的设计有异曲同工之妙。slf4j其中有三个核心概念，logger,appender和encoder。分别指这个日志记录器负责哪个类的日志，日志打印到哪里以及日志打印的格式。三个纬度上可以有不同的实现，使用者可以在每一纬度上定义多个实现，配置文件中将各个纬度的某一个实现组合在一起就ok了。</p><p>一句话就是，桥接就是面向接口编程的集大成者。面向接口编程只是说在系统的某一个功能上将接口和实现解藕，而桥接是详细的分析系统功能，将各个独立的纬度都抽象出来，使用时按需组合。</p><h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>Decorator Pattern</p><h3 id="装饰器模式的理解"><a href="#装饰器模式的理解" class="headerlink" title="装饰器模式的理解"></a>装饰器模式的理解</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h3 id="装饰器的模版代码"><a href="#装饰器的模版代码" class="headerlink" title="装饰器的模版代码"></a>装饰器的模版代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-IO类库源码对装饰器模式的应用"><a href="#Java-IO类库源码对装饰器模式的应用" class="headerlink" title="Java IO类库源码对装饰器模式的应用"></a>Java IO类库源码对装饰器模式的应用</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2471" alt="507526c2e4b255a45c60722df14f9a05.jpeg"></p><p>避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void close() throws IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    throw new IOException(&quot;mark&#x2F;reset not supported&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FilterInputStream extends InputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected FilterInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read() throws IOException &#123;</span><br><span class="line">    return in.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    return in.read(b, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    return in.skip(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return in.available();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void close() throws IOException &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    in.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return in.markSupported();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BufferedInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected BufferedInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现基于缓存的读数据接口...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DataInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected DataInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现读取基本类型数据的接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2472" alt="5082df8e7d5a4d44a34811b9f562d613.jpeg"></p><h3 id="装饰器模式与代理模式的区别"><a href="#装饰器模式与代理模式的区别" class="headerlink" title="装饰器模式与代理模式的区别"></a>装饰器模式与代理模式的区别</h3><ul><li>代理模式中，代理类附加的是跟原始类无关的功能，侧重于业务无关的功能，隐藏了实现细节，是不需要使用者关注的</li></ul><ul><li>装饰器模式中，装饰器类附加的是跟原始类相关的增强功能，定制化诉求高，柔和了业务属性，后面可能改动频繁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A impelements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AProxy implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public AProxy(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);</span><br><span class="line">InputStream bin &#x3D; new BufferedInputStream(in);</span><br><span class="line">DataInputStream din &#x3D; new DataInputStream(bin);</span><br><span class="line">int data &#x3D; din.readInt();</span><br></pre></td></tr></table></figure><h3 id="添加缓存场景应该使用代理模式还说装饰者模式？"><a href="#添加缓存场景应该使用代理模式还说装饰者模式？" class="headerlink" title="添加缓存场景应该使用代理模式还说装饰者模式？"></a>添加缓存场景应该使用代理模式还说装饰者模式？</h3><ul><li><p>对于添加缓存这个应用场景使用哪种模式，要看设计者的意图，如果设计者不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之，如果设计者需要用户自己决定是否使用缓存的功能，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式。</p></li><li><p>缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活。</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>代理模式和装饰者模式都是 代码增强这一件事的落地方案。前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。</li></ul><ul><li>Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.Decorator体现多态性, Proxy体现封装性.reference:<br><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern" target="_blank" rel="noopener">https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern</a></li></ul><h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h2><p>Adapter Design Pattern</p><h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><p>ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类适配器: 基于继承</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee &#x3D; adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); &#x2F;&#x2F;委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。</p><h4 id="1-封装有缺陷的接口设计"><a href="#1-封装有缺陷的接口设计" class="headerlink" title="1. 封装有缺陷的接口设计"></a>1. 封装有缺陷的接口设计</h4><p>当我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public static void staticFunction1() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">  public void uglyNamingFunction2() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line"></span><br><span class="line">  public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">   public void lowPerformanceFunction4() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行重构</span><br><span class="line">public class ITarget &#123;</span><br><span class="line">  void function1();</span><br><span class="line">  void function2();</span><br><span class="line">  void fucntion3(ParamsWrapperDefinition paramsWrapper);</span><br><span class="line">  void function4();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="line">public class CDAdaptor extends CD implements ITarget &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void function1() &#123;</span><br><span class="line">     super.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function2() &#123;</span><br><span class="line">    super.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function3(ParamsWrapperDefinition paramsWrapper) &#123;</span><br><span class="line">     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function4() &#123;</span><br><span class="line">    &#x2F;&#x2F;...reimplement it...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-统一多个类的接口设计"><a href="#2-统一多个类的接口设计" class="headerlink" title="2. 统一多个类的接口设计"></a>2. 统一多个类的接口设计</h4><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体</p><p>例子：假设我们的系统要对用户输入的文本内容做敏感词过滤，，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class ASensitiveWordsFilter &#123; &#x2F;&#x2F; A敏感词过滤系统提供的接口</span><br><span class="line">  &#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本</span><br><span class="line">  public String filterSexyWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterPoliticalWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BSensitiveWordsFilter  &#123; &#x2F;&#x2F; B敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CSensitiveWordsFilter &#123; &#x2F;&#x2F; C敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text, String mask) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="line">public class RiskManagement &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();</span><br><span class="line">  private BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();</span><br><span class="line">  private CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText &#x3D; bFilter.filter(maskedText);</span><br><span class="line">    maskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行改造</span><br><span class="line">public interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义</span><br><span class="line">  String filter(String text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter;</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="line">&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="line">public class RiskManagement &#123; </span><br><span class="line">  private List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; text;</span><br><span class="line">    for (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText &#x3D; filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-替换依赖的外部系统"><a href="#3-替换依赖的外部系统" class="headerlink" title="3. 替换依赖的外部系统"></a>3. 替换依赖的外部系统</h4><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 外部系统A</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  void fa();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例</span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public Demo(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">Demo d &#x3D; new Demo(new A());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将外部系统A替换成外部系统B</span><br><span class="line">public class BAdaptor implemnts IA &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public BAdaptor(B b) &#123;</span><br><span class="line">    this.b&#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">  public void fa() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="line">&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="line">Demo d &#x3D; new Demo(new BAdaptor(new B()));</span><br></pre></td></tr></table></figure><h4 id="4-兼容老版本接口"><a href="#4-兼容老版本接口" class="headerlink" title="4. 兼容老版本接口"></a>4. 兼容老版本接口</h4><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">  public static Emueration emumeration(final Collection c) &#123;</span><br><span class="line">    return new Enumeration() &#123;</span><br><span class="line">      Iterator i &#x3D; c.iterator();</span><br><span class="line">      </span><br><span class="line">      public boolean hasMoreElments() &#123;</span><br><span class="line">        return i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public Object nextElement() &#123;</span><br><span class="line">        return i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-适配不同格式的数据"><a href="#5-适配不同格式的数据" class="headerlink" title="5. 适配不同格式的数据"></a>5. 适配不同格式的数据</h4><p>适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stooges &#x3D; Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br></pre></td></tr></table></figure><h3 id="剖析适配器模式在-Java-日志中的应用（Slf4j）"><a href="#剖析适配器模式在-Java-日志中的应用（Slf4j）" class="headerlink" title="剖析适配器模式在 Java 日志中的应用（Slf4j）"></a>剖析适配器模式在 Java 日志中的应用（Slf4j）</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p><p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</p><p>如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。比如引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p><p>Slf4j 就是为了解决这个问题而产生的，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。</p><p>Slf4j 的适配器实现就是一个很好的适配器模式例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; slf4j统一的接口定义</span><br><span class="line">package org.slf4j;</span><br><span class="line">public interface Logger &#123;</span><br><span class="line">  public boolean isTraceEnabled();</span><br><span class="line">  public void trace(String msg);</span><br><span class="line">  public void trace(String format, Object arg);</span><br><span class="line">  public void trace(String format, Object arg1, Object arg2);</span><br><span class="line">  public void trace(String format, Object[] argArray);</span><br><span class="line">  public void trace(String msg, Throwable t);</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled();</span><br><span class="line">  public void debug(String msg);</span><br><span class="line">  public void debug(String format, Object arg);</span><br><span class="line">  public void debug(String format, Object arg1, Object arg2)</span><br><span class="line">  public void debug(String format, Object[] argArray)</span><br><span class="line">  public void debug(String msg, Throwable t);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...省略info、warn、error等一堆接口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; log4j日志框架的适配器</span><br><span class="line">&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="line">&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，</span><br><span class="line">&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="line">package org.slf4j.impl;</span><br><span class="line">public final class Log4jLoggerAdapter extends MarkerIgnoringBase</span><br><span class="line">  implements LocationAwareLogger, Serializable &#123;</span><br><span class="line">  final transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled() &#123;</span><br><span class="line">    return logger.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg1, Object arg2) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object[] argArray) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg, Throwable t) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略一堆接口的实现...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p><p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p><ul><li><p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p></li><li><p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p></li><li><p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p></li><li><p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p></li></ul><h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h2><p>Facade Design Pattern</p><h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>接口力度太大，则会不通用，接口力度太小，又影响易用性，门面模式就是用来解决接口的可复用性（通用性）和易用性之间的矛盾的。</p><p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。</p><blockquote><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p></blockquote><p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p><p>具体的做法就是：设计接口的时候还优先考虑复用性设计成比较单一职责的细粒度接口，然后额外根据外部系统的使用场景包装一层，提供一组更加简单易用、更高层的接口，从而让接口更易用。</p><p>比如A系统提供了a b c d 4个 接口，现在系统B 完成某个业务功能需要调用系统的 a b d 接口，考虑易用性，提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。这就是门面模式的应用了。</p><h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><h4 id="1-解决易用性问题"><a href="#1-解决易用性问题" class="headerlink" title="1. 解决易用性问题"></a>1. 解决易用性问题</h4><p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p><p>实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p><h4 id="2-解决性能问题"><a href="#2-解决性能问题" class="headerlink" title="2.解决性能问题"></a>2.解决性能问题</h4><p>通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高客户端的响应速度。</p><h4 id="3-解决分布式事务问题"><a href="#3-解决分布式事务问题" class="headerlink" title="3. 解决分布式事务问题"></a>3. 解决分布式事务问题</h4><p>比如这样一个场景，在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p><h3 id="如何组织门面接口和非门面接口？"><a href="#如何组织门面接口和非门面接口？" class="headerlink" title="如何组织门面接口和非门面接口？"></a>如何组织门面接口和非门面接口？</h3><ul><li>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。</li><li>如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li></ul><h3 id="适配器模式和门面模式的区别"><a href="#适配器模式和门面模式的区别" class="headerlink" title="适配器模式和门面模式的区别"></a>适配器模式和门面模式的区别</h3><p>适配器模式和门面模式的共同点是，将不好用的接口适配成好用的接口。那他们的区别是什么？</p><ul><li>适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。是一种“补偿模式”。</li><li>门面模式做接口整合，解决的是多接口调用带来的问题。是一种事前行为，是接口设计时该考虑的。</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</li><li>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</li></ul><h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>组合模式（Composite Design Pattern）</p><h3 id="组合模式的理解："><a href="#组合模式的理解：" class="headerlink" title="组合模式的理解："></a>组合模式的理解：</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>业务场景必须能够表示成树形结构。</p><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。（在这里一般可以抽象出一个抽象类，叶子节点和中间节点（根节点）继承与抽象类，对中间节点（根节点）处理就是递归的调用）</p><h3 id="如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="如何设计实现支持递归遍历的文件系统目录树结构？"></a>如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li>动态地添加、删除某个目录下的子目录或文件；</li><li>统计指定目录下的文件个数；</li><li>统计指定目录下的文件总大小。</li></ul><p>FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class FileSystemNode &#123;</span><br><span class="line">  private String path;</span><br><span class="line">  private boolean isFile;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path, boolean isFile) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">    this.isFile &#x3D; isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      File file &#x3D; new File(path);</span><br><span class="line">      if (!file.exists()) return 0;</span><br><span class="line">      return file.length();</span><br><span class="line">    &#125;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;a.txt</span><br><span class="line">     * &#x2F;wz&#x2F;b.txt</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;c.avi</span><br><span class="line">     * &#x2F;xzg&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;d.txt</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Directory fileSystemTree &#x3D; new Directory(&quot;&#x2F;&quot;);</span><br><span class="line">    Directory node_wz &#x3D; new Directory(&quot;&#x2F;wz&#x2F;&quot;);</span><br><span class="line">    Directory node_xzg &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;&quot;);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    File node_wz_a &#x3D; new File(&quot;&#x2F;wz&#x2F;a.txt&quot;);</span><br><span class="line">    File node_wz_b &#x3D; new File(&quot;&#x2F;wz&#x2F;b.txt&quot;);</span><br><span class="line">    Directory node_wz_movies &#x3D; new Directory(&quot;&#x2F;wz&#x2F;movies&#x2F;&quot;);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    File node_wz_movies_c &#x3D; new File(&quot;&#x2F;wz&#x2F;movies&#x2F;c.avi&quot;);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    Directory node_xzg_docs &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;docs&#x2F;&quot;);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    File node_xzg_docs_d &#x3D; new File(&quot;&#x2F;xzg&#x2F;docs&#x2F;d.txt&quot;);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;&#x2F; files num:&quot; + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(&quot;&#x2F;wz&#x2F; files num:&quot; + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式 Flyweight Design Pattern</p><h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h3 id="享元模式的实现"><a href="#享元模式的实现" class="headerlink" title="享元模式的实现"></a>享元模式的实现</h3><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p><p>以利用享元模式在棋局游戏中节省内存为例：</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 享元类</span><br><span class="line">public class ChessPieceUnit &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String text;</span><br><span class="line">  private Color color;</span><br><span class="line"></span><br><span class="line">  public ChessPieceUnit(int id, String text, Color color) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.text &#x3D; text;</span><br><span class="line">    this.color &#x3D; color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static enum Color &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...省略其他属性和getter方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPieceUnitFactory &#123;</span><br><span class="line">  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;</span><br><span class="line">    return pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPiece &#123;</span><br><span class="line">  private ChessPieceUnit chessPieceUnit;</span><br><span class="line">  private int positionX;</span><br><span class="line">  private int positionY;</span><br><span class="line"></span><br><span class="line">  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;</span><br><span class="line">    this.chessPieceUnit &#x3D; unit;</span><br><span class="line">    this.positionX &#x3D; positionX;</span><br><span class="line">    this.positionY &#x3D; positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 省略getter、setter方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessBoard &#123;</span><br><span class="line">  private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public ChessBoard() &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init() &#123;</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(1), 0,0));</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(2), 1,0));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p><h3 id="如何利用享元模式优化文本编辑器的内存占用？"><a href="#如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="如何利用享元模式优化文本编辑器的内存占用？"></a>如何利用享元模式优化文本编辑器的内存占用？</h3><p>以下代码，在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Character &#123;&#x2F;&#x2F;文字</span><br><span class="line">  private char c;</span><br><span class="line"></span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public Character(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, font, size, colorRGB);</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化方案：</strong><br>在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class CharacterStyle &#123;</span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public CharacterStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean equals(Object o) &#123;</span><br><span class="line">    CharacterStyle otherStyle &#x3D; (CharacterStyle) o;</span><br><span class="line">    return font.equals(otherStyle.font)</span><br><span class="line">            &amp;&amp; size &#x3D;&#x3D; otherStyle.size</span><br><span class="line">            &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CharacterStyleFactory &#123;</span><br><span class="line">  private static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    CharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);</span><br><span class="line">    for (CharacterStyle style : styles) &#123;</span><br><span class="line">      if (style.equals(newStyle)) &#123;</span><br><span class="line">        return style;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    styles.add(newStyle);</span><br><span class="line">    return newStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Character &#123;</span><br><span class="line">  private char c;</span><br><span class="line">  private CharacterStyle style;</span><br><span class="line"></span><br><span class="line">  public Character(char c, CharacterStyle style) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.style &#x3D; style;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="享元模式-VS-单例、缓存、对象池-的区别"><a href="#享元模式-VS-单例、缓存、对象池-的区别" class="headerlink" title="享元模式 VS 单例、缓存、对象池 的区别"></a>享元模式 VS 单例、缓存、对象池 的区别</h3><p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。</p><ul><li><p>应用单例模式是为了保证对象全局唯一。</p></li><li><p>应用享元模式是为了实现对象复用，节省内存。享元模式中的“复用”可以理解为“共享使用”。</p></li><li><p>缓存是为了提高访问效率，而非复用。</p></li><li><p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。比如对象池，线程池</p></li></ul><p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p><h3 id="剖析享元模式在Java-Integer、String中的应用"><a href="#剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="剖析享元模式在Java Integer、String中的应用"></a>剖析享元模式在Java Integer、String中的应用</h3><h4 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h4><p>自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 56; &#x2F;&#x2F;自动装箱</span><br><span class="line">int j &#x3D; i; &#x2F;&#x2F;自动拆箱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i &#x3D; 56；底层执行了：Integer i &#x3D; Integer.valueOf(56);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j &#x3D; i; 底层执行了：int j &#x3D; i.intValue();</span><br></pre></td></tr></table></figure><p>为什么下面代码的运行结果为 一个 true, 一个false？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 &#x3D; 56;</span><br><span class="line">Integer i2 &#x3D; 56;</span><br><span class="line">Integer i3 &#x3D; 129;</span><br><span class="line">Integer i4 &#x3D; 129;</span><br><span class="line">System.out.println(i1 &#x3D;&#x3D; i2);</span><br><span class="line">System.out.println(i3 &#x3D;&#x3D; i4);</span><br></pre></td></tr></table></figure><p>这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建，Integer 类的 valueOf() 函数的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntegerCache 则是生产享元对象的工厂类 （只说名字不叫XXXFactory），代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">        int h &#x3D; 127;</span><br><span class="line">        String integerCacheHighPropValue &#x3D;</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">                i &#x3D; Math.max(i, 127);</span><br><span class="line">                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high &#x3D; h;</span><br><span class="line"></span><br><span class="line">        cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">        int j &#x3D; low;</span><br><span class="line">        for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] &#x3D; new Integer(j++);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。不过 JDK 也提供了方法来让我们可以自定义缓存的最大值(没有提供设置最小值的方法)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure><p>除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。比如 Long 类型对应的 LongCache 享元工厂类及 valueOf()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static class LongCache &#123;</span><br><span class="line">    private LongCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] &#x3D; new Long(i - 128);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Long valueOf(long l) &#123;</span><br><span class="line">    final int offset &#x3D; 128;</span><br><span class="line">    if (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; &#x2F;&#x2F; will cache</span><br><span class="line">        return LongCache.cache[(int)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面三种创建对象的方式，推荐使用哪种？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; new Integer(123);</span><br><span class="line">Integer a &#x3D; 123;</span><br><span class="line">Integer a &#x3D; Integer.valueOf(123);</span><br></pre></td></tr></table></figure><p>答案是推荐使用后面两种，第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p><h4 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s2 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;小争哥&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);  &#x2F;&#x2F;运行结果为：true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);  &#x2F;&#x2F;运行结果为：false</span><br></pre></td></tr></table></figure><p>跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2473" alt="2dfc18575c22efccca191c566b24a22d.jpeg"></p><h4 id="String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？"><a href="#String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？" class="headerlink" title="String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？"></a>String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？</h4><ul><li><p>Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。</p></li><li><p>对于字符串来说，没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。&lt;/p&gt;
&lt;h2 id=&quot;代理模式：代理在RPC、缓存、监控等场景中的应用&quot;&gt;&lt;a href=&quot;#代理模式：代理在RPC、缓存、监控等场景中的应用&quot; class=&quot;headerlink&quot; title=&quot;代理模式：代理在RPC、缓存、监控等场景中的应用&quot;&gt;&lt;/a&gt;代理模式：代理在RPC、缓存、监控等场景中的应用&lt;/h2&gt;&lt;p&gt;Proxy Design Pattern&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part5：设计模式与范式-创建型</title>
    <link href="https://crazyfzw.github.io/2020/10/09/design-pattern-creational-pattern/"/>
    <id>https://crazyfzw.github.io/2020/10/09/design-pattern-creational-pattern/</id>
    <published>2020-10-09T03:32:23.000Z</published>
    <updated>2021-01-02T07:50:06.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><ul><li><p>单例模式用来创建全局唯一的对象。</p></li><li><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p></li><li><p>建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p></li><li><p>原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p></li></ul><a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h3 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h3><h4 id="处理资源访问冲突"><a href="#处理资源访问冲突" class="headerlink" title="处理资源访问冲突"></a>处理资源访问冲突</h4><p>可以使用单例解决资源访问冲突的问题。</p><p>案例：实现了一个往文件中打印日志的 Logger 类</p><p>第一版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(&quot;Created an order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2466" alt="2b0e6141d10399430c59169af4edc3c2.jpeg"></p><p>改造一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2467" alt="203eb5070c3820b48500d4ab95732f29.jpeg"></p><p>FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题。</p><h5 id="通过类级别的锁解决日志覆盖问题"><a href="#通过类级别的锁解决日志覆盖问题" class="headerlink" title="通过类级别的锁解决日志覆盖问题"></a>通过类级别的锁解决日志覆盖问题</h5><p>把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。</p><p>单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(Logger.class) &#123; &#x2F;&#x2F; 类级别的锁</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过单例更优雅的解决日志覆盖问题"><a href="#通过单例更优雅的解决日志覆盖问题" class="headerlink" title="通过单例更优雅的解决日志覆盖问题"></a>通过单例更优雅的解决日志覆盖问题</h5><p>将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  private static final Logger instance &#x3D; new Logger();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static Logger getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表示全局唯一类"><a href="#表示全局唯一类" class="headerlink" title="表示全局唯一类"></a>表示全局唯一类</h4><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。</p><p>案例：实现一个唯一递增 ID 号码生成器</p><p>如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">public class IdGenerator &#123;</span><br><span class="line">  &#x2F;&#x2F; AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br><span class="line">  &#x2F;&#x2F; 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br><span class="line">  &#x2F;&#x2F; 比如下面会用到的incrementAndGet().</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">long id &#x3D; IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure><h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>要实现一个单例，主要关下面几个要点：</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><h4 id="饿汉式-不支持延迟加载"><a href="#饿汉式-不支持延迟加载" class="headerlink" title="饿汉式(不支持延迟加载)"></a>饿汉式(不支持延迟加载)</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式（支持延迟加载、并发度低）"><a href="#懒汉式（支持延迟加载、并发度低）" class="headerlink" title="懒汉式（支持延迟加载、并发度低）"></a>懒汉式（支持延迟加载、并发度低）</h4><p>懒汉式相对于饿汉式的优势是支持延迟加载。给 getInstance() 这个方法加了一把大锁（synchronzed），这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static synchronized IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      instance &#x3D; new IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检测-（支持延迟加载，支持高并发）"><a href="#双重检测-（支持延迟加载，支持高并发）" class="headerlink" title="双重检测 （支持延迟加载，支持高并发）"></a>双重检测 （支持延迟加载，支持高并发）</h4><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">          instance &#x3D; new IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低版本的JDK 因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。可以通过给 instance 成员变量加上 volatile 关键字，禁止指令重排序解决这个问题。  </p><p>需要注意的是高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p><h4 id="静态内部类-既保证了线程安全，又能做到延迟加载"><a href="#静态内部类-既保证了线程安全，又能做到延迟加载" class="headerlink" title="静态内部类 (既保证了线程安全，又能做到延迟加载)"></a>静态内部类 (既保证了线程安全，又能做到延迟加载)</h4><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评论区给出的一种Spring-源码中的实现"><a href="#评论区给出的一种Spring-源码中的实现" class="headerlink" title="评论区给出的一种Spring 源码中的实现"></a>评论区给出的一种Spring 源码中的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ublic class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance&#x3D;null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;&#x2F;&#x2F;</span><br><span class="line">        Singleton temp&#x3D;instance; &#x2F;&#x2F; 为什么要用局部变量来接收</span><br><span class="line">        if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                temp&#x3D;instance;</span><br><span class="line">                if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">                    temp&#x3D;new Singleton();</span><br><span class="line">                    instance&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring源码 如 ReactiveAdapterRegistry。<br>JDK 源码 如 AbstractQueuedSynchronizer。<br>很多地方 都有用 局部变量 来接收 静态的成员变量， 请问下 这么写有什么性能上的优化点吗？</p><p>Using localRef, we are reducing the access of volatile variable to just one for positive usecase. If we do not use localRef, then we would have to access volatile variable twice - once for checking null and then at method return time.<br>Accessing volatile memory is quite an expensive affair because it involves reaching out to main memory.<br>参考链接：<a href="https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6" target="_blank" rel="noopener">https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6</a></p><h3 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h3><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h3 id="有何替代的解决方案？"><a href="#有何替代的解决方案？" class="headerlink" title="有何替代的解决方案？"></a>有何替代的解决方案？</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h3 id="如何设计实现一个集群环境下的分布式单例模式？"><a href="#如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="如何设计实现一个集群环境下的分布式单例模式？"></a>如何设计实现一个集群环境下的分布式单例模式？</h3><h4 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h4><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><h4 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h4><p>通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    Long currentThreadId &#x3D; Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, new IdGenerator());</span><br><span class="line">    return instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long getId() &#123;</span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h4><p>这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><p>实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);</span><br><span class="line">  private static DistributedLock lock &#x3D; new DistributedLock();</span><br><span class="line">  </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static IdGenerator getInstance() </span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      instance &#x3D; storage.load(IdGenerator.class);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchroinzed void freeInstance() &#123;</span><br><span class="line">    storage.save(this, IdGeneator.class);</span><br><span class="line">    instance &#x3D; null; &#x2F;&#x2F;释放对象</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">IdGenerator idGeneator &#x3D; IdGenerator.getInstance();</span><br><span class="line">long id &#x3D; idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure><h4 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h4><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><h5 id="创建指定数量的对象："><a href="#创建指定数量的对象：" class="headerlink" title="创建指定数量的对象："></a>创建指定数量的对象：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BackendServer &#123;</span><br><span class="line">  private long serverNo;</span><br><span class="line">  private String serverAddress;</span><br><span class="line"></span><br><span class="line">  private static final int SERVER_COUNT &#x3D; 3;</span><br><span class="line">  private static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));</span><br><span class="line">    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));</span><br><span class="line">    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private BackendServer(long serverNo, String serverAddress) &#123;</span><br><span class="line">    this.serverNo &#x3D; serverNo;</span><br><span class="line">    this.serverAddress &#x3D; serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getInstance(long serverNo) &#123;</span><br><span class="line">    return serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getRandomInstance() &#123;</span><br><span class="line">    Random r &#x3D; new Random();</span><br><span class="line">    int no &#x3D; r.nextInt(SERVER_COUNT)+1;</span><br><span class="line">    return serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不同类型创建多个对象"><a href="#不同类型创建多个对象" class="headerlink" title="不同类型创建多个对象"></a>不同类型创建多个对象</h5><p>对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private static final ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static Logger getInstance(String loggerName) &#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, new Logger());</span><br><span class="line">    return instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void log() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3</span><br><span class="line">Logger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</span><br></pre></td></tr></table></figure><h3 id="如何理解单例类对象的唯一性的作用范围是类加载器"><a href="#如何理解单例类对象的唯一性的作用范围是类加载器" class="headerlink" title="如何理解单例类对象的唯一性的作用范围是类加载器"></a>如何理解单例类对象的唯一性的作用范围是类加载器</h3><p>对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）,怎么理解？</p><p>java中，两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。单例类对象的唯一性前提也必须保证该类被同一个类加载器加载！</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如 Java 中的 Calendar、DateFormat 类。</p><p>工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。</p><h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>例子： 根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><p>简单工厂的第一种实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    if (parser &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(</span><br><span class="line">              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    IRuleConfigParser parser &#x3D; null;</span><br><span class="line">    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new JsonRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new XmlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new YamlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p><p>简单工厂的第二种实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;</span><br><span class="line">      return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>可以利用多态去掉if分支逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface IRuleConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createParser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    if (parserFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="line">&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="line">public class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂</span><br><span class="line">  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParserFactory getParserFactory(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());</span><br><span class="line">    return parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface IConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createRuleParser();</span><br><span class="line">  ISystemConfigParser createSystemParser();</span><br><span class="line">  &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="什么时候该用工厂模式？"><a href="#什么时候该用工厂模式？" class="headerlink" title="什么时候该用工厂模式？"></a>什么时候该用工厂模式？</h4><ul><li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</p></li><li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p></li></ul><p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p><h4 id="复杂度无法被消除，只能被转移："><a href="#复杂度无法被消除，只能被转移：" class="headerlink" title="复杂度无法被消除，只能被转移："></a>复杂度无法被消除，只能被转移：</h4><ul><li>不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起</li><li>简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中</li><li>工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中</li></ul><h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。</p><p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><p>DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p><h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><h3 id="如何实现一个简单的DI容器"><a href="#如何实现一个简单的DI容器" class="headerlink" title="如何实现一个简单的DI容器"></a>如何实现一个简单的DI容器</h3><p>一个简单的 DI 容器的实现原理，核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h4 id="1-最小原型设计"><a href="#1-最小原型设计" class="headerlink" title="1.最小原型设计"></a>1.最小原型设计</h4><p>配置文件beans.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">            &quot;beans.xml&quot;);</span><br><span class="line">    RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-执行入口"><a href="#2-执行入口" class="headerlink" title="2.执行入口"></a>2.执行入口</h4><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口ClassPathXmlApplicationContext 是接口的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">  Object getBean(String beanId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;</span><br><span class="line">  private BeansFactory beansFactory;</span><br><span class="line">  private BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  public ClassPathXmlApplicationContext(String configLocation) &#123;</span><br><span class="line">    this.beansFactory &#x3D; new BeansFactory();</span><br><span class="line">    this.beanConfigParser &#x3D; new XmlBeanConfigParser();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void loadBeanDefinitions(String configLocation) &#123;</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);</span><br><span class="line">      if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO: log error</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    return beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h4 id="3-配置文件解析"><a href="#3-配置文件解析" class="headerlink" title="3.配置文件解析"></a>3.配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanConfigParser &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(InputStream inputStream);</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(String configContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlBeanConfigParser implements BeanConfigParser &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;</span><br><span class="line">    String content &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(String configContent) &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private String className;</span><br><span class="line">  private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  private Scope scope &#x3D; Scope.SINGLETON;</span><br><span class="line">  private boolean lazyInit &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line"> </span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static enum Scope &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class ConstructorArg &#123;</span><br><span class="line">    private boolean isRef;</span><br><span class="line">    private Class type;</span><br><span class="line">    private Object arg;</span><br><span class="line">    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-核心工厂类设计"><a href="#4-核心工厂类设计" class="headerlink" title="4.核心工厂类设计"></a>4.核心工厂类设计</h4><p>BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class BeansFactory &#123;</span><br><span class="line">  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;</span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);</span><br><span class="line">    if (beanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    return createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected Object createBean(BeanDefinition beanDefinition) &#123;</span><br><span class="line">    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object bean &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();</span><br><span class="line">      if (args.isEmpty()) &#123;</span><br><span class="line">        bean &#x3D; beanClass.newInstance();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Class[] argClasses &#x3D; new Class[args.size()];</span><br><span class="line">        Object[] argObjects &#x3D; new Object[args.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg &#x3D; args.get(i);</span><br><span class="line">          if (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] &#x3D; arg.getType();</span><br><span class="line">            argObjects[i] &#x3D; arg.getArg();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());</span><br><span class="line">            if (refBeanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] &#x3D; createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      throw new BeanCreationFailureException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。</p><h3 id="1-使用场景："><a href="#1-使用场景：" class="headerlink" title="1.使用场景："></a>1.使用场景：</h3><ul><li>类的构造函数必填属性很多，通过set设置，没有办法校验必填属性</li><li>如果类的属性之间有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验</li><li>需要创建不可变对象，不能暴露set方法。<br>（前提是需要传递很多的属性，如果属性很少，可以不需要建造者模式）</li></ul><h3 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2.实现方式："></a>2.实现方式：</h3><p>把构造函数定义为private，定义public static class Builder 内部类，通过Builder 类的set方法设置属性，调用build方法创建对象。</p><p>比如：</p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal;</span><br><span class="line">  private int maxIdle;</span><br><span class="line">  private int minIdle;</span><br><span class="line"></span><br><span class="line">  private ResourcePoolConfig(Builder builder) &#123;</span><br><span class="line">    this.name &#x3D; builder.name;</span><br><span class="line">    this.maxTotal &#x3D; builder.maxTotal;</span><br><span class="line">    this.maxIdle &#x3D; builder.maxIdle;</span><br><span class="line">    this.minIdle &#x3D; builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br><span class="line">  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">    private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    public ResourcePoolConfig build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new ResourcePoolConfig(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxTotal(int maxTotal) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxIdle(int maxIdle) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMinIdle(int minIdle) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="line">ResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(&quot;dbconnectionpool&quot;)</span><br><span class="line">        .setMaxTotal(16)</span><br><span class="line">        .setMaxIdle(10)</span><br><span class="line">        .setMinIdle(12)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="3-和工厂模式的区别："><a href="#3-和工厂模式的区别：" class="headerlink" title="3.和工厂模式的区别："></a>3.和工厂模式的区别：</h3><ul><li>工厂模式：创建不同的同一类型对象（集成同一个父类或是接口的一组子类），由给定的参数来创建哪种类型的对象；</li><li>建造者模式：创建一种类型的复杂对象，通过很多可设置参数，“定制化”的创建对象</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1.什么是原型模式"></a>1.什么是原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><h3 id="2-原型模式的两种实现方法"><a href="#2-原型模式的两种实现方法" class="headerlink" title="2.原型模式的两种实现方法"></a>2.原型模式的两种实现方法</h3><p>原型模式有两种实现方法，深拷贝和浅拷贝。</p><ul><li>浅拷贝只会复制对象中基本数据类型数据（比如，int、long）和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2468" alt="74bceb7a0736957daaa4abeba6826182.jpeg"></li></ul><ul><li>深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2469" alt="b978d054ab3183b9e0ae461e6abac81b.jpeg"></li></ul><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险。</p><h3 id="实现深拷贝的两种常见方式"><a href="#实现深拷贝的两种常见方式" class="headerlink" title="实现深拷贝的两种常见方式"></a>实现深拷贝的两种常见方式</h3><p>那如何实现深拷贝呢？</p><p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。</p><p>第二种方法：先将对象序列化，然后再反序列化成新的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object deepCopy(Object object) &#123;</span><br><span class="line">  ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line">  </span><br><span class="line">  ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">  ObjectInputStream oi &#x3D; new ObjectInputStream(bi);</span><br><span class="line">  </span><br><span class="line">  return oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-如何最快速地clone一个包含10万数据的HashMap散列表"><a href="#3-如何最快速地clone一个包含10万数据的HashMap散列表" class="headerlink" title="3.如何最快速地clone一个包含10万数据的HashMap散列表"></a>3.如何最快速地clone一个包含10万数据的HashMap散列表</h3><p>使用深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Deep copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">      SearchWord searchWord &#x3D; e.getValue();</span><br><span class="line">      SearchWord newSearchWord &#x3D; new SearchWord(</span><br><span class="line">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class="line">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这种特别大数据量大场景，有没有更快、更省内存的实现方式呢？</p><p>方案是：先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。</p><p>优化代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Shallow copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">      &#125;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-什么时候该用深拷贝，什么时候该用还是浅拷贝"><a href="#4-什么时候该用深拷贝，什么时候该用还是浅拷贝" class="headerlink" title="4.什么时候该用深拷贝，什么时候该用还是浅拷贝"></a>4.什么时候该用深拷贝，什么时候该用还是浅拷贝</h3><ul><li>当需要复制的对象只包含基本类型数据的时候，或者要考呗的对象是不可变对象的时候 选择使用浅拷贝。</li><li>当需要拷贝的对象包含其他对象的时候，使用深拷贝</li></ul><p>不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间，当数量特别大的时候也可以使用案例的优化方式，但没有充分的理由，在包含对象的时候，不要为了一点点的性能提升而使用浅拷贝。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单例模式用来创建全局唯一的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）</title>
    <link href="https://crazyfzw.github.io/2020/10/08/design-pattern05/"/>
    <id>https://crazyfzw.github.io/2020/10/08/design-pattern05/</id>
    <published>2020-10-08T11:57:23.000Z</published>
    <updated>2020-12-22T05:21:49.298Z</updated>
    
    <content type="html"><![CDATA[<p>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。</p><a id="more"></a><h2 id="如何写出高质量的代码"><a href="#如何写出高质量的代码" class="headerlink" title="如何写出高质量的代码"></a>如何写出高质量的代码</h2><p><img src="/images/dp01.png" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p><h2 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h2><p><img src="/images/dp02.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b.jpeg"></p><h2 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h2><p><img src="/images/dp03.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7.jpeg"></p><h3 id="面向对象的四大特性"><a href="#面向对象的四大特性" class="headerlink" title="面向对象的四大特性"></a>面向对象的四大特性</h3><ul><li><p>封装<br>封装主要讲如何隐藏信息、保护数据。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p></li><li><p>抽象<br>抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p></li><li><p>继承<br>继承用来表示类之间的 is-a 关系，继承主要是用来解决代码复用的问题。</p></li><li><p>多态<br>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p></li></ul><h3 id="面向对象-VS-面向过程"><a href="#面向对象-VS-面向过程" class="headerlink" title="面向对象 VS 面向过程"></a>面向对象 VS 面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个：</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h3 id="面向对象分析、设计与编程"><a href="#面向对象分析、设计与编程" class="headerlink" title="面向对象分析、设计与编程"></a>面向对象分析、设计与编程</h3><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。面向对象分析就是要搞清楚做什么，产出是详细的需求描述；面向对象设计就是要搞清楚怎么做，产出是类；面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul><li><p>划分职责进而识别出有哪些类<br>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p></li><li><p>定义类及其属性和方法<br>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p></li><li><p>定义类与类之间的交互关系<br>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。（需要注意聚合和组合的区别）</p></li><li><p>将类组装起来并提供执行入口<br>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p></li></ul><h3 id="接口-vs-抽象类"><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h3><p>可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p><p>接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？<br>实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h3 id="基于接口而非实现编程（即基于抽象而非实现编程）"><a href="#基于接口而非实现编程（即基于抽象而非实现编程）" class="headerlink" title="基于接口而非实现编程（即基于抽象而非实现编程）"></a>基于接口而非实现编程（即基于抽象而非实现编程）</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>组合相比继承有哪些优势？<br>继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。但是继承容易出现层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p>而通过组合、接口、委托三个技术就可以在实现继承功能的同时，解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p>如何判断该用组合还是继承？<br>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="贫血模型-VS-充血模型"><a href="#贫血模型-VS-充血模型" class="headerlink" title="贫血模型 VS 充血模型"></a>贫血模型 VS 充血模型</h3><p>对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。  而对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><h2 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h2><p><img src="/images/dp04.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f.jpeg"></p><h3 id="1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）"><a href="#1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）"></a>1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><h3 id="2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）"><a href="#2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）" class="headerlink" title="2.SOLID 原则：OCP 开闭原则（Open Closed Principle）"></a>2.SOLID 原则：OCP 开闭原则（Open Closed Principle）</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><p>两点要注意：</p><ul><li>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li><li>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li></ul><h3 id="3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）"><a href="#3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）"></a>3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>里式替换原则跟多态的区别：</p><ul><li>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</li><li>里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li></ul><h3 id="4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）"><a href="#4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）" class="headerlink" title="4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）"></a>4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。</p><ul><li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li><li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li><li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</li></ul><p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h3 id="5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）"><a href="#5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）" class="headerlink" title="5.DIP 依赖倒置原则 （Dependency Inversion Principle）"></a>5.DIP 依赖倒置原则 （Dependency Inversion Principle）</h3><p>依赖反转原则也叫作依赖倒置原则。主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h3 id="6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）"><a href="#6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）" class="headerlink" title="6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）"></a>6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）</h3><h4 id="Keep-It-Simple-and-Stupid"><a href="#Keep-It-Simple-and-Stupid" class="headerlink" title="Keep It Simple and Stupid"></a>Keep It Simple and Stupid</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段</p><p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p><ul><li>不要使用同事可能不懂的技术来实现代码；</li><li>不要重复造轮子，善于使用已经有的工具类库；</li><li>不要过度优化。</li></ul><h4 id="You-Ain’t-Gonna-Need-It"><a href="#You-Ain’t-Gonna-Need-It" class="headerlink" title="You Ain’t Gonna Need It"></a>You Ain’t Gonna Need It</h4><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h3 id="7-DRY-原则（Don’t-Repeat-Yourself）"><a href="#7-DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="7.DRY 原则（Don’t Repeat Yourself）"></a>7.DRY 原则（Don’t Repeat Yourself）</h3><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，</p><ul><li>功能语义不重复的代码，并不违反 DRY 原则。</li><li>实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。</li><li>代码执行重复也算是违反 DRY 原则。</li></ul><h3 id="8-LOD-迪米特法则（Law-of-Demeter）"><a href="#8-LOD-迪米特法则（Law-of-Demeter）" class="headerlink" title="8.LOD 迪米特法则（Law of Demeter）"></a>8.LOD 迪米特法则（Law of Demeter）</h3><p>迪米特法则的描述为：</p><ul><li>不该有直接依赖关系的类之间，不要有依赖；</li><li>有依赖关系的类之间，尽量只依赖必要的接口。</li></ul><p>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p><ul><li><p>高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</p></li><li><p>松耦合，指的是在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p></li></ul><h2 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h2><p><img src="/images/dp05.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a.jpeg"></p><h3 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1.重构概述"></a>1.重构概述</h3><h4 id="重构的目的：为什么重构（why）？"><a href="#重构的目的：为什么重构（why）？" class="headerlink" title="重构的目的：为什么重构（why）？"></a>重构的目的：为什么重构（why）？</h4><p>重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p><h4 id="重构的对象：重构什么（what）？"><a href="#重构的对象：重构什么（what）？" class="headerlink" title="重构的对象：重构什么（what）？"></a>重构的对象：重构什么（what）？</h4><p>可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p><ul><li>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</li><li></li><li>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</li></ul><h4 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><h4 id="重构的方法：如何重构（how）？"><a href="#重构的方法：如何重构（how）？" class="headerlink" title="重构的方法：如何重构（how）？"></a>重构的方法：如何重构（how）？</h4><ul><li><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。</p></li><li><p>小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p></li></ul><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><h4 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h4><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。这个“单元”一般是类或函数，而不是模块或者系统。</p><h4 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h4><p>单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。</p><h4 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h4><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。</p><p>对于单元测试，我们需要建立以下正确的认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低单元测试的质量要求；</li><li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li><li>写单元测试一般不需要了解代码的实现逻辑；</li><li>单元测试框架无法测试多半是代码的可测试性不好。</li></ul><h4 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h4><ul><li>写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。</li><li>国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，</li><li>没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</li></ul><h3 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3.代码的可测试性"></a>3.代码的可测试性</h3><h4 id="什么是代码的可测试性？"><a href="#什么是代码的可测试性？" class="headerlink" title="什么是代码的可测试性？"></a>什么是代码的可测试性？</h4><p>所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><h4 id="编写可测试性代码的最有效手段"><a href="#编写可测试性代码的最有效手段" class="headerlink" title="编写可测试性代码的最有效手段"></a>编写可测试性代码的最有效手段</h4><ul><li><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p></li><li><p>除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况</p></li></ul><h4 id="典型的、常见的测试不友好的代码（Anti-Patterns）"><a href="#典型的、常见的测试不友好的代码（Anti-Patterns）" class="headerlink" title="典型的、常见的测试不友好的代码（Anti-Patterns）"></a>典型的、常见的测试不友好的代码（Anti-Patterns）</h4><ul><li>代码中包含未决行为逻辑；</li><li>滥用可变全局变量；</li><li>滥用静态方法；</li><li>使用复杂的继承关系；</li><li>高度耦合的代码。</li></ul><h3 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h3><p>解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><h4 id="如何判断代码是否需要解耦？"><a href="#如何判断代码是否需要解耦？" class="headerlink" title="如何判断代码是否需要解耦？"></a>如何判断代码是否需要解耦？</h4><p>间接的衡量：</p><ul><li>比如改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动</li><li>代码的可测试性是否好等等</li></ul><h4 id="如何给代码进行解耦"><a href="#如何给代码进行解耦" class="headerlink" title="如何给代码进行解耦"></a>如何给代码进行解耦</h4><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。还有一些设计模式，比如观察者模式。</p><h3 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h3><p>持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><h4 id="命名与注释"><a href="#命名与注释" class="headerlink" title="命名与注释"></a>命名与注释</h4><ul><li><p>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</p></li><li><p>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p></li><li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。接口有两种命名方式。</p></li><li><p>一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</p></li><li><p>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p></li><li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</p></li></ul><h4 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h4><ul><li>将复杂的逻辑提炼拆分成函数和类；</li><li>通过拆分成多个函数的方式来处理参数过多的情况；</li><li>通过将参数封装为对象来处理参数过多的情况；</li><li>函数中不要使用参数来做代码执行逻辑的控制；</li><li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li><li>用字面常量取代魔法数；</li><li>利用解释性变量来解释复杂表达式。</li></ul><h4 id="统一代码风格、编码规范"><a href="#统一代码风格、编码规范" class="headerlink" title="统一代码风格、编码规范"></a>统一代码风格、编码规范</h4><p>最好能跟业内推荐的风格、开源项目的代码风格相一致，然后在公司内部形成统一，比如可以参照<br><a href="https://ucc-private-download.oss-cn-beijing.aliyuncs.com/66995068b45c4ebfa74afcfc2e76212c.pdf?Expires=1607054448&OSSAccessKeyId=LTAIvsP3ECkg4Nm9&Signature=KOnMQdpuOGJtZVeyIrGlDxkXIlU%3D" target="_blank" rel="noopener">阿里《Java开发手册（嵩山版）》</a></p><h4 id="阿里-Java开发手册（嵩山版）"><a href="#阿里-Java开发手册（嵩山版）" class="headerlink" title="阿里 Java开发手册（嵩山版）"></a>阿里 Java开发手册（嵩山版）</h4><p><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part4：规范与重构</title>
    <link href="https://crazyfzw.github.io/2020/10/07/design-pattern-refactoring/"/>
    <id>https://crazyfzw.github.io/2020/10/07/design-pattern-refactoring/</id>
    <published>2020-10-07T04:37:56.000Z</published>
    <updated>2021-01-02T07:49:57.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>理论一：什么情况下要重构？到底重构什么？又该如何重构？</h2><h3 id="1-重构的目的："><a href="#1-重构的目的：" class="headerlink" title="1. 重构的目的："></a>1. 重构的目的：</h3><p>为什么重构（why）？<br>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p><p>对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><a id="more"></a><h3 id="2-重构的对象："><a href="#2-重构的对象：" class="headerlink" title="2. 重构的对象："></a>2. 重构的对象：</h3><p>重构什么（what）？按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p><p>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</p><p>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p><h3 id="3-重构的时机："><a href="#3-重构的时机：" class="headerlink" title="3. 重构的时机："></a>3. 重构的时机：</h3><p>什么时候重构（when）？我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><p>平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><h3 id="4-重构的方法："><a href="#4-重构的方法：" class="headerlink" title="4. 重构的方法："></a>4. 重构的方法：</h3><p>如何重构（how）？大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p><p>而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p><p>idea 可以安装 Alibaba Java Coding Guidelines 来帮助解决一些规范的问题，重构解决一些低级别的错误<br><a href="https://www.cnblogs.com/DDgougou/p/9282554.html" target="_blank" rel="noopener">https://www.cnblogs.com/DDgougou/p/9282554.html</a></p><h3 id="评论区精彩评论"><a href="#评论区精彩评论" class="headerlink" title="评论区精彩评论"></a>评论区精彩评论</h3><h4 id="一个重构的案例（步骤）"><a href="#一个重构的案例（步骤）" class="headerlink" title="一个重构的案例（步骤）"></a>一个重构的案例（步骤）</h4><p>前段时间刚重构了一个功能模块。该模块可以说是祖传代码。里面堆砌着各种判断条件，就是所谓的箭头型代码。我接手这个功能重构的<br>1.把代码读一遍和跑一遍，理解里面的需求。尽量画一个流程图。<br>2.建立防护网。将需求拆分之后，针对每个拆分的业务点写单元测试。<br>4.开始重构，解耦逻辑，设计方法的时候尽量让职业单一，类与类之间尽量符合迪米特原则，有依赖关系的类尽量只依赖类的特定方法。我觉得比较基础也是比较重要一点。不要有重复代码。命名要规范，类的各个职业要清晰。重构过程中，其实也要时不时的识别代码的坏味道。尽然是重构，那么肯定要比不重构之前肯定要更好。<br>5.重构完成之后，通过防护网的测试。</p><h4 id="重构后的功能一定要可测试"><a href="#重构后的功能一定要可测试" class="headerlink" title="重构后的功能一定要可测试"></a>重构后的功能一定要可测试</h4><p>代码中的坏味道，好比人的头疼脑热。“小病”不管的话，迟早会发展成大病，需要动大手术，甚至病入膏肓。<br>实际中的一些体会：<br>一、在完成一个新需求时，在时间允许的情况下，会经常改进代码，使代码更优雅。<br>二、“重构不改变外部的可见行为“，引入自动化测试非常重要，国内有些团队可能做的不好。因为改动代码可能引入bug，如果没有自动化测试，测起来就会非常费劲，改动的结果不确定。如果测试不方便，谁会愿意修改之前work的代码呢？<br>三、持续集成、自动化测试、持续重构都是很好的工程实践。即使工作的项目中暂时没有使用，也应该有所了解。</p><h4 id="写单元测试很重要，谁写谁知道"><a href="#写单元测试很重要，谁写谁知道" class="headerlink" title="写单元测试很重要，谁写谁知道"></a>写单元测试很重要，谁写谁知道</h4><p>最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。</p><h2 id="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h2><p>什么是单元测试？为什么要写单元测试？如何编写单元测试？如何在团队中推行单元测试？</p><p>那如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合上一节课中我们对重构的定义。</p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p><p>我们常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><h3 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h3><p>写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 TDD 可落地执行的改进方案。</p><h4 id="1-单元测试能有效地帮你发现代码中的-bug"><a href="#1-单元测试能有效地帮你发现代码中的-bug" class="headerlink" title="1.单元测试能有效地帮你发现代码中的 bug"></a>1.单元测试能有效地帮你发现代码中的 bug</h4><p>坚持为自己提交的每一份代码，都编写完善的单元测试。可以减少很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，可以因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证代码质量的一个“杀手锏”，也是帮助拉开与其他人差距的一个“小秘密”。</p><h4 id="2-写单元测试能帮你发现代码设计上的问题"><a href="#2-写单元测试能帮你发现代码设计上的问题" class="headerlink" title="2.写单元测试能帮你发现代码设计上的问题"></a>2.写单元测试能帮你发现代码设计上的问题</h4><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p><h4 id="3-单元测试是对集成测试的有力补充"><a href="#3-单元测试是对集成测试的有力补充" class="headerlink" title="3.单元测试是对集成测试的有力补充"></a>3.单元测试是对集成测试的有力补充</h4><p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p><h4 id="4-写单元测试的过程本身就是代码重构的过程？"><a href="#4-写单元测试的过程本身就是代码重构的过程？" class="headerlink" title="4.写单元测试的过程本身就是代码重构的过程？"></a>4.写单元测试的过程本身就是代码重构的过程？</h4><p>设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p><h4 id="5-阅读单元测试能帮助你快速熟悉代码"><a href="#5-阅读单元测试能帮助你快速熟悉代码" class="headerlink" title="5.阅读单元测试能帮助你快速熟悉代码"></a>5.阅读单元测试能帮助你快速熟悉代码</h4><p>在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p><h4 id="6-单元测试是-TDD-可落地执行的改进方案"><a href="#6-单元测试是-TDD-可落地执行的改进方案" class="headerlink" title="6.单元测试是 TDD 可落地执行的改进方案"></a>6.单元测试是 TDD 可落地执行的改进方案</h4><p>单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点。</p><h3 id="如何编写单元测试"><a href="#如何编写单元测试" class="headerlink" title="如何编写单元测试"></a>如何编写单元测试</h3><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。这些框架提供了通用的执行流程（比如执行测试用例的 TestCaseRunner）和工具类库（比如各种 Assert 判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p><p>除此之外，对于单元测试，我们需要建立以下正确的认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低对单元测试代码质量的要求；</li><li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li><li>单元测试不要依赖被测代码的具体实现逻辑；</li><li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li></ul><h3 id="一个单元测试的例子"><a href="#一个单元测试的例子" class="headerlink" title="一个单元测试的例子"></a>一个单元测试的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Text &#123;</span><br><span class="line">  private String content;</span><br><span class="line"></span><br><span class="line">  public Text(String content) &#123;</span><br><span class="line">    this.content &#x3D; content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将字符串转化成数字，忽略字符串中的首尾空格；</span><br><span class="line">   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Integer toNumber() &#123;</span><br><span class="line">    if (content &#x3D;&#x3D; null || content.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略代码实现...</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要测试 一下Text 类中的 toNumber() 函数的正确性，应该如何编写单元测试呢？</p><p>写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p><h4 id="罗列出各种正常，异常，以及边界的测试用例"><a href="#罗列出各种正常，异常，以及边界的测试用例" class="headerlink" title="罗列出各种正常，异常，以及边界的测试用例"></a>罗列出各种正常，异常，以及边界的测试用例</h4><ul><li>如果字符串只包含数字：“123”，toNumber() 函数输出对应的整数：123。</li><li>如果字符串是空或者 null，toNumber() 函数返回：null。</li><li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数：123。</li><li>如果字符串包含多个首尾空格：“ 123 ”，toNumber() 返回对应的整数：123；</li><li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber() 返回 null；</li></ul><h4 id="将测试用例翻译成代码"><a href="#将测试用例翻译成代码" class="headerlink" title="将测试用例翻译成代码"></a>将测试用例翻译成代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Assert &#123;</span><br><span class="line">  public static void assertEquals(Integer expectedValue, Integer actualValue) &#123;</span><br><span class="line">    if (actualValue !&#x3D; expectedValue) &#123;</span><br><span class="line">      String message &#x3D; String.format(</span><br><span class="line">              &quot;Test failed, expected: %d, actual: %d.&quot;, expectedValue, actualValue);</span><br><span class="line">      System.out.println(message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static boolean assertNull(Integer actualValue) &#123;</span><br><span class="line">    boolean isNull &#x3D; actualValue &#x3D;&#x3D; null;</span><br><span class="line">    if (isNull) &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test failed, the value is not null:&quot; + actualValue);</span><br><span class="line">    &#125;</span><br><span class="line">    return isNull;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TextTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber() &#123;</span><br><span class="line">    Text text &#x3D; new Text(&quot;123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_nullorEmpty() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(null);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot; 123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot; 123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsMultiLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;  123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot;  123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsInvalidCharaters() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;123a4&quot;);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 4&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h3><ul><li>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；</li><li>另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</li></ul><h3 id="重度依赖数据库的业务代码如何做单元测试"><a href="#重度依赖数据库的业务代码如何做单元测试" class="headerlink" title="重度依赖数据库的业务代码如何做单元测试"></a>重度依赖数据库的业务代码如何做单元测试</h3><ul><li>涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</li><li>涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</li></ul><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.以前在开发中，没有写单元测试的意识。开发完功能后，直接去测试一个完整的流程。即前端发请求，服务端处理，看数据库数据。如果功能正确就过。这是从一个功能宏观去考虑测试。而单元测试是更细粒度的测试，它在保证各个“单元”都测试通过的情况下整个功能模块就测试通过了。这样的方式对于我们自己来说对代码可控粒度更细。更能比较清楚的理解某个“单元”在整个功能模块调用链路上的位置，承担什么职责，以及有什么行为。而不是一开始就站在模块宏观角度来思考。通过一个个单元测试的编写，将整个功能模块串联起来，最终达到整个功能模块的全局认知。 这也体现了任务分解的思想。通过单元测试，可以从另外一方面实现对已编写的代码的CodeReview，重新梳理流程。也为以后有重构需求打下基础。目前参与的项目中有单元测试，但是不够完备。可能由于某些原因（开发人员意识问题，团队对单元测试的执行落地程度不够等）。在写单元测试的过程中，遇到单元测试依赖数据库查询问题，因为存在多套环境，如开发环境，仿真环境，线上环境。对于依赖数据查询的单元测试，只能自己造假数据来解决。不知道还有什么好的解决办法。</p><p>作者回复：涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</p><p>2.如果到了具体的业务代码，该怎么写单元测试呢，单元测试正确标准是什么呢，以sql查询到的结果吗？</p><p>作者回复：涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</p><p>3.单元测试很重要，但是为什么大多人都会放弃？我个人觉得最主要的原因并不是代码量大，难以编写等，而是跑单元测试的次数少。很多单元测试都是为了写而写，写完一次可能都不去运行或者只偶尔运行一两次。如果是每次改完代码，都跑一遍单元测试，单元测试的效果会越来越显现。如果只是为了运行一两次或者干脆为了写而写，很容易就会放弃继续写单元测试。</p><p>作者回复：可以集成到代码管理仓库git中，强制跑单元测试成功之后才能提交</p><h2 id="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h2><p>写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。</p><h3 id="1-什么是代码的可测试性？"><a href="#1-什么是代码的可测试性？" class="headerlink" title="1. 什么是代码的可测试性？"></a>1. 什么是代码的可测试性？</h3><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><h3 id="2-编写可测试性代码的最有效手段"><a href="#2-编写可测试性代码的最有效手段" class="headerlink" title="2. 编写可测试性代码的最有效手段"></a>2. 编写可测试性代码的最有效手段</h3><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方</p><h3 id="3-常见的-Anti-Patterns"><a href="#3-常见的-Anti-Patterns" class="headerlink" title="3. 常见的 Anti-Patterns"></a>3. 常见的 Anti-Patterns</h3><p>常见的测试不友好的代码有下面这 5 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h3 id="4-mock-用一个“假”的服务替换真正的服务"><a href="#4-mock-用一个“假”的服务替换真正的服务" class="headerlink" title="4.mock 用一个“假”的服务替换真正的服务"></a>4.mock 用一个“假”的服务替换真正的服务</h3><p>单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><p>那如何来 mock 服务呢？mock 的方式主要有两种，手动 mock 和利用框架 mock。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private Long buyerId;</span><br><span class="line">  private Long sellerId;</span><br><span class="line">  private Long productId;</span><br><span class="line">  private String orderId;</span><br><span class="line">  private Long createTimestamp;</span><br><span class="line">  private Double amount;</span><br><span class="line">  private STATUS status;</span><br><span class="line">  private String walletTransactionId;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; ...get() methods...</span><br><span class="line">  </span><br><span class="line">  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) &#123;</span><br><span class="line">    if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;</span><br><span class="line">      this.id &#x3D; preAssignedId;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.id &#x3D; IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!this.id.startWith(&quot;t_&quot;)) &#123;</span><br><span class="line">      this.id &#x3D; &quot;t_&quot; + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">    this.buyerId &#x3D; buyerId;</span><br><span class="line">    this.sellerId &#x3D; sellerId;</span><br><span class="line">    this.productId &#x3D; productId;</span><br><span class="line">    this.orderId &#x3D; orderId;</span><br><span class="line">    this.status &#x3D; STATUS.TO_BE_EXECUTD;</span><br><span class="line">    this.createTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean execute() throws InvalidTransactionException &#123;</span><br><span class="line">    if ((buyerId &#x3D;&#x3D; null || (sellerId &#x3D;&#x3D; null || amount &lt; 0.0) &#123;</span><br><span class="line">      throw new InvalidTransactionException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    if (status &#x3D;&#x3D; STATUS.EXECUTED) return true;</span><br><span class="line">    boolean isLocked &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">      if (!isLocked) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; 锁定未成功，返回false，job兜底执行</span><br><span class="line">      &#125;</span><br><span class="line">      if (status &#x3D;&#x3D; STATUS.EXECUTED) return true; &#x2F;&#x2F; double check</span><br><span class="line">      long executionInvokedTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">      if (executionInvokedTimestamp - createdTimestap &gt; 14days) &#123;</span><br><span class="line">        this.status &#x3D; STATUS.EXPIRED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">      String walletTransactionId &#x3D; walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">      if (walletTransactionId !&#x3D; null) &#123;</span><br><span class="line">        this.walletTransactionId &#x3D; walletTransactionId;</span><br><span class="line">        this.status &#x3D; STATUS.EXECUTED;</span><br><span class="line">        return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.status &#x3D; STATUS.FAILED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">       RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction 类中的 execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。除此之外，代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。</p><p>1.当代码包含依赖第三方系统的RPC调用时怎么写 单元测试<br>我们通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。具体的代码实现如下所示。通过 mock 的方式，我们可以让 moveMoney() 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MockWalletRpcServiceOne extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return &quot;123bac&quot;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MockWalletRpcServiceTwo extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  &#x2F;&#x2F; 添加一个成员变量及其set方法</span><br><span class="line">  private WalletRpcService walletRpcService;</span><br><span class="line">  </span><br><span class="line">  public void setWalletRpcService(WalletRpcService walletRpcService) &#123;</span><br><span class="line">    this.walletRpcService &#x3D; walletRpcService;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 删除下面这一行代码</span><br><span class="line">    &#x2F;&#x2F; WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  &#x2F;&#x2F; 使用mock对象来替代真正的RPC服务</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当代码中包含一些不是我们维护的组件的调用时如何写单元测试</li></ol><p>如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。这样我们就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了。但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionLock &#123;</span><br><span class="line">  public boolean lock(String id) &#123;</span><br><span class="line">    return RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void unlock() &#123;</span><br><span class="line">    RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  private TransactionLock lock;</span><br><span class="line">  </span><br><span class="line">  public void setTransactionLock(TransactionLock lock) &#123;</span><br><span class="line">    this.lock &#x3D; lock;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; lock.lock();</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  </span><br><span class="line">  TransactionLock mockLock &#x3D; new TransactionLock() &#123;</span><br><span class="line">    public boolean lock(String id) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void unlock() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne());</span><br><span class="line">  transaction.setTransactionLock(mockLock);</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.依赖注入是提高代码可测试性的最有效的手段。</p><p>2.可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之</p><p>3、未决行为：例时间、随机数。将未决行为重新封装，测试时mock，使用匿名类。</p><h2 id="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h2><p>大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，今天我们重点讲解最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合。</p><h3 id="“解耦”为何如此重要？"><a href="#“解耦”为何如此重要？" class="headerlink" title="“解耦”为何如此重要？"></a>“解耦”为何如此重要？</h3><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><h3 id="如何判定代码是否需要“解耦”？"><a href="#如何判定代码是否需要“解耦”？" class="headerlink" title="如何判定代码是否需要“解耦”？"></a>如何判定代码是否需要“解耦”？</h3><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><h3 id="如何给代码“解耦”？"><a href="#如何给代码“解耦”？" class="headerlink" title="如何给代码“解耦”？"></a>如何给代码“解耦”？</h3><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p><h3 id="设计原则回顾"><a href="#设计原则回顾" class="headerlink" title="设计原则回顾"></a>设计原则回顾</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p><h4 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h4><p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p><h4 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h4><p>继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p><h2 id="理论五：让你最快速地改善代码质量的20条编程规范"><a href="#理论五：让你最快速地改善代码质量的20条编程规范" class="headerlink" title="理论五：让你最快速地改善代码质量的20条编程规范"></a>理论五：让你最快速地改善代码质量的20条编程规范</h2><h3 id="1-关于命名"><a href="#1-关于命名" class="headerlink" title="1. 关于命名"></a>1. 关于命名</h3><ul><li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li><li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</li><li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li></ul><h3 id="2-关于注释"><a href="#2-关于注释" class="headerlink" title="2. 关于注释"></a>2. 关于注释</h3><ul><li>关于注释注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li></ul><h3 id="3-关于代码风格"><a href="#3-关于代码风格" class="headerlink" title="3.关于代码风格"></a>3.关于代码风格</h3><h4 id="函数、类多大才合适？"><a href="#函数、类多大才合适？" class="headerlink" title="函数、类多大才合适？"></a>函数、类多大才合适？</h4><p>函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。</p><h4 id="一行代码多长最合适？"><a href="#一行代码多长最合适？" class="headerlink" title="一行代码多长最合适？"></a>一行代码多长最合适？</h4><p> 最好不要超过 IDE 显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h4 id="善用空行分割单元块"><a href="#善用空行分割单元块" class="headerlink" title="善用空行分割单元块"></a>善用空行分割单元块</h4><p>对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。</p><h4 id="四格缩进还是两格缩进？"><a href="#四格缩进还是两格缩进？" class="headerlink" title="四格缩进还是两格缩进？"></a>四格缩进还是两格缩进？</h4><p>我个人比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。</p><h4 id="大括号是否要另起一行？"><a href="#大括号是否要另起一行？" class="headerlink" title="大括号是否要另起一行？"></a>大括号是否要另起一行？</h4><p>我个人还是比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。6. 类中成员的排列顺序在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><h4 id="类中成员的排列顺序"><a href="#类中成员的排列顺序" class="headerlink" title="类中成员的排列顺序"></a>类中成员的排列顺序</h4><p>在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><h3 id="4-关于变成技巧"><a href="#4-关于变成技巧" class="headerlink" title="4.关于变成技巧"></a>4.关于变成技巧</h3><ul><li>将复杂的逻辑提炼拆分成函数和类。</li><li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li><li>函数中不要使用参数来做代码执行逻辑的控制。</li><li>函数设计要职责单一。移</li><li>除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li><li>用字面常量取代魔法数。</li><li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li></ul><p>代码示例<br>1.用解释性变量来解释复杂表达式，以此提高代码可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰</span><br><span class="line">boolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line">if (isSummer) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常量替代魔法数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return (3.1415) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常量替代魔法数字</span><br><span class="line">public static final Double PI &#x3D; 3.1415;</span><br><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.调整执行顺序来减少嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重构前的代码</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;</span><br><span class="line">    for (String str : strList) &#123;</span><br><span class="line">      if (str !&#x3D; null) &#123;</span><br><span class="line">        if (str.contains(substr)) &#123;</span><br><span class="line">          matchedStrings.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  for (String str : strList) &#123;</span><br><span class="line">    if (str !&#x3D; null) &#123;</span><br><span class="line">      if (str.contains(substr)) &#123;</span><br><span class="line">        matchedStrings.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-统一编码规范"><a href="#5-统一编码规范" class="headerlink" title="5.统一编码规范"></a>5.统一编码规范</h3><p>除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</p><h3 id="代码分析工具推荐"><a href="#代码分析工具推荐" class="headerlink" title="代码分析工具推荐"></a>代码分析工具推荐</h3><p>代码中的很多低级质量问题不需要人工去审查，java开发有很多现成的工具可以使用，比如：checkstyle，findbugs, pmd, jacaco, sonar等。</p><p>Checkstyle,findbugs,pmd是静态代码分析工具，通过分析源代码或者字节码，找出代码的缺陷，比如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。三者都可以集成到gradle等构建工具中。</p><p>Jacoco是一种单元测试覆盖率统计工具，也可以集成到gradle等构建工具中，可以生成漂亮的测试覆盖率统计报表，同时Eclipse提供了插件可以EclEmma可以直观的在IDE中查看单元测试的覆盖情况。</p><p>Sonar Sonar 是一个用于代码质量管理的平台。可以在一个统一的平台上显示管理静态分析，单元测试覆盖率等质量报告。</p><h2 id="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h2><h3 id="如何发现代码质量问题-常规checkList"><a href="#如何发现代码质量问题-常规checkList" class="headerlink" title="如何发现代码质量问题-常规checkList"></a>如何发现代码质量问题-常规checkList</h3><ul><li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li><li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li><li>设计模式是否应用得当？是否有过度设计？</li><li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li><li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li><li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li></ul><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2459" alt="041e22cac6ce2ba3481e246c119adfc9.jpeg"></p><h3 id="如何发现代码质量问题-业务需求checkList"><a href="#如何发现代码质量问题-业务需求checkList" class="headerlink" title="如何发现代码质量问题-业务需求checkList"></a>如何发现代码质量问题-业务需求checkList</h3><ul><li>代码是否实现了预期的业务需求？</li><li>逻辑是否正确？是否处理了各种异常情况？日</li><li>志打印是否得当？是否方便 debug 排查问题？</li><li>接口是否易用？是否支持幂等、事务等？</li><li>代码是否存在并发问题？是否线程安全？</li><li>性能是否有优化空间，比如，SQL、算法是否可以优化？</li><li>是否有安全漏洞？比如输入输出校验是否全面？</li><li><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2460" alt="9894233257994a69102afa960692ce98.jpeg"></li></ul><h3 id="一段有很多问题的ID生成器代码"><a href="#一段有很多问题的ID生成器代码" class="headerlink" title="一段有很多问题的ID生成器代码"></a>一段有很多问题的ID生成器代码</h3><p>为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。</p><p>借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在 Java 语言中，我们可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的 ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求 ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID 信息，我们就可以通过请求 ID 来搜索同一个请求的所有日志了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(IdGenerator.class);</span><br><span class="line"></span><br><span class="line">  public static String generate() &#123;</span><br><span class="line">    String id &#x3D; &quot;&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      if (tokens.length &gt; 0) &#123;</span><br><span class="line">        hostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      &#125;</span><br><span class="line">      char[] randomChars &#x3D; new char[8];</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line">      while (count &lt; 8) &#123;</span><br><span class="line">        int randomAscii &#x3D; random.nextInt(122);</span><br><span class="line">        if (randomAscii &gt;&#x3D; 48 &amp;&amp; randomAscii &lt;&#x3D; 57) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;0&#39; + (randomAscii - 48));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 65 &amp;&amp; randomAscii &lt;&#x3D; 90) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;A&#39; + (randomAscii - 65));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 97 &amp;&amp; randomAscii &lt;&#x3D; 122) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;a&#39; + (randomAscii - 97));</span><br><span class="line">          count++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      id &#x3D; String.format(&quot;%s-%d-%s&quot;, hostName,</span><br><span class="line">              System.currentTimeMillis(), new String(randomChars));</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h2><p>重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。</p><ul><li>第一轮重构：提高代码的可读性</li><li>第二轮重构：提高代码的可测试性</li><li>第三轮重构：编写完善的单元测试</li><li>第四轮重构：所有重构完成之后添加注释</li></ul><h3 id="第一轮重构：提高代码的可读性"><a href="#第一轮重构：提高代码的可读性" class="headerlink" title="第一轮重构：提高代码的可读性"></a>第一轮重构：提高代码的可读性</h3><p>首先，我们要解决最明显、最急需改进的代码可读性问题。具体有下面几点：</p><ul><li>hostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候；</li><li>将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数；</li><li>删除代码中的魔法数，比如，57、90、97、122；</li><li>将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数；</li><li>generate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化；对 IdGenerator 类重命名，并且抽象出对应的接口。</li></ul><p>第一轮重构后的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public interface IdGenerator &#123;</span><br><span class="line">  String generate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface LogTraceIdGenerator extends IdGenerator &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      return substrOfHostName;</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码使用举例</span><br><span class="line">LogTraceIdGenerator logTraceIdGenerator &#x3D; new RandomIdGenerator();</span><br></pre></td></tr></table></figure><h3 id="第二轮重构：提高代码的可测试性"><a href="#第二轮重构：提高代码的可测试性" class="headerlink" title="第二轮重构：提高代码的可测试性"></a>第二轮重构：提高代码的可测试性</h3><p>关于代码可测试性的问题，主要包含下面两个方面：</p><ul><li>generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性；</li><li>generate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好。</li></ul><p>对于第一点，我们已经在第一轮重构中解决了。我们将 RandomIdGenerator 类中的 generate() 静态函数重新定义成了普通函数。调用者可以通过依赖注入的方式，在外部创建好 RandomIdGenerator 对象后注入到自己的代码中，从而解决静态函数调用影响代码可测试性的问题。</p><p>对于第二点，我们需要在第一轮重构的基础之上再进行重构。</p><ul><li>从 getLastfieldOfHostName() 函数中，将逻辑比较复杂的那部分代码剥离出来，定义为 getLastSubstrSplittedByDot() 函数。因为 getLastfieldOfHostName() 函数依赖本地主机名，所以，剥离出主要代码之后这个函数变得非常简单，可以不用测试。我们重点测试 getLastSubstrSplittedByDot() 函数即可。</li><li>将 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 这两个函数的访问权限设置为 protected。这样做的目的是，可以直接在单元测试中通过对象来调用两个函数进行测试。</li><li>给 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 两个函数添加 Google Guava 的 annotation @VisibleForTesting。这个 annotation 没有任何实际的作用，只起到标识的作用，告诉其他人说，这两个函数本该是 private 访问权限的，之所以提升访问权限到 protected，只是为了测试，只能用于单元测试中。</li></ul><p>第二轮重构后代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三轮重构：编写完善的单元测试"><a href="#第三轮重构：编写完善的单元测试" class="headerlink" title="第三轮重构：编写完善的单元测试"></a>第三轮重构：编写完善的单元测试</h3><p>经过上面的重构之后，代码存在的比较明显的问题，基本上都已经解决了。我们现在为代码补全单元测试。RandomIdGenerator 类中有 4 个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String generate();</span><br><span class="line">private String getLastfieldOfHostName();</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String getLastSubstrSplittedByDot(String hostName);</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String generateRandomAlphameric(int length);</span><br></pre></td></tr></table></figure><p>在上一步重构中，为了提高代码的可测试性，我们已经将这两个部分代码跟不可控的组件（本机名、随机函数、时间函数）进行了隔离。所以，我们只需要设计完备的单元测试用例即可。具体的代码实现如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGeneratorTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1.field2.field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field3&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1#field2$field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1#field2#field3&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot_nullOrEmpty() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(null);</span><br><span class="line">    Assert.assertNull(actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(6);</span><br><span class="line">    Assert.assertNotNull(actualRandomString);</span><br><span class="line">    Assert.assertEquals(6, actualRandomString.length());</span><br><span class="line">    for (char c : actualRandomString.toCharArray()) &#123;</span><br><span class="line">      Assert.assertTrue((&#39;0&#39; &lt; c &amp;&amp; c &lt; &#39;9&#39;) || (&#39;a&#39; &lt; c &amp;&amp; c &lt; &#39;z&#39;) || (&#39;A&#39; &lt; c &amp;&amp; c &lt; &#39;Z&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理length&lt;&#x3D;0的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(0);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualRandomString);</span><br><span class="line"></span><br><span class="line">    actualRandomString &#x3D; idGenerator.generateRandomAlphameric(-1);</span><br><span class="line">    Assert.assertNull(actualRandomString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>注释不能太多，也不能太少，主要添加在类和函数上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Id Generator that is used to generate random IDs.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The IDs generated by this class are not absolutely unique,</span><br><span class="line"> * but the probability of duplication is very low.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate the random ID. The IDs may be duplicated only in extreme situation.</span><br><span class="line">   *</span><br><span class="line">   * @return an random ID</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the local hostname and</span><br><span class="line">   * extract the last field of the name string splitted by delimiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @return the last field of hostname. Returns null if hostname is not obtained.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the last field of &#123;@hostName&#125; splitted by delemiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @param hostName should not be null</span><br><span class="line">   * @return the last field of &#123;@hostName&#125;. Returns empty string if &#123;@hostName&#125; is empty string.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate random string which</span><br><span class="line">   * only contains digits, uppercase letters and lowercase letters.</span><br><span class="line">   *</span><br><span class="line">   * @param length should not be less than 0</span><br><span class="line">   * @return the random string. Returns empty string if &#123;@length&#125; is 0</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写 100 段凑活能用的代码，对你的代码能力提高更有帮助。</li><li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。</li><li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。</li><li>高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。</li></ul><h2 id="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h2><h3 id="1-返回错误码"><a href="#1-返回错误码" class="headerlink" title="1. 返回错误码"></a>1. 返回错误码</h3><p>C 语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而 Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p><h3 id="2-返回-NULL-值"><a href="#2-返回-NULL-值" class="headerlink" title="2. 返回 NULL 值"></a>2. 返回 NULL 值</h3><p>在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的 NULL 值比返回异常更加合理。</p><h3 id="3-返回空对象"><a href="#3-返回空对象" class="headerlink" title="3. 返回空对象"></a>3. 返回空对象</h3><p>返回 NULL 值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用空集合替代NULL</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepo userRepo; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  </span><br><span class="line">  public List&lt;User&gt; getUsers(String telephonePrefix) &#123;</span><br><span class="line">   &#x2F;&#x2F; 没有查找到数据</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getUsers使用示例</span><br><span class="line">List&lt;User&gt; users &#x3D; userService.getUsers(&quot;189&quot;);</span><br><span class="line">for (User user : users) &#123; &#x2F;&#x2F;这里不需要做NULL值判断</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用空字符串替代NULL</span><br><span class="line">public String retrieveUppercaseLetters(String text) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果text中没有大写字母，返回空字符串，而非NULL值</span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; retrieveUppercaseLetters()使用举例</span><br><span class="line">String uppercaseLetters &#x3D; retrieveUppercaseLetters(&quot;wangzheng&quot;);</span><br><span class="line">int length &#x3D; uppercaseLetters.length();&#x2F;&#x2F; 不需要做NULL值判断 </span><br><span class="line">System.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);</span><br></pre></td></tr></table></figure><h3 id="4-抛出异常对象"><a href="#4-抛出异常对象" class="headerlink" title="4. 抛出异常对象"></a>4. 抛出异常对象</h3><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p><h3 id="5-针对函数抛出异常的三种处理方式"><a href="#5-针对函数抛出异常的三种处理方式" class="headerlink" title="5.针对函数抛出异常的三种处理方式"></a>5.针对函数抛出异常的三种处理方式</h3><p>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。</p><h4 id="直接吞掉"><a href="#直接吞掉" class="headerlink" title="直接吞掉"></a>直接吞掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void func2() &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">    log.warn(&quot;...&quot;, e); &#x2F;&#x2F;吐掉：try-catch打印日志</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接往上抛出-（原封不动地-re-throw）"><a href="#直接往上抛出-（原封不动地-re-throw）" class="headerlink" title="直接往上抛出 （原封不动地 re-throw）"></a>直接往上抛出 （原封不动地 re-throw）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception1 &#123;&#x2F;&#x2F;原封不动的re-throw Exception1</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  func1();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包裹成新的异常抛出-re-throw"><a href="#包裹成新的异常抛出-re-throw" class="headerlink" title="包裹成新的异常抛出 re-throw"></a>包裹成新的异常抛出 re-throw</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception2 &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">   throw new Exception2(&quot;...&quot;, e); &#x2F;&#x2F; wrap成新的Exception2然后re-throw</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>实战二（下）：重构ID生成器项目中各函数的异常处理代码</h2><h3 id="异常处理代码重构"><a href="#异常处理代码重构" class="headerlink" title="异常处理代码重构"></a>异常处理代码重构</h3><p>重构之前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastFiledOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFiledOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() throws IdGenerationFailureException &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      substrOfHostName &#x3D; getLastFieldOfHostName();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      throw new IdGenerationFailureException(&quot;...&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFieldOfHostName() throws UnknownHostException&#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new UnknownHostException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    if (length &lt;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.在 generate() 函数中，我们需要捕获 UnknownHostException 异常，并重新包裹成新的异常 IdGenerationFailureException 往上抛出。之所以这么做，有下面三个原因。</p><ul><li>调用者在使用 generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的。也就说是，这是依赖抽象而非实现编程。</li><li>如果 generate() 函数直接抛出 UnknownHostException 异常，实际上是暴露了实现细节。从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常，暴露给更上层的代码，也就是调用 generate() 函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。</li><li>UnknownHostException 异常跟 generate() 函数，在业务概念上没有相关性。</li></ul><p>2.如果函数是 public 的，你无法掌控会被谁调用以及如何调用（有可能某个同事一时疏忽，传递进了 NULL 值，这种情况也是存在的），为了尽可能提高代码的健壮性，我们最好是在 public 函数中做 NULL 值或空字符串的判断。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>1.程序的 bug 往往都出现在一些边界条件和异常情况下，所以说，异常处理得好坏直接影响了代码的健壮性。</p><p>2.再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</p><p>3.内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</p><p>4.能用的代码和优质代码之间最大的区别就在于细节，这就是60分和100分的差别。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot;&gt;&lt;a href=&quot;#理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot; class=&quot;headerlink&quot; title=&quot;理论一：什么情况下要重构？到底重构什么？又该如何重构？&quot;&gt;&lt;/a&gt;理论一：什么情况下要重构？到底重构什么？又该如何重构？&lt;/h2&gt;&lt;h3 id=&quot;1-重构的目的：&quot;&gt;&lt;a href=&quot;#1-重构的目的：&quot; class=&quot;headerlink&quot; title=&quot;1. 重构的目的：&quot;&gt;&lt;/a&gt;1. 重构的目的：&lt;/h3&gt;&lt;p&gt;为什么重构（why）？&lt;br&gt;对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。&lt;/p&gt;
&lt;p&gt;对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part3：设计原则</title>
    <link href="https://crazyfzw.github.io/2020/10/05/design-pattern-design-principle/"/>
    <id>https://crazyfzw.github.io/2020/10/05/design-pattern-design-principle/</id>
    <published>2020-10-05T04:37:56.000Z</published>
    <updated>2021-01-02T07:49:53.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计原则概述"><a href="#设计原则概述" class="headerlink" title="设计原则概述"></a>设计原则概述</h2><p>SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，SRP单一职责原则 Single Responsibility Principle； KISS保持简单 Keep It Simple and Stupid； YAGNI不需要原则 You Ain’t Gonna Need It ； DRY 不要重复原则 Don’t Repeat Yourself ； LOD 迪米特法则 Law of Demeter。</p><a id="more"></a><p>设计原则和思想比设计模式更加普适和重要。可以这样说，设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。掌握了代码的设计原则和思想，我们才能更清楚的了解，为什么要用某种设计模式，才能更恰到好处地应用设计模式。</p><h2 id="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h2><p>单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p><h3 id="1-如何理解单一职责原则（SRP）？"><a href="#1-如何理解单一职责原则（SRP）？" class="headerlink" title="1. 如何理解单一职责原则（SRP）？"></a>1. 如何理解单一职责原则（SRP）？</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h3 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2. 如何判断类的职责是否足够单一？"></a>2. 如何判断类的职责是否足够单一？</h3><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：类中的代码行数、函数或者属性过多；类依赖的其他类过多，或者依赖类的其他类过多；私有方法过多；比较难给类起一个合适的名字；类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3. 类的职责是否设计得越单一越好？"></a>3. 类的职责是否设计得越单一越好？</h3><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2 id="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h2><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试。</p><h3 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1.如何理解“对扩展开放、对修改关闭”？"></a>1.如何理解“对扩展开放、对修改关闭”？</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><h3 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2. 如何做到“对扩展开放、修改关闭”？"></a>2. 如何做到“对扩展开放、修改关闭”？</h3><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h4 id="通过多态实现"><a href="#通过多态实现" class="headerlink" title="通过多态实现"></a>通过多态实现</h4><p>例子：API 接口监控告警的代码</p><p>改造前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private AlertRule rule;</span><br><span class="line">  private Notification notification;</span><br><span class="line"></span><br><span class="line">  public Alert(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略AlertRule&#x2F;Notification属性和构造函数...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 改动一：添加参数timeoutCount</span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 改动二：添加接口超时处理逻辑</span><br><span class="line">    long timeoutTps &#x3D; timeoutCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">弊端：一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改</span><br></pre></td></tr></table></figure><p>使用多态改造后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private List&lt;AlertHandler&gt; alertHandlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public void addAlertHandler(AlertHandler alertHandler) &#123;</span><br><span class="line">    this.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    for (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class AlertHandler &#123;</span><br><span class="line">  protected AlertRule rule;</span><br><span class="line">  protected Notification notification;</span><br><span class="line">  public AlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void check(ApiStatInfo apiStatInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public TpsAlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    long tps &#x3D; apiStatInfo.getRequestCount()&#x2F; apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？具体的使用代码我也写在这里了。其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  public Alert getAlert() &#123; return alert; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 饿汉式单例</span><br><span class="line">  private static final ApplicationContext instance &#x3D; new ApplicationContext();</span><br><span class="line">  private ApplicationContext() &#123;</span><br><span class="line">    initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  public static ApplicationContext getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略设置apiStatInfo数据值的代码</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果这时需要添加其他规则警告，只需按如下进行改动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123; &#x2F;&#x2F; 代码未改动... &#125;</span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">  private long timeoutCount; &#x2F;&#x2F; 改动一：添加新字段</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AlertHandler &#123; &#x2F;&#x2F;代码未改动... &#125;</span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">&#x2F;&#x2F; 改动二：添加新的handler</span><br><span class="line">public class TimeoutAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;省略代码...&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    &#x2F;&#x2F; 改动三：注册handler</span><br><span class="line">    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他未改动代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略apiStatInfo的set字段代码</span><br><span class="line">    apiStatInfo.setTimeoutCount(289); &#x2F;&#x2F; 改动四：设置tiemoutCount值</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h4 id="通过接口实现"><a href="#通过接口实现" class="headerlink" title="通过接口实现"></a>通过接口实现</h4><p>例子通过 Kafka 来发送异步消息：</p><p>对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这一部分体现了抽象意识</span><br><span class="line">public interface MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class KafkaMessageQueue implements MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class RocketMQMessageQueue implements MessageQueue &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public interface MessageFromatter &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class JsonMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">public class ProtoBufMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private MessageQueue msgQueue; &#x2F;&#x2F; 基于接口而非实现编程</span><br><span class="line">  public Demo(MessageQueue msgQueue) &#123; &#x2F;&#x2F; 依赖注入</span><br><span class="line">    this.msgQueue &#x3D; msgQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; msgFormatter：多态、依赖注入</span><br><span class="line">  public void sendNotification(Notification notification, MessageFormatter msgFormatter) &#123;</span><br><span class="line">    &#x2F;&#x2F;...    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"><a href="#通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）" class="headerlink" title="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"></a>通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）</h4><h3 id="3-如何在项目中合理应用开闭原则？"><a href="#3-如何在项目中合理应用开闭原则？" class="headerlink" title="3.如何在项目中合理应用开闭原则？"></a>3.如何在项目中合理应用开闭原则？</h3><p>1.最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。这样可以避免过度设计。</p><p>2.代码的扩展性会跟可读性相冲突，很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p><h2 id="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h2><p>Liskov Substitution Principle</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。<br>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>中文描述：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><h3 id="里式替换原则的理解"><a href="#里式替换原则的理解" class="headerlink" title="里式替换原则的理解"></a>里式替换原则的理解</h3><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><h3 id="符合里式替换原则的代码示例"><a href="#符合里式替换原则的代码示例" class="headerlink" title="符合里式替换原则的代码示例"></a>符合里式替换原则的代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Transporter &#123;</span><br><span class="line">  private HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  public Transporter(HttpClient httpClient) &#123;</span><br><span class="line">    this.httpClient &#x3D; httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...use httpClient to send request</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SecurityTransporter extends Transporter &#123;</span><br><span class="line">  private String appId;</span><br><span class="line">  private String appToken;</span><br><span class="line"></span><br><span class="line">  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) &#123;</span><br><span class="line">    super(httpClient);</span><br><span class="line">    this.appId &#x3D; appId;</span><br><span class="line">    this.appToken &#x3D; appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(&quot;app-id&quot;, appId);</span><br><span class="line">      request.addPayload(&quot;app-token&quot;, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;    </span><br><span class="line">  public void demoFunction(Transporter transporter) &#123;    </span><br><span class="line">    Reuqest request &#x3D; new Request();</span><br><span class="line">    &#x2F;&#x2F;...省略设置request中数据值的代码...</span><br><span class="line">    Response response &#x3D; transporter.sendRequest(request);</span><br><span class="line">    &#x2F;&#x2F;...省略其他逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 里式替换原则</span><br><span class="line">Demo demo &#x3D; new Demo();</span><br><span class="line">demo.demofunction(new SecurityTransporter(&#x2F;*省略参数*&#x2F;););</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><h3 id="哪些代码违背了里式替换原则"><a href="#哪些代码违背了里式替换原则" class="headerlink" title="哪些代码违背了里式替换原则"></a>哪些代码违背了里式替换原则</h3><h4 id="1-子类违背父类声明要实现的功能"><a href="#1-子类违背父类声明要实现的功能" class="headerlink" title="1. 子类违背父类声明要实现的功能"></a>1. 子类违背父类声明要实现的功能</h4><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><h4 id="2-子类违背父类对输入、输出、异常的约定"><a href="#2-子类违背父类对输入、输出、异常的约定" class="headerlink" title="2. 子类违背父类对输入、输出、异常的约定"></a>2. 子类违背父类对输入、输出、异常的约定</h4><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h4 id="3-子类违背父类注释中所罗列的任何特殊说明"><a href="#3-子类违背父类注释中所罗列的任何特殊说明" class="headerlink" title="3. 子类违背父类注释中所罗列的任何特殊说明"></a>3. 子类违背父类注释中所罗列的任何特殊说明</h4><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><h3 id="判断子类的设计实现是否违背里式替换原则的小窍门"><a href="#判断子类的设计实现是否违背里式替换原则的小窍门" class="headerlink" title="判断子类的设计实现是否违背里式替换原则的小窍门"></a>判断子类的设计实现是否违背里式替换原则的小窍门</h3><p>拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p><h3 id="里式替换与多态的区别"><a href="#里式替换与多态的区别" class="headerlink" title="里式替换与多态的区别"></a>里式替换与多态的区别</h3><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</p><p>而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h2 id="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h2><h3 id="1-如何理解“接口隔离原则”"><a href="#1-如何理解“接口隔离原则”" class="headerlink" title="1.如何理解“接口隔离原则”"></a>1.如何理解“接口隔离原则”</h3><p>Interface Segregation Principle</p><h4 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 API 接口集合</h4><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>例子：服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">  boolean register(String cellphone, String password);</span><br><span class="line">  boolean login(String cellphone, String password);</span><br><span class="line">  UserInfo getUserInfoById(long id);</span><br><span class="line">  UserInfo getUserInfoByCellphone(String cellphone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RestrictedUserService &#123;</span><br><span class="line">  boolean deleteUserByCellphone(String cellphone);</span><br><span class="line">  boolean deleteUserById(long id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService, RestrictedUserService &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略实现代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 API 接口或函数</h4><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>比如一下代码 count() 函数功能不够单一，包含了很多不同的统计功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Statistics &#123;</span><br><span class="line">  private Long max;</span><br><span class="line">  private Long min;</span><br><span class="line">  private Long average;</span><br><span class="line">  private Long sum;</span><br><span class="line">  private Long percentile99;</span><br><span class="line">  private Long percentile999;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter等方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Statistics count(Collection&lt;Long&gt; dataSet) &#123;</span><br><span class="line">  Statistics statistics &#x3D; new Statistics();</span><br><span class="line">  &#x2F;&#x2F;...省略计算逻辑...</span><br><span class="line">  return statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Long max(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public Long min(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125; </span><br><span class="line">public Long average(Colletion&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#x2F;&#x2F; ...省略其他统计函数...</span><br></pre></td></tr></table></figure><h4 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h4><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>例子：我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    private ConfigSource configSource; &#x2F;&#x2F;配置中心（比如zookeeper）</span><br><span class="line">    private String address;</span><br><span class="line">    private int timeout;</span><br><span class="line">    private int maxTotal;</span><br><span class="line">    &#x2F;&#x2F;省略其他配置: maxWaitMillis,maxIdle,minIdle...</span><br><span class="line"></span><br><span class="line">    public RedisConfig(ConfigSource configSource) &#123;</span><br><span class="line">        this.configSource &#x3D; configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return this.address;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他get()、init()方法...</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">      &#x2F;&#x2F;从configSource加载配置到address&#x2F;timeout&#x2F;maxTotal...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br></pre></td></tr></table></figure><p>现在，有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。但是，因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。</p><p>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略其他属性和方法... &#125;</span><br><span class="line"></span><br><span class="line">public class ScheduledUpdater &#123;</span><br><span class="line">    private final ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    private long initialDelayInSeconds;</span><br><span class="line">    private long periodInSeconds;</span><br><span class="line">    private Updater updater;</span><br><span class="line"></span><br><span class="line">    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) &#123;</span><br><span class="line">        this.updater &#x3D; updater;</span><br><span class="line">        this.initialDelayInSeconds &#x3D; initialDelayInSeconds;</span><br><span class="line">        this.periodInSeconds &#x3D; periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">  ConfigSource configSource &#x3D; new ZookeeperConfigSource(&#x2F;*省略参数*&#x2F;);</span><br><span class="line">  public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">  public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">  public static final MySqlConfig mysqlConfig &#x3D; new MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater &#x3D; new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater &#x3D; new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，有一个新的监控需求，期望输出项目的配置信息到一个固定的 HTTP 地址，比如：<a href="http://127.0.0.1:2389/config" target="_blank" rel="noopener">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。</p><p>在原来代码的基础上拓展后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Viewer &#123;</span><br><span class="line">  String outputInPlainText();</span><br><span class="line">  Map&lt;String, String&gt; output();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater, Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig implements Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">  private String host;</span><br><span class="line">  private int port;</span><br><span class="line">  private Map&lt;String, List&lt;Viewer&gt;&gt; viewers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public SimpleHttpServer(String host, int port) &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">  </span><br><span class="line">  public void addViewers(String urlDirectory, Viewer viewer) &#123;</span><br><span class="line">    if (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    this.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void run() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    ConfigSource configSource &#x3D; new ZookeeperConfigSource();</span><br><span class="line">    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">    public static final MySqlConfig mysqlConfig &#x3D; new MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer &#x3D; new SimpleHttpServer(“127.0.0.1”, 2389);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则</p><h3 id="2-接口隔离原则与单一职责原则的区别"><a href="#2-接口隔离原则与单一职责原则的区别" class="headerlink" title="2.接口隔离原则与单一职责原则的区别"></a>2.接口隔离原则与单一职责原则的区别</h3><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2 id="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h2><h3 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h3><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><h3 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h3><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p>现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</p><h3 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h3><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>例子：<br>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</p><h2 id="理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？"><a href="#理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？"></a>理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？</h2><p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p><blockquote><p>Keep It Simple and Stupid.<br>Keep It Short and Simple.Keep<br>It Simple and Straightforward.</p></blockquote><p>KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。</p><h3 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h3><ul><li><p>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</p></li><li><p>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</p></li><li><p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p></li></ul><h3 id="YAGNI-原则"><a href="#YAGNI-原则" class="headerlink" title="YAGNI 原则"></a>YAGNI 原则</h3><blockquote><p>You Ain’t Gonna Need It。</p></blockquote><p>直译就是：你不会需要它,实际上，这条原则的核心思想就是：不要做过度设计。</p><p>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</p><p>比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h2 id="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h2><h3 id="DRY-原则（Don’t-Repeat-Yourself）"><a href="#DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="DRY 原则（Don’t Repeat Yourself）"></a>DRY 原则（Don’t Repeat Yourself）</h3><p>原则我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p><h3 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h3><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><h2 id="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h2><p>Law of Demeter</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p><p><strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</strong></p><h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><ol><li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</li></ol><h3 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2. 如何理解“迪米特法则”？"></a>2. 如何理解“迪米特法则”？</h3><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h3 id="3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"><a href="#3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？" class="headerlink" title="3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"></a>3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？</h3><p>目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。</p><h2 id="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h2><p>以 分兑换系统的开发实战 为例：</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"><a href="#1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中" class="headerlink" title="1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"></a>1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中</h4><p>你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。</p><h4 id="2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"><a href="#2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。" class="headerlink" title="2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"></a>2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</h4><p>用户用例有点儿类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。<br>比如，有关积分有效期的用户用例，我们可以进行如下的设计：</p><ul><li>用户在获取积分的时候，会告知积分的有效期；</li><li>用户在使用积分的时候，会优先使用快过期的积分；</li><li>用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；</li><li>用户在查询总可用积分的时候，会排除掉过期的积分。</li></ul><h4 id="3-大致梳理出需求功能点"><a href="#3-大致梳理出需求功能点" class="headerlink" title="3. 大致梳理出需求功能点"></a>3. 大致梳理出需求功能点</h4><ul><li>积分赚取和兑换规则</li><li>积分消费和兑换规则</li><li>积分及其明细查询</li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="1-合理地将功能划分到不同模块"><a href="#1-合理地将功能划分到不同模块" class="headerlink" title="1. 合理地将功能划分到不同模块"></a>1. 合理地将功能划分到不同模块</h4><p>除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>可以这样划分：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><h4 id="2-设计模块与模块之间的交互关系"><a href="#2-设计模块与模块之间的交互关系" class="headerlink" title="2. 设计模块与模块之间的交互关系"></a>2. 设计模块与模块之间的交互关系</h4><p>比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好</p><p>比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。</p><p>除此之外，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。</p><h4 id="3-设计模块的接口、数据库、业务模型"><a href="#3-设计模块的接口、数据库、业务模型" class="headerlink" title="3. 设计模块的接口、数据库、业务模型"></a>3. 设计模块的接口、数据库、业务模型</h4><p>务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p></li><li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p></li><li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p></li></ol><h2 id="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h2><p>我们平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）。</p><p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p><h3 id="针对积分系统，我们先来看，如何设计数据库。"><a href="#针对积分系统，我们先来看，如何设计数据库。" class="headerlink" title="针对积分系统，我们先来看，如何设计数据库。"></a>针对积分系统，我们先来看，如何设计数据库。</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2453" alt="e9562c46bcb8fc45634f0d870c4778c4.jpeg"></p><h3 id="如何设计积分系统的接口"><a href="#如何设计积分系统的接口" class="headerlink" title="如何设计积分系统的接口"></a>如何设计积分系统的接口</h3><p>为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2454" alt="7b9008f6bc107add2b21d3dba901deaf.jpeg"></p><h3 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h3><p>从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型，对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。</p><h3 id="为什么要分-MVC-三层开发？"><a href="#为什么要分-MVC-三层开发？" class="headerlink" title="为什么要分 MVC 三层开发？"></a>为什么要分 MVC 三层开发？</h3><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><h3 id="BO、VO、Entity-存在的意义是什么？"><a href="#BO、VO、Entity-存在的意义是什么？" class="headerlink" title="BO、VO、Entity 存在的意义是什么？"></a>BO、VO、Entity 存在的意义是什么？</h3><p>对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因。</p><p>1.VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。</p><p>2.VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</p><p>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</p><h3 id="VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set"><a href="#VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set" class="headerlink" title="VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set"></a>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</h3><ol><li><p>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</p></li><li><p>Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p></li></ol><h2 id="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看。</p><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要。</p><h4 id="1-功能性需求分析"><a href="#1-功能性需求分析" class="headerlink" title="1.功能性需求分析"></a>1.功能性需求分析</h4><ul><li>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。</li><li>统计信息的类型：max、min、avg、percentile、count、tps 等。</li><li>统计信息显示格式：Json、Html、自定义显示格式。</li><li>统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端</li></ul><p>借助设计产品的时候，经常用到的线框图，把最终数据的显示样式画出来<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2455" alt="f04b341ad5fda418ae24f166d0a4dde5.jpeg"></p><p>实际上，从线框图中，我们还能挖掘出了下面几个隐藏的需求。</p><ul><li>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</li><li>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 12 月 11 日 00 点到 12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等。</li><li>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件。</li></ul><h4 id="2-非功能性需求分析"><a href="#2-非功能性需求分析" class="headerlink" title="2.非功能性需求分析"></a>2.非功能性需求分析</h4><h5 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h5><p>在开发这样一个技术框架的时候，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是我们应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p><h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件</p><h5 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h5><p>要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。</p><h5 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h5><p>为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等。</p><h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p>借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础。</p><p>，我们可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以 JSON 的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多。</p><p>首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。在原型系统的代码实现中，我们可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。</p><p>最小原型的代码实现如下所示。其中，recordResponseTime() 和 recordTimestamp() 两个函数分别用来记录接口请求的响应时间和访问时间。startRepeatedReport() 函数以指定的频率统计数据并输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Metrics &#123;</span><br><span class="line">  &#x2F;&#x2F; Map的key是接口名称，value对应接口请求的响应时间或时间戳；</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; responseTimes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; timestamps &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">  public void recordResponseTime(String apiName, double responseTime) &#123;</span><br><span class="line">    responseTimes.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    responseTimes.get(apiName).add(responseTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void recordTimestamp(String apiName, double timestamp) &#123;</span><br><span class="line">    timestamps.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    timestamps.get(apiName).add(timestamp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startRepeatedReport(long period, TimeUnit unit)&#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : responseTimes.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiRespTimes &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;max&quot;, max(apiRespTimes));</span><br><span class="line">          stats.get(apiName).put(&quot;avg&quot;, avg(apiRespTimes));</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : timestamps.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiTimestamps &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;count&quot;, (double)apiTimestamps.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, period, unit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private double max(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">  private double avg(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Metrics metrics &#x3D; new Metrics();</span><br><span class="line">  </span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    metrics.startRepeatedReport(60, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void register(UserVo user) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;regsiter&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;register&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;login&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;login&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于最新的原型进一步考虑"><a href="#基于最新的原型进一步考虑" class="headerlink" title="基于最新的原型进一步考虑"></a>基于最新的原型进一步考虑</h3><p>图可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题。</p><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2456" alt="926561b82b49c937dcf4a2b9e6b35c16.jpeg"></p><p>把整个框架分为四个模块：数据采集、存储、聚合统计、显示。每个模块负责的工作简单罗列如下。</p><ul><li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。数据采集过程要高度容错，不能影响到接口本身的可用性。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，我们也要尽量考虑其易用性。</li><li>存储：负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程异步完成。</li><li>聚合统计：负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps 等。为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。</li><li>显示：负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等。</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol><li>对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。</li></ol><p>2.对于复杂框架的设计，很多人往往觉得无从下手。今天我们分享了几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p><p>3.面向对象分析、设计和实现的时候，我们讲到设计阶段最终输出的是类的设计，</p><h2 id="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h2><p>即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式。所以，我们应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0……版本中继续迭代优化。</p><ul><li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。</li><li>存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，我们暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行。</li><li>聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps。</li><li>显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔 n 秒统计显示上 m 秒的数据（比如，间隔 60s 统计上 60s 的数据）。邮件每日统计上日的数据。</li></ul><h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>先大致识别出下面几个接口或类：</p><ul><li>MetricsCollector 类负责提供 API，来采集接口请求的原始数据。我们可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个 MetricsCollector 的实现方式。</li><li>MetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来存储。</li><li>Aggregator 类负责根据原始数据计算统计数据。</li><li>ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，我们暂时还不能确定。</li></ul><h3 id="2-定义类及类与类之间的关系"><a href="#2-定义类及类与类之间的关系" class="headerlink" title="2. 定义类及类与类之间的关系"></a>2. 定义类及类与类之间的关系</h3><p>接下来就是定义类及属性和方法，定义类与类之间的关系：</p><p>大致地识别出几个核心的类之后，我的习惯性做法是，先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。在设计类、类与类之间交互的时候，我会不断地用之前学过的设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS 原则、DRY 原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。</p><p>MetricsCollector 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MetricsCollector &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125; &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MetricsStorage、RedisMetricsStorage 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface MetricsStorage &#123;</span><br><span class="line">  void saveRequestInfo(RequestInfo requestInfo);</span><br><span class="line"></span><br><span class="line">  List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimeInMillis, long endTimeInMillis);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimeInMillis, long endTimeInMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisMetricsStorage implements MetricsStorage &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略属性和构造函数等...</span><br><span class="line">  @Override</span><br><span class="line">  public void saveRequestInfo(RequestInfo requestInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aggregator 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Aggregator &#123;</span><br><span class="line">  public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) &#123;</span><br><span class="line">    double maxRespTime &#x3D; Double.MIN_VALUE;</span><br><span class="line">    double minRespTime &#x3D; Double.MAX_VALUE;</span><br><span class="line">    double avgRespTime &#x3D; -1;</span><br><span class="line">    double p999RespTime &#x3D; -1;</span><br><span class="line">    double p99RespTime &#x3D; -1;</span><br><span class="line">    double sumRespTime &#x3D; 0;</span><br><span class="line">    long count &#x3D; 0;</span><br><span class="line">    for (RequestInfo requestInfo : requestInfos) &#123;</span><br><span class="line">      ++count;</span><br><span class="line">      double respTime &#x3D; requestInfo.getResponseTime();</span><br><span class="line">      if (maxRespTime &lt; respTime) &#123;</span><br><span class="line">        maxRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      if (minRespTime &gt; respTime) &#123;</span><br><span class="line">        minRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      sumRespTime +&#x3D; respTime;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      avgRespTime &#x3D; sumRespTime &#x2F; count;</span><br><span class="line">    &#125;</span><br><span class="line">    long tps &#x3D; (long)(count &#x2F; durationInMillis * 1000);</span><br><span class="line">    Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(RequestInfo o1, RequestInfo o2) &#123;</span><br><span class="line">        double diff &#x3D; o1.getResponseTime() - o2.getResponseTime();</span><br><span class="line">        if (diff &lt; 0.0) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">        &#125; else if (diff &gt; 0.0) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int idx999 &#x3D; (int)(count * 0.999);</span><br><span class="line">    int idx99 &#x3D; (int)(count * 0.99);</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      p999RespTime &#x3D; requestInfos.get(idx999).getResponseTime();</span><br><span class="line">      p99RespTime &#x3D; requestInfos.get(idx99).getResponseTime();</span><br><span class="line">    &#125;</span><br><span class="line">    RequestStat requestStat &#x3D; new RequestStat();</span><br><span class="line">    requestStat.setMaxResponseTime(maxRespTime);</span><br><span class="line">    requestStat.setMinResponseTime(minRespTime);</span><br><span class="line">    requestStat.setAvgResponseTime(avgRespTime);</span><br><span class="line">    requestStat.setP999ResponseTime(p999RespTime);</span><br><span class="line">    requestStat.setP99ResponseTime(p99RespTime);</span><br><span class="line">    requestStat.setCount(count);</span><br><span class="line">    requestStat.setTps(tps);</span><br><span class="line">    return requestStat;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestStat &#123;</span><br><span class="line">  private double maxResponseTime;</span><br><span class="line">  private double minResponseTime;</span><br><span class="line">  private double avgResponseTime;</span><br><span class="line">  private double p999ResponseTime;</span><br><span class="line">  private double p99ResponseTime;</span><br><span class="line">  private long count;</span><br><span class="line">  private long tps;</span><br><span class="line">  &#x2F;&#x2F;...省略getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsoleReporter、EmailReporterv 代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class ConsoleReporter &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">  public ConsoleReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 第4个代码逻辑：定时触发第1、2、3代码逻辑的执行；</span><br><span class="line">  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) &#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 第1个代码逻辑：根据给定的时间区间，从数据库中拉取数据；</span><br><span class="line">        long durationInMillis &#x3D; durationInSeconds * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          &#x2F;&#x2F; 第2个代码逻辑：根据原始数据，计算得到统计数据；</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第3个代码逻辑：将统计数据显示到终端（命令行或邮件）；</span><br><span class="line">        System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMillis + &quot;]&quot;);</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailReporter &#123;</span><br><span class="line">  private static final Long DAY_HOURS_IN_SECONDS &#x3D; 86400L;</span><br><span class="line"></span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private EmailSender emailSender;</span><br><span class="line">  private List&lt;String&gt; toAddresses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this(metricsStorage, new EmailSender(&#x2F;*省略参数*&#x2F;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.emailSender &#x3D; emailSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addToAddress(String address) &#123;</span><br><span class="line">    toAddresses.add(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startDailyReport() &#123;</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.DATE, 1);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">    calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">    calendar.set(Calendar.SECOND, 0);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">    Date firstTime &#x3D; calendar.getTime();</span><br><span class="line">    Timer timer &#x3D; new Timer();</span><br><span class="line">    timer.schedule(new TimerTask() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        long durationInMillis &#x3D; DAY_HOURS_IN_SECONDS * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: 格式化为html格式，并且发送邮件</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, firstTime, DAY_HOURS_IN_SECONDS * 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 将类组装起来并提供执行入口<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    MetricsStorage storage &#x3D; new RedisMetricsStorage();</span><br><span class="line">    ConsoleReporter consoleReporter &#x3D; new ConsoleReporter(storage);</span><br><span class="line">    consoleReporter.startRepeatedReport(60, 60);</span><br><span class="line"></span><br><span class="line">    EmailReporter emailReporter &#x3D; new EmailReporter(storage);</span><br><span class="line">    emailReporter.addToAddress(&quot;wangzheng@xzg.com&quot;);</span><br><span class="line">    emailReporter.startDailyReport();</span><br><span class="line"></span><br><span class="line">    MetricsCollector collector &#x3D; new MetricsCollector(storage);</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(100000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Review-设计与实现-以及问题分析"><a href="#Review-设计与实现-以及问题分析" class="headerlink" title="Review 设计与实现 以及问题分析"></a>Review 设计与实现 以及问题分析</h3><ul><li><p>Aggregator 类是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算。当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化。</p></li><li><p>ConsoleReporter、EmailReporterConsoleReporter 和 EmailReporter 中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 DRY 原则。而且整个类负责的事情比较多，职责不是太单一。特别是显示部分的代码，可能会比较复杂（比如 Email 的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好。</p></li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol><li><p>写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的 Unix 系统，第一版很简单、粗糙，代码不到 1 万行。所以，迭代思维很重要，不要刚开始就追求完美。</p></li><li><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计原则概述&quot;&gt;&lt;a href=&quot;#设计原则概述&quot; class=&quot;headerlink&quot; title=&quot;设计原则概述&quot;&gt;&lt;/a&gt;设计原则概述&lt;/h2&gt;&lt;p&gt;SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，SRP单一职责原则 Single Responsibility Principle； KISS保持简单 Keep It Simple and Stupid； YAGNI不需要原则 You Ain’t Gonna Need It ； DRY 不要重复原则 Don’t Repeat Yourself ； LOD 迪米特法则 Law of Demeter。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码</title>
    <link href="https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/"/>
    <id>https://crazyfzw.github.io/2020/10/03/design-pattern-object-oriented02/</id>
    <published>2020-10-03T15:37:56.000Z</published>
    <updated>2021-01-02T07:49:47.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h2><h3 id="1-什么是基于贫血模型的传统开发模式？"><a href="#1-什么是基于贫血模型的传统开发模式？" class="headerlink" title="1.什么是基于贫血模型的传统开发模式？"></a>1.什么是基于贫血模型的传统开发模式？</h3><p>像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo &#x3D; userService.getUserById(userId);</span><br><span class="line">    UserVo userVo &#x3D; [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity &#x3D; userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo &#x3D; [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-什么是基于充血模型的-DDD-开发模式？"><a href="#2-什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="2.什么是基于充血模型的 DDD 开发模式？"></a>2.什么是基于充血模型的 DDD 开发模式？</h3><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><h3 id="3-贫血模型-与-充血模型的代码模式区别"><a href="#3-贫血模型-与-充血模型的代码模式区别" class="headerlink" title="3.贫血模型 与 充血模型的代码模式区别"></a>3.贫血模型 与 充血模型的代码模式区别</h3><p>基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p><h3 id="4-为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#4-为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="4.为什么基于贫血模型的传统开发模式如此受欢迎？"></a>4.为什么基于贫血模型的传统开发模式如此受欢迎？</h3><ol><li><p>一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，基于贫血模型的传统开发模式简单够用</p></li><li><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p></li><li><p>思维已固化，转型有成本</p></li></ol><h3 id="5-什么时候该选择用贫血模型？什么时候该用充血模型？"><a href="#5-什么时候该选择用贫血模型？什么时候该用充血模型？" class="headerlink" title="5.什么时候该选择用贫血模型？什么时候该用充血模型？"></a>5.什么时候该选择用贫血模型？什么时候该用充血模型？</h3><p>基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><h2 id="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h2><h3 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h3><p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p><p><img src="/images/or01.jpg" alt="9e91377602ef154eaf866c7e9263a64a.jpeg"></p><h4 id="1-充值"><a href="#1-充值" class="headerlink" title="1.充值"></a>1.充值</h4><p>充值用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水</p><p><img src="/images/or02.jpg" alt="3915a6544403854d35678c81fe65f014.jpeg"></p><h4 id="2-支付"><a href="#2-支付" class="headerlink" title="2. 支付"></a>2. 支付</h4><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。<br><img src="/images/or03.jpg" alt="7eb44e2f8661d1c3debde85f79fb2c5e.jpeg"></p><h4 id="3-提现"><a href="#3-提现" class="headerlink" title="3. 提现"></a>3. 提现</h4><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。<br><img src="/images/or04.jpg" alt="66ede1de93d29b86a9194ea0f80d1e43.jpeg"></p><h4 id="4-查询余额"><a href="#4-查询余额" class="headerlink" title="4.查询余额"></a>4.查询余额</h4><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p><h4 id="5-查询交易流水"><a href="#5-查询交易流水" class="headerlink" title="5.查询交易流水"></a>5.查询交易流水</h4><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p><h4 id="钱包系统的设计思路-1"><a href="#钱包系统的设计思路-1" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h4><p>可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p><p><img src="/images/or05.jpg" alt="60d3cfec73986b52e3a6ef4fe147e562.jpeg"></p><p>以虚拟钱包的设计为例，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</p><p><img src="/images/or06.jpg" alt="d1a9aeb6642404f80a62293ab2e45630.jpeg"></p><p>充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？<br>虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p><p>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</p><p>可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p><p><img src="/images/or07.jpg" alt="fb356a2589a14f2f3440247e3c7a7718.jpeg"></p><h3 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h3><p>是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，省略了具体的代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VirtualWalletController &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123; ... &#125; &#x2F;&#x2F;查询余额</span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;出账</span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;入账</span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123; ...&#125; &#x2F;&#x2F;转账</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWalletBo &#123;&#x2F;&#x2F;省略getter&#x2F;setter&#x2F;constructor方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime;</span><br><span class="line">  private BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWalletBo getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWalletBo walletBo &#x3D; convert(walletEntity);</span><br><span class="line">    return walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    if (balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new NoSufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity &#x3D; new VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId &#x3D; transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    try &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; catch (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h3><p>跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。</p><p>把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWallet &#123; &#x2F;&#x2F; Domain领域模型(充血模型)</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime &#x3D; System.currentTimeMillis();;</span><br><span class="line">  private BigDecimal balance &#x3D; BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet(Long preAllocatedId) &#123;</span><br><span class="line">    this.id &#x3D; preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal balance() &#123;</span><br><span class="line">    return this.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(BigDecimal amount) &#123;</span><br><span class="line">    if (this.balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(BigDecimal amount) &#123;</span><br><span class="line">    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">      throw new InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    return wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    &#x2F;&#x2F;...跟基于贫血模型的传统开发模式的代码一样...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p><p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><h3 id="精彩评论：充血模型可以说是业务的精准抽象"><a href="#精彩评论：充血模型可以说是业务的精准抽象" class="headerlink" title="精彩评论：充血模型可以说是业务的精准抽象"></a>精彩评论：充血模型可以说是业务的精准抽象</h3><p>我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。</p><p>在维护性上来说，如果项目新进了开发人员，如果是贫血模型的service代码，无论代码如何清晰，注释如何完备，代码结构设计得如何优雅，都没有办法第一时间理解系统的核心业务逻辑，但是如果是充血模型，直接阅读充血模型的行为方法，起码能够很快理解70%左右的业务逻辑，因为充血模型可以说是业务的精准抽象，我想，这就是领域模型驱动能够达到”驱动”效果的由来吧。</p><h2 id="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"></a>实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>1.第一轮寄出分析：<br>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>2.第二轮优化分析<br>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的， 存在 重放攻击问题。我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p>3.第三轮优化分析</p><p>4.第四轮优化分析</p><p><img src="/images/or08.jpg" alt="bde932c73c6636ad85380e4801dbfb60.jpeg"></p><p>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li><p>开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p></li><li><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p></li></ol><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>3.针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.工作中遇到非crud的需求我就会想尽一切办法让他通用，基本需求分析和需求设计的时间占用百分之五十，开发和重构到自认为最优占用百分之五十。比如最简单的验证码功能，几乎每个项目都有，我就封装一套验证码服务，主要功能有你在配置文件里配置好需要被验证码拦截的路径，这里还要考虑到通配符，空格等等细节和可扩展的点，内置图片验证码，极验证，手机验证以及自定义验证码等等，总之我认为如果有机会遇到非crud的需求，一定要好好珍惜，好好把握，把他打造成属于自己的产品，这样会让自己下意识的去想尽一切办法把他做到最优，亲儿子一样的待遇，再也不会无脑cv</p><ol start="2"><li>一句话：使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进。<br>拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：</li><li>什么叫接口鉴权？搞清基本概念</li><li>接口鉴权最佳实践是什么？技术调研</li><li>appid和secret key从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。</li><li>appid secretkey存储在什么地方呢？数据存储</li><li>用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。</li><li>这个功能如何测试？提前想好如何测试</li><li>接口鉴权功能何时上线？估计工期</li><li>鉴权成功或失败返回码和信息定义？约定返回结果</li></ol><p>关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击。</p><ol start="3"><li>程序员十倍法则</li></ol><h2 id="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h2><p>向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><p>例子：我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p><p>1.把 URL、AppID、密码、时间戳拼接为一个字符串；<br>2.对字符串通过加密算法加密生成 token；<br>3.将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；<br>4.解析 URL，得到 token、AppID、时间戳等信息；<br>5.从存储中取出 AppID 和对应的密码；<br>6.根据时间戳判断 token 是否过期失效；<br>7.验证两个 token 是否匹配；</p><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><h3 id="2-定义类及其属性和方法"><a href="#2-定义类及其属性和方法" class="headerlink" title="2. 定义类及其属性和方法"></a>2. 定义类及其属性和方法</h3><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage</p><p>AuthToken 类相关的功能点有四个：</p><ul><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token；</li><li>根据时间戳判断 token 是否过期失效；</li><li>验证两个 token 是否匹配。</li></ul><p><img src="/images/or09.jpg" alt="69c8954e0db1a4db99a6094ee359fc9b.jpeg"></p><p>Url 类相关的功能点有两个：</p><ul><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息。<br><img src="/images/or10.jpg" alt="1cc9b95e511bd49fbc23c00ac5c0fed6.jpeg"></li></ul><p>CredentialStorage 类相关的功能点有一个：</p><ul><li>从存储中取出 AppID 和对应的密码。</li></ul><p><img src="/images/or11.jpg" alt="3b6d2c0cadafa723e26cc032c29c8785.jpeg"></p><h3 id="3-定义类与类之间的交互关系"><a href="#3-定义类与类之间的交互关系" class="headerlink" title="3. 定义类与类之间的交互关系"></a>3. 定义类与类之间的交互关系</h3><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p><p>泛化（Generalization）可以简单理解为继承关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实现（Realization）一般是指接口和实现类之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>组合 （Composition）只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系强调部分与整体的关系，其中包括两种情况，关联性强（大雁与翅膀）的与关联性弱（学生与班级）的。（这里将将 UML 定义的 关联、聚合、组合 统一归类为组合）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">组合（Composition）：关联性强（大雁与翅膀）</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">聚合（Aggregation）：关联性弱（学生与班级）</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  public void func(B b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-将类组装起来并提供执行入口"><a href="#4-将类组装起来并提供执行入口" class="headerlink" title="4. 将类组装起来并提供执行入口"></a>4. 将类组装起来并提供执行入口</h3><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p><h3 id="评论区的代码实现参考"><a href="#评论区的代码实现参考" class="headerlink" title="评论区的代码实现参考"></a>评论区的代码实现参考</h3><p><a href="https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014</a></p><p><a href="https://gitee.com/MondayLiu/geek-design" target="_blank" rel="noopener">https://gitee.com/MondayLiu/geek-design</a></p><p><a href="https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth" target="_blank" rel="noopener">https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot;&gt;&lt;a href=&quot;#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot; class=&quot;headerlink&quot; title=&quot;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&quot;&gt;&lt;/a&gt;实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？&lt;/h2&gt;&lt;h3 id=&quot;1-什么是基于贫血模型的传统开发模式？&quot;&gt;&lt;a href=&quot;#1-什么是基于贫血模型的传统开发模式？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是基于贫血模型的传统开发模式？&quot;&gt;&lt;/a&gt;1.什么是基于贫血模型的传统开发模式？&lt;/h3&gt;&lt;p&gt;像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美-笔记Part1：面向对象-如何写出高质量的代码</title>
    <link href="https://crazyfzw.github.io/2020/10/01/design-pattern-object-oriented01/"/>
    <id>https://crazyfzw.github.io/2020/10/01/design-pattern-object-oriented01/</id>
    <published>2020-10-01T03:32:52.000Z</published>
    <updated>2021-01-02T07:49:40.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习设计模式的重要性"><a href="#学习设计模式的重要性" class="headerlink" title="学习设计模式的重要性"></a>学习设计模式的重要性</h2><h3 id="学习设计模式可以让读源码、框架事半功倍"><a href="#学习设计模式可以让读源码、框架事半功倍" class="headerlink" title="学习设计模式可以让读源码、框架事半功倍"></a>学习设计模式可以让读源码、框架事半功倍</h3><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p><a id="more"></a><h3 id="提高复杂代码的设计和开发能力"><a href="#提高复杂代码的设计和开发能力" class="headerlink" title="提高复杂代码的设计和开发能力"></a>提高复杂代码的设计和开发能力</h3><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p><h2 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h2><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h2 id="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h2><p><img src="/images/20201001.jpg" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p><ul><li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul><h2 id="面向对象编程的一些基础概念"><a href="#面向对象编程的一些基础概念" class="headerlink" title="面向对象编程的一些基础概念"></a>面向对象编程的一些基础概念</h2><ol><li><p>什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p></li><li><p>什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li><li><p>如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p></li><li><p>面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p></li><li><p>什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p></li></ol><h2 id="UML-图只要能表达出设计就可以了"><a href="#UML-图只要能表达出设计就可以了" class="headerlink" title="UML 图只要能表达出设计就可以了"></a>UML 图只要能表达出设计就可以了</h2><p>要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。</p><h2 id="封装、抽象、继承、多态-存在的意义"><a href="#封装、抽象、继承、多态-存在的意义" class="headerlink" title="封装、抽象、继承、多态 存在的意义"></a>封装、抽象、继承、多态 存在的意义</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据, 封装存在的意思，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。但是，过度的使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态特性能提高代码的可扩展性和复用性。除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><p>接下来，看个例子如何利用接口类来实现多态特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Iterator arrayIterator = <span class="keyword">new</span> Array();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    Iterator linkedListIterator = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。</p><p>具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。</p><p>我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p><p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p><h3 id="面向对象特性的-What-How-Why-模型总结"><a href="#面向对象特性的-What-How-Why-模型总结" class="headerlink" title="面向对象特性的 What/How/Why 模型总结"></a>面向对象特性的 What/How/Why 模型总结</h3><p>##封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。</p><p>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。</p><p>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。</p><p>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。</p><p>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。</p><h2 id="什么是面向过程编程？什么是面向过程编程语言？"><a href="#什么是面向过程编程？什么是面向过程编程语言？" class="headerlink" title="什么是面向过程编程？什么是面向过程编程语言？"></a>什么是面向过程编程？什么是面向过程编程语言？</h2><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>面向对象编程相比起面向过程编程的优势主要有三个。</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h2 id="怎么考虑选择使用面向过程语言还是面向对象语言？"><a href="#怎么考虑选择使用面向过程语言还是面向对象语言？" class="headerlink" title="怎么考虑选择使用面向过程语言还是面向对象语言？"></a>怎么考虑选择使用面向过程语言还是面向对象语言？</h2><p>使用任何一个编程语言编写的程序，最终执行上都要落实到CPU一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。<br>C语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C语言用数组char a[8]，经过编译以后变成了（基地址＋偏移量）的方式。对于CPU来说，没有运算比加法更快，它的执行效率的算法复杂度是O(1)的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C语言是极好的选择。<br>C语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了OOP等更“智能”的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节, 占用了更大的内存空间, 占用了更多的CPU运算。从这个角度看，OOP这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核600MHz为主流，运行Android系统点击一个界面需要2秒才能响应，那我们现在用的大部分手机程序绝对不是使用JAVA开发的，Android操作系统也不可能建立起这么大的生态。</p><h2 id="哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的？"></a>哪些代码设计看似是面向对象，实际是面向过程的？</h2><h3 id="1-滥用-getter、setter-方法"><a href="#1-滥用-getter、setter-方法" class="headerlink" title="1. 滥用 getter、setter 方法"></a>1. 滥用 getter、setter 方法</h3><p>面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p><p>在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</p><p>Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-滥用全局变量和全局方法"><a href="#2-滥用全局变量和全局方法" class="headerlink" title="2. 滥用全局变量和全局方法"></a>2. 滥用全局变量和全局方法</h3><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性</p><h3 id="3-定义数据和方法分离的"><a href="#3-定义数据和方法分离的" class="headerlink" title="3. 定义数据和方法分离的"></a>3. 定义数据和方法分离的</h3><p>这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的</p><h2 id="接口vs抽象类的区别？"><a href="#接口vs抽象类的区别？" class="headerlink" title="接口vs抽象类的区别？"></a>接口vs抽象类的区别？</h2><h3 id="1-抽象类的特性"><a href="#1-抽象类的特性" class="headerlink" title="1.抽象类的特性"></a>1.抽象类的特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">    doLog(level, message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, String filepath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.fileWriter = <span class="keyword">new</span> FileWriter(filepath); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MessageQueueLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）。</p></li><li><p>我抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作抽象方法。</p></li><li><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p></li></ul><h3 id="2-接口的特性"><a href="#2-接口的特性" class="headerlink" title="2.接口的特性"></a>2.接口的特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...鉴权逻辑..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...限流逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用Demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">  <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRpcRequest</span><span class="params">(RpcRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        filter.doFilter(req);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">      <span class="comment">// ...处理过滤结果...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略其他处理逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能包含属性（也就是成员变量）。</li><li>接口只能声明方法，方法不能包含代码实现。</li><li>类实现接口的时候，必须实现接口中声明的所有方法。</li></ul><h3 id="3-抽象类和接口的语法特性小结"><a href="#3-抽象类和接口的语法特性小结" class="headerlink" title="3.抽象类和接口的语法特性小结"></a>3.抽象类和接口的语法特性小结</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><h3 id="4-抽象类和接口的区别"><a href="#4-抽象类和接口的区别" class="headerlink" title="4.抽象类和接口的区别"></a>4.抽象类和接口的区别</h3><p>抽象类更多的是为了代码复用，多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。</p><p>而接口就更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。<br>你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><h3 id="5-什么时候该用抽象类？什么时候该用接口？"><a href="#5-什么时候该用抽象类？什么时候该用接口？" class="headerlink" title="5.什么时候该用抽象类？什么时候该用接口？"></a>5.什么时候该用抽象类？什么时候该用接口？</h3><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h2 id="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h2><h3 id="结合一个有关图片存储的实战案例"><a href="#结合一个有关图片存储的实战案例" class="headerlink" title="结合一个有关图片存储的实战案例"></a>结合一个有关图片存储的实战案例</h3><p>下面是 “基于实现的编程”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket代码逻辑...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...; <span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    AliyunImageStore imageStore = <span class="keyword">new</span> AliyunImageStore(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">    String accessToken = imageStore.generateAccessToken();</span><br><span class="line">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的问题分析：</p><ol><li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li></ol><p>2.封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。比如 generateAccessToken 这个特殊的方法就没必要暴露了</p><p>3.为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</p><p>改造成 “基于接口而非实现编程” 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span></span>;</span><br><span class="line">  <span class="function">Image <span class="title">download</span><span class="params">(String url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span>  </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">    <span class="comment">//...返回图片的url...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...;<span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    ImageStore imageStore = <span class="keyword">new</span> PrivateImageStore(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么基于接口而非实现编程？"><a href="#为什么基于接口而非实现编程？" class="headerlink" title="为什么基于接口而非实现编程？"></a>为什么基于接口而非实现编程？</h3><p>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性</p><h3 id="有必要为每个类都定义接口吗？"><a href="#有必要为每个类都定义接口吗？" class="headerlink" title="有必要为每个类都定义接口吗？"></a>有必要为每个类都定义接口吗？</h3><ol><li>视业务场景而定，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li><li>某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li></ol><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><ol start="2"><li>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</li></ol><p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2 id="为何说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#为何说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="为何说要多用组合少用继承？如何决定该用组合还是继承？"></a>为何说要多用组合少用继承？如何决定该用组合还是继承？</h2><h3 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h3><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。<br>比如继承<br><img src="/images/20201002.jpg" alt="3f99fa541e7ec7656a1dd35cc4f28bc6.jpeg"></p><h3 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h3><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><h3 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h3><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"><a href="#如何用组合、接口、委托三个技术手段来避免继承层级过多的问题" class="headerlink" title="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"></a>如何用组合、接口、委托三个技术手段来避免继承层级过多的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FlyAbility implements Flyable </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span>&#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> EggLayAbility eggLayAbility = <span class="keyword">new</span> EggLayAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习设计模式的重要性&quot;&gt;&lt;a href=&quot;#学习设计模式的重要性&quot; class=&quot;headerlink&quot; title=&quot;学习设计模式的重要性&quot;&gt;&lt;/a&gt;学习设计模式的重要性&lt;/h2&gt;&lt;h3 id=&quot;学习设计模式可以让读源码、框架事半功倍&quot;&gt;&lt;a href=&quot;#学习设计模式可以让读源码、框架事半功倍&quot; class=&quot;headerlink&quot; title=&quot;学习设计模式可以让读源码、框架事半功倍&quot;&gt;&lt;/a&gt;学习设计模式可以让读源码、框架事半功倍&lt;/h3&gt;&lt;p&gt;优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://crazyfzw.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Java SPI 机制</title>
    <link href="https://crazyfzw.github.io/2019/08/24/java-spi/"/>
    <id>https://crazyfzw.github.io/2019/08/24/java-spi/</id>
    <published>2019-08-24T04:37:56.000Z</published>
    <updated>2021-01-02T07:53:23.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPI-可以用来做什么"><a href="#SPI-可以用来做什么" class="headerlink" title="# SPI 可以用来做什么"></a><a href="#SPI-可以用来做什么" title="# SPI 可以用来做什么"></a># SPI 可以用来做什么</h2><p>在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：</p><ol><li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li><li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。</li></ol><p>而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。</p><p>Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。</p><a id="more"></a><p>（大致原理就是：在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用 java.util.ServiceLoader 来加载具体的实现。）</p><p><img src="/images/2019082401.png" alt=""></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><a href="#使用场景" title="使用场景"></a>使用场景</h3><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：</p><ol><li><p>JDBC自动加载不同类型的数据库驱动， mysql-connector-java-xxx.jar</p></li><li><p>日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类</p></li><li><p>Dubbo中在Java SPI 的基础上做了加强， 实现了根据方法参数或者配置来决定该使用哪个扩展。比如LoadBalance 做到了根据调用者参数的指定来应用不同的负债均衡策略。</p></li></ol><h2 id="如何实现一个自定义-SPI"><a href="#如何实现一个自定义-SPI" class="headerlink" title="# 如何实现一个自定义 SPI"></a><a href="#如何实现一个自定义-SPI" title="# 如何实现一个自定义 SPI"></a># 如何实现一个自定义 SPI</h2><p>这里由于现实情况不同厂商的实现肯定是分开的，所以不同厂商我是建了不同的 maven-modules， 目录结果如下：</p><p><img src="/images/2019082402.png" alt=""></p><h3 id="1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来"><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" class="headerlink" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a>1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 建立连接</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span></span>;</span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><h3 id="2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" class="headerlink" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a>2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository</h3><p> MysqlRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mysql"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.mysql.MysqlRepository</span></pre></td></tr></table></figure><p>OracleRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Oracle"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span></pre></td></tr></table></figure><p>MongoRepository 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span><span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mongo"</span>);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span></pre></td></tr></table></figure><h3 id="3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）"><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" class="headerlink" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a>3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）</h3><p>这里是invoker-test 模块的pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>interface-standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oracle-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"></span><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure><h3 id="4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现"><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" class="headerlink" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a>4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line"></span><span class="line">        ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);</span><span class="line"></span><span class="line">        Iterator&lt;IRepository&gt; it = serviceLoader.iterator();</span><span class="line">        <span class="keyword">while</span> (it != <span class="keyword">null</span> &amp;&amp; it.hasNext())&#123;</span><span class="line">            IRepository repositoryService = it.next();</span><span class="line">            System.out.println(<span class="string">"class:"</span> + repositoryService.getClass().getName());</span><span class="line">            repositoryService.connect(<span class="string">"172.0.0.1:3306"</span>);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>运行效果图如下：</p><p><img src="/images/2019082403.png" alt=""></p><p><strong>调用主类无需修改代码，只需通过修改pom引入不同的依赖，就可以选择切换不同的实现。</strong></p><h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="# SPI 的优缺点"></a><a href="#SPI-的优缺点" title="# SPI 的优缺点"></a># SPI 的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><a href="#优点：" title="优点："></a>优点：</h3><ol><li>Java SPI的使用很简单。也做到了基本的加载扩展点的功能，可以使业务代码和组件代码脱耦，启用替换可插拔</li><li>拓展性好，在不修改原来代码的基础上，通过添加代码就可以拓展新的能力</li><li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便</li></ol><h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><a href="#不足：" title="不足："></a>不足：</h3><ol><li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li><li>不提供类似于Spring的IOC和AOP功能，扩展如果依赖其他的扩展，做不到自动注入和装配</li></ol><p>针对这些问题， Dubbo在原生  Java SPI 的基础上做了一些拓展。 可见参考文献[3][4]。</p><p>*<em>本文涉及的spi-demo源码地址： *</em><br><a href="https://github.com/crazyfzw/spi-demo.git" target="_blank" rel="noopener">https://github.com/crazyfzw/spi-demo.git</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://www.cnkirito.moe/spi/" target="_blank" rel="noopener">JAVA拾遗–关于SPI机制</a></p><p>[2]<a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">JDBC实现及 DriverManager 源码解析</a></p><p>[3]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">Dubbo可扩展机制实战</a></p><p>[4]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html" target="_blank" rel="noopener">Dubbo可扩展机制源码解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SPI-可以用来做什么&quot;&gt;&lt;a href=&quot;#SPI-可以用来做什么&quot; class=&quot;headerlink&quot; title=&quot;# SPI 可以用来做什么&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#SPI-可以用来做什么&quot; title=&quot;# SPI 可以用来做什么&quot;&gt;&lt;/a&gt;# SPI 可以用来做什么&lt;/h2&gt;&lt;p&gt;在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。&lt;/li&gt;
&lt;li&gt;作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。&lt;/p&gt;
&lt;p&gt;Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crazyfzw.github.io/categories/Java/"/>
    
    
      <category term="Java SPI" scheme="https://crazyfzw.github.io/tags/Java-SPI/"/>
    
  </entry>
  
  <entry>
    <title>慢谈 Redis 实现分布式锁 以及 Redisson 源码解析</title>
    <link href="https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/"/>
    <id>https://crazyfzw.github.io/2019/08/24/distributed-locks-with-redis/</id>
    <published>2019-08-24T03:51:21.000Z</published>
    <updated>2021-01-02T07:54:31.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="# 产生背景"></a><a href="#产生背景" title="# 产生背景"></a># 产生背景</h2><blockquote><p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p></blockquote><p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p><p>随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p><a id="more"></a><h2 id="实现分布式锁的三种选择"><a href="#实现分布式锁的三种选择" class="headerlink" title="# 实现分布式锁的三种选择"></a><a href="#实现分布式锁的三种选择" title="# 实现分布式锁的三种选择"></a># 实现分布式锁的三种选择</h2><ul><li>基于数据库实现分布式锁*   基于zookeeper实现分布式锁</li><li>基于Redis缓存实现分布式锁</li></ul><p>以上三种方式都可以实现分布式锁，其中，从健壮性考虑， 用 zookeeper 会比用 Redis 实现更好，但从性能角度考虑，基于 Redis 实现性能会更好，如何选择，还是取决于业务需求。</p><h2 id="基于-Redis-实现分布式锁的三种方案"><a href="#基于-Redis-实现分布式锁的三种方案" class="headerlink" title="# 基于 Redis 实现分布式锁的三种方案"></a><a href="#基于-Redis-实现分布式锁的三种方案" title="# 基于 Redis 实现分布式锁的三种方案"></a># 基于 Redis 实现分布式锁的三种方案</h2><ul><li>用 Redis 实现分布式锁的正确姿势（实现一）</li><li>用 Redisson 实现分布式可重入锁（RedissonLock）（实现二）</li><li>用 Redisson 实现分布式锁(红锁 RedissonRedLock)（实现三）</li></ul><p><strong>本文主要探讨基于 Redis 实现分布式锁的方案，主要分析并对比了以上三种方案，并大致分析了 Redisson 的 RedissonLock 、 RedissonRedLock 源码。</strong></p><h2 id="分布式锁需满足四个条件"><a href="#分布式锁需满足四个条件" class="headerlink" title="# 分布式锁需满足四个条件"></a><a href="#分布式锁需满足四个条件" title="# 分布式锁需满足四个条件"></a># 分布式锁需满足四个条件</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li><li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li></ol><h2 id="用-Redis-实现分布式锁的正确姿势（实现一）"><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" class="headerlink" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a># 用 Redis 实现分布式锁的正确姿势（实现一）</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a><a href="#主要思路" title="主要思路"></a>主要思路</h3><p>通过 set key value px milliseconds nx 命令实现加锁， 通过Lua脚本实现解锁。核心实现命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁（unique_value可以是UUID等）</span></span><span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span><span class="line"></span><span class="line"><span class="comment">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span></span><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><span class="line"><span class="keyword">else</span></span><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><span class="line">end</span></pre></td></tr></table></figure><p>这种实现方式主要有以下几个要点：</p><ul><li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p></li><li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p></li><li><p>释放锁时要验证 value 值，防止误解锁；</p></li><li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p></li></ul><h3 id="完整代码实现如下："><a href="#完整代码实现如下：" class="headerlink" title="完整代码实现如下："></a><a href="#完整代码实现如下：" title="完整代码实现如下："></a>完整代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><span class="line"></span><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><span class="line"></span><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span><span class="line">        </span><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line"></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><a href="#加锁代码分析" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><a href="#解锁代码分析" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p><h3 id="这种方式仍存在单点风险"><a href="#这种方式仍存在单点风险" class="headerlink" title="这种方式仍存在单点风险"></a><a href="#这种方式仍存在单点风险" title="这种方式仍存在单点风险"></a>这种方式仍存在单点风险</h3><p><strong>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</strong></p><ol><li>客户端A从master获取到锁</li><li>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。</li><li>主从切换，slave节点被晋级为master节点</li><li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</li></ol><p><strong>所以在这种实现之下，不论Redis的部署架构是单机模式、主从模式、哨兵模式还是集群模式，都存在这种风险。因为Redis的主从同步是异步的。 运行的是，Redis 之父 antirez 提出了 redlock算法 可以解决这个问题。</strong></p><h2 id="Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" class="headerlink" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</h2><h3 id="什么是-Redisson"><a href="#什么是-Redisson" class="headerlink" title="什么是 Redisson"></a><a href="#什么是-Redisson" title="什么是 Redisson"></a>什么是 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><a href="#Redisson-分布式重入锁用法" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><span class="line">Config config = <span class="keyword">new</span> Config();</span><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><span class="line">RLock rLock = redissonClient.getLock(lockKey);</span><span class="line"><span class="keyword">try</span> &#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><span class="line">    <span class="keyword">if</span> (res) &#123;</span><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><span class="line">    &#125;</span><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><span class="line">    rLock.unlock();</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="加锁源码分析"><a href="#加锁源码分析" class="headerlink" title="加锁源码分析"></a><a href="#加锁源码分析" title="加锁源码分析"></a>加锁源码分析</h3><p><strong>1.通过 getLock 方法获取对象</strong></p><p><strong>org.redisson.Redisson#getLock()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     *  构造并返回一个 RedissonLock 对象 </span></span><span class="line"><span class="comment">     * commandExecutor: 与 Redis 节点通信并发送指令的真正实现。需要说明一下，CommandExecutor 实现是通过 eval 命令来执行 Lua 脚本</span></span><span class="line"><span class="comment">     * name: 锁的全局名称</span></span><span class="line"><span class="comment">     * id: Redisson 客户端唯一标识，实际上就是一个 UUID.randomUUID()</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name, id);</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>2.通过tryLock方法尝试获取锁</strong></p><p>tryLock方法里的调用关系大致如下：</p><p><img src="/images/2019041501.png" alt=""></p><p><strong>org.redisson.RedissonLock#tryLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">    <span class="comment">//取得最大等待时间</span></span><span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><span class="line">    <span class="comment">//记录下当前时间</span></span><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><span class="line">    <span class="comment">//取得当前线程id（判断是否可重入锁的关键）</span></span><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><span class="line">    <span class="comment">//1.尝试申请锁，返回还剩余的锁过期时间</span></span><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span><span class="line">    <span class="comment">//2.如果为空，表示申请锁成功</span></span><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">    &#125;</span><span class="line">    <span class="comment">//3.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span><span class="line">    time -= System.currentTimeMillis() - current;</span><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 通过 promise.trySuccess 设置异步执行的结果为null</span></span><span class="line"><span class="comment">         * Promise从Uncompleted--&gt;Completed ,通知 Future 异步执行已完成</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        acquireFailed(threadId);</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    current = System.currentTimeMillis();</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.订阅锁释放事件，并通过await方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：</span></span><span class="line"><span class="comment">     * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争</span></span><span class="line"><span class="comment">     * 当 this.await返回false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败</span></span><span class="line"><span class="comment">     * 当 this.await返回true，进入循环尝试获取锁</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><span class="line">    <span class="comment">//await 方法内部是用CountDownLatch来实现阻塞，获取subscribe异步执行的结果（应用了Netty 的 Future）</span></span><span class="line">    <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span><span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><span class="line">                    unsubscribe(subscribeFuture, threadId);</span><span class="line">                &#125;</span><span class="line">            &#125;);</span><span class="line">        &#125;</span><span class="line">        acquireFailed(threadId);</span><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">try</span> &#123;</span><span class="line">        <span class="comment">//计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败</span></span><span class="line">        time -= System.currentTimeMillis() - current;</span><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">            acquireFailed(threadId);</span><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 5.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁</span></span><span class="line"><span class="comment">         * 获取锁成功，则立马返回true，</span></span><span class="line"><span class="comment">         * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回false结束循环</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><span class="line">            <span class="comment">// 再次尝试申请锁</span></span><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span><span class="line">            <span class="comment">// 成功获取锁则直接返回true结束循环</span></span><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">//超过最大等待时间则返回false结束循环，获取锁失败</span></span><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">                acquireFailed(threadId);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            currentTime = System.currentTimeMillis();</span><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><span class="line">                <span class="comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span></span><span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="comment">//则就在wait time 时间范围内等待可以通过信号量</span></span><span class="line">                getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">//7.更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span></span><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><span class="line">                acquireFailed(threadId);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><span class="line">        <span class="comment">//7.无论是否获得锁,都要取消订阅解锁消息</span></span><span class="line">        unsubscribe(subscribeFuture, threadId);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>其中 tryAcquire 内部通过调用 tryLockInnerAsync 实现申请锁的逻辑。申请锁并返回锁有效期还剩余的时间，如果为空说明锁未被其它线程申请则直接获取并返回，如果获取到时间，则进入等待竞争逻辑。</p><p><strong>org.redisson.RedissonLock#tryLockInnerAsync</strong></p><p><strong>加锁流程图：</strong><br><img src="/images/2019041502.png" alt=""></p><p><strong>实现源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><span class="line">              <span class="comment">// 1.如果缓存中的key不存在，则执行 hset 命令(hset key UUID+threadId 1),然后通过 pexpire 命令设置锁的过期时间(即锁的租约时间)</span></span><span class="line">              <span class="comment">// 返回空值 nil ，表示获取锁成功</span></span><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><span class="line">                  <span class="string">"return nil; "</span> +</span><span class="line">              <span class="string">"end; "</span> +</span><span class="line">               <span class="comment">// 如果key已经存在，并且value也匹配，表示是当前线程持有的锁，则执行 hincrby 命令，重入次数加1，并且设置失效时间</span></span><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><span class="line">                  <span class="string">"return nil; "</span> +</span><span class="line">              <span class="string">"end; "</span> +</span><span class="line">               <span class="comment">//如果key已经存在，但是value不匹配，说明锁已经被其他线程持有，通过 pttl 命令获取锁的剩余存活时间并返回，至此获取锁失败</span></span><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><span class="line">               <span class="comment">//这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span><span class="line">               Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key；</p></li><li><p>ARGV[1]就是internalLockLeaseTime，即锁的租约时间（持有锁的有效时间），默认30s；</p></li><li><p>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值 value，即UUID+threadId。</p></li></ul><h3 id="解锁源码分析"><a href="#解锁源码分析" class="headerlink" title="解锁源码分析"></a><a href="#解锁源码分析" title="解锁源码分析"></a>解锁源码分析</h3><p>unlock 内部通过 get(unlockAsync(Thread.currentThread().getId()))  调用 unlockInnerAsync 解锁。</p><p><strong>org.redisson.RedissonLock#unlock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><span class="line">    <span class="keyword">try</span> &#123;</span><span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span><span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span><span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="keyword">throw</span> e;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>get方法利用是 CountDownLatch 在异步调用结果返回前将当前线程阻塞，然后通过 Netty 的 FutureListener 在异步调用完成后解除阻塞，并返回调用结果。</p><p><strong>org.redisson.command.CommandAsyncService#get</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;   <span class="comment">//任务还没完成</span></span><span class="line">        <span class="comment">// 设置一个单线程的同步控制器</span></span><span class="line">        CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><span class="line">            <span class="comment">//操作完成时，唤醒在await()方法中等待的线程</span></span><span class="line">            l.countDown();</span><span class="line">        &#125;);</span><span class="line"></span><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                <span class="comment">//阻塞等待</span></span><span class="line">                l.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                interrupted = <span class="keyword">true</span>;</span><span class="line">                <span class="keyword">break</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><span class="line">            Thread.currentThread().interrupt();</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><span class="line">        <span class="keyword">return</span> future.getNow();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">throw</span> convertException(future);</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>org.redisson.RedissonLock#unlockInnerAsync</strong></p><p><strong>解锁流程图：</strong><br><img src="/images/2019041503.png" alt=""></p><p><strong>实现源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><span class="line">            <span class="comment">//如果分布式锁存在，但是value不匹配，表示锁已经被其他线程占用，无权释放锁，那么直接返回空值（解铃还须系铃人）</span></span><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><span class="line">                <span class="string">"return nil;"</span> +</span><span class="line">            <span class="string">"end; "</span> +</span><span class="line">             <span class="comment">//如果value匹配，则就是当前线程占有分布式锁，那么将重入次数减1</span></span><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><span class="line">             <span class="comment">//重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只能更新失效时间，还不能删除</span></span><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><span class="line">                <span class="string">"return 0; "</span> +</span><span class="line">            <span class="string">"else "</span> +</span><span class="line">             <span class="comment">//重入次数减1后的值如果为0，这时就可以删除这个KEY，并发布解锁消息，返回1</span></span><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><span class="line">                <span class="string">"return 1; "</span>+</span><span class="line">            <span class="string">"end; "</span> +</span><span class="line">            <span class="string">"return nil;"</span>,</span><span class="line">            <span class="comment">//这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="解锁消息处理"><a href="#解锁消息处理" class="headerlink" title="解锁消息处理"></a><a href="#解锁消息处理" title="解锁消息处理"></a>解锁消息处理</h3><p><strong>org.redisson.pubsub#onMessage</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_MESSAGE = <span class="number">0L</span>;</span><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long READ_UNLOCK_MESSAGE = <span class="number">1L</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockPubSub</span><span class="params">(PublishSubscribeService service)</span> </span>&#123;</span><span class="line">        <span class="keyword">super</span>(service);</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Override</span></span><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 判断是否是解锁消息</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span><span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span><span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span><span class="line">                runnableToExecute.run();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 释放一个信号量，唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            value.getLatch().release();</span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">                <span class="comment">/**</span></span><span class="line"><span class="comment">                 * 如果还有其他Listeners回调，则也唤醒执行</span></span><span class="line"><span class="comment">                 */</span></span><span class="line">                Runnable runnableToExecute = value.getListeners().poll();</span><span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span><span class="line">                    <span class="keyword">break</span>;</span><span class="line">                &#125;</span><span class="line">                runnableToExecute.run();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            value.getLatch().release(value.getLatch().getQueueLength());</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span><span class="line"></span></pre></td></tr></table></figure><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><a href="#总结对比" title="总结对比"></a>总结对比</h3><p>通过 Redisson 实现分布式可重入锁（实现二），比纯自己通过set key value px milliseconds nx +lua 实现（实现一）的效果更好些，虽然基本原理都一样，因为通过分析源码可知，RedissonLock<br>是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。   </p><p><strong>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</strong></p><p><strong>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</strong></p><h2 id="redlock算法"><a href="#redlock算法" class="headerlink" title="# redlock算法"></a><a href="#redlock算法" title="# redlock算法"></a># redlock算法</h2><p>Redis 官网对 redLock 算法的介绍大致如下：</p><blockquote><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">The Redlock algorithm</a></p></blockquote><p>在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p><ol><li><p>获取当前Unix时间，以毫秒为单位。</p></li><li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p></li><li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p></li><li><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p></li><li><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p></li></ol><h2 id="用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" class="headerlink" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</h2><p>这里以三个单机模式为例，需要特别注意的是他们完全互相独立，不存在主从复制或者其他集群协调机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span></pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><span class="line"></span><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><span class="line"></span><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><span class="line"></span><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span><span class="line"><span class="comment"> */</span></span><span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span><span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span><span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span><span class="line"></span><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span><span class="line"><span class="comment"> */</span></span><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><span class="line"></span><span class="line"><span class="keyword">try</span> &#123;</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><span class="line">    <span class="keyword">if</span> (res) &#123;</span><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><span class="line">    &#125;</span><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><span class="line">    redLock.unlock();</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong>最核心的变化就是需要构建多个 RLock ,然后根据多个 RLock 构建成一个 RedissonRedLock，因为 redLock 算法是建立在多个互相独立的 Redis 环境之上的（为了区分可以叫为 Redission node），Redission node 节点既可以是单机模式(single)，也可以是主从模式(master/salve)，哨兵模式(sentinal)，或者集群模式(cluster)。这就意味着，不能跟以往这样只搭建 1个 cluster、或 1个 sentinel 集群，或是1套主从架构就了事了，需要为 RedissonRedLock 额外搭建多几套独立的 Redission 节点。 比如可以搭建3个 或者5个 Redission节点，具体可看视资源及业务情况而定。</strong></p><p><strong>下图是一个利用多个 Redission node 最终 组成 RedLock分布式锁的例子，需要特别注意的是每个  Redission node 是互相独立的，不存在任何复制或者其他隐含的分布式协调机制。</strong></p><p><img src="/images/2019041504.png" alt=""><br><img src="/images/2019041505.png" alt=""></p><h2 id="Redisson-实现redlock算法源码分析（RedLock）"><a href="#Redisson-实现redlock算法源码分析（RedLock）" class="headerlink" title="# Redisson 实现redlock算法源码分析（RedLock）"></a><a href="#Redisson-实现redlock算法源码分析（RedLock）" title="# Redisson 实现redlock算法源码分析（RedLock）"></a># Redisson 实现redlock算法源码分析（RedLock）</h2><p><strong>加锁核心代码</strong></p><p> <strong>org.redisson.RedissonMultiLock#tryLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span><span class="line">101</span><span class="line">102</span><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span><span class="line">    &#125;</span><span class="line">    </span><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span><span class="line">        remainTime = unit.toMillis(waitTime);</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 1\. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 2\. 遍历所有节点通过EVAL命令执行lua加锁</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span><span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><span class="line">        RLock lock = iterator.next();</span><span class="line">        <span class="keyword">boolean</span> lockAcquired;</span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><span class="line">                lockAcquired = lock.tryLock();</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><span class="line">            &#125;</span><span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span><span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span><span class="line">            unlockInner(Arrays.asList(lock));</span><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><span class="line">        &#125;</span><span class="line">        </span><span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             *4\. 如果获取到锁则添加到已获取锁集合中</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            acquiredLocks.add(lock);</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="comment">/**</span></span><span class="line"><span class="comment">             * 5\. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span><span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span><span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span><span class="line"><span class="comment">             */</span></span><span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span><span class="line">                <span class="keyword">break</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><span class="line">                unlockInner(acquiredLocks);</span><span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">                &#125;</span><span class="line">                failedLocksLimit = failedLocksLimit();</span><span class="line">                acquiredLocks.clear();</span><span class="line">                <span class="comment">// reset iterator</span></span><span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><span class="line">                    iterator.previous();</span><span class="line">                &#125;</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                failedLocksLimit--;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">/**</span></span><span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><span class="line">            time = System.currentTimeMillis();</span><span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><span class="line">                unlockInner(acquiredLocks);</span><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span><span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><span class="line">            futures.add(future);</span><span class="line">        &#125;</span><span class="line">        </span><span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><span class="line">            rFuture.syncUninterruptibly();</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p><p>[2]<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Distributed locks with Redis 中文版</a></p><p>[3]<a href="https://redis.io/commands/set" target="_blank" rel="noopener">SET - Redis</a></p><p>[4]<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">EVAL command</a></p><p>[5] <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></p><p>[6]<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p><p>[7]<a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">Redlock实现分布式锁</a></p><p>[8]<a href="https://mp.weixin.qq.com/s/iaZcc7QGbGHkZkfLeYp1yg" target="_blank" rel="noopener">Redisson实现Redis分布式锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;产生背景&quot;&gt;&lt;a href=&quot;#产生背景&quot; class=&quot;headerlink&quot; title=&quot;# 产生背景&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#产生背景&quot; title=&quot;# 产生背景&quot;&gt;&lt;/a&gt;# 产生背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。&lt;/p&gt;
&lt;p&gt;随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="distributed" scheme="https://crazyfzw.github.io/categories/distributed/"/>
    
    
      <category term="Redis" scheme="https://crazyfzw.github.io/tags/Redis/"/>
    
      <category term="Redisson" scheme="https://crazyfzw.github.io/tags/Redisson/"/>
    
  </entry>
  
</feed>
