<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazyfzw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、概述Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 开发与运维 1：聊聊 Redis">
<meta property="og:url" content="https://crazyfzw.github.io/2018/08/01/talk-about-redis/index.html">
<meta property="og:site_name" content="Crazyfzw&#39;s blog">
<meta property="og:description" content="一、概述Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808000.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080801.svg">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080802.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080804.svg">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080803.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080805.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080806.svg">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080807.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080809.svg">
<meta property="og:image" content="https://crazyfzw.github.io/images/2018080808.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808010.svg">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808011.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808012.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808013.png">
<meta property="og:image" content="https://crazyfzw.github.io/images/20180808014.png">
<meta property="article:published_time" content="2018-08-01T12:51:03.000Z">
<meta property="article:modified_time" content="2021-01-02T07:53:38.687Z">
<meta property="article:author" content="crazyfzw">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crazyfzw.github.io/images/20180808000.png">

<link rel="canonical" href="https://crazyfzw.github.io/2018/08/01/talk-about-redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Redis 开发与运维 1：聊聊 Redis | Crazyfzw's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Crazyfzw's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Crazyfzw's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Return to base, step by step.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://crazyfzw.github.io/2018/08/01/talk-about-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="crazyfzw">
      <meta itemprop="description" content="做个有趣的技术人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crazyfzw's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 开发与运维 1：聊聊 Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-01 20:51:03" itemprop="dateCreated datePublished" datetime="2018-08-01T20:51:03+08:00">2018-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-02 15:53:38" itemprop="dateModified" datetime="2021-01-02T15:53:38+08:00">2021-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/01/talk-about-redis/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/01/talk-about-redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的数据都放到内存中，因此 Redis 速度很快。除此之外，Redis 还提供了 持久化、主从复制、集群 以及以下几点功能：</p>
<ul>
<li>提供了键过期功能，可以用来实现缓存。</li>
<li>提供了发布订阅功能，可以用来实现消息系统。</li>
<li>支持 Lua 脚本功能，可以根据需要定制自己的 Redis 命令。</li>
<li>提供了简单的事务功能， 能在一定程度上保证事物特性。</li>
<li>提供了流水线（Pipeline）功能， 客户端可以将一批命令一次性传到 Redis，从而减少网络的开销。</li>
</ul>
<a id="more"></a>

<p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。redisObject 最主要的信息如图所示：</p>
<p><img src="/images/20180808000.png" alt=""></p>
<p>其中 type 代表一个 value 对象具体是何种数据类型，encoding 是不同数据类型在redis内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int。</p>
<h2 id="二、Redis提供的五种数据结构"><a href="#二、Redis提供的五种数据结构" class="headerlink" title="二、Redis提供的五种数据结构"></a>二、Redis提供的五种数据结构</h2><p><strong>五种数据结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>字符串类型是 Redis 最基础的数结构。首先键都是字符串类型， 而且其他几种数据结构 都是 在字符串类型基础上构建的。</p>
<p><img src="/images/2018080801.svg" alt=""></p>
<p>上图是string 在 redis 中的宏观样子，它的数据结构如下图所示：</p>
<p><img src="/images/2018080802.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>每种数据类型对应的命令都非常多，以下只列举 string 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set</td>
<td align="center">set key value</td>
<td align="center">设置指定 key 的值</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get key</td>
<td align="center">获取指定 key 的值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del key</td>
<td align="center">删除指定 key 的值</td>
</tr>
<tr>
<td align="center">setex</td>
<td align="center">setex key seconds value</td>
<td align="center">设置健并指定多少秒后过期</td>
</tr>
<tr>
<td align="center">setnx</td>
<td align="center">setnx key value</td>
<td align="center">只有当 key 不存在时才设置成功(setnx 可以作为分布式锁 的一种实现方案)</td>
</tr>
<tr>
<td align="center">mset</td>
<td align="center">mset key1 value1 key2 value2 …</td>
<td align="center">批量设置多个 key-value 对</td>
</tr>
<tr>
<td align="center">mget</td>
<td align="center">mget key1 key2 key3 …</td>
<td align="center">批量获取多个 key 的值</td>
</tr>
<tr>
<td align="center">incr</td>
<td align="center">incr key</td>
<td align="center">对值做自增操作</td>
</tr>
</tbody></table>
<p><strong>mset、mget 等批量操作可以减少网络传输的次数，从而可以提高效率。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>string 的典型使用场景：</strong></p>
<ul>
<li>缓存功能</li>
<li>计数</li>
<li>共享 Session</li>
<li>限速</li>
</ul>
<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>哈希类型是指键值本身又是一个键值对结构，形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;&#123;&#123; field1， value1&#125;，...&#123; fieldN， valueN&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img src="/images/2018080804.svg" alt=""></p>
<p>下图是字符串和哈希类型的对比：</p>
<p><img src="/images/2018080803.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 hash 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hset</td>
<td align="center">hset key field value</td>
<td align="center">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td align="center">hget</td>
<td align="center">hget key field</td>
<td align="center">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel key field1 field2 …</td>
<td align="center">删除一个或者多个 field</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen key</td>
<td align="center">计算 field 个数</td>
</tr>
<tr>
<td align="center">hmset</td>
<td align="center">hmset key field value field1 field2 …</td>
<td align="center">批量设置一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hmget</td>
<td align="center">hmget key field field1 field2 …</td>
<td align="center">批量获取一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists key field</td>
<td align="center">判断 key 中是否存在某个 field</td>
</tr>
<tr>
<td align="center">hkeys</td>
<td align="center">hkeys key</td>
<td align="center">获取指定 key 中的所有 field</td>
</tr>
<tr>
<td align="center">hvals</td>
<td align="center">hvals key</td>
<td align="center">获取指定 key 中的所有 value</td>
</tr>
<tr>
<td align="center">hgetall</td>
<td align="center">hgetall key</td>
<td align="center">获取指定 key 中的所有 field-value</td>
</tr>
</tbody></table>
<p><strong>在使用 hgetall 时， 如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果只需要获取部分 field，可以使用 hmget，如果一定要获取全部 field-value，可以使用 hscan 命令，该命令会渐进式遍历哈希类型。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>hash 的典型使用场景：</strong><br>比如缓存用户信息。每个用户属性使用一对field-value，但是只用一个键保存。如下图所示：</p>
<p><img src="/images/2018080805.png" alt=""></p>
<p>优点：简单直观，如果使用合理可以减少内存空间的使用。</p>
<p>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>
<h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>列表类型是用来存储多个有序的字符串，支持两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p>
<p><img src="/images/2018080806.svg" alt=""></p>
<p>下图为列表两端插入和弹出操作，a、b、c、d、e五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element），一个列表最多可以存储232-1个元素。</p>
<p><img src="/images/2018080807.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 list 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rpush</td>
<td align="center">rpush key value1 value2 …</td>
<td align="center">从右边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">lpush</td>
<td align="center">lpush key value1 value2 …</td>
<td align="center">从左边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">linsert</td>
<td align="center">linsert key before</td>
<td align="center">在 pivot 前或者后插入一个新元素 value</td>
</tr>
<tr>
<td align="center">lrange</td>
<td align="center">lrange key start end</td>
<td align="center">获取指定索引范围内的所有元素，索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N。 lrange key 0 -1  表示从左到右获取列表的所有元素</td>
</tr>
<tr>
<td align="center">lindex</td>
<td align="center">lindex key index</td>
<td align="center">获取列表指定索引下标的元素，lindex key -1 表示获取列表的最后一个元素</td>
</tr>
<tr>
<td align="center">llen</td>
<td align="center">llen key</td>
<td align="center">获取列表长度</td>
</tr>
<tr>
<td align="center">lpop</td>
<td align="center">lpop key</td>
<td align="center">从列表左侧弹窗元素</td>
</tr>
<tr>
<td align="center">rpop</td>
<td align="center">rpop key</td>
<td align="center">从列表右侧弹出元素</td>
</tr>
<tr>
<td align="center">lrem</td>
<td align="center">lrem key count value</td>
<td align="center">当 count&gt;0 , 从左到右，删除count个值等于 value的元素；当 count&lt;0，从右到左，删除count的绝对值个值等于value的元素；当 count=0，删除所有值等于 value的元素</td>
</tr>
<tr>
<td align="center">ltrim</td>
<td align="center">ltrim key start end</td>
<td align="center">只保留key 从start 到end 的元素</td>
</tr>
<tr>
<td align="center">lset</td>
<td align="center">lset key index newValue</td>
<td align="center">修改指定索引小标的元素</td>
</tr>
</tbody></table>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p><strong>list 的典型使用场景：</strong></p>
<ul>
<li>消息队列</li>
<li>文章列表</li>
</ul>
<p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·lpush+lpop&#x3D;Stack（栈）</span><br><span class="line">·lpush+rpop&#x3D;Queue（队列）</span><br><span class="line">·lpsh+ltrim&#x3D;CappedCollection（有限集合）</span><br><span class="line">·lpush+ brpop&#x3D; Message Queue（消息队列）</span><br></pre></td></tr></table></figure>

<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>集合类型也是用来保存多个的字符串元素，但和列表类型不同的是，集合中的元素是无序并且不可重复的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p>
<p><img src="/images/2018080809.svg" alt=""></p>
<p><img src="/images/2018080808.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 set 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sadd</td>
<td align="center">sadd key value1 value2 …</td>
<td align="center">添加一个或多个元素</td>
</tr>
<tr>
<td align="center">srem</td>
<td align="center">srem key value1 value2 …</td>
<td align="center">删除一个或多个元素</td>
</tr>
<tr>
<td align="center">scard</td>
<td align="center">scard key</td>
<td align="center">计算元素个数</td>
</tr>
<tr>
<td align="center">sismember</td>
<td align="center">sismember key element</td>
<td align="center">判断元素是否在集合中，返回1表示存在，0 表示不存在</td>
</tr>
<tr>
<td align="center">srandmember</td>
<td align="center">srandmember key count</td>
<td align="center">随机从集合返回count个元素，count 不写默认为1</td>
</tr>
<tr>
<td align="center">spop</td>
<td align="center">spop key</td>
<td align="center">从集合随机弹出元素</td>
</tr>
<tr>
<td align="center">smembers</td>
<td align="center">smembers key</td>
<td align="center">获取所有元素</td>
</tr>
<tr>
<td align="center">sinter</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">suinon</td>
<td align="center">suinon key1 key2 …</td>
<td align="center">求多个集合的并集</td>
</tr>
<tr>
<td align="center">sdiff</td>
<td align="center">sdiff key1 key2 …</td>
<td align="center">求多个集合的差集</td>
</tr>
<tr>
<td align="center">sinterstore</td>
<td align="center">sinterstore key key1 key2 …</td>
<td align="center">求多个集合的交集并保存到key中</td>
</tr>
<tr>
<td align="center">suinonstore</td>
<td align="center">suinonstore key key1 key2 …</td>
<td align="center">求多个集合的并集并保存到key中</td>
</tr>
<tr>
<td align="center">sdiffstore</td>
<td align="center">sdiffstore key key1 key2 …</td>
<td align="center">求多个集合的差集并保存到key中</td>
</tr>
</tbody></table>
<p><strong>smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>set 的典型使用场景：</strong></p>
<ul>
<li>sadd=Tagging（标签）</li>
<li>spop/srandmember=Randomitem（生成随机数，比如抽奖）</li>
<li>sadd+sinter=SocialGraph（社交需求）</li>
</ul>
<p>标签（tag）是集合类型一个比较典型的使用场景。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签。</p>
<h3 id="ZSET（sorted-set）"><a href="#ZSET（sorted-set）" class="headerlink" title="ZSET（sorted set）"></a>ZSET（sorted set）</h3><p>有序集合，保留了集合元素不可重复的特性，并在集合的基础上增加了元素排序功能。需要注意的是，它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。有序集合还提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p>
<p><img src="/images/20180808010.svg" alt=""></p>
<p>下图是一个有序集合的例子，该有序集合包含kris、mike、frank、tim、martin、tom，它们的分数分别是1、91、200、220、250、251。</p>
<p><img src="/images/20180808011.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 zset 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zadd</td>
<td align="center">zadd key score member [score member …]</td>
<td align="center">向有序集合添加一个或多个成员以及分数，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="center">zcard</td>
<td align="center">zcard key</td>
<td align="center">计算成员个数</td>
</tr>
<tr>
<td align="center">zscore</td>
<td align="center">zscore key member</td>
<td align="center">计算某个成员的分数，存在则返回分数，否则返回 nil</td>
</tr>
<tr>
<td align="center">zrank</td>
<td align="center">zrank key element</td>
<td align="center">返回分数从低到高的排名</td>
</tr>
<tr>
<td align="center">zrevrank</td>
<td align="center">zrevrank key count</td>
<td align="center">返回分数从高到低的排名</td>
</tr>
<tr>
<td align="center">zrem</td>
<td align="center">zrem member [member …]</td>
<td align="center">删除一个或多个成员</td>
</tr>
<tr>
<td align="center">zincrby</td>
<td align="center">zincrby key increment member</td>
<td align="center">给key中的member 增加 increment 分</td>
</tr>
<tr>
<td align="center">zrange</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">zremrangebyscore</td>
<td align="center">zremrangebyscore key min max</td>
<td align="center">删除指定分数范围的成员</td>
</tr>
</tbody></table>
<p><strong>zset 同样可以计算集合的交、并、差，以上没有一一列举</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<p><strong>zset 的典型使用场景：</strong></p>
<p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p>
<p>以点赞数位例，主要需要实现以下4个功能</p>
<ul>
<li>添加用户赞数</li>
<li>取消用户赞数</li>
<li>展示获取赞数最多的十个用户</li>
<li>展示用户信息以及用户分数</li>
</ul>
<h2 id="三、Redis的使用场景"><a href="#三、Redis的使用场景" class="headerlink" title="三、Redis的使用场景"></a>三、Redis的使用场景</h2><p>由于 redis 支持多种数据类型，所以适用场景也非常多。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>对于热点数据，缓存的价值非常大。例如，分类栏目(读频率高)等。可以将这些热点数据放到内存中，通过设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 </p>
<h3 id="共享Session（会话缓存）"><a href="#共享Session（会话缓存）" class="headerlink" title="共享Session（会话缓存）"></a>共享Session（会话缓存）</h3><p>在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息。比如我们公司就使用Redis共享Session来实现单点登录。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>数据统计的需求非常普遍，通过原子递增保持计数。例如，应用数、资源数、点赞数、收藏数、分享数等。这种高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作。</p>
<h3 id="排行榜以及热门列表"><a href="#排行榜以及热门列表" class="headerlink" title="排行榜以及热门列表"></a>排行榜以及热门列表</h3><p>例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：比如按照时间、播放量、点击率、点赞数等。可以利用有序集合 zset 实现。</p>
<h3 id="社交列表"><a href="#社交列表" class="headerlink" title="社交列表"></a>社交列表</h3><p>社交属性相关的列表信息，例如，用户点赞列表、用户分享列表、用户收藏列表、用户关注列表、用户粉丝列表等，使用 Hash 类型数据结构是个不错的选择。</p>
<h3 id="记录用户判定信息"><a href="#记录用户判定信息" class="headerlink" title="记录用户判定信息"></a>记录用户判定信息</h3><p>记录一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否评论分享等。</p>
<h3 id="交集、并集和差集"><a href="#交集、并集和差集" class="headerlink" title="交集、并集和差集"></a>交集、并集和差集</h3><p>在某些场景中，例如社交场景，通过交集、并集和差集运算，可以非常方便地实现共同好友，共同关注，共同偏好等社交关系。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>例如验证码只有60秒有效期，超过时间无法使用，或者基于 Oauth2 的 Token 只能在 5 分钟内使用一次，超过时间也无法使用。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中list的数据结构实现是双向链表，所以非常适合应用于消息队列（生产者/消费者模型）。 生产者利用 lpush 命令将数据添加到链表头部，消费者通过 brpop（右端阻塞弹出） 命令将元素从链表尾部取出。并且可以保证消息的有序性。比如可以用这种方式让多个应用更新最新的内容。</p>
<p>不过最好还是用 RabbitMQ 等市面上成熟的消息队列中间件。</p>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>由于Redis的单线程命令处理机制，如果有多个客户端同时执行 setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="四、Redis的数据淘汰策略-内存淘汰机制"><a href="#四、Redis的数据淘汰策略-内存淘汰机制" class="headerlink" title="四、Redis的数据淘汰策略(内存淘汰机制)"></a>四、Redis的数据淘汰策略(内存淘汰机制)</h2><h3 id="内存淘汰的过程"><a href="#内存淘汰的过程" class="headerlink" title="内存淘汰的过程"></a>内存淘汰的过程</h3><p>首先，客户端发起了需要申请更多内存的命令（如set）。</p>
<p>然后，Redis检查内存使用情况，如果已使用的内存大于 maxmemory 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p>
<p>最后，如果上面都没问题，则这个命令执行成功。</p>
<h3 id="8-种淘汰策略"><a href="#8-种淘汰策略" class="headerlink" title="8 种淘汰策略"></a>8 种淘汰策略</h3><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持以下6种策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">noeviction</td>
<td align="center">当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lfu</td>
<td align="center">从所有键中驱逐使用频率最少的键</td>
</tr>
<tr>
<td align="center">volatile-lfu</td>
<td align="center">从已设置过期时间的数据集中挑选使用频率最少的键</td>
</tr>
</tbody></table>
<p>需要注意的是：作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<h3 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h3><p>下面看看几种策略的适用场景</p>
<p>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。</p>
<p>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</p>
<p>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。</p>
<p><strong>推荐用法：</strong><br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h3 id="如何配置最大内存及淘汰策略"><a href="#如何配置最大内存及淘汰策略" class="headerlink" title="如何配置最大内存及淘汰策略"></a>如何配置最大内存及淘汰策略</h3><p>我们通过配置redis.conf中的 maxmemory 这个值来开启内存淘汰功能，以及配置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 100000</span><br><span class="line"></span><br><span class="line">#设置淘汰策略</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>需要注意的是，maxmemory 为0的时候表示我们对Redis的内存使用没有限制。</p>
<p>此外，redis支持动态改配置，无需重启。</p>
<p>设置最大内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory 100000</span><br></pre></td></tr></table></figure>

<p>设置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set maxmemory-policy noeviction</span><br></pre></td></tr></table></figure>

<h2 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h2><p>Redis支持RDB和AOF两种持久化机制，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化，从而能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p>
<h3 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据生成快照（Snapshot）以紧凑压缩的二级制文件格式保存到硬盘。</p>
<p>触发RDB持久化过程分为手动触发和自动触发。手动触发分别对应save和bgsave命令，其中save存在阻塞问题，基本已经废弃，Redis内部所有的涉及RDB的操作都采用bgsave的方式。执行save 或 bgsave 将在 redis 安装目录中创建dump.rdb （可配置）文件,如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</p>
<p>可以在redis.conf中做一些 RDB 相关的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 快照的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 存放快照的目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"># 在进行镜像备份时,是否进行压缩。</span><br><span class="line"># yes：压缩，但是需要一些cpu的消耗。</span><br><span class="line"># no：不压缩，需要更多的磁盘空间。</span><br><span class="line">rdbcompression yes</span><br><span class="line">#900秒后且至少1个key发生变化时创建快照  </span><br><span class="line">save 900 1  </span><br><span class="line">#300秒后且至少10个key发生变化时创建快照  </span><br><span class="line">save 300 10  </span><br><span class="line">#60秒后且至少10000个key发生变化时创建快照  </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p><strong>RDB的优点：</strong></p>
<ul>
<li><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p>
</li>
<li><p>Redis加载RDB恢复数据远远快于AOF的方式。</p>
</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p>
</li>
<li><p>一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。例如，每隔30分钟或者更长的时间来创建一次快照，Redis停止工作时（例如意外断电）就可能丢失这30分钟的数据。</p>
</li>
<li><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p>
</li>
</ul>
<h3 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h3><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过 appendfilename 配置设置，默认文件名是 appendonly.aof。保存路径同 RDB 持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。如下图所示：</p>
<p><img src="/images/20180808012.png" alt=""></p>
<p>AOF 工作流程 ：</p>
<p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p>
<p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p>
<p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p>
<p><strong>下面分别讲下每个过程：</strong></p>
<h4 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h4><p>AOF命令写入是吧文本协议格式的内容追加到缓存区。</p>
<p>如以下 set hello world 命令的文本协议格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></table></figure>

<p><strong>采用文本协议格式的原因：</strong><br>文本协议具有可读性，方便直接修改和处理。同时还可以避免二次开销。</p>
<p><strong>先写入缓存区而不是直接写入硬盘的原因：</strong><br>如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。Redis支持三种不同的缓冲区同步文件策略如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，影响 Redis 的高性能，一般不推荐使用。</span><br><span class="line"># appendfsync always </span><br><span class="line"></span><br><span class="line">#完全依赖操作系统的写入，一般为30秒左右一次，性能最好但是数据安全性无法保证，不被推荐。</span><br><span class="line"># appendfsync no  </span><br><span class="line"></span><br><span class="line">#每秒钟强制写入磁盘一次，兼顾性能和数据安全性，在性能和持久化方面做了很好的折中，理论上只有在系统突然宕机的情况下丢失1秒的数据。是受推荐的方式。</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p>
<p>重写的过程主要做了一下事情：</p>
<p>1）进程内已经超时的数据不再写入文件。</p>
<p>2）旧的AOF文件中的无效命令不再写入，如delkey1、hdelkey2、sremkeys、seta111、seta222 等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p>
<p>3）多条写命令可以合并为一个，如：lpushlista、lpushlistb、lpushlistc可以转化为：lpushlistabc。</p>
<p>具体的重写流程如下图所示：</p>
<p><img src="/images/20180808013.png" alt=""></p>
<p>可以通过下面配置设置什么时候开启自动重写：</p>
<p>AOF重写过程可以手动触发（直接调用bgrewriteaof命令）和自动触发：根据配置的auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># AOF文件名  </span><br><span class="line">appendfilename appendonly.aof </span><br><span class="line"></span><br><span class="line">#当进程中BGSAVE或BGREWRITEAOF命令正在执行时不阻止主进程中的fsync()调用（默认为no，当存在延迟问题时需调整为yes）  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">#当AOF增长率为100%且达到了64mb时开始自动重写AOF  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>


<h3 id="重启加载-数据恢复"><a href="#重启加载-数据恢复" class="headerlink" title="重启加载(数据恢复)"></a>重启加载(数据恢复)</h3><p>RDB 和 AOF 文件都可以用于服务器重启时的数据恢复。</p>
<p>下图为 Redis 持久化文件加载流程(即重启阶段恢复数据的流程)：</p>
<p><img src="/images/20180808014.png" alt=""></p>
<p>流程说明：</p>
<p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p>
<p>2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p>
<p>3）加载AOF/RDB文件成功 后，Redis 启动成功。 </p>
<p>4）AOF/RDB文件存在错误时，Redis 启动失败并打印错误信息。</p>
<h2 id="六、Redis-为什么速度快"><a href="#六、Redis-为什么速度快" class="headerlink" title="六、Redis 为什么速度快"></a>六、Redis 为什么速度快</h2><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p>
<ul>
<li><p>纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒。</p>
</li>
<li><p>Redis采用了单线程设计，单线程避免了线程切换和竞态产生消耗。</p>
</li>
<li><p>Redis采用了非阻塞I/O模型，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p>
</li>
<li><p>Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p>
</li>
</ul>
<h2 id="七、Redis-为什么采用单线程"><a href="#七、Redis-为什么采用单线程" class="headerlink" title="七、Redis 为什么采用单线程"></a>七、Redis 为什么采用单线程</h2><p>Redis 为什么采用单线程设计，主要原因如下：</p>
<ul>
<li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li>
<li>采用单线程设计，可以极大简化数据结构和算法的实现，使代码更清晰，处理逻辑更简单。</li>
<li>单线程避免了不必要的线程切换和竞态产生消耗。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，不会出现死锁而导致的性能消耗。</li>
</ul>
<p>采用单线程设计也有一个弊端，就是无法发挥多核CPU性能，如果某个命令执行过长，会造成其他命令的阻塞。</p>
<p>解决的办法是，通过在一个多核的机器上部署多个redis实例，组成master-master，master-slave的形式，实现读写分离。把耗时的读命令完全可以放到slave中来解决。</p>
<h2 id="八、Redis的内部结构"><a href="#八、Redis的内部结构" class="headerlink" title="八、Redis的内部结构"></a>八、Redis的内部结构</h2><p>Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p>
<p>可以通过阅读 <a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a> 来学习。<br>还可以参考下 <a href="http://zhangtielei.com/posts/server.html" target="_blank" rel="noopener">Redis内部数据结构详解</a> 系列博客</p>
<h2 id="九、Redis-集群方案与实现"><a href="#九、Redis-集群方案与实现" class="headerlink" title="九、Redis 集群方案与实现"></a>九、Redis 集群方案与实现</h2><p>后面会单独写篇文章讲 Redis 的 复制、哨兵、集群。</p>
<h2 id="十、Redis-与-Memcached-的差异"><a href="#十、Redis-与-Memcached-的差异" class="headerlink" title="十、Redis 与 Memcached 的差异"></a>十、Redis 与 Memcached 的差异</h2><p>Redis 和 Memcache 都是基于内存的数据存储系统。Redis是一个开源的key-value存储系统，而Memcached是高性能分布式内存缓存服务。那么Redis 与 Memcached 之间有什么区别呢？</p>
<p>Redis的作者Salvatore Sanfilippo曾经对这两种基于内存的数据存储系统进行过比较：</p>
<ul>
<li><p>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p>
</li>
<li><p>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p>
</li>
<li><p>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p>
</li>
</ul>
<h3 id="数据类型支持不同"><a href="#数据类型支持不同" class="headerlink" title="数据类型支持不同"></a>数据类型支持不同</h3><p>Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。</p>
<p>Memcached仅支持简单的key-value结构的数据记录。</p>
<h3 id="内存管理机制不同"><a href="#内存管理机制不同" class="headerlink" title="内存管理机制不同"></a>内存管理机制不同</h3><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
<p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。</p>
<p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题，但是它最大的缺点就是会导致空间浪费，因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
<h3 id="数据持久化支持"><a href="#数据持久化支持" class="headerlink" title="数据持久化支持"></a>数据持久化支持</h3><p>Redis支持内存数据的持久化，而且提供了RDB快照和AOF日志两种主要的持久化策略。</p>
<p>memcached是不支持数据持久化操作的。</p>
<h3 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h3><p>Redis 本身提供了 Cluster，引入Master节点和Slave节点，支持在服务器端构建分布式存储。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>
<p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p>
<h2 id="十一、参考文献"><a href="#十一、参考文献" class="headerlink" title="十一、参考文献"></a>十一、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://redislabs.com/community/ebook/" target="_blank" rel="noopener">《Redis IN ACTION》</a> ah L. Carlson<br>[3] <a href="http://blog.720ui.com/columns/redis_action_all/" target="_blank" rel="noopener">Redis实战 文集</a><br>[4] <a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis应用场景</a><br>[5] <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考</a><br>[6] <a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述Redis和Memcached的差异</a><br>[7] <a href="https://www.zhihu.com/question/19645807" target="_blank" rel="noopener">MongoDB 或者 redis 可以替代 memcached 吗?</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/10/redis-shell/" rel="prev" title="Redis 开发与运维 2：Redis环境搭建及Redis shell的使用">
      <i class="fa fa-chevron-left"></i> Redis 开发与运维 2：Redis环境搭建及Redis shell的使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/07/29/database-sharding/" rel="next" title="数据存储 3：分库与分表">
      数据存储 3：分库与分表 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-number">1.</span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Redis提供的五种数据结构"><span class="nav-number">2.</span> <span class="nav-text">二、Redis提供的五种数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STRING"><span class="nav-number">2.1.</span> <span class="nav-text">STRING</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HASH"><span class="nav-number">2.2.</span> <span class="nav-text">HASH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIST"><span class="nav-number">2.3.</span> <span class="nav-text">LIST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SET"><span class="nav-number">2.4.</span> <span class="nav-text">SET</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZSET（sorted-set）"><span class="nav-number">2.5.</span> <span class="nav-text">ZSET（sorted set）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Redis的使用场景"><span class="nav-number">3.</span> <span class="nav-text">三、Redis的使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">3.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享Session（会话缓存）"><span class="nav-number">3.2.</span> <span class="nav-text">共享Session（会话缓存）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数器"><span class="nav-number">3.3.</span> <span class="nav-text">计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排行榜以及热门列表"><span class="nav-number">3.4.</span> <span class="nav-text">排行榜以及热门列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#社交列表"><span class="nav-number">3.5.</span> <span class="nav-text">社交列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录用户判定信息"><span class="nav-number">3.6.</span> <span class="nav-text">记录用户判定信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交集、并集和差集"><span class="nav-number">3.7.</span> <span class="nav-text">交集、并集和差集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时效性"><span class="nav-number">3.8.</span> <span class="nav-text">时效性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">3.9.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁实现"><span class="nav-number">3.10.</span> <span class="nav-text">分布式锁实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Redis的数据淘汰策略-内存淘汰机制"><span class="nav-number">4.</span> <span class="nav-text">四、Redis的数据淘汰策略(内存淘汰机制)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存淘汰的过程"><span class="nav-number">4.1.</span> <span class="nav-text">内存淘汰的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-种淘汰策略"><span class="nav-number">4.2.</span> <span class="nav-text">8 种淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何选择淘汰策略"><span class="nav-number">4.3.</span> <span class="nav-text">如何选择淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何配置最大内存及淘汰策略"><span class="nav-number">4.4.</span> <span class="nav-text">如何配置最大内存及淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Redis-的持久化机制"><span class="nav-number">5.</span> <span class="nav-text">五、Redis 的持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-快照持久化"><span class="nav-number">5.1.</span> <span class="nav-text">RDB 快照持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-日志持久化"><span class="nav-number">5.2.</span> <span class="nav-text">AOF 日志持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令写入"><span class="nav-number">5.2.1.</span> <span class="nav-text">命令写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件同步"><span class="nav-number">5.2.2.</span> <span class="nav-text">文件同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重写机制"><span class="nav-number">5.2.3.</span> <span class="nav-text">重写机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重启加载-数据恢复"><span class="nav-number">5.3.</span> <span class="nav-text">重启加载(数据恢复)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、Redis-为什么速度快"><span class="nav-number">6.</span> <span class="nav-text">六、Redis 为什么速度快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、Redis-为什么采用单线程"><span class="nav-number">7.</span> <span class="nav-text">七、Redis 为什么采用单线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Redis的内部结构"><span class="nav-number">8.</span> <span class="nav-text">八、Redis的内部结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、Redis-集群方案与实现"><span class="nav-number">9.</span> <span class="nav-text">九、Redis 集群方案与实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、Redis-与-Memcached-的差异"><span class="nav-number">10.</span> <span class="nav-text">十、Redis 与 Memcached 的差异</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型支持不同"><span class="nav-number">10.1.</span> <span class="nav-text">数据类型支持不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理机制不同"><span class="nav-number">10.2.</span> <span class="nav-text">内存管理机制不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据持久化支持"><span class="nav-number">10.3.</span> <span class="nav-text">数据持久化支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群管理的不同"><span class="nav-number">10.4.</span> <span class="nav-text">集群管理的不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、参考文献"><span class="nav-number">11.</span> <span class="nav-text">十一、参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="crazyfzw"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">crazyfzw</p>
  <div class="site-description" itemprop="description">做个有趣的技术人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazyfzw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazyfzw" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.douban.com/people/crazyfzw/" title="Booklist → https:&#x2F;&#x2F;book.douban.com&#x2F;people&#x2F;crazyfzw&#x2F;" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Booklist</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:crazyfzw@gmail.com" title="E-Mail → mailto:crazyfzw@gmail.com" rel="noopener" target="_blank"><i class="fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/104894167431407693109" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;104894167431407693109" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100011315733045" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100011315733045" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3829383159" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3829383159" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.importnew.com/" title="http:&#x2F;&#x2F;www.importnew.com&#x2F;" rel="noopener" target="_blank">ImportNew</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/categories/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;categories&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ibm.com/developerworks/cn/java/" title="https:&#x2F;&#x2F;www.ibm.com&#x2F;developerworks&#x2F;cn&#x2F;java&#x2F;" rel="noopener" target="_blank">IBM developerworks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com&#x2F;" rel="noopener" target="_blank">美团点评技术团队</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://calvin1978.blogcn.com/" title="http:&#x2F;&#x2F;calvin1978.blogcn.com&#x2F;" rel="noopener" target="_blank">江南白衣的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.720ui.com/" title="http:&#x2F;&#x2F;blog.720ui.com" rel="noopener" target="_blank">梁桂钊的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/581f548ef0ec" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;581f548ef0ec" rel="noopener" target="_blank">李艳鹏的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jinnianshilongnian.iteye.com/" title="http:&#x2F;&#x2F;jinnianshilongnian.iteye.com&#x2F;" rel="noopener" target="_blank">张开涛的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/zuoxiaolong" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;zuoxiaolong" rel="noopener" target="_blank">左潇龙的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/xrq730/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xrq730&#x2F;" rel="noopener" target="_blank">五月的仓颉</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yikun.github.io/" title="https:&#x2F;&#x2F;yikun.github.io&#x2F;" rel="noopener" target="_blank">Yikun的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/" title="http:&#x2F;&#x2F;www.ruanyifeng.com" rel="noopener" target="_blank">阮一峰的个人网站</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://honphanjohn.top/" title="https:&#x2F;&#x2F;honphanjohn.top&#x2F;" rel="noopener" target="_blank">啊钟的博客</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyfzw</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">568k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:37</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'jyxPxkBMeEmDfMMTuuyBdGdu-gzGzoHsz',
      appKey     : '7SEECyfT4R10oTtj4zDMOdBt',
      placeholder: "ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
