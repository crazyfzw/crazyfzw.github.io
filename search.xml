<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用Apktool获取别人APP中的图片及布局资源进行学习</title>
    <url>/2016/04/19/Apktool/</url>
    <content><![CDATA[<p>当我们看到一款UI布局很漂亮的APP，想要了解别人是怎么实现的时候，就可以通过Apktool工具来反编译别人的apk，从而获取图片及布局资源来进行学习。</p>
<p>其实我们下载到的Android 应用，是可以直接把后缀名改成zip的，然后解压zip就可以得到对应的文件目录</p>
<p><img src="/images/2016041901.jpg" alt=""></p>
<a id="more"></a>



<p>其中，res为所有资源文件，META-INF为签名信息，classes.dex为java源码编译后生成的字节码。</p>
<p>原以为这样轻松的就可以拿到别人的布局源码了，实则不然，点开res/layout下的一个布局文件看看</p>
<p><img src="/images/2016041902.jpg" alt=""></p>
<p>然后发现里面都是XML文件经过编译的机器码。那么怎么获取别人的布局文件呢?这时，Apktool就派上用场了。</p>
<h3 id="首先下载安装Apktool："><a href="#首先下载安装Apktool：" class="headerlink" title="首先下载安装Apktool："></a>首先下载安装Apktool：</h3><p>下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">http://ibotpeaches.github.io/Apktool/install/</a></p>
<p><img src="/images/2016041903.jpg" alt=""></p>
<h3 id="下载对应版本"><a href="#下载对应版本" class="headerlink" title="下载对应版本"></a>下载对应版本</h3><p><em>1.</em> 将wrapper script右键选择连接另存为得到apktool.bat文件， </p>
<ol start="2">
<li><p>在 <a href="https://bitbucket.org/iBotPeaches/apktool/downloads" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads</a><br>下载最新版本的apktool.jar包如现在最新的apktool_2.1.0.jar，并删除版本号重名名为apktool.jar</p>
</li>
<li><p>将apktool.bat、apktool.jar、及想要编译的apk文件放在同一文件夹下</p>
</li>
<li><p>通过cmd进入对应目录运行apktool.bat  d -f [apk文件 ]  [输出文件夹]就可以得到相应的布局资源文件了，截图如下</p>
</li>
</ol>
<p><img src="/images/2016041904.jpg" alt=""></p>
<p><img src="/images/2016041905.jpg" alt=""></p>
<p>这时打开res下的文件目录会发现有很多abc及notfication开头的文件，这些文件是自动生成的，并不是开发者真正写的布局文件，我们需要看的是其他xml文件,如黄色部分。</p>
<p><img src="/images/2016041906.jpg" alt=""></p>
<p>点开就可以看到相应的xml布局源码了</p>
<p><img src="/images/2016041907.jpg" alt=""></p>
<p>如果想要看别人java源码，学习别人功能的实现的话，就要用到dex2jar及jd-gui了，</p>
<p>其中dex2jar可以将apk改成zip加压后得到的classes.dex文件反编译成jar文件。</p>
<p>jd-gui：可以查看dex2jar转换出来的jar文件，就是我们想要的java源码了。</p>
<p>想看详细用法的可以参考：<a href="http://blog.csdn.net/ithomer/article/details/6727581" target="_blank" rel="noopener">Android APK反编译详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>Material Design之利用CollapsingToolbarLayout轻松实现知乎日报新闻详情页顶部效果（带banner的toolbar伸缩折叠效果）</title>
    <url>/2016/05/07/CollapsingToolbarLayout/</url>
    <content><![CDATA[<p>我们都知道CoordinatorLayout+AppBarLayout可以轻松实现滚动隐藏ToolBar的效果，今天我要写的是CollapsingToolbarLayout+CoordinatorLayout+AppBarLayout实现带Banner的Toolbar折叠效果————向上滚动时，Banner会随着滚动手势向上收缩至隐藏，Banner上的文字（实际上是CollapsingToolbarLayout上的文字）会逐渐缩小最后显示在Toolbar上，向下滚动时，Banner会逐渐显示并还原为原来大小，同时文字也会最近变大重回原来的位置。</p>
<a id="more"></a>


<p>知乎日报新闻详情页就用了这种效果，那赶紧看下面Gif效果图吧：</p>
<p><img src="/images/2016050701.gif" alt=""></p>
<p><strong>实现方法：</strong></p>
<h2 id="1-布局xml："><a href="#1-布局xml：" class="headerlink" title="1.布局xml："></a>1.布局xml：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"256dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar_layout"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:contentScrim</span>=<span class="string">"@color/toolbarcolor"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:expandedTitleMarginStart</span>=<span class="string">"38dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:src</span>=<span class="string">"@drawable/skill"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseParallaxMultiplier</span>=<span class="string">"0.7"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v4.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scrollbars</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/webview"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span><span class="tag">&lt;/<span class="name">WebView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.v4.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>CollapsingToolbarLayout中的属性：</strong></p>
<p><strong>A：contentScrim</strong> - 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。</p>
<p><strong>B：expandedTitleMarginStart</strong> - 设置扩张时候(还没有收缩时)title与左边的距离。</p>
<p><strong>C：layout_scrollFlags:设置滚动表现：</strong></p>
<ul>
<li>1) Scroll, 表示向下滚动列表时候,CollapsingToolbarLayout会滚出屏幕并且消失</li>
<li>2) exitUntilCollapsed, 表示这个layout会一直滚动离开屏幕范围,直到它收折成它的最小高度.</li>
<li>3) enterAlways: 一旦向上滚动这个view就可见。</li>
<li>4) enterAlwaysCollapsed: 这个flag定义的是已经消失之后何时再次显示。假设你定义了一个最小高度（minHeight）同时enterAlways也定义了， 那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。  </li>
</ul>
<p><strong>ImageView及Toolbar中的属性：</strong></p>
<p>A: layout_collapseMode=”parallax”,这是控制滚出屏幕范围的效果的</p>
<ul>
<li><p>1) pin,确保Toolbar在view折叠的时候仍然被固定在屏幕的顶部。</p>
</li>
<li><p>2) parallax,设置为这个模式时，在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果, 通常和layout_collapseParallaxMultiplier(设置视差因子，值为0~1)搭配使用。</p>
</li>
</ul>
<h2 id="2-主要java代码："><a href="#2-主要java代码：" class="headerlink" title="2.主要java代码："></a>2.主要java代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line">        getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">        toolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                onBackPressed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CollapsingToolbarLayout必须把title设置到CollapsingToolbarLayout上，设置到Toolbar上则不会显示</span></span><br><span class="line">        CollapsingToolbarLayout mCollapsingToolbarLayout = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar_layout);</span><br><span class="line">        mCollapsingToolbarLayout.setTitle(<span class="string">"Bar Brother 徒手健身"</span>);</span><br><span class="line">        <span class="comment">//通过CollapsingToolbarLayout修改字体颜色</span></span><br><span class="line">        mCollapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);<span class="comment">//设置还没收缩时状态下字体颜色</span></span><br><span class="line">        mCollapsingToolbarLayout.setCollapsedTitleTextColor(Color.WHITE);<span class="comment">//设置收缩后Toolbar上字体的颜色</span></span><br><span class="line">        <span class="comment">//toolbar navigationicon 改变返回按钮颜色</span></span><br><span class="line">        <span class="keyword">final</span> Drawable upArrow = getResources().getDrawable(R.drawable.abc_ic_ab_back_mtrl_am_alpha);</span><br><span class="line">        upArrow.setColorFilter(getResources().getColor(R.color.white), PorterDuff.Mode.SRC_ATOP);</span><br><span class="line">        getSupportActionBar().setHomeAsUpIndicator(upArrow);</span><br><span class="line"></span><br><span class="line">        mWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">        <span class="comment">//设置支持js</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//!!设置跳转的页面始终在当前WebView打开</span></span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</span><br><span class="line">        mWebView.loadUrl(<span class="string">"https://"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>源码可在我的Github下载：<a href="https://github.com/crazyfzw/CollapsingToolbarLayoutDemo" target="_blank" rel="noopener">https://github.com/crazyfzw/CollapsingToolbarLayoutDemo</a></p>
<p>参考：</p>
<p>   <a href="http://developer.android.com/intl/ko/reference/android/support/design/widget/CollapsingToolbarLayout.html" target="_blank" rel="noopener">http://developer.android.com/intl/ko/reference/android/support/design/widget/CollapsingToolbarLayout.html</a></p>
<p>   <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html</a></p>
<p>推荐：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2015/0531/2958.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/developer/2015/0531/2958.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>DrawerLayout+NavigationView打造Google原生Material Design风格侧滑菜单</title>
    <url>/2016/05/30/DrawerLayout-NavigationView/</url>
    <content><![CDATA[<p>最近做的一个项目需要用到侧滑菜单，在GitHub上找了下，有个很热门的drawer Library，<a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="noopener">https://github.com/mikepenz/MaterialDrawer</a>，用起来挺方便的，使用方法也详细。但还是想自己动手写一个，因为Google在SDK中增加了DrawerLayout，NavigationView，实现侧滑菜单还是挺方便的。</p>
<a id="more"></a>


<p>先看下gif效果图：</p>
<p><img src="/images/2016053001.gif" alt=""></p>
<p><strong>实现步骤：</strong></p>
<h2 id="1-写主布局-activity-main-xml"><a href="#1-写主布局-activity-main-xml" class="headerlink" title="1.写主布局 activity_main.xml"></a>1.写主布局 activity_main.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_drawerlayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第一个位置 主界面内容 main content--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/content_main"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第二个位置  来放Drawerlayout中的内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_navigationview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:itemTextColor</span>=<span class="string">"@color/selector_nav_menu_textcolor"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"left"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里注意一下，主界面的内容一定要放在DrawerLayout的第一个位置，第二个位置应该放置的是Drawer的菜单内容，可以有多种方式自定义，我这里使用的是NavigationView。</p>
<p><strong>NavigationView有几个属性需要注意的：</strong></p>
<ul>
<li><p>app:headerLayout：    可以指定自己定义的布局作为NavigationView的头部</p>
</li>
<li><p>app:menu：            指定Nav中的Menu菜单项布局</p>
</li>
<li><p>app:itemTextColor：   用来设置Nav中，menu item的颜色选择器。在选择器中可以定义文字被选中状态的颜色以及正常状态下的颜色</p>
</li>
</ul>
<p>如本例的  selector_nav_menu_textcolor.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- pink theme--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@color/main_pink_light"</span> <span class="attr">android:state_checked</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@color/main_black_grey"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义Drawer的头部，即NavigationView的header，-eg本例-navigation-header-xml"><a href="#2-自定义Drawer的头部，即NavigationView的header，-eg本例-navigation-header-xml" class="headerlink" title="2.自定义Drawer的头部，即NavigationView的header， eg本例 navigation_header.xml"></a>2.自定义Drawer的头部，即NavigationView的header， eg本例 navigation_header.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"220dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/nav_header"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.crazyfzw.materialdrawer.CircleImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userAvater"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:civ_border_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:civ_border_color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userName"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"4dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/text__white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"crazyfzw"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userSignature"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/text__white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"野蛮体魄"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面用到的CircleImageView是GitHub上一个热门的开源控件，这里给出地址：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a>，当然你也可以extend ImageView去自定义</p>
<h2 id="3-自定义Drawer的菜单选项，即NavigationView中的menu，eg本例-menu-menu-navigation-xml"><a href="#3-自定义Drawer的菜单选项，即NavigationView中的menu，eg本例-menu-menu-navigation-xml" class="headerlink" title="3.自定义Drawer的菜单选项，即NavigationView中的menu，eg本例 menu/menu_navigation.xml"></a>3.自定义Drawer的菜单选项，即NavigationView中的menu，eg本例 menu/menu_navigation.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group1"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_home_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_home"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_home"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_file_download_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_offline_manager"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_offline_manager"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group2"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_star_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_favorites"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_favorites"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_history_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_histories"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_histories"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_people_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_following"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_following"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_account_balance_wallet_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_pay"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_growth_process"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group3"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_color_lens_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_theme"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orderInCategory</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/title_theme_store"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_settings"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orderInCategory</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_settings"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这里的group用来分组，android:checkableBehavior=”single”用来指明选项菜单只能单选。android:checkable=”true”指定item项是否可选，图标的话，这里推荐使用google官方的 <a href="https://design.google.com/icons/" target="_blank" rel="noopener">Material icons</a></p>
<h2 id="4-最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码"><a href="#4-最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码" class="headerlink" title="4.最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码"></a>4.最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">       setSupportActionBar(toolbar);</span><br><span class="line"></span><br><span class="line">       mDrawerLayout = (DrawerLayout) findViewById(R.id.id_drawerlayout);</span><br><span class="line">       mNavigationView = (NavigationView) findViewById(R.id.id_navigationview);</span><br><span class="line"></span><br><span class="line">       ActionBarDrawerToggle mActionBarDrawerToggle = <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, mDrawerLayout, toolbar, R.string.open, R.string.close);</span><br><span class="line">       mActionBarDrawerToggle.syncState();</span><br><span class="line">       mDrawerLayout.setDrawerListener(mActionBarDrawerToggle);</span><br><span class="line">       mNavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">       mNavigationView.inflateMenu(R.menu.menu_navigation);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置NavigationView中menu的item被选中后要执行的操作</span></span><br><span class="line">       onNavgationViewMenuItemSelected(mNavigationView);</span><br><span class="line"></span><br><span class="line">       View navheaderView = mNavigationView.getHeaderView(<span class="number">0</span>);  <span class="comment">//获取头部布局</span></span><br><span class="line"></span><br><span class="line">       currentUserAvater = (CircleImageView) navheaderView.findViewById(R.id.current_userAvater);</span><br><span class="line">       currentUserName = (TextView) navheaderView.findViewById(R.id.current_userName);</span><br><span class="line">       currentUserSignature = (TextView) navheaderView.findViewById(R.id.current_userSignature);</span><br><span class="line"></span><br><span class="line">       currentUserAvater.setImageResource(R.drawable.default_avater);</span><br><span class="line">       currentUserName.setText(<span class="string">"crazyfzw"</span>);</span><br><span class="line">       currentUserSignature.setText(<span class="string">"平静温和地前进"</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add item select listener</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mNav</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNavgationViewMenuItemSelected</span><span class="params">(NavigationView mNav)</span> </span>&#123;</span><br><span class="line">       mNav.setNavigationItemSelectedListener(<span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">               String msgString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">switch</span> (menuItem.getItemId()) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 在这里添加对应菜单选择后的事件处理，如</span></span><br><span class="line">                  <span class="comment">// case R.id.nav_menu_home:</span></span><br><span class="line">                  <span class="comment">//    msgString = (String) menuItem.getTitle();</span></span><br><span class="line">                  <span class="comment">//     break;</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Menu item点击后选中，并关闭Drawerlayout</span></span><br><span class="line">               menuItem.setChecked(<span class="keyword">true</span>);</span><br><span class="line">               mDrawerLayout.closeDrawers();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里我用的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">NavigationView.inflateMenu(R.menu.menu_navigation);</span><br></pre></td></tr></table></figure>
<p>来添加自定义的NavigationView头部，及菜单布局，当然，你也可以用上面题到的静态属性app:headerLayout：及app:menu：指定,上面代码中有个地方需要特别注意了，就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View navheaderView &#x3D; mNavigationView.getHeaderView(0);</span><br><span class="line">currentUserName &#x3D; (TextView) navheaderView.findViewById(R.id.current_userName);</span><br></pre></td></tr></table></figure>

<p>这里如果直接用findViewById()获取NavigationView的中的控件会出现空指针异常，如图：</p>
<p><img src="/images/2016053002.jpg" alt=""><br><img src="/images/2016053003.jpg" alt=""></p>
<p>因为在activity刚创建的时候，Dawer其实是没有打开的，所以布局没有初始化加载进来，这时去findViewById()自然会找不到了。解决的办法是通过NavigationView.getHeaderView(0);获取到navheaderView，然互在通过navheaderView.findViewById()就可以找到相应的空间了。</p>
<p>当然你也可以在在inflateHeaderView的同时取到这个navheaderView，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View navheaderView &#x3D; mNavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">currentUserName &#x3D; (TextView) navheaderView.findViewById(R.id.current_userName);</span><br></pre></td></tr></table></figure>


<p>本案例的源码可以到我的GitHub上下载或者Star： <a href="https://github.com/crazyfzw/MaterialDrawer" target="_blank" rel="noopener">https://github.com/crazyfzw/MaterialDrawer</a></p>
]]></content>
  </entry>
  <entry>
    <title>RecyclerView+SwipeRefreshLayout实现下拉刷新列表</title>
    <url>/2016/04/12/RecyclerView-SwipeRefreshLayout/</url>
    <content><![CDATA[<h2 id="一：RecyclerView的用法："><a href="#一：RecyclerView的用法：" class="headerlink" title="一：RecyclerView的用法："></a>一：RecyclerView的用法：</h2><p> <strong>RecyclerView是google在2014年I/O大会上提出新的用于取代ListView的组件，是 android-support-v7-21 版本中新增的一个 Widgets，它的灵活性与可替代性比listview更好。</strong></p>
<a id="more"></a>



<p> 使用 RecyclerView首先应该认识两个要点：</p>
<p><strong>1. Adapter：</strong>使用RecyclerView之前，需要继承RecyclerView.Adapter定义一个自己的适配器，作用是将数据与每一个item的界面进行绑定，注意，与ListView不同，这里不在是使用传统的ArrayAdapter、SimpleAdapter、BaseAdapter。</p>
<p><strong>2.LayoutManager：</strong> 控制每个Item项的布局显示。</p>
<p>目前SDK中提供了三种自带的LayoutManager:<br>LinearLayoutManager（可以实现垂直滚动的线性列表、水平线滚动性列表）<br>GridLayoutManager    （可以实现垂直Grid列表、水平线Grid列表列表）<br>StaggeredGridLayoutManager (可以实现瀑布流列表)</p>
<p>RecyclerView的详细用法可以参考：</p>
<p><a href="http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" target="_blank" rel="noopener">http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html</a></p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2004.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2004.html</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45059587</a></p>
<h2 id="二：SwipeRefreshLayout的用法："><a href="#二：SwipeRefreshLayout的用法：" class="headerlink" title="二：SwipeRefreshLayout的用法："></a>二：SwipeRefreshLayout的用法：</h2><p>SwipeRefreshLayout也是一个下拉刷新控件，已经被加在在support v4兼容包下，两个要点：</p>
<p><strong>1.</strong> 只要在需要刷新的控件最外层加上SwipeRefreshLayout，然后他的child首先是可滚动的view，如RecyclerView、ListView等</p>
<p><strong>2.</strong> 实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。</p>
<p>SwipeRefreshLayout的详细用法可以参考：</p>
<p><a href="http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html" target="_blank" rel="noopener">http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html</a></p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1028/1861.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1028/1861.html</a></p>
<h2 id="三、下面我通过RecyclerView-SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法："><a href="#三、下面我通过RecyclerView-SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法：" class="headerlink" title="三、下面我通过RecyclerView+SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法："></a>三、下面我通过RecyclerView+SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法：</h2><p>运行效果图gif：</p>
<p><img src="/images/2016041201.gif" alt=""></p>
<h3 id="1-在build-gradle-中添加依赖"><a href="#1-在build-gradle-中添加依赖" class="headerlink" title="1. 在build.gradle 中添加依赖"></a>1. 在build.gradle 中添加依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;com.android.support:recyclerview-v7:22.2.0&#39;</span><br></pre></td></tr></table></figure>

<p>这里只要是recyclerview-v7:21.0.+就可以了。</p>
<h3 id="2-创建布局文件"><a href="#2-创建布局文件" class="headerlink" title="2. 创建布局文件"></a>2. 创建布局文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_swiperefreshlayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_recyclerview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-继承RecyclerView-Adapter创建自己的Adapter"><a href="#3-继承RecyclerView-Adapter创建自己的Adapter" class="headerlink" title="3.继承RecyclerView.Adapter创建自己的Adapter."></a>3.继承RecyclerView.Adapter创建自己的Adapter.</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecyclerViewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyRecyclerViewAdapter</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据集</span></span><br><span class="line">    <span class="keyword">public</span> String[] datass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.在构造函数中取得数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerViewAdapter</span><span class="params">(String[] datas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.datass = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span>  <span class="title">OnItemClickListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> positon)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnItemClickListener mOnItemClickListener;</span><br><span class="line">    <span class="comment">//添加接口和设置Adapter的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(OnItemClickListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mOnItemClickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///3.创建新View，被LayoutManager所调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个View，简单起见直接使用系统提供的布局，就是一个TextView</span></span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(android.R.layout.simple_list_item_1,parent,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//创建一个ViewHolder</span></span><br><span class="line">        ViewHolder viewHolder= <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.将数据与界面进行绑定的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        holder.textView.setText(datass[position]);</span><br><span class="line">        <span class="keyword">if</span> (mOnItemClickListener!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            holder.itemView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    mOnItemClickListener.onItemClick(holder.itemView, position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.返回数据的长度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datass.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.自定义的ViewHolder，取得每个Item的的所有界面元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TextView textView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            textView = (TextView) itemView.findViewById(android.R.id.text1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout-OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh-方法中。"><a href="#4-在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout-OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh-方法中。" class="headerlink" title="4.在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。"></a>4.在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">SwipeRefreshLayout</span>.<span class="title">OnRefreshListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> SwipeRefreshLayout swipeRefreshLayout;</span><br><span class="line">    <span class="keyword">private</span> MyRecyclerViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line"></span><br><span class="line">        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</span><br><span class="line">        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)</span><br><span class="line">                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示垂直的RecyclerView</span></span><br><span class="line">        initVerticalRecyclerView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置SwipeRefreshLayout实现下拉刷新效果</span></span><br><span class="line">        swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.id_swiperefreshlayout);</span><br><span class="line">        <span class="comment">//设置进度条颜色，最多设置4种循环显示</span></span><br><span class="line">        swipeRefreshLayout.setColorSchemeResources(android.R.color.white,</span><br><span class="line">                android.R.color.holo_green_light,</span><br><span class="line">                android.R.color.holo_orange_light, android.R.color.holo_red_light);</span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVerticalRecyclerView</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.id_recyclerview);</span><br><span class="line">        <span class="comment">//创建一个垂直的线性布局管理器</span></span><br><span class="line">        LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>,LinearLayoutManager.VERTICAL,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到RecyclerView，并设置布局管理器</span></span><br><span class="line">        mRecyclerView.setLayoutManager(layoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果确定每个item项的高度是固定的，设置这个选项可以提高性能</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建或取得数据集，数据推荐还是时有List集合</span></span><br><span class="line">        <span class="keyword">final</span> String[] datas = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;datas.length; i++)&#123;</span><br><span class="line">            datas[i]=<span class="string">"item"</span>+i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建adapter并且制定数据集</span></span><br><span class="line">        adapter = <span class="keyword">new</span> MyRecyclerViewAdapter(datas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为RecyclerView绑定Adapter</span></span><br><span class="line">        mRecyclerView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在Adapter中添加好事件后，变可以在这里注册事件实现监听了</span></span><br><span class="line">        adapter.setOnItemClickListener(<span class="keyword">new</span> MyRecyclerViewAdapter.OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> positon)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getBaseContext(), <span class="string">"item"</span>+positon, Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 刷新时模拟数据的变化</span></span><br><span class="line">        <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">                    adapter.datass[i] = <span class="string">"new"</span> + temp;</span><br><span class="line">                &#125;</span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/crazyfzw/RecyclerViewDemo" target="_blank" rel="noopener">完整源码可以到我的github下载：https://github.com/crazyfzw/RecyclerViewDemo</a></p>
]]></content>
  </entry>
  <entry>
    <title>为RecyclerView的不同item项实现不同的布局(添加分类Header)</title>
    <url>/2016/04/22/RecyclerView-withHeader/</url>
    <content><![CDATA[<p>最近在做一个应用的时候，需要为GridLayoutManager添加头部header，然后自然而然就想到了用不同的itemType去加载不同的布局。</p>
<h2 id="1-实现多item布局，用不同的itemType去加载不同的布局。"><a href="#1-实现多item布局，用不同的itemType去加载不同的布局。" class="headerlink" title="1.实现多item布局，用不同的itemType去加载不同的布局。"></a>1.实现多item布局，用不同的itemType去加载不同的布局。</h2><p>主要思路就是先定义好标识itemType的常量，然后重写getItemViewType()方法，根据不同的位置（position）返回不同的Type，接着在onCreateViewHolder()中根据参数viewType去判断该item项应该 inflate 哪个布局文件，并返回相应的ViewHolder实例(这里ViewHolder是根据不同的item布局预先自定义好的不同的ViewHolder)</p>
<a id="more"></a>



<p>比如我的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecyclerCardviewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerView</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> ITEM_TYPE &#123;</span><br><span class="line">        ITEM_TYPE_Theme,</span><br><span class="line">        ITEM_TYPE_Video</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据集</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; mdatas;</span><br><span class="line">    <span class="keyword">private</span> TextView themeTitle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerCardviewAdapter</span><span class="params">(List&lt;Integer&gt; datas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.mdatas = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewType == ITEM_TYPE.ITEM_TYPE_Theme.ordinal())&#123;</span><br><span class="line"></span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.videothemelist,parent,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThemeVideoHolder(view);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(viewType == ITEM_TYPE.ITEM_TYPE_Video.ordinal())&#123;</span><br><span class="line"></span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.videocardview,parent,<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> VideoViewHolder(view);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> ThemeVideoHolder)&#123;</span><br><span class="line"></span><br><span class="line">           themeTitle.setText(<span class="string">"励志"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> VideoViewHolder)&#123;</span><br><span class="line">            ((VideoViewHolder)holder).videologo.setImageResource(R.drawable.lianzai_02);</span><br><span class="line">            ((VideoViewHolder)holder).videovname.setText(<span class="string">"励志，俄小伙练习街头健身一年的体型变化，Dear Hard Work！"</span>);</span><br><span class="line">            ((VideoViewHolder)holder).videoviewed.setText(<span class="string">"2780次"</span>);</span><br><span class="line">            ((VideoViewHolder)holder).videocomment.setText(<span class="string">"209条"</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> position % <span class="number">5</span> == <span class="number">0</span> ? ITEM_TYPE.ITEM_TYPE_Theme.ordinal() : ITEM_TYPE.ITEM_TYPE_Video.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mdatas.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeVideoHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThemeVideoHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            themeTitle = (TextView) itemView.findViewById(R.id.hometab1_theme_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ImageView videologo;</span><br><span class="line">        <span class="keyword">public</span> TextView videovname;</span><br><span class="line">        <span class="keyword">public</span> TextView videoviewed;</span><br><span class="line">        <span class="keyword">public</span> TextView videocomment;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VideoViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            videologo = (ImageView) itemView.findViewById(R.id.videologo);</span><br><span class="line">            videoviewed = (TextView) itemView.findViewById(R.id.videoviewed);</span><br><span class="line">            videocomment = (TextView) itemView.findViewById(R.id.videocomment);</span><br><span class="line">            videovname = (TextView) itemView.findViewById(R.id.videoname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，使用的是 LayoutManager 中发 LinearLayoutManager，效果图如下:</p>
<p><img src="/images/2016042201.jpg" alt=""></p>
<p>但是，当我们把 LayoutManager 改成GridLayoutManager的时候你就出现了不是我们期待的效果，如下图：</p>
<p><img src="/images/2016042202.jpg" alt=""></p>
<p>What the hell is going on? 什么鬼？怎么添加的header随着其他item项以cell的形式出现在网格上。仔细想一想，发现了下面代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridLayoutManager layoutManager &#x3D; new GridLayoutManager(this,2, GridLayoutManager.VERTICAL,false);</span><br></pre></td></tr></table></figure>

<p>哦！原来我们在创建GridLayoutManager的时候需要设定每行显示多少个item项，我们这里设置的是2，而我们添加的header是以item项的形式添加进来的，所以也会以cell的形式出现。那么，有没有办法让header这个item占据两个cell，单独霸占一行呢？答案是肯定的，我们可以通过setSpanSizeLookup抽象类中的getSpanSize()方法的返回值来设定每个item项占据多少个单元格 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gridManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getItemViewType(position) == ITEM_TYPE.ITEM_TYPE_Theme.ordinal()</span><br><span class="line">                        ? gridManager.getSpanCount() : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，这段代码在自定义Adapter中应该添加在何处呢？放在onAttachedToRecyclerView()中再合适不过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</span><br><span class="line">        <span class="keyword">if</span>(manager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> GridLayoutManager gridManager = ((GridLayoutManager) manager);</span><br><span class="line">            gridManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> getItemViewType(position) == ITEM_TYPE.ITEM_TYPE_Theme.ordinal()</span><br><span class="line">                            ? gridManager.getSpanCount() : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时就可以实现我想要的效果了，运行效果图如下：</p>
<p><img src="/images/2016042203.jpg" alt=""></p>
<p>代码我已经抽离出来放到我的Github了：<a href="https://github.com/crazyfzw/RecycleViewWithHeader" target="_blank" rel="noopener">https://github.com/crazyfzw/RecycleViewWithHeader</a></p>
<h2 id="2-最后说一下为什么为什么用RecyclerView取代ListView。"><a href="#2-最后说一下为什么为什么用RecyclerView取代ListView。" class="headerlink" title="2.最后说一下为什么为什么用RecyclerView取代ListView。"></a>2.最后说一下为什么为什么用RecyclerView取代ListView。</h2><p>用过ListView的都知道，在ListView中若要复用视图缓存，就要在getView()方法中手动判断convertView是否为空，若不为空则复用视图缓存，若为空则重新加载视图，而RecyclerView相当于对ListView的Adapter进行了再次封装，把ListView手动判断是否有缓存的代码封装到RecyclerView内部，使这部分逻辑不可见，我们只需要通过getItemCount()方法告诉RecyclerView有多少项数据，然后在onCreateViewHolder()中加载item布局实例化ViewHolder，然后在onBindViewHolder()中完成数据的绑定即可。</p>
]]></content>
  </entry>
  <entry>
    <title>数据存储 1：数据库索引的原理及使用策略</title>
    <url>/2018/07/18/RDBMS-INDEX/</url>
    <content><![CDATA[<p>本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时最经常用到的索引。</p>
<a id="more"></a>

<h2 id="一、数据库索引的原理"><a href="#一、数据库索引的原理" class="headerlink" title="一、数据库索引的原理"></a>一、数据库索引的原理</h2><blockquote>
<p>这部分内容主要来源于互联网上关于索引的主流文章，本人在理解的基础上梳理整合成本部分内容，当是个人的一篇学习笔记，参考的文章可见参考文献一栏。</p>
</blockquote>
<h3 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助数据库高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>说白了，索引就是一种可以应用高效查询算法的数据结构。</p>
<p>之所以要建立索引，其实就是为了构建一种数据结构，然后可以在上面应用一种高效的查询算法，最终提高数据的查询速度。</p>
<p>所以在讲索引的数据结构之前不妨先了解下比较常见的查询算法及其所要求的特定数据结构。</p>
<h3 id="2-常见的查询算法"><a href="#2-常见的查询算法" class="headerlink" title="2. 常见的查询算法"></a>2. 常见的查询算法</h3><h4 id="2-1-顺序查找（linear-search-）"><a href="#2-1-顺序查找（linear-search-）" class="headerlink" title="2.1 顺序查找（linear search ）"></a>2.1 顺序查找（linear search ）</h4><p>最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量大时效率极低。 </p>
<p>数据结构：有序或无序队列 </p>
<p>复杂度：O(n) </p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-二分查找（binary-search）"><a href="#2-2-二分查找（binary-search）" class="headerlink" title="2.2 二分查找（binary search）"></a>2.2 二分查找（binary search）</h4><p>比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 </p>
<p>数据结构：有序数组 </p>
<p>复杂度：O(logn) </p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-二叉排序树查找"><a href="#2-3-二叉排序树查找" class="headerlink" title="2.3 二叉排序树查找"></a>2.3 二叉排序树查找</h4><p>二叉排序树的特点是：</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>它的左、右子树也分别为二叉排序树。</p>
<p>搜索的原理：</p>
<p>若b是空树，则搜索失败，否则;</p>
<p>若x等于b的根节点的数据域之值，则查找成功；否则：</p>
<p>若x小于b的根节点的数据域之值，则搜索左子树；否则：</p>
<p>查找右子树。</p>
<p>数据结构：二叉排序树 </p>
<p>时间复杂度： O(log2N)</p>
<h4 id="2-4-索引是为了应用某种高级查找算法而建立的一种数据结构："><a href="#2-4-索引是为了应用某种高级查找算法而建立的一种数据结构：" class="headerlink" title="2.4 索引是为了应用某种高级查找算法而建立的一种数据结构："></a>2.4 索引是为了应用某种高级查找算法而建立的一种数据结构：</h4><p>稍微分析以上查找算法会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上。但是数据库存储的数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h3 id="3-多叉平衡查找树（B-tree-和-B-Tree）"><a href="#3-多叉平衡查找树（B-tree-和-B-Tree）" class="headerlink" title="3. 多叉平衡查找树（B-tree 和 B+Tree）"></a>3. 多叉平衡查找树（B-tree 和 B+Tree）</h3><p>上面讲到了二叉树，它的搜索时间复杂度为O(log2N)，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p>
<h4 id="3-1-B-Tree"><a href="#3-1-B-Tree" class="headerlink" title="3.1 B-Tree"></a>3.1 B-Tree</h4><blockquote>
<p>具体讲解之前，有一点，再次强调下：B-树，也就是B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解，有人可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree指的就是B树。特此说明。</p>
</blockquote>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。</p>
<p>下图是一个B-Tree示例：</p>
<p><img src="/images/2018071801.png" alt="image"></p>
<p>那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">     <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     foreach(node.key)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">  &#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure>

<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，这也是索引会降低增删改数据性能的原因。</p>
<h4 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B+Tree"></a>3.2 B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而 B 树的叶子节点并没有包括全部需要查找的信息)</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。所有的内节点点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的内节点也包含需要查找的有效信息)</p>
<p>下图是一个简单的B+Tree示意</p>
<p><img src="/images/2018071802.png" alt="image"></p>
<h3 id="4-为什么索引用B-Tree实现"><a href="#4-为什么索引用B-Tree实现" class="headerlink" title="4. 为什么索引用B+Tree实现"></a>4. 为什么索引用B+Tree实现</h3><p>这里必须强调的是，数据库索引实际上用的是带有顺序的B+Tree。在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 </p>
<p>如下图所示：</p>
<p><img src="/images/2018071803.png" alt="image"></p>
<p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能。如图如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？"><a href="#4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？" class="headerlink" title="4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？"></a>4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？</h4><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<h4 id="4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？"><a href="#4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？" class="headerlink" title="4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？"></a>4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？</h4><p>B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmax&#x3D;floor(pagesize&#x2F;(keysize+datasize+pointsize))</span><br></pre></td></tr></table></figure>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>因为B+Tree 的内节点只存储只存储key，不存储Data，所以出度越大，索引性能越好。</p>
<h3 id="5-B-Tree-的查找过程"><a href="#5-B-Tree-的查找过程" class="headerlink" title="5. B+Tree 的查找过程"></a>5. B+Tree 的查找过程</h3><p>B-树和B+树查找过程基本一致。</p>
<p>下面以 B+Tree 树的数据结构举例说下查找过程：</p>
<p><img src="/images/20180718.jpg" alt="image"></p>
<p>如上图 B + Tree 的数据结构。是由一个一个的磁盘块组成的树形结构，每个磁盘块由数据项和指针组成。所有的数据都是存放在叶子节点，非叶子节点不存放数据。</p>
<p><strong>查找过程：</strong><br>以磁盘块1为例，指针 P1 表示小于17的磁盘块，P2 表示在 17~35 之间的磁盘块，P3 则表示大于35的磁盘块。</p>
<p>比如要查找数据项99，首先将磁盘块1 load 到内存中，发生 1 次 IO。接着通过二分查找发现 99 大于 35，所以找到了 P3 指针。通过P3 指针发生第二次 IO 将磁盘块4加载到内存。再通过二分查找发现大于87，通过 P3 指针发生了第三次 IO 将磁盘块11 加载到内存。最后再通过一次二分查找找到了数据项99。</p>
<p>由此可见，如果一个几百万的数据查询只需要进行三次 IO 即可找到数据，那么整个效率将是非常高的。</p>
<p>观察树的结构，发现查询需要经历几次 IO 是由树的高度来决定的，而树的高度又由磁盘块，数据项的大小决定的。</p>
<p>磁盘块越大，数据项越小那么数的高度就越低。这也就是为什么索引字段要尽可能小的原因。</p>
<h3 id="6-MySQL索引实现"><a href="#6-MySQL索引实现" class="headerlink" title="6. MySQL索引实现"></a>6. MySQL索引实现</h3><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h4 id="6-1-MyISAM索引实现"><a href="#6-1-MyISAM索引实现" class="headerlink" title="6.1 MyISAM索引实现"></a>6.1 MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，这种索引方式称称为“非聚集索引”。</p>
<p>下图是MyISAM索引的原理图：</p>
<p><img src="/images/2018071804.png" alt="image"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/images/2018071805.png" alt="image"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h4 id="6-2-InnoDB索引实现"><a href="#6-2-InnoDB索引实现" class="headerlink" title="6.2 InnoDB索引实现"></a>6.2 InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。键值的逻辑顺序决定了表中相应行的物理顺序，这种索引方式称称为“聚集索引”。</p>
<p>如下图所示：<br><img src="/images/2018071806.png" alt="image"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="/images/2018071807.png" alt="image"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="7-聚集索引与非聚集索引的区别"><a href="#7-聚集索引与非聚集索引的区别" class="headerlink" title="7. 聚集索引与非聚集索引的区别"></a>7. 聚集索引与非聚集索引的区别</h3><p>前面已经通过MySQL索引实现中已经讲到InnoDB索引实现用的是“聚集索引”，而MyISAM索引实现的实现用的是“非聚集索引”，那么 聚集索引与非聚集索引到底有什么区别呢？</p>
<p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</strong></p>
<h4 id="7-1-聚集索引"><a href="#7-1-聚集索引" class="headerlink" title="7.1 聚集索引"></a>7.1 聚集索引</h4><p>聚集索引表记录的排列顺序与索引的排列顺序一致</p>
<p><strong>优点：</strong>查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。</p>
<p><strong>缺点：</strong>对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，从而降低了执行速度。</p>
<h4 id="7-2-非聚集索引"><a href="#7-2-非聚集索引" class="headerlink" title="7.2 非聚集索引"></a>7.2 非聚集索引</h4><p>叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>
<p><strong>优点：</strong>对数据更新影响较小。</p>
<p><strong>缺点：</strong>聚集索引检索效率比聚集索引低,必须先查到查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>
<h4 id="7-3-如何选择使用聚集索引或非聚集索引（很重要）："><a href="#7-3-如何选择使用聚集索引或非聚集索引（很重要）：" class="headerlink" title="7.3 如何选择使用聚集索引或非聚集索引（很重要）："></a>7.3 如何选择使用聚集索引或非聚集索引（很重要）：</h4><table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody></table>
<h2 id="二、如何设计索引"><a href="#二、如何设计索引" class="headerlink" title="二、如何设计索引"></a>二、如何设计索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，数据库在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p>
<h3 id="1-一般两种情况下不建议建索引："><a href="#1-一般两种情况下不建议建索引：" class="headerlink" title="1. 一般两种情况下不建议建索引："></a>1. 一般两种情况下不建议建索引：</h3><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Index Selectivity &#x3D; 字段对应不重复的值 &#x2F; 表总记录数</span><br></pre></td></tr></table></figure>

<p>显然选择性的取值范围为(0, 1]，值越大，即选择性越高的索引价值越大，这是由B+Tree的性质决定的。</p>
<p>例如，可以应用求一个字段的Selectivity，判断是否有必要给这个这个字段加索引，以及</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0000 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<h3 id="2-设计索引一般需要考虑以下3点："><a href="#2-设计索引一般需要考虑以下3点：" class="headerlink" title="2. 设计索引一般需要考虑以下3点："></a>2. 设计索引一般需要考虑以下3点：</h3><ol>
<li>看数据量，根据记录数，看是否有建索引的必要；</li>
<li>根据计算字段的索引选择性判断给某个字段加索引是否比较有价值；</li>
<li>看能否使用前缀索引取代全列索引，综合考虑索引选择性与key的长度，做个折中，尽可能使得前缀索引的选择性接近全列索引，同时又减段索引key的长度，从而减少了索引文件的大小和维护开销。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引建上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Table1</span><br><span class="line">ADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>有一点需要注意的是：前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h2 id="三、索引使用的注意事项-策略及优化"><a href="#三、索引使用的注意事项-策略及优化" class="headerlink" title="三、索引使用的注意事项(策略及优化)"></a>三、索引使用的注意事项(策略及优化)</h2><p>并不是建立索引就能显著提高查询速度，在索引的使用过程中，存在一些使用细节和注意事项，因为稍不留心，就可能导致在查询过程中索引失效。</p>
<p>一下列举一些需要注意的事项：</p>
<h3 id="1-不要在列上使用函数"><a href="#1-不要在列上使用函数" class="headerlink" title="1. 不要在列上使用函数"></a>1. 不要在列上使用函数</h3><p>不要在列上使用函数，这将导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where year(publish_time) &lt; 2018</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where publish_time &lt; &#39;2018-01-01&#39;</span><br></pre></td></tr></table></figure>


<h3 id="2-不要在列上进行计算"><a href="#2-不要在列上进行计算" class="headerlink" title="2. 不要在列上进行计算"></a>2. 不要在列上进行计算</h3><p>不要在列上进行运算，这也将导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where id &#x2F; 100 &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where id &#x3D; 1 * 100</span><br></pre></td></tr></table></figure>

<h3 id="3-尽量避免使用-或-not-in或-lt-gt-等否定操作符"><a href="#3-尽量避免使用-或-not-in或-lt-gt-等否定操作符" class="headerlink" title="3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符"></a>3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</h3><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt;操作符，<br>这些负向查询也会导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where id not in (1,3,4);</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where id in (2,5,6);</span><br></pre></td></tr></table></figure>

<h3 id="4-尽量避免使用-or-来连接条件"><a href="#4-尽量避免使用-or-来连接条件" class="headerlink" title="4. 尽量避免使用 or 来连接条件"></a>4. 尽量避免使用 or 来连接条件</h3><p>应该尽量避免在 where 子句中使用 or来连接条件，因为这会导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id&#x3D; 1 or id &#x3D;2</span><br></pre></td></tr></table></figure>

<p>应改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id in(1,2)</span><br></pre></td></tr></table></figure>

<h3 id="5-字段的默认值不要为-null"><a href="#5-字段的默认值不要为-null" class="headerlink" title="5. 字段的默认值不要为 null"></a>5. 字段的默认值不要为 null</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。</p>
<p>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p>
<h3 id="6-不要让数据库帮我们做隐式类型转换"><a href="#6-不要让数据库帮我们做隐式类型转换" class="headerlink" title="6. 不要让数据库帮我们做隐式类型转换"></a>6. 不要让数据库帮我们做隐式类型转换</h3><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where telno&#x3D;1888888888</span><br></pre></td></tr></table></figure>

<p>这样虽然可以查出数据，但是会导致全表扫描。</p>
<p>应改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where telno&#x3D;&#39;1888888888&#39;</span><br></pre></td></tr></table></figure>

<h3 id="7-前导模糊查询会导致索引失效"><a href="#7-前导模糊查询会导致索引失效" class="headerlink" title="7. 前导模糊查询会导致索引失效"></a>7. 前导模糊查询会导致索引失效</h3><p>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。</p>
<h3 id="8-数据区分不明显的不建议创建索引"><a href="#8-数据区分不明显的不建议创建索引" class="headerlink" title="8. 数据区分不明显的不建议创建索引"></a>8. 数据区分不明显的不建议创建索引</h3><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段</p>
<h3 id="9-可以用复合索引替代多个单列索引"><a href="#9-可以用复合索引替代多个单列索引" class="headerlink" title="9. 可以用复合索引替代多个单列索引"></a>9. 可以用复合索引替代多个单列索引</h3><p>MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。</p>
<p>假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：</p>
<p>select * from news where news_year = 2017 and news_month = 1<br>事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。</p>
<h3 id="10-覆盖索引的好处"><a href="#10-覆盖索引的好处" class="headerlink" title="10. 覆盖索引的好处"></a>10. 覆盖索引的好处</h3><p>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p>
<h3 id="11-范围查询对多列查询的影响"><a href="#11-范围查询对多列查询的影响" class="headerlink" title="11. 范围查询对多列查询的影响"></a>11. 范围查询对多列查询的影响</h3><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</p>
<p>举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：</p>
<p>select * from news where publish_time &gt;= ‘2017-01-02’ and publish_time &lt;= ‘2017-01-08’ and enable = 1<br>这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。</p>
<p>对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。</p>
<p>例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where news_weekth &#x3D; 1 and enable &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。</p>
<h3 id="12-复合索引（联合索引）"><a href="#12-复合索引（联合索引）" class="headerlink" title="12. 复合索引（联合索引）"></a>12. 复合索引（联合索引）</h3><p>首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：</p>
<p>第一个字段一定是有序的<br>当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>5</td>
</tr>
</tbody></table>
<p>其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。</p>
<h3 id="13-复合索引的最左前缀原理"><a href="#13-复合索引的最左前缀原理" class="headerlink" title="13. 复合索引的最左前缀原理"></a>13. 复合索引的最左前缀原理</h3><p>在复合索引的基础上，再来详细介绍一下联合索引的查询。还是复合索引中的例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：</p>
<p>以下的查询方式都可以用到索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where a&#x3D;1；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</span><br></pre></td></tr></table></figure>
<p>上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。</p>
<p>如果查询语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where a&#x3D;1 and c&#x3D;3； 那么只会用到索引a。</span><br></pre></td></tr></table></figure>

<p>如果查询语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and c&#x3D;3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。</span><br></pre></td></tr></table></figure>
<p>如果用到了最左前缀，但是顺序颠倒会用到索引吗？</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and a&#x3D;1；</span><br><span class="line">select * from table where b&#x3D;2 and a&#x3D;1 and c&#x3D;3；</span><br></pre></td></tr></table></figure>
<p>如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。</p>
<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1] MySQL索引背后的数据结构及算法原理 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>[2] 从B树、B+树、B* 树谈到 R树 <a href="https://blog.csdn.net/v_july_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6530142</a><br>[3] 聚集索引和非聚集索引 <a href="https://www.cnblogs.com/aspnethot/articles/1504082.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspnethot/articles/1504082.html</a><br>[4] 你知道数据库索引的工作原理吗？<a href="http://www.ituring.com.cn/article/986" target="_blank" rel="noopener">http://www.ituring.com.cn/article/986</a><br>[5] 如何设计索引 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/" target="_blank" rel="noopener">http://blog.720ui.com/2017/mysql_core_03_how_use_index/</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云ECS：Java WEB环境搭建</title>
    <url>/2017/11/02/aliyun-ecs-java-web-setup/</url>
    <content><![CDATA[<p>前些时间，买了个 阿里云 ECS，详细配置为 1vCPU、1GB 内存、40GB系统盘、20GB SSD，搭载的是 CentOS 7.4 系统。这里仅记录下在 ECS 上搭建 Java WEB 环境的过程。</p>
<a id="more"></a>

<h2 id="一、远程连接服务器"><a href="#一、远程连接服务器" class="headerlink" title="一、远程连接服务器"></a>一、远程连接服务器</h2><p>我这里使用的是 Xshell + Xftp 组合。Xshell 用来远程访问并控制终端，Xftp  基本上只用于传输文件。</p>
<p><img src="/images/2017110601.png" alt=""></p>
<p><img src="/images/2017110602.png" alt=""></p>
<p><img src="/images/2017110603.png" alt=""></p>
<h2 id="二、-格式化和挂载数据盘-这里以-dev-xvdb为例"><a href="#二、-格式化和挂载数据盘-这里以-dev-xvdb为例" class="headerlink" title="二、 格式化和挂载数据盘   (这里以/dev/xvdb为例)"></a>二、 格式化和挂载数据盘   (这里以/dev/xvdb为例)</h2><p>这里需要注意的是单独购买的数据盘需要先挂载数据盘，然后才能格式化。随实例一起购买的数据盘，无需挂载，直接格式化。</p>
<p>1.查看分区    df -h</p>
<p>2.查看数据盘  fdisk -l    </p>
<p>3.使用 fdisk命令分区 </p>
<p>  &emsp;1）运行 fdisk /dev/xvdb，对数据盘进行分区。根据提示，依次输入 n，p，1，两次回车，wq，分区就开始了</p>
<p>  &emsp;2）运行 fdisk -l 命令，查看新的分区是否已经建好</p>
<p>4.格式化新分区</p>
<p>  &emsp;1）运行 mkfs.ext3 /dev/xvdb1，对新分区进行格式化。格式化所需时间取决于数据盘大小。您也可自主决定选用其他文件格式，如 ext4 等</p>
<p>  &emsp;2）运行 echo /dev/xvdb1 /mnt ext3 defaults 0 0 &gt;&gt; /etc/fstab 写入新分区信息，完成后，可以使用 cat /etc/fstab 命令查看</p>
<p>5.挂载新分区<br>  运行 mount /dev/xvdb1 /mnt 挂载新分区，然后执行 df -h 查看分区。如果出现数据盘信息，说明挂载成功，可以使用新分区了</p>
<h2 id="三、安装JDK"><a href="#三、安装JDK" class="headerlink" title="三、安装JDK"></a>三、安装JDK</h2><p>这里可以通过 wget 命令去在线下载，然后再用 tar 命令解压到指定目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.linuxeye.com&#x2F;jdk&#x2F;jdk-8u141-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>


<p>因为我本地已经有tomcat 以及jdk 了，所以为了方便，直接通过 Xftp 上传到指定目录</p>
<p><img src="/images/2017110604.png" alt=""></p>
<p>接着设<strong>置 JDK 的环境变量</strong>，步骤如下：</p>
<ol>
<li>先用 vi  /etc/profile 打开配置文件</li>
<li>然后 按 i 键进入编辑模式</li>
<li>接着插入下面的信息，指定jdk目录</li>
<li>接着按 Esc 键退出编辑模式，输入 :wq 保存并关闭文件，如果不小心写错，不想保存，则可以通过:q!退出。</li>
<li>最后，通过 source /etc/profile 加载环境变量</li>
<li>输入 java -version 查看jdk版本，验证是否安装成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;jdk1.7.0_60</span><br><span class="line">export CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p><img src="/images/2017110605.png" alt=""></p>
<p><img src="/images/2017110606.png" alt=""></p>
<h2 id="四、安装-Tomcat"><a href="#四、安装-Tomcat" class="headerlink" title="四、安装 Tomcat"></a>四、安装 Tomcat</h2><p>tomcat 的安装更简单， 基本上传到指定目录，在 server.xml 改下端口就行了。</p>
<p><img src="/images/2017110607.png" alt=""></p>
<h2 id="五、开放端口"><a href="#五、开放端口" class="headerlink" title="五、开放端口"></a>五、开放端口</h2><p>需要格外注意的是 CentOS 7.4 系统默认开启了防火墙。需要配置安全组 放行 80、443 或 8080 端口入方向规则。</p>
<p>参考  《ECS安全组实践 》 <a href="https://help.aliyun.com/document_detail/51170.html?spm=5176.product25365.6.742.0SxQKm" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/51170.html?spm=5176.product25365.6.742.0SxQKm</a></p>
<p><img src="/images/2017110608.png" alt=""></p>
<p><img src="/images/2017110609.jpg" alt=""></p>
<h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>通过 tomcat 下的 startup.sh 启动下 tomcat，就可以验证了。</p>
<p><img src="/images/2017110610.png" alt=""></p>
<p><img src="/images/2017110611.png" alt=""></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>[1]<a href="https://help.aliyun.com/document_detail/51376.html?spm=5176.doc51170.6.717.2smpOG" target="_blank" rel="noopener">Linux 格式化和挂载数据盘</a></p>
<p>[2]<a href="https://help.aliyun.com/document_detail/51376.html?spm=5176.doc51170.6.717.2smpOG" target="_blank" rel="noopener">手工部署Java Web项目</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题解决</title>
    <url>/2018/06/13/cross-domain-solution/</url>
    <content><![CDATA[<h2 id="一、跨域的由来"><a href="#一、跨域的由来" class="headerlink" title="一、跨域的由来"></a>一、跨域的由来</h2><p>为了保证用户信息的安全，防止恶意的网站窃取数据，目前，所有浏览器都实行了同源策略，要求域名、协议、端口必须都相同才属于同源，只有同源才可以访问其他页面的对象，否则将受到以下限制：</p>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p>
<a id="more"></a>

<h2 id="二、微服务之后跨域问题更普遍存在"><a href="#二、微服务之后跨域问题更普遍存在" class="headerlink" title="二、微服务之后跨域问题更普遍存在"></a>二、微服务之后跨域问题更普遍存在</h2><p>在现在前后端分离，分布式服务、微服务化之后，我们将复杂的业务拆分成细小的服务组件，部署到不同的主机下，往往存在不同的域名。因此，跨域问题，就更普遍存在了。</p>
<h2 id="三、跨域问题解决方法"><a href="#三、跨域问题解决方法" class="headerlink" title="三、跨域问题解决方法"></a>三、跨域问题解决方法</h2><h3 id="1-使用代理页面实现跨域"><a href="#1-使用代理页面实现跨域" class="headerlink" title="1. 使用代理页面实现跨域"></a>1. 使用代理页面实现跨域</h3><p>该方法可以解决所有跨域获取 DOM，跨域调用 js方法等，如刷新父级页面、关闭窗口等。典型的例子就如iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信的问题。常见报错：</p>
<p><img src="/images/2018061301.png" alt=""></p>
<p><strong>实现原理：</strong>在目标页面 A 的同级目录下新建一个代理页面 spyA，然后在调用的页面中通过 iframe 加载代理页面 spyA ，使它在加载的过程中被执行，而且它与目标页面是同源的，所以不存在跨域问题，可以利用这个代理页面避开跨域访问问题，在代理页面可以获取DOM及执行函数等操作。（我喜欢把这个代理页面称为间谍页面，你可以通过这个间谍页面做一些无法直接做到的事情）</p>
<p><strong>A.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> main window <span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>    </span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span></span><br><span class="line">    /**</span><br><span class="line"><span class="actionscript">     *to <span class="keyword">do</span> something you want <span class="keyword">in</span> here</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    $(<span class="string">"#btn"</span>).val(<span class="string">"really?"</span>);  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A.html main<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"I am a Butten"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1/B.html"</span> <span class="attr">name</span>=<span class="string">"myframe"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>B.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> iframe window,Open in A.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>  </span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">callSpyA</span><span class="params">()</span></span>&#123;  </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(exec_obj)==<span class="string">'undefined'</span>)&#123;  </span></span><br><span class="line"><span class="javascript">        exec_obj = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </span></span><br><span class="line"><span class="actionscript">        exec_obj.name = <span class="string">'tmp_frame'</span>;  </span></span><br><span class="line"><span class="actionscript">        exec_obj.src = <span class="string">'http://localhost:8080/spyA.html'</span>;  </span></span><br><span class="line"><span class="actionscript">        exec_obj.style.display = <span class="string">'none'</span>;  </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(exec_obj);  </span></span><br><span class="line"><span class="actionscript">    &#125;<span class="keyword">else</span>&#123;  </span></span><br><span class="line"><span class="javascript">        exec_obj.src = <span class="string">'http://localhost:8080/spyA.html?'</span> + <span class="built_in">Math</span>.random();  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>B.html iframe<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"exec main function"</span> <span class="attr">onclick</span>=<span class="string">"callSpyA()"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>


<p><strong>spyA.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> spy page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个代理页面，用于代替完成一些受跨域限制无法直接做到的事情  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">       <span class="comment">&lt;!-- do something --&gt;</span></span></span></span><br><span class="line">        parent.parent.doSomething(); </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>
### 2.使用 window.postMessage 方法实现跨域

<p>HTML5 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p><strong>实现原理：</strong>是通过 message 事件监听对方消息， 当需要跨域调用时，直接通 window.postMessage 发送通知， 然后目标页面监听到消息后在监听方法里面做一些操作。（通过 window.postMessage 还读写其他窗口的 LocalStorage）</p>
<p><strong>A.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;    </span></span><br><span class="line"><span class="actionscript">                <span class="comment">// event.origin属性可以过滤不是发给本窗口的消息 </span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (event.origin == <span class="string">'http://a.com'</span>)   </span></span><br><span class="line">               /**</span><br><span class="line"><span class="actionscript">                  *to <span class="keyword">do</span> something you want <span class="keyword">in</span> here</span></span><br><span class="line">                */</span><br><span class="line"><span class="actionscript">                    alert(event.data); <span class="comment">//输出：Hello   </span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>


<p><strong>B.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://a.com/A.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.postMessage(<span class="string">'Hello'</span>,      <span class="string">"http://a.com"</span>);    </span></span><br><span class="line">            &#125;;    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<br/>
### 3. 通过 搭建中间转发层 或者 Nginx 反向代理 实现跨域

<p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>
<p>但是由于同源策略只是对浏览器的一种安全策略，所以我们可以绕过浏览器实现跨域，通过搭建中间层在服务端转发前端请求到真正的目的地址，或者通过 Niginx 反响代理，利用Nginx解析URL地址的时候进行判断，将请求转发的具体的服务器上。</p>
<p><img src="/images/2018061302.png" alt=""></p>
<br/>
### 4. 通过 CORS 实现跨域
CORS 全称为 Cross Origin Resource Sharing（跨域资源共享），CORS 支持所有类型的 HTTP 请求，CORS 需要浏览器和服务器同时支持，但是整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，但用户不会有感觉。因此，实现 CORS 通信的关键是服务端。服务端只需添加相关响应头信息，即可实现客户端发出 AJAX 跨域请求。

<p>值得高心的是， SpringMVC 4.2 中已经增加了增加 CORS 的支持，通过 @CrossOrigin 注解可以轻松实现跨域，可以加在整个 controller 上，也可以单独加在某个方法前面。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(<span class="string">"http://crazyfzw.com"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"toList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">	String rfUrl = PropertiesUtil.getSystem(<span class="string">"edrfUrl"</span>);</span><br><span class="line">	request.setAttribute(<span class="string">"rfUrl"</span>,rfUrl);</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">"/web/workforminfo/workforminfo_list"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br/>
## 四、参考文献：   

<p>1.<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></p>
<p>2.<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p>
<p>3.<a href="https://blog.csdn.net/isea533/article/details/50449907" target="_blank" rel="noopener">Spring MVC 4.2 增加 CORS 支持</a></p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Tablayout+Viewpager+Fragment实现滑动Tab</title>
    <url>/2016/04/09/Tablayout-Viewpager-Fragment-Tab/</url>
    <content><![CDATA[<p>实现活动Tab的方式有很多种，今天我们要用的是使用Google 提供的Design support library 库中的Tablayout去实现，Tablayout是Google I/O 2015 退出8个新的组件之一，可以轻松的结合Viewpager和Fragment实现滑动tab菜单。</p>
<a id="more"></a>


<p>运行效果截图：</p>
<p><img src="/images/20160101.jpg" alt=""></p>
<p><img src="/images/20160102.jpg" alt=""></p>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-添加支持类"><a href="#1-添加支持类" class="headerlink" title="1.添加支持类"></a>1.添加支持类</h3><p>在build.gradle(Module:app)中通过以下代码添加支持类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile 'com.android.support:appcompat-v7:22.2.0'</span><br><span class="line">  compile 'com.android.support:design:22.2.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-创建Sliding-Tabs-Layout（主布局文件）"><a href="#2-创建Sliding-Tabs-Layout（主布局文件）" class="headerlink" title="2.创建Sliding Tabs Layout（主布局文件）"></a>2.创建Sliding Tabs Layout（主布局文件）</h3><p>用android.support.design.widget.TabLayout创建tab布局，用android.support.v4.view.ViewPager显示关联tab的Fragment.<br>eg:main_content.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tab_layout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--app:tabMode="scrollable"--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建Fragment："><a href="#3-创建Fragment：" class="headerlink" title="3.创建Fragment："></a>3.创建Fragment：</h3><p>为每个tab项创建一个对应的fragment用于展示内容。eg:与tab1对应的fragment_tab1.xml代码如下：</p>
<h4 id="3-1Fragment布局"><a href="#3-1Fragment布局" class="headerlink" title="3.1Fragment布局"></a>3.1Fragment布局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.crazyfzw.tablayoutviewpager.TabFragment1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Update blank fragment layout --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"tab1页内容"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在本例中，我们再创建两个这样布局的fragment_tab2.xml、fragment_tab3.xml.</p>
<h4 id="3-2创建fragment布局文件对应的逻辑类Fragment-java用于展示tab的内容"><a href="#3-2创建fragment布局文件对应的逻辑类Fragment-java用于展示tab的内容" class="headerlink" title="3.2创建fragment布局文件对应的逻辑类Fragment.java用于展示tab的内容"></a>3.2创建fragment布局文件对应的逻辑类Fragment.java用于展示tab的内容</h4><p>eg:这里TabFragment1.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TabFragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_PARAM1 = <span class="string">"param1"</span>;</span><br><span class="line">    <span class="keyword">private</span> String mParam1;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TabFragment1 <span class="title">newInstance</span><span class="params">(String param1)</span> </span>&#123;</span><br><span class="line">        TabFragment1 fragment = <span class="keyword">new</span> TabFragment1();</span><br><span class="line">        Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">        args.putString(ARG_PARAM1, param1);</span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TabFragment1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParam1 = getArguments().getString(ARG_PARAM1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        View myview = inflater.inflate(R.layout.fragment_tab1, container, <span class="keyword">false</span>);</span><br><span class="line">        textView = (TextView) myview.findViewById(R.id.textView1);</span><br><span class="line">        textView.setText(mParam1);</span><br><span class="line">        <span class="keyword">return</span> myview;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>同样，为了演示本例创建相似的TabFragment2java、TabFragment3.java</p>
<h3 id="4-创建ViewPager的适配器"><a href="#4-创建ViewPager的适配器" class="headerlink" title="4.创建ViewPager的适配器:"></a>4.创建ViewPager的适配器:</h3><p>实现FragmentPagerAdapter接口并重载其中的方法，用于控制tab与内容页content的关系。其中getPageTitle(int position)方法为每个tab取得标题title,而getItem(int position)方法决定每个tab显示哪个fragment.</p>
<p>eg:MyViewPagerAdapter.java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentStatePagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Fragment&gt; myFragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; myFragmentTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewPagerAdapter</span><span class="params">(FragmentManager fm, Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, String title)</span> </span>&#123;</span><br><span class="line">        myFragments.add(fragment);</span><br><span class="line">        myFragmentTitles.add(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragments.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragmentTitles.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最后一步，在Activity中把ViewPager-与PagerAdapter绑定，然后让用setupWithViewPager-viewPager-方法把pager与tab关联在一起。"><a href="#5-最后一步，在Activity中把ViewPager-与PagerAdapter绑定，然后让用setupWithViewPager-viewPager-方法把pager与tab关联在一起。" class="headerlink" title="5.最后一步，在Activity中把ViewPager 与PagerAdapter绑定，然后让用setupWithViewPager(viewPager)方法把pager与tab关联在一起。"></a>5.最后一步，在Activity中把ViewPager 与PagerAdapter绑定，然后让用setupWithViewPager(viewPager)方法把pager与tab关联在一起。</h3><p>主要两步:<br>A:找到ViewPager控件并setAdapter(adapter);<br>B：找到tablayout控件并用用setupWithViewPager(viewPager)方法把pager与tab关联在一起。</p>
<p>eg:本例Mainactivity.java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TabLayout tabLayout;</span><br><span class="line">    <span class="keyword">private</span> ViewPager viewPager;</span><br><span class="line">    <span class="keyword">private</span> MyViewPagerAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tabLayout = (TabLayout) findViewById(R.id.tab_layout);</span><br><span class="line">        viewPager = (ViewPager) findViewById(R.id.pager);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setupViewPager(viewPager);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">        adapter = <span class="keyword">new</span> MyViewPagerAdapter(getSupportFragmentManager(), <span class="keyword">this</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment1().newInstance(<span class="string">"Page1"</span>), <span class="string">"Tab 1"</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment2().newInstance(<span class="string">"Page2"</span>), <span class="string">"Tab 2"</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment3().newInstance(<span class="string">"Page3"</span>), <span class="string">"Tab 3"</span>);</span><br><span class="line">        viewPager.setAdapter(adapter);</span><br><span class="line">        tabLayout.setupWithViewPager(viewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行就可以了。</p>
<p><strong>注意：</strong><br>运行的时候在 adapter.addFragment(new TabFragment1().newInstance(“Page1”),”Tab1”);<br>中很可能会出现错误，无法将子类abFragment1的对象转化为Fragment对象。提示cannot convert from Tab1Fragment(android.support.v4.app.Fragment) to Fragment(android.app.Fragment).这是因为导入包不一致，一般的问题在于：这里或者PaperAdapter中导入的是android.support.v4.app.Fragment，而Fragment的子类Tab1Fragment中导入的是android.app.Fragment，包不同所以无法转换，这里统一导入android.support.v4.app.Fragment就可以解决了。</p>
<p>本例源码可以到我的github去下载 <a href="https://github.com/crazyfzw/TablayoutViewpager" target="_blank" rel="noopener">https://github.com/crazyfzw/TablayoutViewpager</a></p>
<p><strong>参考文献：</strong></p>
<p><a href="https://developer.android.com/intl/zh-cn/reference/android/support/design/widget/TabLayout.html" target="_blank" rel="noopener">https://developer.android.com/intl/zh-cn/reference/android/support/design/widget/TabLayout.html</a><br><a href="https://github.com/codepath/android_guides/wiki/ViewPager-with-FragmentPagerAdapter" target="_blank" rel="noopener">https://github.com/codepath/android_guides/wiki/ViewPager-with-FragmentPagerAdapter</a><br><a href="http://blog.csdn.net/jason0539/article/details/9712273" target="_blank" rel="noopener">http://blog.csdn.net/jason0539/article/details/9712273</a></p>
<p>若想实现带图标的滑动tab或者更详细的Tablayout推荐参考<br><a href="https://github.com/codepath/android_guides/wiki/Google-Play-Style-Tabs-using-TabLayout#design-support-library" target="_blank" rel="noopener">https://github.com/codepath/android_guides/wiki/Google-Play-Style-Tabs-using-TabLayout#design-support-library</a></p>
]]></content>
  </entry>
  <entry>
    <title>轻松实现APP自动检测更新</title>
    <url>/2016/08/24/app-auto-update/</url>
    <content><![CDATA[<p><strong>概述：</strong>为了以快速并且节约的方式让APP更新版本，通常需要在APP内增加自动检测更新新版本的功能。</p>
<h2 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h2><p><img src="/images/2016082401.jpg" alt="">)<img src="/images/2016082402.jpg" alt="">)<img src="/images/2016082403.jpg" alt="">)<img src="/images/2016082404.jpg" alt="">  </p>
<a id="more"></a>





<h2 id="实现：4个步骤"><a href="#实现：4个步骤" class="headerlink" title="实现：4个步骤"></a>实现：4个步骤</h2><p><img src="/images/2016082405.png" alt=""> </p>
<h3 id="1-在服务端放置存储版本信息的文件"><a href="#1-在服务端放置存储版本信息的文件" class="headerlink" title="1.在服务端放置存储版本信息的文件"></a>1.在服务端放置存储版本信息的文件</h3><p>  一般以json格式保存必要的信息：apk文件下载地址、版本号、更新内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "url":"http://crazyfzw.github.io/demo/auto-update-version/new-version-v2.0.apk",</span><br><span class="line">  "versionCode":2,</span><br><span class="line">  "updateMessage":"[1]新增视频弹幕功能<span class="tag">&lt;<span class="name">br</span>/&gt;</span>[2]优化离线缓存功能<span class="tag">&lt;<span class="name">br</span>/&gt;</span>[3]增强了稳定性"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-继承AsyncTask创建一个异步任务去下载版本信息文件"><a href="#2-继承AsyncTask创建一个异步任务去下载版本信息文件" class="headerlink" title="2.继承AsyncTask创建一个异步任务去下载版本信息文件"></a>2.继承AsyncTask创建一个异步任务去下载版本信息文件</h3><p> 从服务器取得版本信息，与本地apk对比版本号，判断是否有更新，若有，则以Dialog让用户选择是否更新，若用户选择更新，则调用服务去完成apk文件的下载</p>
<p><strong>CheckVersionInfoTask.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckVersionInfoTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CheckVersionInfoTask"</span>;</span><br><span class="line">    <span class="keyword">private</span> ProgressDialog dialog;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mShowProgressDialog;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_INFO_URL = <span class="string">"http://crazyfzw.github.io/demo/auto-update-version/update.json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckVersionInfoTask</span><span class="params">(Context context, <span class="keyword">boolean</span> showProgressDialog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mShowProgressDialog = showProgressDialog;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化显示Dialog</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mShowProgressDialog) &#123;</span><br><span class="line">            dialog = <span class="keyword">new</span> ProgressDialog(mContext);</span><br><span class="line">            dialog.setMessage(mContext.getString(R.string.check_new_version));</span><br><span class="line">            dialog.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在后台任务(子线程)中检查服务器的版本信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getVersionInfo(VERSION_INFO_URL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台任务执行完毕后，解除Dialog并且解析return返回的结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dialog != <span class="keyword">null</span> &amp;&amp; dialog.isShowing()) &#123;</span><br><span class="line">            dialog.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(result)) &#123;</span><br><span class="line">            parseJson(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从服务器取得版本信息</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">       "url":"http://crazyfzw.github.io/demo/auto-update-version/new-version-v2.0.apk",</span></span><br><span class="line"><span class="comment">        "versionCode":2,</span></span><br><span class="line"><span class="comment">       "updateMessage":"[1]新增视频弹幕功能&lt;br/&gt;[2]优化离线缓存功能&lt;br/&gt;[3]增强了稳定性"</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVersionInfo</span><span class="params">(String urlStr)</span></span>&#123;</span><br><span class="line">        HttpURLConnection uRLConnection = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buffer = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">            uRLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            uRLConnection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            is = uRLConnection.getInputStream();</span><br><span class="line">            buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = buffer.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                strBuilder.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            result = strBuilder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"http post error"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (uRLConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                uRLConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JSONObject obj = <span class="keyword">new</span> JSONObject(result);</span><br><span class="line">            String apkUrl = obj.getString(<span class="string">"url"</span>);                 <span class="comment">//APK下载路径</span></span><br><span class="line">            String updateMessage = obj.getString(<span class="string">"updateMessage"</span>);<span class="comment">//版本更新说明</span></span><br><span class="line">            <span class="keyword">int</span> apkCode = obj.getInt(<span class="string">"versionCode"</span>);              <span class="comment">//新版APK对于的版本号</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取得已经安装在手机的APP的版本号 versionCode</span></span><br><span class="line">            <span class="keyword">int</span> versionCode = getCurrentVersionCode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对比版本号判断是否需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (apkCode &gt; versionCode) &#123;</span><br><span class="line"></span><br><span class="line">                    showDialog(updateMessage, apkUrl);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShowProgressDialog) &#123;</span><br><span class="line">                Toast.makeText(mContext, mContext.getString(R.string.there_no_new_version), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"parse json error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得当前版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentVersionCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mContext.getPackageManager().getPackageInfo(mContext.getPackageName(), <span class="number">0</span>).versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示对话框提示用户有新版本，并且让用户选择是否更新版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadUrl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">(String content, <span class="keyword">final</span> String downloadUrl)</span> </span>&#123;</span><br><span class="line">            AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(mContext);</span><br><span class="line">            builder.setTitle(R.string.dialog_choose_update_title);</span><br><span class="line">            builder.setMessage(Html.fromHtml(content))</span><br><span class="line">                    .setPositiveButton(R.string.dialog_btn_confirm_download, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//下载apk文件</span></span><br><span class="line">                            goToDownloadApk(downloadUrl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(R.string.dialog_btn_cancel_download, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            AlertDialog dialog = builder.create();</span><br><span class="line">            <span class="comment">//点击对话框外面,对话框不消失</span></span><br><span class="line">            dialog.setCanceledOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">            dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用intent启用DownloadService服务去下载AKP文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadUrl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goToDownloadApk</span><span class="params">(String downloadUrl)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(mContext, DownloadApkService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        intent.putExtra(<span class="string">"apkUrl"</span>, downloadUrl);</span><br><span class="line">        mContext.startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注：其中用到的 StorageUtils.getCacheDirectory(context) 是用于取得应用在手机缓存目录</p>
<p><strong>StorageUtils.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"StorageUtils"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTERNAL_STORAGE_PERMISSION = <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StorageUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns application cache directory. Cache directory will be created on SD card</span></span><br><span class="line"><span class="comment">     * ("/Android/data/[app_package_name]/cache") if card is mounted and app has appropriate permission. Else -</span></span><br><span class="line"><span class="comment">     * Android defines cache directory on device's file system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getCacheDirectory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        File appCacheDir = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) &#123;</span><br><span class="line">            appCacheDir = getExternalCacheDir(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appCacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            appCacheDir = context.getCacheDir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appCacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Can't define system cache directory! The app should be re-installed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appCacheDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getExternalCacheDir</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        File dataDir = <span class="keyword">new</span> File(<span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"Android"</span>), <span class="string">"data"</span>);</span><br><span class="line">        File appCacheDir = <span class="keyword">new</span> File(<span class="keyword">new</span> File(dataDir, context.getPackageName()), <span class="string">"cache"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!appCacheDir.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appCacheDir.mkdirs()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Unable to create external cache directory"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> File(appCacheDir, <span class="string">".nomedia"</span>).createNewFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Can't create \".nomedia\" file in application external cache directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appCacheDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasExternalStoragePermission</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> perm = context.checkCallingOrSelfPermission(EXTERNAL_STORAGE_PERMISSION);</span><br><span class="line">        <span class="keyword">return</span> perm == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-创建服务-Service-完成apk文件的下载，下载完成后调用系统的安装程序完成安装"><a href="#3-创建服务-Service-完成apk文件的下载，下载完成后调用系统的安装程序完成安装" class="headerlink" title="3.创建服务(Service)完成apk文件的下载，下载完成后调用系统的安装程序完成安装"></a>3.创建服务(Service)完成apk文件的下载，下载完成后调用系统的安装程序完成安装</h3><p><strong>DownloadApkService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadApkService</span> <span class="keyword">extends</span> <span class="title">IntentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">10</span> * <span class="number">1024</span>; <span class="comment">//缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DownloadService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> NotificationManager mNotifyManager;</span><br><span class="line">    <span class="keyword">private</span> NotificationCompat.Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadApkService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"DownloadApkService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在onHandleIntent中下载apk文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化通知，用于显示下载进度</span></span><br><span class="line">        mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        mBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line">        String appName = getString(getApplicationInfo().labelRes);</span><br><span class="line">        <span class="keyword">int</span> icon = getApplicationInfo().icon;</span><br><span class="line">        mBuilder.setContentTitle(appName).setSmallIcon(icon);</span><br><span class="line"></span><br><span class="line">        String urlStr = intent.getStringExtra(<span class="string">"apkUrl"</span>); <span class="comment">//从intent中取得apk下载路径</span></span><br><span class="line"></span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立下载连接</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            urlConnection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            urlConnection.setDoOutput(<span class="keyword">false</span>);</span><br><span class="line">            urlConnection.setConnectTimeout(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            urlConnection.setReadTimeout(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip, deflate"</span>);</span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以文件流读取数据</span></span><br><span class="line">            <span class="keyword">long</span> bytetotal = urlConnection.getContentLength(); <span class="comment">//取得文件长度</span></span><br><span class="line">            <span class="keyword">long</span> bytesum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> byteread = <span class="number">0</span>;</span><br><span class="line">            in = urlConnection.getInputStream();</span><br><span class="line">            File dir = StorageUtils.getCacheDirectory(<span class="keyword">this</span>); <span class="comment">//取得应用缓存目录</span></span><br><span class="line">            String apkName = urlStr.substring(urlStr.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, urlStr.length());<span class="comment">//取得apK文件名</span></span><br><span class="line">            File apkFile = <span class="keyword">new</span> File(dir, apkName);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(apkFile);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> oldProgress = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((byteread = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bytesum += byteread;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, byteread);</span><br><span class="line">                <span class="keyword">int</span> progress = (<span class="keyword">int</span>) (bytesum * <span class="number">100L</span> / bytetotal);</span><br><span class="line">                <span class="comment">// 如果进度与之前进度相等，则不更新，如果更新太频繁，则会造成界面卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (progress != oldProgress) &#123;</span><br><span class="line">                    updateProgress(progress);</span><br><span class="line">                &#125;</span><br><span class="line">                oldProgress = progress;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下载完成,调用installAPK开始安装文件</span></span><br><span class="line">            installAPk(apkFile);</span><br><span class="line">            Log.d(<span class="string">"调试"</span>,<span class="string">"download apk finish"</span>);</span><br><span class="line">            mNotifyManager.cancel(NOTIFICATION_ID);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"download apk file error"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时更新下载进度条显示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> progress</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> progress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"正在下载:" + progress + "%"</span></span><br><span class="line">        mBuilder.setContentText(<span class="keyword">this</span>.getString(R.string.dialog_choose_update_content, progress)).setProgress(<span class="number">100</span>, progress, <span class="keyword">false</span>);</span><br><span class="line">        PendingIntent pendingintent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent(), PendingIntent.FLAG_CANCEL_CURRENT);</span><br><span class="line">        mBuilder.setContentIntent(pendingintent);</span><br><span class="line">        mNotifyManager.notify(NOTIFICATION_ID, mBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用系统安装程序安装下载好的apk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apkFile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPk</span><span class="params">(File apkFile)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">//如果没有设置SDCard写权限，或者没有sdcard,apk文件保存在内存中，需要授予权限才能安装</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] command = &#123;<span class="string">"chmod"</span>, <span class="string">"777"</span>, apkFile.toString()&#125;; <span class="comment">//777代表权限 rwxrwxrwx</span></span><br><span class="line">            ProcessBuilder builder = <span class="keyword">new</span> ProcessBuilder(command);</span><br><span class="line">            builder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        intent.setDataAndType(Uri.fromFile(apkFile), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-最后一步，new并execute我们写好的异步任务就行了。"><a href="#4-最后一步，new并execute我们写好的异步任务就行了。" class="headerlink" title="4.最后一步，new并execute我们写好的异步任务就行了。"></a>4.最后一步，new并execute我们写好的异步任务就行了。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new CheckVersionInfoTask(MainActivity.this, true).execute();</span><br></pre></td></tr></table></figure>


<p><strong>注：记得在AndroidManifest.xml中生明权限及注册Service哦</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</span><br><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>本案例完整源码：<a href="https://github.com/crazyfzw/AppAutoCheckUpdate" target="_blank" rel="noopener">https://github.com/crazyfzw/AppAutoCheckUpdate</a></p>
<h2 id="用到的相关知识："><a href="#用到的相关知识：" class="headerlink" title="用到的相关知识："></a>用到的相关知识：</h2><p>异步任务AsysTask的相关用法：郭霖的Android AsyncTask完全解析，带你从源码的角度彻底理解</p>
<p>自动启动线程执行耗时任务并会自动停止的服务 IntentService的用法：Android理解：IntentService</p>
]]></content>
  </entry>
  <entry>
    <title>Git 提交代码到远程仓库</title>
    <url>/2017/12/20/git-1/</url>
    <content><![CDATA[<h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><h3 id="一、Git如何把本地代码推送到远程仓库"><a href="#一、Git如何把本地代码推送到远程仓库" class="headerlink" title="一、Git如何把本地代码推送到远程仓库"></a>一、Git如何把本地代码推送到远程仓库</h3><h4 id="1-拉取指定分支代码"><a href="#1-拉取指定分支代码" class="headerlink" title="1. 拉取指定分支代码"></a>1. 拉取指定分支代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b dev https:&#x2F;&#x2F;github.com&#x2F;crazyfzw&#x2F;RecycleViewWithHeader.git</span><br></pre></td></tr></table></figure>


<h4 id="2-初始化版本库"><a href="#2-初始化版本库" class="headerlink" title="2. 初始化版本库"></a>2. 初始化版本库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h4 id="3-添加文件到版本库（只是添加到缓存区）-代表添加文件夹下所有文件"><a href="#3-添加文件到版本库（只是添加到缓存区）-代表添加文件夹下所有文件" class="headerlink" title="3. 添加文件到版本库（只是添加到缓存区） .代表添加文件夹下所有文件"></a>3. 添加文件到版本库（只是添加到缓存区） .代表添加文件夹下所有文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h4 id="4-把添加的文件提交到版本库，并填写提交备注"><a href="#4-把添加的文件提交到版本库，并填写提交备注" class="headerlink" title="4. 把添加的文件提交到版本库，并填写提交备注"></a>4. 把添加的文件提交到版本库，并填写提交备注</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m  &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
<p><em>到目前为止，已经完成了本地代码库的初始化，但是还没有提交到远程服务器，所以关键的来了，要提交到就远程代码服务器，进行以下两步：</em></p>
<a id="more"></a>

<h4 id="5-把本地库与远程库关联"><a href="#5-把本地库与远程库关联" class="headerlink" title="5. 把本地库与远程库关联"></a>5. 把本地库与远程库关联</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 你的远程库地址</span><br></pre></td></tr></table></figure>
<h4 id="6-推送代码到远程仓库（-第一次推送时）"><a href="#6-推送代码到远程仓库（-第一次推送时）" class="headerlink" title="6. 推送代码到远程仓库（ 第一次推送时）"></a>6. 推送代码到远程仓库（ 第一次推送时）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h4 id="7-推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）"><a href="#7-推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）" class="headerlink" title="7. 推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）"></a>7. 推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<a id="more"></a>


<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据存储 3：分库与分表</title>
    <url>/2018/07/29/database-sharding/</url>
    <content><![CDATA[<h2 id="一、分库与分表是为了解决什么问题（目的）"><a href="#一、分库与分表是为了解决什么问题（目的）" class="headerlink" title="一、分库与分表是为了解决什么问题（目的）"></a>一、分库与分表是为了解决什么问题（目的）</h2><p>随着业务的增长，表数据的增加，查询一次所消耗的时间会变得越来越长，甚至会造成数据库的单点压力。当数据库已经成为系统性能的瓶颈，这时，通过分库分表，可以减小数据库的单库单表负担，提高查询性能，缩短查询时间，从而提升系统的响应速度。</p>
<a id="more"></a>


<h2 id="二、分库分表方案应该尽量避免的两个问题"><a href="#二、分库分表方案应该尽量避免的两个问题" class="headerlink" title="二、分库分表方案应该尽量避免的两个问题"></a>二、分库分表方案应该尽量避免的两个问题</h2><ol>
<li>数据迁移</li>
<li>热点数据</li>
</ol>
<h2 id="三、垂直拆分"><a href="#三、垂直拆分" class="headerlink" title="三、垂直拆分"></a>三、垂直拆分</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块以及表的相关性来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</p>
<p>比如以一个订单系统吧为例：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。如下图：</p>
<p><img src="/images/2018073001.png" alt=""></p>
<p><strong>小结：</strong></p>
<p>数据库的 CPU、内存、磁盘 IO 、连接资源、网络带宽都是有限的，所以单个物理机上容易出现资源竞争和性能瓶颈。通过垂直分库，一方面，可以解决数据库单点压力过大的问题，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。另一方面，数据库层面的拆分们也有利于我们针对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。因此，垂直分库是大型分布式系统中优化数据库架构的重要手段。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>垂直分表在日常开发和设计中比较常见。垂直拆分，其实就是“大表拆小表”，把表的列字段进行拆分，即一张字段比较多的表拆分为多张表，这样使得行数据变小。一方面，可以减少客户端程序和数据库之间的网络传输的字节数，因为生产环境共享同一个网络带宽，随着并发查询的增多，有可能造成带宽瓶颈从而造成阻塞。另一方面，一个数据块能存放更多的数据，在查询时就会减少 I/O 次数。</p>
<p>通常就是建立“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：</p>
<p><img src="/images/2018073002.png" alt=""></p>
<p><strong>拆分策略：</strong></p>
<ol>
<li><p>将不常用的字段单独拆分到另外一张扩展表，例如前面讲解到的用户家庭地址，这个字段是可选字段，在数据库操作的时候除了个人信息外，并不需要经常读取或是更改这个字段的值。</p>
</li>
<li><p>将大文本的字段单独拆分到另外一张扩展表，例如 BLOB 和 TEXT 字符串类型的字段，以及 TINYBLOB、 MEDIUMBLOB、 LONGBLOB、 TINYTEXT、 MEDIUMTEXT、 LONGTEXT字符串类型。这样可以减少客户端程序和数据库之间的网络传输的字节数。</p>
</li>
<li><p>将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。举个例子，假设用户表的设计中，还存在“最后登录时间”字段，每次用户登录时会被更新。这张用户表会存在频繁的更新操作，此外，每次更新时会导致该表的查询缓存被清空。所以，可以把这个字段放到另一个表中，这样查询缓存会增加很多性能。对于需要经常关联查询的字段，建议放在同一张表中。不然在联合查询的情况下，会带来数据库额外压力。</p>
</li>
</ol>
<p><strong>小结：</strong></p>
<p>拆分字段的操作应该在数据库表设计阶段就做好。尽量避免在发展过程中做垂直分表，因为做字段拆分后，需要改以前的映射实体以及查询语句，会额外带来一定的成本和风险。</p>
<h2 id="四、水平拆分"><a href="#四、水平拆分" class="headerlink" title="四、水平拆分"></a>四、水平拆分</h2><p>垂直拆分只是解决了单库压力的问题。依然可能存在单表数据量过大影响查询性能的问题。若确实存在，则这时就应该考虑水平拆分。</p>
<p>水平分表也称为横向分表，是一种把单表按某个规则把数据分散到多个表的拆分方式，以此来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。</p>
<p>如下图所示：比如：把单表1亿数据按某个规则拆分，分别存储到10个相同结果的表，每个表的数据是1千万，拆分出来的表，可以综合实际情况考虑是放在同一个库中，还是分别放至到不同数据库中，即同时进行水平拆库操作，如下图所示：</p>
<p><img src="/images/2018073003.png" alt=""></p>
<p><strong>水平分表策略</strong></p>
<p>常见的水平分表策略归纳起来，可以总结为随机分表和连续分表两种情况。例如，取模切分、Hash切分就属于随机分表，而按时间维度切分、ID 范围切分则属于连续分表。</p>
<h3 id="连续切分（范围切分）"><a href="#连续切分（范围切分）" class="headerlink" title="连续切分（范围切分）"></a>连续切分（范围切分）</h3><p>连续分表可以快速定位到表进行高效查询，大多数情况下，可以有效避免跨表查询。如果想扩展，只需要添加额外的分表就可以了，无需对其他分表的数据进行数据迁移。但是，连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。</p>
<p>比如按照时间区间或ID区间来切分：</p>
<p><img src="/images/2018073004.png" alt=""></p>
<p>优点：单表大小可控，天然水平扩展。<br>缺点：无法解决集中写入瓶颈的问题，可能存在热点数据问题。</p>
<h3 id="随机切分（Hash切分、取模切分）"><a href="#随机切分（Hash切分、取模切分）" class="headerlink" title="随机切分（Hash切分、取模切分）"></a>随机切分（Hash切分、取模切分）</h3><p>随机分表是遵循规则策略进行写入与读取，而不是真正意义上的随机。通常，采用取模分表或者自定义 Hash 分表的方式进行水平拆分。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。此外，随机分表比较容易面临跨表查询的复杂问题。</p>
<p>比如以下取模切分：</p>
<p><img src="/images/2018073005.png" alt=""></p>
<p>后面这里需要再结合案例展开详细写。</p>
<p>优点：不存在热点数据问题，不存在几种写入瓶颈问题。<br>缺点：再次扩展难度增大，需要迁移旧数据。</p>
<p><strong>小结：</strong></p>
<p>水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，通常做法是把拆分后的表放到不同的库中。但这也涉及一个成本问题，需要综合考虑实际的访问量、并发数、未来可预见的一段时间的业务增长量、以及成本。</p>
<p>水平拆分可以降低单表数据量，让每个单表的数据量保持在一定范围内，从而提升单表读写性能。但水平拆分后，同一业务数据分布在不同的表或库中，可能需要把单表事务改成跨表事务，需要转变数据统计方式等。</p>
<h2 id="五、垂直水平拆分混合"><a href="#五、垂直水平拆分混合" class="headerlink" title="五、垂直水平拆分混合"></a>五、垂直水平拆分混合</h2><p>垂直水平拆分，是综合了垂直和水平拆分方式的一种混合方式。首先，按业务及表的相关性垂直分库（垂直切分），划分出不同的库，然后再挑选出数据量大、增长迅猛的表进行水平分表（水平切分）。</p>
<p>比如针对一个订单系统的垂直水平拆分如下：</p>
<p><img src="/images/2018073006.png" alt=""></p>
<p><strong>小结：</strong></p>
<p>需要注意的是，水平拆分的表需要放到不同的数据库才能减少数据库的但点压力，但是考虑到成本和后期的管理维护问题，现实情况，往往不会弄单库单表的情况（除非真的必要）。</p>
<p>为了提示机器的利用率，在水平切分完成后可再进行一次“反向的Merge”,即：将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个分片放到同一个数据库上，在逻辑上它们依然是独立的分片，有各自的主表，并且提升了数据库服务器的利用率。</p>
<p>整个过程可以参考下图：</p>
<p><img src="/images/2018073007.png" alt=""></p>
<h2 id="六、分库分表实践案例"><a href="#六、分库分表实践案例" class="headerlink" title="六、分库分表实践案例"></a>六、分库分表实践案例</h2><p>下面是唯品会以及美团点评对订单系统的分库分表，个人觉得比较有参考意义。具体详情可参考原文。</p>
<h3 id="唯品会的订单分库分表实践总结以及关键步骤"><a href="#唯品会的订单分库分表实践总结以及关键步骤" class="headerlink" title="唯品会的订单分库分表实践总结以及关键步骤"></a>唯品会的订单分库分表实践总结以及关键步骤</h3><p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p>
<h3 id="大众点评订单系统分库分表实践"><a href="#大众点评订单系统分库分表实践" class="headerlink" title="大众点评订单系统分库分表实践"></a>大众点评订单系统分库分表实践</h3><p>原文地址：<a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p>
<h3 id="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"><a href="#阿里一种可以避免数据迁移的分库分表scale-out扩容方式" class="headerlink" title="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"></a>阿里一种可以避免数据迁移的分库分表scale-out扩容方式</h3><p>文章地址：<a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p>
<br/>
## 七、分库分表带来的问题以及对应的解决办法

<h3 id="1-表关联问题（跨库-Join）"><a href="#1-表关联问题（跨库-Join）" class="headerlink" title="1. 表关联问题（跨库 Join）"></a>1. 表关联问题（跨库 Join）</h3><p>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。</p>
<p>基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。所以，在设计及拆分阶段应尽量避免出现跨库Join（将那些存在关联关系的表记录存放在同一个分片上）。若开发过程中还是出现了需要跨库查询的场景，则可以通过在程序中进行拼装解决（二次查询或者通过RPC调用来得到关联的数据,然后再进行拼装）。</p>
<p><strong>下面，提供几种跨库J oin的解决思路：</strong></p>
<p><strong>ER分片</strong><br>在关系型数据库中，表之间往往存在一些关联的关系。如果我们可以先确定好关联关系，在设计或拆分阶将那些存在关联关系的表记录存放在同一个分片上，那么就能很好的避免跨分片 join 问题。</p>
<p><strong>通过全局表进行规避</strong></p>
<p>比如“数据字典表”，这种系统中的所有模块都可能会用到的表，这类数据通常也很少发生修改（甚至几乎不会），也不用太担心“一致性”问题。所以可以将这类表在每个数据库中均保存一份，以此来了避免跨库join查询。这种表，可以称之为全局表。</p>
<p><strong>通过反范式化设计进行规避</strong></p>
<p>可以通过个别字段的冗余来避免跨库join查询，这是一种典型的反范式设计。</p>
<p>举个电商业务中很简单的场景：</p>
<p>“订单表”中保存 “卖家Id” 的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。单这也存在一个问题，比如卖家修改了Name之后，是否需要在订单信息中同步更新呢？</p>
<p>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。另一方面，这种方式存在数据一致性问题，如果业务对数据一致性强要求，那就需要通过额外的手段来保证（比如可以借助数据库中的触发器或者在业务代码层面去保证）。</p>
<p><strong>通过在系统层二次查询组装解决</strong></p>
<p>可以在程序中通过或者通过RPC调用来得到关联的数据，从而避免跨库join查询。需要特别注意的是，这里的二次查询或者通过RPC调用最好不要放在循环中去执行，否则效率会很低，甚至会严重影响系统的性能。</p>
<p>通常的做法是把循环调用改成一次调用，一次取出所有关联的数据，然后再进行组装。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> QuestionResponse <span class="title">GetOrderList</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	QuestionResponse response = <span class="keyword">new</span> QuestionResponse();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取基本结构集</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Order&gt; result =  orderServer.getOrderList();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	List&lt;Long&gt; productIds = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Order order : result) &#123;			</span><br><span class="line">		productIds.add(order.getProductId());			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 传入关联数据的ID集合，一次查询出所有关联数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Product&gt; productList =  productServer.getOrderList(productIds);</span><br><span class="line">	<span class="keyword">for</span> (Order order : result) &#123;			</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 匹配数据，并赋值		</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	response.setResult(result);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<p>简单字段组装的情况下，我们只需要先获取“主表”数据，然后再根据关联关系，调用其他模块的组件或服务来获取依赖的其他字段（如例中依赖的用户信息），最后将数据进行组装。</p>
<p>通常，我们都会通过缓存来避免频繁RPC通信和数据库查询的开销。</p>
<h3 id="2-分页与排序问题（limit、order-by）"><a href="#2-分页与排序问题（limit、order-by）" class="headerlink" title="2. 分页与排序问题（limit、order by）"></a>2. 分页与排序问题（limit、order by）</h3><p>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p>
<p>如下图所示取第一页数：</p>
<p><img src="/images/2018073008.png" alt=""></p>
<p>上图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="/images/2018073009.png" alt=""></p>
<p>那为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差（典型的大分页问题，比如搜索引擎结果页中，越往后翻响应越慢）。</p>
<h3 id="3-跨分片的函数处理-Count、Max、Min、Sum"><a href="#3-跨分片的函数处理-Count、Max、Min、Sum" class="headerlink" title="3. 跨分片的函数处理(Count、Max、Min、Sum)"></a>3. 跨分片的函数处理(Count、Max、Min、Sum)</h3><p>在使用Max、Min、Sum、Count之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：</p>
<p><img src="/images/2018073010.png" alt=""></p>
<h3 id="4-分布式事务问题"><a href="#4-分布式事务问题" class="headerlink" title="4. 分布式事务问题"></a>4. 分布式事务问题</h3><p>按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。以往在代码中通过spring注解简单配置就能实现事务，现在则需要花很大的成本去保证一致性。后面会单独写一篇文章展开讲。</p>
<h3 id="5-分布式全局唯一ID"><a href="#5-分布式全局唯一ID" class="headerlink" title="5. 分布式全局唯一ID"></a>5. 分布式全局唯一ID</h3><p><a href="https://crazyfzw.github.io/2018/07/21/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-2%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/#more">分布式系统全局唯一ID生成方案</a></p>
<h2 id="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"><a href="#八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）" class="headerlink" title="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"></a>八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）</h2><p>分库与分表主要用于应对当前互联网常见的两个场景：海量数据和高并发。但是分库分表同时也提高了系统的复杂度以及维护成本。分库与分表是一把双刃剑，因此，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑通过分库与分表提高系统的性能。</p>
<p>一般表数据在1000W以内都不需要考虑分表。分库分表时应考虑尽可能考虑可预见的几年内业务的增长，对数据库服务器的QPS、连接数、容量等做合理评估和规划。</p>
<h2 id="九、分库分表后如何迁移数据"><a href="#九、分库分表后如何迁移数据" class="headerlink" title="九、分库分表后如何迁移数据"></a>九、分库分表后如何迁移数据</h2><p>对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</p>
<h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><p>[1] <a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p>
<p>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p>
<p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486426&idx=1&sn=20e965a30c59613b5b11e42e004d2445&chksm=96c9bdbaa1be34ac8d25637272287da249fe2cb804315e2fc73f87d770dd7a41fdb286fa114e&scene=27#wechat_redirect" target="_blank" rel="noopener">分库分表的几种常见形式以及可能遇到的难题</a></p>
<p>[4] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486422&idx=1&sn=f6dd2a02c96bc3467de83bb34c87fe64&chksm=96c9bdb6a1be34a0e5c218d4143a05d04404d1515a972b642c447967847c3dac58eb59f4742f&scene=27#wechat_redirect" target="_blank" rel="noopener">水平分库分表的关键步骤以及可能遇到的问题</a></p>
<p>[5] <a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p>
<p>[6] <a href="http://jm.taobao.org/%2F2017%2F01%2F19%2F20170119%2F" target="_blank" rel="noopener">阿里巴巴分布式数据库服务DRDS研发历程</a></p>
<p>[7] <a href="https://help.aliyun.com/product/29657.html?spm=a2c4g.11186623.6.540.43ee6b20kxutaK" target="_blank" rel="noopener">阿里的分布式数据库DRDS</a></p>
<p>[8] <a href="https://juejin.im/post/5992b2f8f265da3e185eb75d" target="_blank" rel="noopener">贝聊通过DRDS实现亿级数据库分库分表实践</a></p>
<p>[9] <a href="http://blog.720ui.com/2017/mysql_core_08_multi_db_table/" target="_blank" rel="noopener">分库与分表设计</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 4 ：Java的类加载机制</title>
    <url>/2018/07/12/classloader/</url>
    <content><![CDATA[<h2 id="一、Class文件"><a href="#一、Class文件" class="headerlink" title="一、Class文件"></a>一、Class文件</h2><p>在开始讲类加载机制之前，不妨先来了解一下 java 中的这个 ”类“。我们都知道 java 最著名的优点之一就是 摆脱了硬件平台的束缚，实现了”一次编写、到处运行“，那么 java 是怎么做到这种跨平台的呢？答案是通过  虚拟机 + “字节码”。</p>
<a id="more"></a>


<ol>
<li><p>java程序在编译时并不直接编译成依赖于平台的特定机器语言，而是编译成与平台无关的”字节码”，由java虚拟机来执行，java虚拟机执行的时候才将字节码翻译成目标平台对应的机器指令代码。</p>
</li>
<li><p>不同平台的不同虚拟机都可以载入和执行这种平台无关的“字节码”。</p>
</li>
</ol>
<p>这种具有特定的二进制文件格式的“字节码”就是 “Class文件”，即类加载机制中的“类”。</p>
<p><img src="/images/2018071001.png" alt=""></p>
<p>class文件一组以8位字节为单位的二进制流，由无符号数和表两种数据类型组成组成，无符号数实质上就是不同大小的字节，u1、u2、u4、u8分别代表1、2、4、8个字节；表是由多个无符号数或者其他表作为数据项构成的复合数据类型。</p>
<p>*<em>class类文件由以下部分组成： *</em></p>
<ul>
<li>魔数</li>
<li>次版本</li>
<li>主版本</li>
<li>常量池</li>
<li>类访问标识</li>
<li>此类信息常量池索引</li>
<li>父类信息常量池索引</li>
<li>接口集合常量池索引</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>类属性集合</li>
</ul>
<h2 id="二、类的生命周期"><a href="#二、类的生命周期" class="headerlink" title="二、类的生命周期"></a>二、类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图：<br><img src="/images/2018071002.png" alt=""></p>
<p>图中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段不一定：它在某些情况下可以在初始化阶段之后才开始，这是为了支持Java语言的运行时绑定（也称为动态绑定）。</p>
<h2 id="三、类加载的时机"><a href="#三、类加载的时机" class="headerlink" title="三、类加载的时机"></a>三、类加载的时机</h2><p>类加载的时机主要还是依赖于初始化的时机。虚拟机规定有且仅有5种情况会触发类的初始化 ，而在初始化之前，自然是要先经过加载、验证、准备的，所以类加载的时机依主要还是看什么情况下会触发类的初始化。下文中会详细讲下类初始化的触发条件。</p>
<h2 id="四、类加载的过程"><a href="#四、类加载的过程" class="headerlink" title="四、类加载的过程"></a>四、类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>把数据从 Class 文件加载到内存，有预加载和运行时加载2种：</p>
<p><strong>1、预加载：</strong>虚拟机启动时，会加载 JAVA_HOME/lib/ 下的 rt.jar 中 .class 文件，这个 jar 包里面的内容是程序运行时非常可能会用到的基础类，像 java.lang.<em>、java.util.</em>、java.io.*等，因此随着虚拟机一起加载。可以写一个空的main函数，设置虚拟机参数为 “-XX:+TraceClassLoading”，运行一下 </p>
<p><img src="/images/2018071003.png" alt=""></p>
<p><img src="/images/2018071004.png" alt=""><br>…</p>
<p><strong>2、运行时加载：</strong>虚拟机会根据类的全限定名在内存中查找是否已经加载了这个类，如果没有，则会通过委托机制（双亲委派模型，后面会细讲）加载这个类。在加载阶段，虚拟机做了以下3件事情：</p>
<p>1) 根据全限定名 获取 .class 文件的二进制字节流；<br>2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段主要会完成下面4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<p><strong>1.文件格式验证</strong><br>验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机处理。</p>
<ul>
<li><p>是否以魔数 0xCAFEBABE 开头</p>
</li>
<li><p>主次版本号是否在当前虚拟机处理范围之内，紧接着魔数的4个字节存储的是 Class 文件的版本号：第5和第6是次版本号，第7和弟8个字节是主版本号。高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件。比如：在JDK1.7下编译生成的Class文件，那么JDK1.7及以上的版本能运行这个 Class 文件，但是JDK1.6乃更低的JDK版本是无法运行 Class文件的。</p>
</li>
<li><p>常量池中的常量是否有不被支持的常量类型；</p>
</li>
<li><p>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；</p>
</li>
<li><p>CONSTANTUtf8info型的常量中是否有不符合UTF8编码的数据；</p>
</li>
<li><p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</p>
<p>等等</p>
</li>
</ul>
<p><strong>2.元数据验证</strong><br>主要目的是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<ul>
<li>这个类是否有父类；</li>
<li>这个类的父类是否继承了不准许被继承的类；</li>
<li>如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法；</li>
<li>类中的字段方法是否与父类产生矛盾。<br>等等</li>
</ul>
<p><strong>3.字节码验证</strong></p>
<p>对方法体进行校验，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作；</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上；</li>
<li>保证方法体中的类型转换是有效的。<br>等等</li>
</ul>
<p><strong>4.符号引用验证</strong><br>目的是确保解析动作能正常进行，如果无法通过符号引用验证，抛出  java.lang.NoSuchFieldError、java.lang.NoSuchMethodError、java.lang.IIegalAccessError 等。</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否找到相应的类；</li>
<li>在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段；</li>
<li>符号引用中的类、字段、方法的访问性是否被当前类访问。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。关于这点，有两个地方注意一下：</p>
<p>1、这时候只会对类变量（被static修饰的变量）进行内存分配，而不会给实例变量分配内存，，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中；</p>
<p>2、在准备阶段，对于非final修饰的static变量，设置的初始值为数据类型的零值，对于 被final修饰的 static变量，则会直接赋予所指定的值。<br>比如”public static int value = 123;”，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；而”public static final int value = 123;”就不一样了，在准备阶段，虚拟机就会给value直接赋值为123。</p>
<p>基本数据类型的零值如下表：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>short</td>
<td>(short) 0</td>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
<td>reference</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>(byte) 0</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。那么，符号引用与直接引用又有什么区别呢？</p>
<p><strong>1、符号引用</strong><br>符号引用以一组符号来描述所引用的目标，定义在java虚拟机规范中的Class文件格式中，它与虚拟机实现的内存布局无关，引用的目标并不一定加载到内存中。</p>
<p>符号引用包含了下面3种信息：</p>
<ul>
<li><p>类和接口的全限定名</p>
</li>
<li><p>字段的名称和描述符</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
</ul>
<p>下面写个简单的例子，然后先用 javac 编译出二进制字节码，然后再用 jdk 自带的反编译工具 javap 反编译输出常量表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018071005.png" alt=""></p>
<p>结果如下：<br><img src="/images/2018071006.png" alt=""></p>
<p>Constant Pool 的结果中，带”Utf8”的就是符号引用，比如 #8 为 n, #9 为 I, 表示的是 int 型的变量 n。</p>
<p><strong>2、直接引用</strong><br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，如果有了直接引用，那引用的目标必定已经存在在内存中了。同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 java 程序代码（或者说是字节码）</p>
<p><strong>初始化阶段主要做了以下2件事：</strong></p>
<ol>
<li><p>给静态变量赋予指定的值，需要注意区别的是，在准备阶段，给静态变量设置的初始值是类型的零值，到了初始化阶段才会赋予程序实际指定的值。</p>
</li>
<li><p>执行静态代码块</p>
</li>
</ol>
<p>注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()方法，其他线程都要阻塞等待，直至活动线程执行<clinit>()方法完毕。因此如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程不会再次进入<clinit>()方法了，因为同一个类加载器下，一个类只会初始化一次。</p>
<p><strong>初始化的时机（触发条件）</strong><br>虚拟机规定有且仅有以下5种情况会触发类的初始化  （而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>使用 new 关键字实例化对象的时候，读取或设置一个类的静态字段（该字段不被 final 修饰）的时候，以及调用一个类的静态方法的时候；</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候；</li>
<li>当初始化一个类的时候,如果发现其父类还没有进行过初始化，则需要先初始化其父类；</li>
<li>当虚拟机启动的时候,用户需要指定一个要执行的主类(包含 main 方法的那个类)，虚拟机需要先初始化这个主类；</li>
<li>当使用JDK1.7的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REFgetStatic、REFputStatic、REF_invokeStatic 的方法句柄,并且这个方法句柄所对应的类没有进行过初始化。</li>
</ol>
<p>以上5种称为对类的主动引用，只有主动引用才会触发对类的初始化，除此之外，所有引用类的方式都不会触发初始化，称为被动引用，常见的有下面3种：</p>
<p><strong>1、通过子类引用父类静态字段，不会导致子类初始。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071007.png" alt=""></p>
<p><strong>2、通过数组定义引用类，不会触发此类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] supArr= <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071008.png" alt=""></p>
<p><strong>3、引用常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类，因此也不会触发类的初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD =  <span class="string">"Hello World"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstCLass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071009.png" alt=""></p>
<h2 id="五、类与类加载器"><a href="#五、类与类加载器" class="headerlink" title="五、类与类加载器"></a>五、类与类加载器</h2><p>Java 代码要想运行，首先需要将源代码进行编译生成 .class 文件，然后把 .class 字节码文件加载到 JVM  中运行，实现这个加载动作的程序就是类加载器。在类加载阶段，类加载器负责通过一个类的全限定名来获取此类的二进制字节流。</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限定于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗点说就是：比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个.class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。</p>
<p>Java为我们提供了3种原生的类加载器：分别是启动类加载器（Bootstrap ClassLoader）、拓展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）。除此之外，用户还可以根据自己的需要自定义类加载器。</p>
<p>下面分别详细介绍下3种原生的类加载器：</p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>启动类加载器，又称引导类加载器。区别于那些由独立于虚拟机外部、由java语言实现的类加载器，启动类加载器使用C++实现，是虚拟机自身的一部分。主要负责加载 <JAVA_HOME>\lib 目录下 rt.jar、resources.jar、charsets.jar 等 java 核心类库。</p>
<p>通过下面代码我们可以查看启动类加载器的扫描路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;    </span><br><span class="line">            System.out.println(urls[i].toExternalForm());    </span><br><span class="line">        &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="/images/2018071301.png" alt=""></p>
<h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><p>扩展类加载器，由 sun.misc.Launcher$ExtClassLoader 实现，主要负责加载 Java 的扩展类库，默认加载 JAVA_HOME/jre/lib/ext/ 目录下的所有 Jar 包或者由 java.ext.dirs 系统属性指定的 Jar 包。</p>
<p>通过下面代码我们可以查看启动类加载器的扫描路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Program Files\Java\jdk1.8.0_91\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>


<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p>应用程序类加载器，又称系统类加载器。由 sun.misc.Launcher$AppClassLoader 实现，负责在 JVM 启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH 操作系统属性所指定的 JAR 类包和类路径。调用 ClassLoader.getSystemClassLoader() 可以获取该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器。</p>
<p>执行以下代码即可获得 classpath 加载路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br></pre></td></tr></table></figure>


<h3 id="3种原生类加载器的关系"><a href="#3种原生类加载器的关系" class="headerlink" title="3种原生类加载器的关系"></a>3种原生类加载器的关系</h3><p><img src="/images/2018071401.png" alt=""></p>
<p>需要注意2点：</p>
<ul>
<li>AppClassloader 的父加载器是 ExtClassloader。</li>
<li>ExtClassloader 的父加载器为 null，但是要注意的是 ExtClassloader 的父加载器并不是 BootstrapClassloader。</li>
</ul>
<p>执行以下代码验证下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>根据结果可以看出：Application ClassLoader 是系统类加载器；Application ClassLoader 的父加载器确实是 Extension ClassLoader。那么为什么 ExtClassLoader 的父加载器为 null 呢？原因是因为 Bootstrap ClassLoader 以外的ClassLoader 都是Java实现的，因此这些 ClassLoader 势必在 Java 堆中有一份实例在，所以 Extension ClassLoader 和 Application ClassLoader 都能打印出实现类。但是Bootstrap ClassLoader 是JVM的一部分，是用 C++ 写的，不属于Java，自然在Java堆中也没有自己的空间， BootstrapClassloader 对 Java 不可见，所以就返回null了。</p>
<h2 id="六、双亲委派模型（类的加载机制：委托机制）"><a href="#六、双亲委派模型（类的加载机制：委托机制）" class="headerlink" title="六、双亲委派模型（类的加载机制：委托机制）"></a>六、双亲委派模型（类的加载机制：委托机制）</h2><p>Java 类加载器使用的是委托机制，也就是一个类加载器在加载一个类时候会首先尝试委派给父类加载器来加载。类加载器之间的层次关系如下图所示，称为类加载器的双亲委派模型。</p>
<p><img src="/images/2018071402.png" alt=""></p>
<h3 id="双亲委派模型的工作过程："><a href="#双亲委派模型的工作过程：" class="headerlink" title="双亲委派模型的工作过程："></a>双亲委派模型的工作过程：</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，并且每一个层次的类加载器都是如此，因此所有的加载请求，最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈无法完成这个加载请求（它的搜索范围中没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p>下面从源码看如何实现委托机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(Stringname,<span class="keyword">boolean</span> resolve)  </span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException  </span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  </span><br><span class="line">           <span class="comment">// 首先从jvm缓存查找该类</span></span><br><span class="line">           Class c = findLoadedClass(name); <span class="comment">// (1)</span></span><br><span class="line">           <span class="keyword">if</span> (c ==<span class="keyword">null</span>) &#123;  </span><br><span class="line">               longt0 = System.nanoTime();  </span><br><span class="line">               <span class="keyword">try</span> &#123;  <span class="comment">//然后委托给父类加载器进行加载</span></span><br><span class="line">                   <span class="keyword">if</span> (parent !=<span class="keyword">null</span>) &#123;  </span><br><span class="line">                       c = parent.loadClass(name,<span class="keyword">false</span>);  (<span class="number">2</span>)</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果父类加载器为null,则委托给BootStrap加载器加载</span></span><br><span class="line">                       c = findBootstrapClassOrNull(name);  (<span class="number">3</span>)</span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundExceptione) &#123;  </span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found  </span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader  </span></span><br><span class="line">               &#125;  </span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c ==<span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">// 若仍然没有找到则调用findclass查找</span></span><br><span class="line">                   <span class="comment">// to find the class.  </span></span><br><span class="line">                   longt1 = System.nanoTime();  </span><br><span class="line">                   c = findClass(name);  (<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats  </span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 -t0);  </span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">               resolveClass(c);  <span class="comment">//（5）</span></span><br><span class="line">           &#125;  </span><br><span class="line">           returnc;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码（1）表示从 JVM 缓存查找该类，如果该类之前被加载过，则直接从 JVM 缓存返回该类。</p>
<p>代码（2）表示如果 JVM 缓存不存在该类，则看当前类加载器是否有父加载器，若有则委托父类加载器进行加载，否者调用（3），委托 BootStrapClassloader 进行加载，如果还是没有找到，则调用当前 Classloader 的 findclass 方法进行查找。</p>
<p>代码（5）则是当字节码加载到内存后进行链接操作，对文件格式和字节码验证，并为 static 字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等。</p>
<p>从上面源码知道要想修改类加载委托机制，实现自己的载入策略，可以通过覆盖 ClassLoader 的 findClass 方法或者覆盖 loadClass 方法来实现。需要注意的是，如果不想打破双亲委派模型，那么只需要重写findClass方法即可，如果明确想打破双亲委派模型，才需要重写整个loadClass方法。当然，我们自定义的ClassLoader往往不想打破双亲委派模型，所以自定义的 ClassLoader 继承自java.lang.ClassLoader并且只重写findClass方法即可。</p>
<p>如果想了解具体怎么去自定义一个类加载器，可以拓展阅读这篇文章：<br><a href="https://www.cnblogs.com/xrq730/p/4847337.html" target="_blank" rel="noopener">自定义一个类加载器</a></p>
<h3 id="为什么要使用委托加载机制"><a href="#为什么要使用委托加载机制" class="headerlink" title="为什么要使用委托加载机制?"></a>为什么要使用委托加载机制?</h3><ol>
<li><p>避免重复加载，当父类加载器已经加载了该类的时候，就没有必要子 ClassLoader 再加载一次。</p>
</li>
<li><p>Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，存放于rt.jar中，无论哪一个类加载器要去加载这个类，最终都是由Bootstrap ClassLoader去加载，因此Object类在程序的各种类加载器环境中都是一个类。相反，如果没有双亲委派模型，由各个类自己去加载的话，如果用户自己编写了一个java.lang.Object，并放在CLASSPATH下，那系统中将会出现多个不同的Object类，Java体系中最基础的行为也将无法保证，应用程序也将会变得一片混乱。</p>
</li>
</ol>
<h3 id="为打破双亲委派模型而生的加载器-线程上下文加载器（Thread-Context-ClassLoader）"><a href="#为打破双亲委派模型而生的加载器-线程上下文加载器（Thread-Context-ClassLoader）" class="headerlink" title="为打破双亲委派模型而生的加载器-线程上下文加载器（Thread Context ClassLoader）"></a>为打破双亲委派模型而生的加载器-线程上下文加载器（Thread Context ClassLoader）</h3><p>双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的类加载器进行加载），这些基础类总是作为被用户调用的API而使用，但凡事没有绝对的，如果基础类又要调用回用户的代码，该怎么办？</p>
<p>典型的场景比如Java 的 SPI (Service Provider Interface)，Java 提供了很多服务提供者接口，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由启动类加载器(Bootstrap Classloader)来加载的；而SPI的实现类是由应用类加载器(Application ClassLoader)来加载的。因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类，所以启动类加载器是无法找到 SPI 的实现类的。</p>
<p>为了解决这个问题，Java设计团队提供了 一个特殊的加载器-线程上下文加载器（Thread Context ClassLoader）来帮助高层的类加载器调用低层类加载器。线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p>
<p>这个类加载器可以通过 java.lang.Thread类的 setContextClassLoaser() 进行设置，如果创建线程时没设置，则继承父类线程的，如果在上层也没有设置过，那么 Thread.currentThread().getContextClassLoader() 取出的就是 默认的 应用类加载器，就可以实现不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。</p>
<p><strong>线程上下文类加载器的适用场景：</strong></p>
<ul>
<li><p>1.当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</p>
</li>
<li><p>2.当使用本类托管类加载，然而加载本类的ClassLoader未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。</p>
</li>
</ul>
<p>拓展阅读 <a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">从JDBC案例分析对线程上下文加载器的使用</a></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明 第六章、第七章<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html</a><br><a href="http://www.infoq.com/cn/articles/cf-Java-class-loader" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/cf-Java-class-loader</a><br><a href="http://ifeve.com/jvm-classloader/" target="_blank" rel="noopener">http://ifeve.com/jvm-classloader/</a><br><a href="https://gitbook.cn/books/5a7719e7367c47172bea2b53/index.html" target="_blank" rel="noopener">https://gitbook.cn/books/5a7719e7367c47172bea2b53/index.html</a><br><a href="http://www.cnblogs.com/xrq730/p/4845144.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4845144.html</a><br><a href="http://www.cnblogs.com/xrq730/p/4844915.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4844915.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo篇之(一)：实现原理及架构详解</title>
    <url>/2018/06/10/dubbo-architecture/</url>
    <content><![CDATA[<h2 id="一、Dubbo-的由来及解决的问题"><a href="#一、Dubbo-的由来及解决的问题" class="headerlink" title="一、Dubbo 的由来及解决的问题"></a>一、Dubbo 的由来及解决的问题</h2><p>随着互联网的发展，市场需求快速变更，业务持续高速增长，网站早已从单一应用架构演变为分布式服务架构及流动计算架构。</p>
<p><img src="/images/2018061001.png" alt=""></p>
<a id="more"></a>


<p>业界出现了一些比较流行的 RPC 框架，如 Apache Thrift、Hessian、gRPC 等。但是随着 RPC 框架的推广和使用的日益深入，服务越来越多,当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时衍生出一些新的需求：</p>
<p><strong>1. 依赖管理：</strong>当服务越来越多时，服务URL配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大，此时需要一个服务注册中心来管理服务的依赖关系，并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>2. 透明路由：</strong>通过订阅发布机制，消费只需要关系服务本身，并不需要配置具体的服务提供地址，实现服务的自动发现。动态的注册和发现服务，使服务的位置透明。</p>
<p><strong>3. 服务治理：</strong> 业务失败之后的放通处理，超时时间控制、流程等常用的因为功能，希望能够独立出一个服务治理中心，统一对集群各节点的服务做在线治理，提升治理效率.</p>
<p><strong>为了解决以上问题，Dubbo 应运而上，Dubbo 除了 RPC 功能,还提供了丰富的服务治理功能。</strong></p>
<p><strong>1. 透明化的远程方法调用，</strong>底层封装了 Java NIO 通信框架 Netty、序列化及反序列化框架、以及应用层提供线程池和消息调度，使业务可以快速的实现跨进程的远程通信，就像调用本地服务那样去调用远程服务，而不需要关系底层的通信细节，例如链路的闪断、失败重试等，极大的提高了应用的开发效率。</p>
<p><strong>2. 软负载均衡及容错机制，</strong>可以在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</p>
<p><strong>3. 服务自动注册与发现，</strong>基于服务注册中心的订阅发布机制，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加或删除服务提供者。 </p>
<p><strong>4. 服务治理，</strong>包括服务注册、服务降级、访问控制、动态配置路由规则、权重调节、负载均衡。</p>
<p><strong>5. Spring 框架无缝集成、</strong>配置化发布服务。</p>
<h2 id="二、Dubbo-的工作原理"><a href="#二、Dubbo-的工作原理" class="headerlink" title="二、Dubbo 的工作原理"></a>二、Dubbo 的工作原理</h2><p><img src="/images/2018061002.png" alt=""></p>
<h3 id="1-节点说明："><a href="#1-节点说明：" class="headerlink" title="1) 节点说明："></a>1) 节点说明：</h3><p>Provider：暴露服务的服务提供方<br>Consumer：调用远程服务的服务消费方<br>Registry：服务注册与发现的注册中心<br>Monitor： 统计服务的调用次数和调用时间的监控中心<br>Container：服务运行容器</p>
<h3 id="2-调用过程及工作原理："><a href="#2-调用过程及工作原理：" class="headerlink" title="2) 调用过程及工作原理："></a>2) 调用过程及工作原理：</h3><p><strong>0.</strong> 服务容器负责启动，加载，运行服务提供者，通过 main 函数初始化 Spring 上下文，根据服务提供者配置的XML文件将服务按照指定的协议发布，完成服务化的初始化工作。。</p>
<p><strong>1.</strong> 服务提供者在启动时，根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到注册中心，向注册中心注册自己提供的服务。</p>
<p><strong>2.</strong> 服务消费者在启动时，消费者根据服务消费者XML配置文件的服务引用信息，连接到注册中心，向注册中心订阅自己所需的服务。</p>
<p><strong>3.</strong> 服务注册中心根据服务订阅的关系，返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送最新的服务地址信息给消费者。</p>
<p><strong>4.</strong> 服务消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择选一台提供者进行，然后根据协议类型建立链路，跨进程调用服务提供者，如果调用失败，再选另一台调用。</p>
<p><strong>5.</strong> 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="三、Dubbo-的实现原理-基本设计原则"><a href="#三、Dubbo-的实现原理-基本设计原则" class="headerlink" title="三、Dubbo 的实现原理(基本设计原则)"></a>三、Dubbo 的实现原理(基本设计原则)</h2><p><strong>1.</strong> 为了保持极强的扩展性，Dubbo 一开始就使用 Microkernel + Plugin （微核心+插件）的设计模式，Microkernel 只负责组装 Plugin，Dubbo 通过利用并改进JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制实现自身的大部分功能(除 Service 和 Config 层为API)。采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息，基于扩展点自适应机制，根据URL中的配置信息，在链的最后一节调用真实的引用，所以Dubbo天生就具有极强的灵活的拓展性。</p>
<p><strong>2.</strong> 从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。</p>
<h2 id="四、Dubbo-的架构与设计"><a href="#四、Dubbo-的架构与设计" class="headerlink" title="四、Dubbo 的架构与设计"></a>四、Dubbo 的架构与设计</h2><p>Dubbo 最大的特点是按照分层的方式来架构，将整个框架分为10层，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。</p>
<p>整体分层设计：</p>
<p><img src="/images/2018061003.png" alt=""></p>
<p>Dubbo框架设计一共划分了10个层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI；最上面的 Service 层是留给实际想要使用 Dubbo 开发分布式服务的开发者实现业务逻辑的接口层；图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</p>
<ol>
<li><p>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</p>
</li>
<li><p>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心，可以直接 new 配置类，也可以通过 spring 解析配置生成配置类。</p>
</li>
<li><p>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory。</p>
</li>
<li><p>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为 RegistryFactory、Registry 和 RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。</p>
</li>
<li><p>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为 Cluster、Directory、Router 和 LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</p>
</li>
<li><p>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService。</p>
</li>
<li><p>远程调用层（Protocol）：封将 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocol、Invoker 和 Exporter。Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker  的生命周期管理。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>
</li>
<li><p>信息交换层（Exchange）：封装请求响应模式，同步转异步，以 Request 和 Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer。</p>
</li>
<li><p>网络传输层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec。</p>
</li>
<li><p>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、 ObjectInput、ObjectOutput和ThreadPool。</p>
</li>
</ol>
<p>从上图可以看出，Dubbo 对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口。根据官方提供的，对于上述各层之间关系的描述，如下所示：</p>
<p>  ● 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</p>
<p>  ● 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</p>
<p>  ● 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p>
<p>  ● Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</p>
<p>  ● 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p>
<p>  ● Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</p>
<h2 id="五、Dubbo的缺点"><a href="#五、Dubbo的缺点" class="headerlink" title="五、Dubbo的缺点"></a>五、Dubbo的缺点</h2><p>对语言的支持不友好，只支持JAVA语言。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a href="http://dubbo.apache.org/books/dubbo-user-book/" target="_blank" rel="noopener">dubbo-user-book</a><br><a href="http://dubbo.apache.org/books/dubbo-dev-book/" target="_blank" rel="noopener">dubbo-dev-book</a><br><a href="http://shiyanjun.cn/archives/325.html" target="_blank" rel="noopener">Dubbo架构设计详解</a><br><a href="http://jm.taobao.org/categories/Dubbo/" target="_blank" rel="noopener">阿里中间件团队博客-Dubbo分类</a></p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>2016秋招笔试面试题二：Android及网络协议部分</title>
    <url>/2016/12/31/interview-1/</url>
    <content><![CDATA[<h1 id="一、Android基础"><a href="#一、Android基础" class="headerlink" title="一、Android基础"></a><strong>一、Android基础</strong></h1><h2 id="1-Android四大组件的理解"><a href="#1-Android四大组件的理解" class="headerlink" title="1.Android四大组件的理解"></a><strong>1.Android四大组件的理解</strong></h2><p><strong>Activity：</strong>从字面上理解，Activity是活动的意思。一个Activity通常展现为一个可视化的用户界面，是Android程序与用户交互的窗口，也是Android组件中最基本也是最复杂的一个组件。从视觉效果来看，一个Activity占据当前的窗口，响应所有窗口事件，具备有控件，菜单等界面元素。从内部逻辑来看，Activity需要为了保持各个界面状态，需要做很多持久化的事情，还需要妥善管理生命周期，和一些转跳逻辑。</p>
<a id="more"></a>


<p><strong>Service：</strong>服务是运行在后台的一个组件，从某从意义上说，服务就像一个没有界面的Activity。它们在很多Android的概念方面比较接近，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事件，定义好需要接受的Intent提供同步和异步的接口。</p>
<p><strong>BroadcastReceiver：</strong>广播接收者，不执行任何任务，广播是一种广泛运用的在应用程序之间传输信息的机制 。而 BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件。Broadcast Receiver 不包含任何用户界面。然而它们可以启动一个Activity以响应接受到的信息，或者通过NotificationManager通知用户。可以通过多种方式使用户知道有新的通知产生：闪动背景灯、震动设备、发出声音等等。通常程序会在状态栏上放置一个持久的图标，用户可以打开这个图标并读取通知信息。在Android中还有一个很重要的概念就是Intent，如果说Intent是一个对动作和行为的抽象描述，负责组件之间程序之间进行消息传递。那么Broadcast Receiver组件就提供了一种把Intent作为一个消息广播出去，由所有对其感兴趣的程序对其作出反应的机制。</p>
<p><strong>Content Provider：</strong>即内容提供者，作为应用程序之间唯一的共享数据的途径，Content Provider 主要的功能就是存储并检索数据以及向其他应用程序提供访问数据。<br>对应用而言，也可以将底层数据封装成ContentProvider，这样可以有效的屏蔽底层操作的细节，并且使程序保持良好的扩展性和开放性。Android提供了一些主要数据类型的Contentprovider，比如音频、视频、图片和私人通讯录等。可在android.provider包下面找到一些android提供的Contentprovider。可以获得这些Contentprovider，查询它们包含的数据，当然前提是已获得适当的读取权限。如果我们想公开自己应用程序的数据，可以创建自己的 Content provider 的接口。</p>
<h2 id="2-Activity的生命周期"><a href="#2-Activity的生命周期" class="headerlink" title="2.Activity的生命周期"></a><strong>2.Activity的生命周期</strong></h2><p><img src="http://img.blog.csdn.net/20161231134946734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">        </p>
<h2 id="3-activity的onCreat-方法参数的作用"><a href="#3-activity的onCreat-方法参数的作用" class="headerlink" title="3.activity的onCreat()方法参数的作用"></a><strong>3.activity的onCreat()方法参数的作用</strong></h2><p>onCreate方法的参数是一个Bundle类型的参数，savedInstanceState也就是保存Activity的状态的,当<br>一个Activity在生命周期以不正常的状态结束前，会调用onsaveInstanceState该方法保存状态。</p>
<h2 id="4-AsyncTask-的使用"><a href="#4-AsyncTask-的使用" class="headerlink" title="4.AsyncTask 的使用"></a><strong>4.AsyncTask 的使用</strong></h2><p>为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它就可以非常灵活方便地从子线程切换到UI线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;  </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	        progressDialog.show();  </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Boolean <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">try</span> &#123;  </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">			<span class="keyword">int</span> downloadPercent = doDownload();  </span><br><span class="line">			publishProgress(downloadPercent);  </span><br><span class="line">			<span class="keyword">if</span> (downloadPercent &gt;= <span class="number">100</span>) &#123;  </span><br><span class="line">			    <span class="keyword">break</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	 &#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;  </span><br><span class="line">	        progressDialog.setMessage(<span class="string">"当前下载进度："</span> + values[<span class="number">0</span>] + <span class="string">"%"</span>);  </span><br><span class="line">	    &#125; </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onPostExecute</span><span class="params">(Boolean result)</span> </span>&#123;  </span><br><span class="line">	        progressDialog.dismiss();  </span><br><span class="line">	<span class="keyword">if</span> (result) &#123;  </span><br><span class="line">	            Toast.makeText(context, <span class="string">"下载成功"</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">	            Toast.makeText(context, <span class="string">"下载失败"</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>1) onPreExecute()</strong><br>这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。<br><strong>2)  doInBackground(Params…)</strong><br>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。<br><strong>3) onProgressUpdate(Progress…)</strong><br>当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。<br><strong>4) onPostExecute(Result)</strong><br>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。</p>
<p>详见：<a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="noopener">郭霖的AsyncTask完全解析</a></p>
<h2 id="5-IntentService与Service的异同"><a href="#5-IntentService与Service的异同" class="headerlink" title="5.IntentService与Service的异同"></a><strong>5.IntentService与Service的异同</strong></h2><p>IntentService是继承Service的，那么它包含了Service的全部特性，当然也包含service的生命周期，那么与service不同的是，IntentService在执行onCreate操作的时候，内部开了一个线程，去你执行你的耗时操作。</p>
<h2 id="6-IntentService-的使用"><a href="#6-IntentService-的使用" class="headerlink" title="6.IntentService 的使用"></a><strong>6.IntentService 的使用</strong></h2><p>IntentService是会自动开启子线程并会自动结束的Service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要一个无参数的构造方法，调用父类的带String参数的构造方法，参数是线程名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestIntentService</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	  <span class="keyword">super</span>(<span class="string">"TestIntentService"</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写IntentService的onHandleIntent，处理耗时的任务。这个方法是在单独线程中运行，而不是在主线程中，所以不会阻塞主线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 耗时任务代码</span></span><br><span class="line">	    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>1) IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求。<br>2) 对于startService()请求执行onHandleIntent()中的耗时任务，会生成一个队列，每次只有一个Intent传入onHandleIntent()方法并执行。也就是同一时间只会有一个耗时任务被执行，其他的请求还要在后面排队， onHandleIntent()方法不会多线程并发执行。<br>3) 当所有startService()请求被执行完成后，IntentService 会自动销毁，所以不需要自己写stopSelf()或stopService()来销毁服务。<br>4) 提供默认的onBind()实现 ，即返回null，不适合绑定的 Service。<br>5) 提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</p>
<p>详见： 叉叉哥的IntentService 解析</p>
<h2 id="7-Android的几种数据存储方式"><a href="#7-Android的几种数据存储方式" class="headerlink" title="7.Android的几种数据存储方式"></a><strong>7.Android的几种数据存储方式</strong></h2><ul>
<li><p>SharePreferences</p>
</li>
<li><p>SQLite</p>
</li>
<li><p>Contert Provider</p>
</li>
<li><p>文件存储</p>
</li>
<li><p>网络数据库存储</p>
</li>
</ul>
<h2 id="8-SQLite数据库版本更新时如何避免数据丢失"><a href="#8-SQLite数据库版本更新时如何避免数据丢失" class="headerlink" title="8.SQLite数据库版本更新时如何避免数据丢失"></a><strong>8.SQLite数据库版本更新时如何避免数据丢失</strong></h2><p>随着应用的升级或者需求的变化，有时需要在原来的表的基础上增加字段，并且需要保证不丢失原来的数据。</p>
<p>其实SqliteOpenHelper的构造方法里有一个参数是int version, 意思是指当前数据库的版本。比如我们的1.0应用中数据库版本是1，当我们需要在2.0版本的应用中改变数据库（可能是增加一个字段，或者是删除一个字段等），我们就要设置int verison的值大于前面一个版本的数据库版本的值，例如改为2，就会触发onUpgrade()方法。所以，我们可以在onUpgrade()方法中进行更新数据库操作。</p>
<p>为了避免表结构改变而引起数据丢失，我们可以在改变表结构之前，通过建立临时表来处理。</p>
<p>那么可以采取在一个事务中执行如下语句来实现修改表的需求。<br><strong>1) 将表改为临时表</strong></p>
<p>ALTER TABLE User RENAME TO _TEMP_User;</p>
<p><strong>2) 创建新的表</strong></p>
<p>CREATE TABLE User (Userid text primary key not null, Sex text not null,Birthday text not null,Name text not null);</p>
<p><strong>3) 导入数据</strong></p>
<p>INSERT INTO User SELECT Userid,””,””,Name FROM TO_TEMP_User;</p>
<p>或者</p>
<p>INSERT INTO User() SELECT Userid,””,””,Name FROM TO_TEMP_User;<br>*注意，“”是用来补充原来不存在的数据的。</p>
<p><strong>4)  删除临时表</strong></p>
<p>DROP TABLE _TEMP_User;</p>
<p>详细可见：<a href="http://www.lai18.com/content/1369050.html" target="_blank" rel="noopener">http://www.lai18.com/content/1369050.html</a></p>
<h2 id="9-Android中，进程通讯-IPC-的方式有哪些"><a href="#9-Android中，进程通讯-IPC-的方式有哪些" class="headerlink" title="9.Android中，进程通讯(IPC)的方式有哪些"></a><strong>9.Android中，进程通讯(IPC)的方式有哪些</strong></h2><p>1)  Linux系统进程间通信有哪些方式？</p>
<ul>
<li><p>socket </p>
</li>
<li><p>name pipe命名管道</p>
</li>
<li><p>message queue消息队列     </p>
</li>
<li><p>singal信号量</p>
</li>
<li><p>share memory共享内存</p>
</li>
</ul>
<p>2) Java系统的通信方式是什么？</p>
<ul>
<li>socket  </li>
<li>name pipe</li>
</ul>
<p>3) Android系统通信方式是什么？<br> Binder 通信</p>
<p>Android进程间通信是通过Binder来实现的。远程Service在Client绑定服务时，会在onBind()的回调中返回一个Binder，当Client调用bindService()与远程Service建立连接成功时，会拿到远程Binder实例，从而使用远程Service提供的服务。</p>
<p>详细可见：<br><a href="http://gold.xitu.io/entry/570af83b8ac247004c31a130" target="_blank" rel="noopener">http://gold.xitu.io/entry/570af83b8ac247004c31a130</a></p>
<h2 id="9-Android中，线程通讯的几种方式"><a href="#9-Android中，线程通讯的几种方式" class="headerlink" title="9.Android中，线程通讯的几种方式  　"></a><strong>9.Android中，线程通讯的几种方式</strong>  　</h2><p>   　<br>    1)  handle</p>
<p>　　2)  Activity.runOnUIThread(Runnable)</p>
<p>　　3)  View.Post(Runnable)</p>
<p>　　4)  View.PostDelayed(Runnabe,long)</p>
<p>　　5)  AsyncTask<br>　　<br>　　6)IntentService：内部有handlethread，属于服务的一种执行完自动结束  优点：优先级高不易被杀死。</p>
<h1 id="二、协议"><a href="#二、协议" class="headerlink" title="二、协议"></a><strong>二、协议</strong></h1><h2 id="1-OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#1-OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="1.OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a><strong>1.OSI，TCP/IP，五层协议的体系结构，以及各层协议</strong></h2><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</p>
<p>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</p>
<p><strong>每一层的协议如下：</strong></p>
<ul>
<li><p>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） </p>
</li>
<li><p>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</p>
</li>
<li><p>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX</p>
</li>
<li><p>会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII</p>
</li>
<li><p>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS </p>
</li>
</ul>
<p><strong>每一层的作用如下：</strong></p>
<ul>
<li><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame）</p>
</li>
<li><p>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</p>
</li>
<li><p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</p>
</li>
<li><p>会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
</li>
<li><p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<p>注意：HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
</li>
</ul>
<p>详细可见：<br><a href="http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21189&amp;query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21189&amp;query=&amp;asc=true&amp;order=&amp;page=1</a></p>
<h2 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2.TCP和UDP的区别"></a><strong>2.TCP和UDP的区别</strong></h2><p>1) TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。</p>
<p>2) TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</p>
<p>3) TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</p>
<h2 id="3-TCP协议中的三次握手及四次挥手"><a href="#3-TCP协议中的三次握手及四次挥手" class="headerlink" title="3.TCP协议中的三次握手及四次挥手"></a><strong>3.TCP协议中的三次握手及四次挥手</strong></h2><p><strong>三次握手：</strong><br>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><strong>四次挥手</strong><br>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
<p>详细可见：<br><a href="http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21194&amp;query=&amp;asc=true&amp;order=&amp;page=6" target="_blank" rel="noopener">http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21194&amp;query=&amp;asc=true&amp;order=&amp;page=6</a></p>
<h2 id="4-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#4-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="4.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a><strong>4.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</strong></h2><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="5-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#5-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="5.在浏览器中输入www.baidu.com后执行的全部过程"></a><strong>5.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></strong></h2><p>1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
<p>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>秋招笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>2016秋招笔试面试题一：Java及基础部分</title>
    <url>/2016/12/30/interview-2/</url>
    <content><![CDATA[<h2 id="1-面向对象的特征"><a href="#1-面向对象的特征" class="headerlink" title="1.面向对象的特征"></a><strong>1.面向对象的特征</strong></h2><p><strong>1) 抽象：</strong> 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p> <strong>2) 继承：</strong> 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 </p>
<p><strong>3) 封装：</strong> 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<p> <strong>4) 多态性：</strong> 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。   </p>
<a id="more"></a>

 <br/> 
## **2.java和c++最大的区别**

<ul>
<li>内存管理 </li>
<li>指针</li>
</ul>
<h2 id="3-JAVA-中int和Integer的区别"><a href="#3-JAVA-中int和Integer的区别" class="headerlink" title="3.JAVA 中int和Integer的区别"></a><strong>3.JAVA 中int和Integer的区别</strong></h2><p>int是一种基本数据类型，而Integer是相应于int的类类型，称为对象包装。</p>
<p>Integer类在对象中包装了一个基本类型int的值。Integer类型的对象包含一个int类型的字段，Integer是int的封装类。<br>此外，该类提供了多个方法，能在int类型和String类型之间互相转换，还提供了处理int类型时非常有用的其他一些常量和方法。<br>详细可见：<a href="http://www.jianshu.com/p/4d6fc88f9458" target="_blank" rel="noopener">http://www.jianshu.com/p/4d6fc88f9458</a></p>
<br/>
## **4.Java的作用域**
**private** 私有权限。只有自己能用。
**friendly** 包权限。同一个包下的可用。不写时默认为friendly 
**protected** 继承权限。（是包权限的扩展，子女类也可使用）。
**public** 谁都可以用。
详细可见：
http://blog.csdn.net/ladofwind/article/details/774072

<br/> 
## **5.overload和override的区别**
**override：**（重写，会覆盖父类的方法，是父类与子类之间多态性的一种表现）
1) 方法名、参数、返回值必须相同。 
2) 子类方法不能缩小父类方法的访问权限。 
3) 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。 
4) 存在于父类和子类之间。，被覆盖的方法不能为private
5) 方法被定义为final不能被重写。 


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;     </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">5</span>);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;     </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">10</span>);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">override</span> </span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">   B b = <span class="keyword">new</span> B();     </span><br><span class="line">   A a= (A)b;<span class="comment">//把 b 强 制转换成A的类型     </span></span><br><span class="line">   <span class="keyword">int</span> x=a.getVal();     </span><br><span class="line">   System.out.println(x);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>overload</strong>（重载，一个类中定义多个同名的方法，这些方法的参数不相同，是一个类中多态性的一种表现） </p>
<p>1) 参数类型、个数、顺序至少有一个不相同。<br>2) 不能通过访问权限、返回类型、抛出的异常进行重载；<br>3) 存在于父类和子类、同类中。<br>4) 方法的异常类型和数目不会对重载造成影响； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverloadDemo</span> </span>&#123;     </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"NO parameters"</span>);     </span><br><span class="line">	&#125;     </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"a:"</span>+a);     </span><br><span class="line">	&#125;<span class="comment">//end of Overload test for one integer parameter.     </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"a and b:"</span>+a+<span class="string">" "</span>+b);     </span><br><span class="line">	       </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"double a:"</span>+a);     </span><br><span class="line">	   <span class="keyword">return</span> a*a;     </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span></span>&#123;     </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">	   OverloadDemo ob = <span class="keyword">new</span> OverloadDemo();     </span><br><span class="line">	   <span class="keyword">double</span> result;     </span><br><span class="line">	   ob.test();     </span><br><span class="line">	   ob.test(<span class="number">10</span>);     </span><br><span class="line">	   ob.test(<span class="number">10</span>, <span class="number">20</span>);     </span><br><span class="line">	   result = ob.test(<span class="number">123.25</span>);     </span><br><span class="line">	   System.out.println(<span class="string">"Result of ob.test(123.25):"</span>+result);  </span><br><span class="line">	 &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

 <br/> 
## **6. volatile关键字的作用**
当我们使用volatile关键字去修饰变量的时候，所以线程都会直接在内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。从而保证多线程中变量的安全性。

<h2 id="7-error和exeception的区别"><a href="#7-error和exeception的区别" class="headerlink" title="7.error和exeception的区别"></a><strong>7.error和exeception的区别</strong></h2><p><img src="http://img.blog.csdn.net/20161229225813014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>Error类和Exception类都继承自Throwable类。        </p>
<p>Error的继承关系：java.lang.Object &gt; java.lang.Throwable &gt; java.lang.Error</p>
<p>Exception的继承关系：<br>java.lang.Object &gt; java.lang.Throwable &gt;　java.lang.Exception</p>
<p><strong>二者的不同之处：</strong><br>Exception：</p>
<p>1) 可以是可被控制(checked) 或不可控制的(unchecked)<br>2) 表示一个由程序员导致的错误<br>3) 应该在应用程序级被处理        </p>
<p>Error：</p>
<p>1) 总是不可控制的(unchecked)<br>2) 经常用来用于表示系统错误或低层资源的错误<br>3) 如何可能的话，应该在系统级被捕捉<br>详细可见：<a href="http://wenku.baidu.com/link?url=Xvk-" target="_blank" rel="noopener">http://wenku.baidu.com/link?url=Xvk-</a></p>
<br/>
## **8. String、StringBuffer、StringBuilder的区别**

<p><strong>String 与StringBuffer对比</strong><br>      String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，从而降低了效率。<br>     而使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。别是字符串对象经常改变的情况下推荐使用 StringBuffer 特。 </p>
<p><strong>StringBuffer与StringBuilder对比</strong><br>StringBuffer：线程安全<br>StringBuilder：线程不安全，单在单线程中，性能比StringBuffer好</p>
<p>区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。</p>
<p>由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。<br>详细可见<br><a href="http://blog.csdn.net/rmn190/article/details/1492013" target="_blank" rel="noopener">http://blog.csdn.net/rmn190/article/details/1492013</a><br><a href="http://blog.csdn.net/mad1989/article/details/26389541" target="_blank" rel="noopener">http://blog.csdn.net/mad1989/article/details/26389541</a></p>
<br/>
## **9.final，finally, finalize的区别**
**final** 用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。
**finally** 是异常处理语句结构的一部分，表示总是执行。
**finalize**是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。

<p>详细可见：<br><a href="http://jingyan.baidu.com/article/597a064363b676312b5243ad.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/597a064363b676312b5243ad.html</a></p>
<br/>
## **10.数组与链表的区别，哪个访问更快**

<p><strong>数组：</strong>静态分配连续的存储空间，每个元素的占用的内存大小相同，可以通过下表快速访问任以元素，访问速度快，但是插入删除要移动大量元素，所以不适合做用于存储需要频繁该改变的数据。</p>
<p><strong>链表：</strong>动态分配内存，不连续，通过指针联系，如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。 </p>
<p>总结：<br>数组静态分配内存，链表动态分配内存，不易造成浪费；<br>数组在内存中连续，链表不连续；<br>数组元素在栈区，链表元素在堆区；<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。<br>详细可见：<br><a href="http://blog.csdn.net/wangshihui512/article/details/9787699" target="_blank" rel="noopener">http://blog.csdn.net/wangshihui512/article/details/9787699</a></p>
<br/>
## **11.java的垃圾处理机制**
**概念：**在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾收集意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。

<p><strong>优点：</strong><br> 1）垃圾回收能自动释放内存空间，减轻编程的负担<br> 2）有效的减少内存泄漏</p>
<p><strong>缺点：</strong><br>垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。 </p>
<p>在HotSpot虚拟机中，物理的将内存分为两个—年轻代(young generation)和老年代(old generation)。</p>
<p><strong>年轻代：</strong>新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说发生了一次“minor GC”。</p>
<p><strong>老年代：</strong>没有变得不可达，存活下来的年轻代对象被复制到这里。这块内存区域一般大于年轻代。因为它更大的规模，GC发生的次数比在年轻代的少。对象从老年代消失时，我们说“major GC”（或“full GC”）发生了。</p>
<p><strong>mimor GC</strong>（发生在年轻代中）<br>为了理解GC，我们学习一下年轻代，对象第一次创建发生在这块内存区域。年轻代分为3块，Eden区和2个Survivor区。</p>
<p>年轻代总共有3块空间，其中2块为Survivor区。各个空间的执行顺序如下：</p>
<p>绝大多数新创建的对象分配在Eden区。</p>
<p>在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。</p>
<p>在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。</p>
<p>一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。</p>
<p>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p>
<p>major GC (又叫full GC，发生在啊老年代中)<br>当老年代数据满时，基本上会执行一次GC，使数据从老年代消失时</p>
<p>详细可见：<br><a href="http://www.importnew.com/20354.html" target="_blank" rel="noopener">http://www.importnew.com/20354.html</a><br><a href="http://lemote.blog.163.com/blog/static/1748395072013111641050934/" target="_blank" rel="noopener">http://lemote.blog.163.com/blog/static/1748395072013111641050934/</a></p>
<br/>
## **12.java内存泄漏**

<p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>所以在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p>
<p><img src="http://img.blog.csdn.net/20161229230246863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>详细可见：<br><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/</a></p>
<br/>
## **13.进程及线程**
一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。
[阮一峰：进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
[JAVA多线程和并发基础面试问答](JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94)

<br/>
## **14.同步及异步**
**同步：**指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；        

<p><strong>异步：</strong>指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>
<br/>
## **15.死锁**
两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。

<p><strong>死锁的四个条件是：</strong><br>禁止抢占：no preemption<br>持有和等待：hold and wait<br>互斥：mutual exclusion<br>循环等待：circular waiting</p>
<p><strong>死锁的消除</strong><br>最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。可以把一个或多个进程回滚到先前的某个状态。<br>详细可见:<br><a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81</a></p>
<br/>
## **16.生产者消费者架构**
(在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。)

<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。<br>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法[1]等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。</p>
<p>生产者消费者模式<br>产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>用处广泛<br>Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是实现方法更高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>(补充:什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？<br>java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。<br>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。<br>BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。)<br>详细可见：<br><a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/producers-and-consumers-mode</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98</a></p>
<br/>
## **17.set用法**
http://www.cnblogs.com/TimeStory/p/3858479.html

<br/>
## **18.设计模式之设计原则**

<p><strong>1) 单一职责原则(SRP)</strong><br>定义：就一个类而言，应该仅有一个引起它变化的原因。 </p>
<p><strong>2)  开放封闭原则(ASD)</strong><br>定义：类、模块、函数等等等应该是可以拓展的，但是不可修改。</p>
<p><strong>3) 里氏替换原则(LSP)</strong><br>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象替换</p>
<p><strong>4) 依赖倒置原则(DIP)</strong><br>定义：高层模块不应该依赖低层模块，两个都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 </p>
<p><strong>5) 迪米特原则(LOD)</strong><br>定义：一个软件实体应当尽可能少地与其他实体发生相互作用。 </p>
<p><strong>6) 接口隔离原则(ISP)</strong><br>定义：一个类对另一个类的依赖应该建立在最小的接口上。 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 </p>
<p>详细可见：<br><a href="http://blog.csdn.net/itachi85/article/details/50491657" target="_blank" rel="noopener">http://blog.csdn.net/itachi85/article/details/50491657</a></p>
<br/>
## **19.抽象类与接口的区别**
![这里写图片描述](http://img.blog.csdn.net/20161230000616380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


<p><img src="http://img.blog.csdn.net/20161230000636824?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>详细可见：<br><a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">http://www.importnew.com/12399.html</a></p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>秋招笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SPI 机制</title>
    <url>/2019/08/24/java-spi/</url>
    <content><![CDATA[<h2 id="SPI-可以用来做什么"><a href="#SPI-可以用来做什么" class="headerlink" title="# SPI 可以用来做什么"></a><a href="#SPI-可以用来做什么" title="# SPI 可以用来做什么"></a># SPI 可以用来做什么</h2><p>在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：</p>
<ol>
<li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。</li>
</ol>
<p>而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。</p>
<p>Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。</p>
<a id="more"></a>
<p>（大致原理就是：在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用 java.util.ServiceLoader 来加载具体的实现。）</p>
<p><img src="/images/2019082401.png" alt=""></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><a href="#使用场景" title="使用场景"></a>使用场景</h3><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：</p>
<ol>
<li><p>JDBC自动加载不同类型的数据库驱动， mysql-connector-java-xxx.jar</p>
</li>
<li><p>日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类</p>
</li>
<li><p>Dubbo中在Java SPI 的基础上做了加强， 实现了根据方法参数或者配置来决定该使用哪个扩展。比如LoadBalance 做到了根据调用者参数的指定来应用不同的负债均衡策略。</p>
</li>
</ol>
<h2 id="如何实现一个自定义-SPI"><a href="#如何实现一个自定义-SPI" class="headerlink" title="# 如何实现一个自定义 SPI"></a><a href="#如何实现一个自定义-SPI" title="# 如何实现一个自定义 SPI"></a># 如何实现一个自定义 SPI</h2><p>这里由于现实情况不同厂商的实现肯定是分开的，所以不同厂商我是建了不同的 maven-modules， 目录结果如下：</p>
<p><img src="/images/2019082402.png" alt=""></p>
<h3 id="1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来"><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" class="headerlink" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a>1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 建立连接</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span></span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h3 id="2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" class="headerlink" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a>2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository</h3><p> MysqlRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mysql"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.mysql.MysqlRepository</span>
</pre></td></tr></table></figure>

<p>OracleRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Oracle"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span>
</pre></td></tr></table></figure>

<p>MongoRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mongo"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span>
</pre></td></tr></table></figure>

<h3 id="3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）"><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" class="headerlink" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a>3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）</h3><p>这里是invoker-test 模块的pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>interface-standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oracle-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span>
</pre></td></tr></table></figure>

<h3 id="4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现"><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" class="headerlink" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a>4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);</span>
<span class="line"></span>
<span class="line">        Iterator&lt;IRepository&gt; it = serviceLoader.iterator();</span>
<span class="line">        <span class="keyword">while</span> (it != <span class="keyword">null</span> &amp;&amp; it.hasNext())&#123;</span>
<span class="line">            IRepository repositoryService = it.next();</span>
<span class="line">            System.out.println(<span class="string">"class:"</span> + repositoryService.getClass().getName());</span>
<span class="line">            repositoryService.connect(<span class="string">"172.0.0.1:3306"</span>);</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>运行效果图如下：</p>
<p><img src="/images/2019082403.png" alt=""></p>
<p><strong>调用主类无需修改代码，只需通过修改pom引入不同的依赖，就可以选择切换不同的实现。</strong></p>
<h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="# SPI 的优缺点"></a><a href="#SPI-的优缺点" title="# SPI 的优缺点"></a># SPI 的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><a href="#优点：" title="优点："></a>优点：</h3><ol>
<li>Java SPI的使用很简单。也做到了基本的加载扩展点的功能，可以使业务代码和组件代码脱耦，启用替换可插拔</li>
<li>拓展性好，在不修改原来代码的基础上，通过添加代码就可以拓展新的能力</li>
<li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便</li>
</ol>
<h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><a href="#不足：" title="不足："></a>不足：</h3><ol>
<li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li>
<li>不提供类似于Spring的IOC和AOP功能，扩展如果依赖其他的扩展，做不到自动注入和装配</li>
</ol>
<p>针对这些问题， Dubbo在原生  Java SPI 的基础上做了一些拓展。 可见参考文献[3][4]。</p>
<p>*<em>本文涉及的spi-demo源码地址： *</em><br><a href="https://github.com/crazyfzw/spi-demo.git" target="_blank" rel="noopener">https://github.com/crazyfzw/spi-demo.git</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://www.cnkirito.moe/spi/" target="_blank" rel="noopener">JAVA拾遗–关于SPI机制</a></p>
<p>[2]<a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">JDBC实现及 DriverManager 源码解析</a></p>
<p>[3]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">Dubbo可扩展机制实战</a></p>
<p>[4]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html" target="_blank" rel="noopener">Dubbo可扩展机制源码解析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 3：Java内存模型-内存区域划分以及对象创建的过程</title>
    <url>/2018/07/11/jvm-memory-division/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>与 C、C++ 相比，Java 把内存控制权交给了虚拟机，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去配对delete/free代码，最直接的好处就是不容易出现内存泄露和内存溢出问题，但是一旦出现内存泄露和内存溢出的问题，如果不了解JVM是如何划分内存区域的，那就难以排查问题，所以了解虚拟机的内存区域以及会引起内存泄露和内存溢出的常见场景，将会帮助我们更快的排查问题，这也是成为 OOM Killer 的基本素质。</p>
<a id="more"></a>

<h2 id="二、内存区域划分"><a href="#二、内存区域划分" class="headerlink" title="二、内存区域划分"></a>二、内存区域划分</h2><p>java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。如下图所示：</p>
<p><img src="/images/2018091701.png" alt=""></p>
<p>上图描述了Java虚拟机运行时的数据区，下面再详细讲下各个区域的特点，下面我用思维导图的形式描述。</p>
<p><img src="/images/2018091702.png" alt=""></p>
<h2 id="三、对象创建的过程"><a href="#三、对象创建的过程" class="headerlink" title="三、对象创建的过程"></a>三、对象创建的过程</h2><p>Java是一门面向对象的语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（克隆、反序列化）就是一个new关键字而已，但再背后虚拟机为我们做了哪些事呢？下面看一下在虚拟机层面上创建对象的步骤：</p>
<p>1、虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的初始化过程。</p>
<p>2、类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。这里分配内存的方式有两种：</p>
<ul>
<li><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。</p>
</li>
<li><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。</p>
</li>
</ul>
<p>另外需要特别注意的是new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。</p>
<p>3、内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>4、对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。</p>
<p>5、执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<p><strong>整个过程可以简要概括为： 检查加载类 -&gt; 给对象分配内存 -&gt; 初始化零值 -&gt; 设置对象头信息 -&gt; 调用构造函数初始化<init></strong></p>
<h2 id="四、对象的内存布局"><a href="#四、对象的内存布局" class="headerlink" title="四、对象的内存布局"></a>四、对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中的布局分为3快区域：对象头（Header）、实例数据（Instance Data）、对其填充（Padding）。如下图所示：</p>
<p><img src="/images/2018091703.png" alt=""></p>
<h2 id="五、对象的访问"><a href="#五、对象的访问" class="headerlink" title="五、对象的访问"></a>五、对象的访问</h2><p>引用存放在虚拟机栈中，数据类型为reference，对象实例存放在堆中。<br>而我们的Java程序需要通过栈上的 reference 数据（引用）来操作堆上的具体对象，那么引用是如何指向对象实例的呢？主流的访问方式有两种：</p>
<p>第一种是通过句柄池，如果使用句柄池，那么java堆中将会划分出一部分内存作为句柄池，句柄包含对象类型指针指向方法区的类型信息，还有对象实例指针，指向堆中的实例地址。如下图所示：</p>
<p><img src="/images/2018091704.png" alt=""></p>
<p>第二种是reference引用直接指向堆中的对象实例，对象实例的对象头存放对象类型指针。如下图所示：</p>
<p><img src="/images/2018091705.png" alt=""></p>
<p><strong>对比：</strong><br>两种方法各有优势，第一种可以在对象实例在GC时移动的时候只改变句柄池中的对象实例数据指针，而不用改变reference引用本身。第二种方法就是访问速度快，减少了一次指针定位的时间开销。目前HotSpot虚拟机就采用的第二种方式。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>《深入理解Java虚拟机》 –第二章 周志明著 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存区域划分</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记 (二)：目录文件操作常用命令</title>
    <url>/2017/10/17/linux-note2/</url>
    <content><![CDATA[<p>Linux 中的所有管理任务都可以在控制台中完成。许多情况下，使用控制台比使用图形化的程序更快捷，而且还可能实现额外的功能。不仅如此，所有的控制台任务都可以写到脚本中，这样就可以自动执行。</p>
<a id="more"></a>

<h2 id="进入控制台"><a href="#进入控制台" class="headerlink" title="进入控制台"></a>进入控制台</h2><p>在典型的 Linux 系统中，通过组合键 Ctrl + Alt + (F1 - F6) 您可以切换到另外的控制台；如果您是在图形模式下，那么您可以打开一个 终端 (terminal)以进入控制台窗口。通常在桌面的任务条上会有终端的按钮。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>所有的命令和选项都区分大小写。 -R 与 -r不同，会去执行不同的操作。控制台命令几乎全都是小写的。下面是一些最常用的命令：</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>使用我们所熟悉的 cd 命令可以在目录间切换。一定注意的是在 Linux 中用的是正斜杠 (/)，而不是您所熟悉的反斜杠 ()。反斜杠也用到了，但只是用来说明命令需要换行继续，这样可以提高比较长的命令的可读性。</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls 命令用于列出一个目录下的所有文件。可以使用许多不同的开关更改列表的表示形式：</p>
<p>列出文件<br><img src="/images/2018041701.png" alt=""></p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前工作目录</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>使用 cp 命令来复制文件。这个命令与 DOS 下的 copy 命令基本一样。基本的开关如下：<br>复制文件<br><img src="/images/2018041702.png" alt=""></p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用 mv 命令来移动和重命名文件。这个命令的工作方式基本上与 DOS 中的 move 命令一样，不过它可以移动整个目录结构及所有文件。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>使用 cat 命令来查看文件的内容。它相当于 DOS 中的 type 命令。它将把文件的内容转储到另一个文件、屏幕或者其他命令。 cat 是concatenate 的简写，还可以将一系列的文件合并为一个大文件。</p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>使用命令 more 可以以分页的方式查看文件。它基本上与 DOS 中的 more命令相同。</p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less 命令也是用来查看文件，但是它支持上下滚屏以及在文档中进行文本搜索。</p>
<h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>有一些人可能会说 vi 表示“virtually impossible”。它是 Unix 中的一个历史悠久的文本编辑器。 vi 并不真正直观，但是现在几乎所有的类 Unix 环境中都有 vi 。对于 Linux 中安装的版本有一个内置的教程，一旦您熟悉了 vi ，只需几次击键就可以完成不可思议的任务。说实话，没有任何编辑器能够取代 vi 来编辑密码和配置文件。</p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>使用 man 命令来查看命令的文档。man 是 manual 的缩写。几乎每一个命令都有相应的文档。要深入了解 man ，请输入以下命令：<br>man man</p>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>info 命令与 man 命令类似，不过它提供了超链接文本，可以更方便地浏览文档。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（三）：服务器常用命令</title>
    <url>/2017/10/20/linux-note3/</url>
    <content><![CDATA[<h4 id="查看指定关键字进程"><a href="#查看指定关键字进程" class="headerlink" title="查看指定关键字进程"></a>查看指定关键字进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看指定进程进程 ps -ef | grep  </span><br><span class="line">如查看java进程  ps -ef | grep java  </span><br><span class="line">查看tomcat进程  ps -ef | grep tomcat</span><br><span class="line">查看某项目进程  ps -ef | grep 目录名  ps -ef | grep ems</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="查看实时日志"><a href="#查看实时日志" class="headerlink" title="查看实时日志"></a>查看实时日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f logs&#x2F;catalina.out</span><br><span class="line"></span><br><span class="line">tail -5000f logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure>


<h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure>

<h4 id="根据-关键词-查看日志-并返回关键词所在行："><a href="#根据-关键词-查看日志-并返回关键词所在行：" class="headerlink" title="根据 关键词 查看日志 并返回关键词所在行："></a>根据 关键词 查看日志 并返回关键词所在行：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 路径&#x2F;文件名 | grep 关键词</span><br></pre></td></tr></table></figure>


<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sz 文件名</span><br></pre></td></tr></table></figure>

<h4 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h4 id="强制终止进程"><a href="#强制终止进程" class="headerlink" title="强制终止进程"></a>强制终止进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 5031</span><br></pre></td></tr></table></figure>

<h4 id="查看内存占用情况"><a href="#查看内存占用情况" class="headerlink" title="查看内存占用情况"></a>查看内存占用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<h4 id="实时显示各个进程的资源占用情况"><a href="#实时显示各个进程的资源占用情况" class="headerlink" title="实时显示各个进程的资源占用情况"></a>实时显示各个进程的资源占用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记 (一)：目录、文件、权限、账户</title>
    <url>/2017/09/23/linux-note1/</url>
    <content><![CDATA[<h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h3><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p>
<p>Linux 是进行内核研究、学习 UNIX 或学习编程的绝佳学习平台；Linux 是作为编程平台的绝佳选择。</p>
<p>您习惯 Linux 的工作方式后，您将具有更大的工具集来控制和维护您的环境。Linux 的强大之处在于它的稳定性和灵活性。一旦您领悟了 Linux 的思想，您将可以完成更多的任务，使更多的任务自动化，更多地以远程方式完成任务。</p>
<p>Linux 相对于 Windows 的许多变化都是有益的。空闲的 GUI 的开销被归还给服务。任务可以脚本化并可以自动执行。配置文件基于文本并且人类可读。在大多数情况下不必重新引导系统。实际上，您应该抑制重新引导系统的冲动。</p>
<a id="more"></a>

<p><strong>重新引导是最后的手</strong><br>如果您确实重新引导了 Linux 系统，问题很可能得不到解决，而且还会使问题更加恶化。学习并掌握 Linux 服务和运行级别是成功解决问题的关键。学习 Linux 最困难的就是克服重新引导系统的习惯。</p>
<p><strong>命令区分大小写</strong><br>所有的 Linux 命令和选项都区分大小写。例如， -R 与 -r不同，会去做不同的事情。控制台命令几乎都是小写的。
　　　</p>
<h3 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h3><p><img src="/images/2017092301.png" alt="这里写图片描述"></p>
<ul>
<li><p><strong>/bin：</strong><br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong></p>
<pre><code>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的            方式是相同的。</code></pre></li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home：</strong><br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib：</strong><br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。     </p>
</li>
<li><p><strong>/lost+found：</strong><br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文 件。</p>
</li>
<li><p><strong>/media：</strong><br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt：</strong><br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<ul>
<li><p><strong>/opt：</strong><br>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc：</strong><br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<br>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</p>
</li>
<li><p><strong>/root：</strong><br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin：</strong><br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux：</strong><br>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv：</strong><br>该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys：</strong><br>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp：</strong><br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr：</strong><br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var：</strong><br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
</ul>
<p>　　　　　　</p>
<h3 id="3-文件权限控制"><a href="#3-文件权限控制" class="headerlink" title="3.文件权限控制"></a>3.文件权限控制</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r:4            </span><br><span class="line">w:2</span><br><span class="line">x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">others&#x3D; --- &#x3D; 0+0+0 &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770 , 如下：</p>
<p> chmod [-R] xyz 文件或目录</p>
<p>如：  <code>chmod -R 777 .bashrc    chmod 777 .bashrc</code></p>
<p>选项与参数：</p>
<ul>
<li><strong>xyz</strong> ： 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。  </li>
<li><strong>-R</strong> ：进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>那如果要将权限变成 -rwxr-xr– 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。
　　　</p>
<h3 id="4-系统用户账号的管理"><a href="#4-系统用户账号的管理" class="headerlink" title="4.系统用户账号的管理"></a>4.系统用户账号的管理</h3><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<p><strong>1、用 useradd 命令添加新的用户账号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<ul>
<li>-c comment 指定一段注释性描述。    </li>
<li>-G 用户组，用户组 指定用户所属的附加组。   </li>
<li>-s Shell文件 指定用户的登录Shell。    </li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
<p>eg:</p>
<p>1) <code>useradd –d /usr/sam -m sam</code></p>
<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。</p>
<p>2) <code>useradd -s /bin/sh -g group –G adm,root gem</code></p>
<p>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。这里可能新建组：#groupadd group及groupadd adm<br>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p><strong>2、用 usermod 命令修改账号</strong></p>
<p>修可根据实际情况修改用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>eg: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam</span><br></pre></td></tr></table></figure>
<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<p><strong>3、用 userdel  命令删除帐号</strong></p>
<p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。常用的选项是-r，它的作用是把用户的主目录一起删除。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel sam</span><br></pre></td></tr></table></figure>

<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<p>4、用 passwd 命令管理用户口令</p>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。  </li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>eg:<br>1）当前普通用户修改该用户自己的口令：<br>$ passwd<br>Old password:<strong>**</strong><br>New password:<strong>***</strong><br>Re-enter new password:<strong>***</strong></p>
<p>2）超级用户，可以用下列形式指定任何用户的口令：<br> passwd sam<br>New password:<strong>***</strong><br>Re-enter new password:<strong>***</strong></p>
<p>3）删除口令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd -d sam</span><br></pre></td></tr></table></figure>

<p>注：系删除口令后，下次登录统就不再询问口令。</p>
<p>4）锁定某一用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd -l sam</span><br></pre></td></tr></table></figure>

<p>注：被锁定的用户无法登录</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 5 ：Java的反射机制</title>
    <url>/2018/07/16/jvm-java-reflection/</url>
    <content><![CDATA[<h2 id="一、什么是反射"><a href="#一、什么是反射" class="headerlink" title="一、什么是反射"></a>一、什么是反射</h2><p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息，以及动态调用对象的方法的功能来自于Java语言的反射（Reflection）机制。</p>
<a id="more"></a>

<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中：</p>
<ul>
<li>Class类： 代表一个类；</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）；</li>
<li>Method类：代表类的方法；</li>
<li>Constructor类：代表类的构造方法；</li>
<li>Array类：提供了动态创建数组，以及访问数组元素的静态方法。</li>
</ul>
<h2 id="二、java反射的作用-应用"><a href="#二、java反射的作用-应用" class="headerlink" title="二、java反射的作用(应用)"></a>二、java反射的作用(应用)</h2><blockquote>
<p>Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc. at compile time. It is also possible to instantiate new objects, invoke methods and get/set field values using reflection.</p>
</blockquote>
<p><strong>上面几句话概括了java反射机制的2个核心作用：</strong><br>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)动态获取类，接口，变量以及方法等信息。反射机制还可以让我们在运行期实例化对象，动态调用对象的方法。下面详细写下java机制的这2个核心作用。</p>
<h3 id="1、获取程序在运行时刻的内部结构（动态获取类的信息）"><a href="#1、获取程序在运行时刻的内部结构（动态获取类的信息）" class="headerlink" title="1、获取程序在运行时刻的内部结构（动态获取类的信息）"></a>1、获取程序在运行时刻的内部结构（动态获取类的信息）</h3><p>Java 反射的第一个主要作用是获取程序在运行时刻的内部结构。这对于程序的检查工具和调试器来说，是非常实用的功能。只需要短短的十几行代码，就可以遍历出来一个Java类的内部结构，包括其中的构造方法、声明的域和定义的方法等。</p>
<p>以下例子用反射获取类的对象，然后通过这个对象获取这个类的所有 public 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Method[] methods = ReflectionDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line"></span><br><span class="line">		    System.out.println(<span class="string">"method = "</span> + method.getName());</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070901.png" alt=""></p>
<h3 id="2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）"><a href="#2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）" class="headerlink" title="2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）"></a>2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）</h3><p>java反射的另外一个作用是在运行时刻对一个Java对象进行操作。这些操作包括动态创建一个Java类的对象，获取某个域的值以及调用某个方法。在Java源代码中编写的对类和对象的操作，都可以在运行时刻通过反射API来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length;  <span class="comment">//长</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;   <span class="comment">//宽</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取对象调用方法的传统写法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Rectangle rectangle0 = 	<span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">		System.out.println(<span class="string">"长方形rectangle0的面积是："</span>+rectangle0.getArea());</span><br><span class="line">		</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 通过java反射动态调用对象的写法</span></span><br><span class="line"><span class="comment">	         */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;			</span><br><span class="line">		    Constructor constructor = Rectangle<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; <span class="comment">//获取构造方法</span></span><br><span class="line">		    Rectangle rectangle1 = (Rectangle) constructor.newInstance(<span class="number">4</span>,<span class="number">5</span>);                <span class="comment">//创建对象</span></span><br><span class="line">		    Method method = Rectangle.class.getMethod("getArea");                           //获取方法</span><br><span class="line">		    System.out.println(<span class="string">"长方形rectangle1的面积是："</span>+method.invoke(rectangle1));      <span class="comment">//调用方法</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">		    e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070902.png" alt=""></p>
<h2 id="三、java反射机制的详细用法"><a href="#三、java反射机制的详细用法" class="headerlink" title="三、java反射机制的详细用法"></a>三、java反射机制的详细用法</h2><p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中。</p>
<ul>
<li>Class类： 代表一个类。</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
<li>Array类：提供了动态创建数组，以及访问数组元素的静态方法。</li>
</ul>
<h3 id="1-Java反射-Classes"><a href="#1-Java反射-Classes" class="headerlink" title="1.Java反射-Classes"></a>1.Java反射-Classes</h3><table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>1) public String getName()</td>
<td>返回含包名的完整类名</td>
</tr>
<tr>
<td>3) public static Class forName(String className)throws ClassNotFoundException</td>
<td>加载类并返回Class对象</td>
</tr>
<tr>
<td>4) public Object newInstance()throws InstantiationException,IllegalAccessException</td>
<td>创建实例对象</td>
</tr>
<tr>
<td>5) public Class getSuperclass()</td>
<td>返回父类Class引用</td>
</tr>
<tr>
<td>6) public Field[] getFields()throws SecurityException</td>
<td>获取类的public类型的属性</td>
</tr>
<tr>
<td>7) public Field[] getDeclaredFields()throws SecurityException</td>
<td>获取类的所有属性</td>
</tr>
<tr>
<td>8) public Method[] getMethods()throws SecurityException</td>
<td>获取类的public类型的方法</td>
</tr>
<tr>
<td>9) public Method[] getDeclaredMethods()</td>
<td>获取类的所有类型的方法</td>
</tr>
<tr>
<td>10) public Method getDeclaredMethod(String name,Class[] parameterTypes)throws NoSuchMethodException,SecurityException</td>
<td>返回类中指定参数类型的方法</td>
</tr>
<tr>
<td>12) public Constructor[] getDeclaredConstructors()throws SecurityException</td>
<td>获取类的构造方法数组</td>
</tr>
<tr>
<td>13) getDeclaredConstructor(Class[] parameterTypes)</td>
<td>获取类的特定构造方法，parameterTypes参数指定构造方法的参数类型</td>
</tr>
<tr>
<td>14) public boolean isInterface()</td>
<td>判断是否是接口</td>
</tr>
<tr>
<td>15) public boolean isArray()</td>
<td>判断是否是数组</td>
</tr>
<tr>
<td>16) public boolean isPrimitive()</td>
<td>判断是否是原始数据类型</td>
</tr>
</tbody></table>
<p>以下是根据 API 中的一些方法获取类信息的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取类</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Class class1 = MainText<span class="class">.<span class="keyword">class</span></span>;	</span><br><span class="line">		Class class2 = Class.forName(<span class="string">"reflection.Rectangle"</span>);</span><br><span class="line">		System.out.println(class2.getName());</span><br><span class="line">		System.out.println(class2.getSimpleName());</span><br><span class="line">				</span><br><span class="line">		Package pack = class2.getPackage();     <span class="comment">//获取包</span></span><br><span class="line">		Field[] field = class2.getFields(); 	<span class="comment">//获取字段</span></span><br><span class="line">		Method[] method = class2.getMethods();  <span class="comment">//获取方法</span></span><br><span class="line">		Annotation[] annotations = class2.getAnnotations(); <span class="comment">//获取注解</span></span><br><span class="line">		Constructor[] constructors = class2.getConstructors(); <span class="comment">//获取构造器	</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取修饰符并判断类型</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> modifiers = class2.getModifiers();</span><br><span class="line">		<span class="comment">//判断的值为 true or false</span></span><br><span class="line">		Modifier.isAbstract(modifiers);</span><br><span class="line">		Modifier.isFinal(modifiers);</span><br><span class="line">		Modifier.isInterface(modifiers);</span><br><span class="line">		Modifier.isNative(modifiers);</span><br><span class="line">		Modifier.isPrivate(modifiers);</span><br><span class="line">		Modifier.isProtected(modifiers);</span><br><span class="line">		Modifier.isPublic(modifiers);</span><br><span class="line">		Modifier.isStatic(modifiers);</span><br><span class="line">		Modifier.isStrict(modifiers);</span><br><span class="line">		Modifier.isSynchronized(modifiers);</span><br><span class="line">		Modifier.isTransient(modifiers);</span><br><span class="line">		Modifier.isVolatile(modifiers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Java反射-Fields"><a href="#2-Java反射-Fields" class="headerlink" title="2.Java反射-Fields"></a>2.Java反射-Fields</h3><p>通过使用 java.lang.reflect.Field , 可以在运行期访问或者改变类成员变量的值。</p>
<p>下面以一个简单的例子演示下获取Field的值与改变Field的值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">private</span> <span class="keyword">int</span> x;      </span><br><span class="line">	  <span class="keyword">public</span> <span class="keyword">int</span> y;    </span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   	  </span><br><span class="line">		  <span class="keyword">super</span>();          </span><br><span class="line">		  <span class="keyword">this</span>.x = x;          </span><br><span class="line">		  <span class="keyword">this</span>.y = y; </span><br><span class="line">	  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取变量信息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Point instanceObj = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">		Class class1 = instanceObj.getClass();	</span><br><span class="line">		Field[] field1 = class1.getFields();      <span class="comment">//获取Field 列表</span></span><br><span class="line">		Field field2 = class1.getField(<span class="string">"y"</span>);      <span class="comment">//获取指定Field</span></span><br><span class="line">		String fieldName = field2.getName();      <span class="comment">//获取变量名</span></span><br><span class="line">		Object fieldType = field2.getType();      <span class="comment">//获取变量类型</span></span><br><span class="line">		<span class="keyword">int</span> a = field2.getModifiers();            <span class="comment">//获取修饰符</span></span><br><span class="line">		Modifier.isAbstract(a);                   <span class="comment">//判断是否含某修饰符       </span></span><br><span class="line">		System.out.println(field2.get(instanceObj));      <span class="comment">//获取对象对应的Field值</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 改变变量的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		field2.set(instanceObj, <span class="number">6</span>);                    <span class="comment">//改变Field的值 </span></span><br><span class="line">		System.out.println(field2.get(instanceObj));   <span class="comment">//输出改变后的值</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面一个例子是网上一个比较有趣的例子，主要体现了使用Field时一些需要特别注意的地方，摘于<a href="http://www.360doc.com/content/17/0820/17/46591991_680655030.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0820/17/46591991_680655030.shtml</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">private</span> <span class="keyword">int</span> x;      </span><br><span class="line">	  <span class="keyword">public</span> <span class="keyword">int</span> y;    </span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   	  </span><br><span class="line">		  <span class="keyword">super</span>();          </span><br><span class="line">		  <span class="keyword">this</span>.x = x;          </span><br><span class="line">		  <span class="keyword">this</span>.y = y; </span><br><span class="line">	  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里说的Field都是 类 身上的，不是实例上的  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        Point pt1 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//得到一个字段  </span></span><br><span class="line">        Field fieldY = pt1.getClass().getField(<span class="string">"y"</span>); <span class="comment">//y 是变量名  </span></span><br><span class="line">        <span class="comment">//fieldY的值是5么？？ 大错特错  </span></span><br><span class="line">        <span class="comment">//fieldY和pt1根本没有什么关系，你看，是pt1.getClass()，是 字节码 啊  </span></span><br><span class="line">        <span class="comment">//不是pt1对象身上的变量，而是类上的，要用它取某个对象上对应的值  </span></span><br><span class="line">        <span class="comment">//要这样  </span></span><br><span class="line">        System.out.println(fieldY.get(pt1)); <span class="comment">//这才是5  </span></span><br><span class="line">        <span class="comment">//现在要x了    </span></span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        Field fieldX = pt1.getClass().getField("x"); //x 是变量名 </span></span><br><span class="line"><span class="comment">        System.out.println(fieldX.get(pt1));  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//运行 报错 私有的，找不到  </span></span><br><span class="line">        <span class="comment">//NoSuchFieldException  </span></span><br><span class="line">        <span class="comment">//说明getField 只可以得到 公有的  </span></span><br><span class="line">        <span class="comment">//怎么得到私有的呢？？  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        //这个管你公的私的，都拿来 </span></span><br><span class="line"><span class="comment">        Field fieldX = pt1.getClass().getDeclaredField("x");</span></span><br><span class="line"><span class="comment">        //然后轮到这里错了 </span></span><br><span class="line"><span class="comment">        // java.lang.IllegalAccessException: </span></span><br><span class="line"><span class="comment">        //Class com.ncs.ReflectTest can not access a member of class com.ncs.Point with modifiers "private" </span></span><br><span class="line"><span class="comment">        System.out.println(fieldX.get(pt1)); </span></span><br><span class="line"><span class="comment">        */</span>           </span><br><span class="line">        <span class="comment">//三步曲 一是不让你知道我有钱 二是把钱晃一下，不给用  三是暴力抢了  </span></span><br><span class="line">        <span class="comment">//暴力反射    </span></span><br><span class="line">        Field fieldX = pt1.getClass().getDeclaredField(<span class="string">"x"</span>); <span class="comment">//这个管你公的私的，都拿来  </span></span><br><span class="line">        fieldX.setAccessible(<span class="keyword">true</span>);<span class="comment">//上面的代码已经看见钱了，开始抢了  </span></span><br><span class="line">        System.out.println(fieldX.get(pt1));             </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070903.png" alt=""></p>
<p><strong>关于 Field 的用法需要特别注意的是下表的区别：</strong></p>
<p><img src="/images/2018070904.png" alt=""></p>
<ol>
<li>getField()、getFields() 方法能获得的是 public 的字段，包括父类中的字段；</li>
<li>geDeclaredField()、geDeclaredFields() 获取的包括 public、private 和 proteced 的字段，但是不包括父类的申明字段。</li>
</ol>
<h3 id="3-Java反射-Method"><a href="#3-Java反射-Method" class="headerlink" title="3.Java反射-Method"></a>3.Java反射-Method</h3><p>通过使用 java.lang.reflect.Method, 可以在运行期动态调用对象的方法。</p>
<p>下面写个小 demo 演示下在运行期动态调用有参方法还有无参方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length;  <span class="comment">//长</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;   <span class="comment">//宽</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Rectangle instanceObj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">		Class class1 = instanceObj.getClass();	</span><br><span class="line">		Method method[] = class1.getMethods();              <span class="comment">//获取所有 public 方法        		</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用无参方法</span></span><br><span class="line"><span class="comment">		 * 目标方法没有参数，那么在调用getMethod()方法时第二个参数传入null即可</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method method1 = class1.getMethod(<span class="string">"getArea"</span>, <span class="keyword">null</span>); <span class="comment">//获取指定的无参方法</span></span><br><span class="line">			System.out.println(method1);</span><br><span class="line">			System.out.println(method1.invoke(instanceObj, <span class="keyword">null</span>));</span><br><span class="line">		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) &#123;			</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用带参数的方法</span></span><br><span class="line"><span class="comment">		 * 目标方法有参数，那么在调用getMethod()方法时需要用new Class[]&#123;&#125; 参数对应的参数类型</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method method2 = class1.getMethod(<span class="string">"getArea"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>&#125;)</span>;  <span class="comment">//获取指定的带参数的方法</span></span><br><span class="line">			System.out.println(method2);</span><br><span class="line">			System.out.println(method2.invoke(instanceObj, <span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) &#123;				</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070905.png" alt=""></p>
<p><strong>关于Method.invoke()方法需要特别注意2点：</strong></p>
<ol>
<li><p>如果是一个静态方法调用的话则可以用null代替指定对象作为invoke()的参数，如果调用的方法不是静态方法，就要传入有效的对象实例而不是null。</p>
</li>
<li><p>Method.invoke(Object target, Object … parameters) 的第二个参数是一个可变参数列表，必须要传入与你要调用方法的形参一一对应的实参，否则会抛出 java.lang.IllegalArgumentException:  异常。</p>
</li>
</ol>
<h3 id="4-Java反射-Annotation"><a href="#4-Java反射-Annotation" class="headerlink" title="4.Java反射-Annotation"></a>4.Java反射-Annotation</h3><p>利用Java反射机制可以在运行期获取Java类的注解信息，包括以下:</p>
<ul>
<li>类注解</li>
<li>方法注解</li>
<li>参数注解</li>
<li>变量注解</li>
</ul>
<p>下面通过一个例子演示一下类注解的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(name=<span class="string">"Java Reflection"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Class class1 = MyObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Annotation[] annotations = class1.getAnnotations();  <span class="comment">//获取类的注解</span></span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">			<span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyAnnotation) &#123;</span><br><span class="line">				MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">				System.out.println(<span class="string">"name:"</span> + myAnnotation.name());</span><br><span class="line">				System.out.println(<span class="string">"value:"</span> + myAnnotation.value());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
下面再通过一个例子演示一下方法注解的用法：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@MyAnnotation</span>(name=<span class="string">"Java Reflection"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		Class class1 = MyObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Method method = class1.getMethod(<span class="string">"doSomething"</span>, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		Annotation[] annotations = method.getAnnotations();  <span class="comment">//获取类的注解</span></span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">			<span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyAnnotation) &#123;</span><br><span class="line">				MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">				System.out.println(<span class="string">"name:"</span> + myAnnotation.name());</span><br><span class="line">				System.out.println(<span class="string">"value:"</span> + myAnnotation.value());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下2点：</p>
<ol>
<li><p>@Retention(RetentionPolicy.RUNTIME)表示这个注解可以在运行期通过反射访问。如果没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。</p>
</li>
<li><p>@Target(ElementType.TYPE) 表示这个注解只能用在类型上面（比如类跟接口），同样可以把TYPE改为FIELD或者METHOD，或者不用这个指定，那么，这个注解就在类、方法和变量上就都可以使用。</p>
</li>
</ol>
<h2 id="四、反射的适用场景及优缺点"><a href="#四、反射的适用场景及优缺点" class="headerlink" title="四、反射的适用场景及优缺点"></a>四、反射的适用场景及优缺点</h2><h3 id="反射的适用场景"><a href="#反射的适用场景" class="headerlink" title="反射的适用场景"></a>反射的适用场景</h3><blockquote>
<p>Java Reflection is quite powerful and can be very useful. For instance, Java Reflection can be used to map properties in JSON files to getter / setter methods in Java objects, like Jackson, GSON, Boon etc.does. Or, Reflection can be used to map the column names of a JDBC ResultSet to getter / setter methods in a Java object.</p>
</blockquote>
<p>Java反射机制功能强大而且非常实用，举个例子，比如 jackson，Gson ，利用 java 反射 可以把JSON 中的属性 映射到 java 实体对象 的   getter / setter 方法上。比如Hibernate通过java 反射还可以把数据库中的列字段映射到java实体对象的 getter / setter 方法上。（把从数据库查询的结果记录映射到对应的实体类）</p>
<p><strong>反射主要用在以下地方：</strong></p>
<p><strong>1. 用于开发灵活可配置的基础框架</strong><br>反射机制是很多Java框架的基石，而一般应用层面很少用。典型的如 Hibernate、Spring中也用到很多反射机制。最经典的就是在xml文件或者properties里面写好了配置，然后在Java类里面解析xml或properties里面的内容，得到一个字符串，然后用反射机制，根据这个字符串获得某个类的Class实例，这样就可以动态配置一些东西，不用每一次都要在代码里面去new或者做其他的事情，以后要改的话直接改配置文件，代码维护起来就很方便了。</p>
<p><strong>2. 插件化支持</strong><br>因为一开始还不能确定插件的类型还有名称，所以无法初始化，需要在程序运行过程中，获取到插件的信息，然后再通过反射实例化对象并完成后续的动态调用。</p>
<p><strong>3.在编码阶段还不能确定类名，</strong>类名需要从配置或者其他地方读取过来，这时候就没有办法硬编码new ClassName(),而必须用到反射才能创建这个对象。</p>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p><strong>优点：</strong><br>可以在运行期获取类信息、实例化对象、动态调用方法，修改程序行为，利用这些特性可以设计出灵活和拓展性更好的程序。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>使用反射的性能较低，jvm 需要做额外的检查校验，并且可能会导致JVM无法优化代码;</li>
<li>使用反射相对来说不安全，写法也更复杂，更容易出错，运行期的BUG比编译期的BUG更不容易被发现；</li>
<li>破坏了类的封装性，可以通过反射获取这个类的私，有方法和属性，</li>
</ol>
<h3 id="怎么考虑是否使用反射"><a href="#怎么考虑是否使用反射" class="headerlink" title="怎么考虑是否使用反射"></a>怎么考虑是否使用反射</h3><p><strong>在业务场景中，如果非必须，则不直接使用java的反射。</strong></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p><a href="http://ifeve.com/java-reflection/" target="_blank" rel="noopener">http://ifeve.com/java-reflection/</a><br><a href="https://www.javatpoint.com/java-reflection" target="_blank" rel="noopener">https://www.javatpoint.com/java-reflection</a><br><a href="http://www.360doc.com/content/11/1231/14/1954236_176297236.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/1231/14/1954236_176297236.shtml</a><br><a href="https://blog.csdn.net/tjpu_lin/article/details/23557443" target="_blank" rel="noopener">https://blog.csdn.net/tjpu_lin/article/details/23557443</a><br><a href="https://blog.csdn.net/zolalad/article/details/29370565" target="_blank" rel="noopener">https://blog.csdn.net/zolalad/article/details/29370565</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>反射机制</tag>
        <tag>java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven初识</title>
    <url>/2017/01/25/maven/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h2><p>Maven 的主要目的是为开发者提供<br>  ● 一个可复用、可维护、更易理解的工程综合模型<br>  ● 与这个模型交互的插件或者工具</p>
<p>Maven 能够帮助开发者完成以下工作：<br>  ● 构建<br>  ● 文档生成<br>  ● 报告<br>  ● 依赖<br>  ● SCMs<br>  ● 发布<br>  ● 分发<br>  ● 邮件列表</p>
<p>Maven 工程结构和内容被定义在一个 xml 文件中 － pom.xml，是 Project Object Model (POM) 的简称，此文件是整个 Maven 系统的基础组件</p>
<a id="more"></a>



<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h2><p><a href="http://wiki.jikexueyuan.com/project/maven/environment-setup.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/maven/environment-setup.html</a></p>
<h2 id="三、POM"><a href="#三、POM" class="headerlink" title="三、POM"></a><strong>三、POM</strong></h2><p>POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。</p>
<p>在创建 POM 之前，我们首先确定工程组（groupId），及其名称（artifactId）和版本，在仓库中这些属性是工程的唯一标识。这些可以在仓库repository中查看到相关信息</p>
<p><img src="http://img.blog.csdn.net/20170125110747398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>下面以java EE的常见 pom.xml为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 集中定义依赖版本号 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.4<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper.version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">mapper.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commons-io.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">commons-io.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">redis.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">redis.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-data-redis.version</span>&gt;</span>1.7.5.RELEASE<span class="tag">&lt;/<span class="name">spring-data-redis.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jxls-core.version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">jxls-core.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">poi.version</span>&gt;</span>3.15<span class="tag">&lt;/<span class="name">poi.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mchange-commons-java.version</span>&gt;</span>0.2.12<span class="tag">&lt;/<span class="name">mchange-commons-java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>4.3.9.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">quartz.version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">quartz.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fastjson.version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">fastjson.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jsp-api.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">jsp-api.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p6spy.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">p6spy.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- api --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Jackson Json处理工具包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 通用Mapper --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.abel533<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- apache-velocity --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--c3p0工具包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mchange-commons-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mchange-commons-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Apache工具组件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-io.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- POI --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-scratchpad<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- jslx --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.jxls<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxls-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jxls-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- jxl --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.jexcelapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- quartz --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;quartz.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>opensymphony<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- hibernate --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;p6spy.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">&lt;!-- ehcache --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>14.0.2.0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-data-redis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- dubbox使用jar --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.2-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jline<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jline<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.94<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/joda-time/joda-time --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jstl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jsp-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">directory</span>&gt;</span>resource<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">warSourceDirectory</span>&gt;</span>WebRoot<span class="tag">&lt;/<span class="name">warSourceDirectory</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="三、仓库："><a href="#三、仓库：" class="headerlink" title="三、仓库："></a><strong>三、仓库：</strong></h2><p><strong>1) 本地仓库</strong><br>Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。<br>Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。</p>
<p>可以在maven安装地址的conf/settings.xml 指定本地仓库的路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/myLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2）中央仓库</strong><br><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><br><a href="https://search.maven.org/" target="_blank" rel="noopener">https://search.maven.org/</a></p>
<p><strong>3)远程仓库</strong><br>可以在私有服务器上搭建自己的maven仓库，外网的内网的都可以。eg:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.176.234/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Maven 依赖搜索顺序<br>步骤1：在本地仓库找<br>步骤2：若本地仓库没找到则去中央仓库找，找到则下载到本地仓库，留着日后备用<br>步骤3：若中央仓库没找到，则会检查时候有设置远程仓库，若有，则会在远程仓库中查找并下载到本地仓库备用。若没设置远程仓库或者在远程仓库中也无法找到，则会抛出错误(无法找到依赖的文件)</p>
<p><img src="http://img.blog.csdn.net/20170125110520928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> <strong>针对这种情况，可以通过构建外部依赖的方法解决。</strong></p>
<br>

<h2 id="四、构建外部依赖"><a href="#四、构建外部依赖" class="headerlink" title="四、构建外部依赖"></a><strong>四、构建外部依赖</strong></h2><p>把jar包文件并放到工程lib下，然后在pom.xml中添加依赖，eg:</p>
<p><img src="http://img.blog.csdn.net/20170125110843211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.bank<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumerBanking<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumerBanking<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="五、依赖管理-Maven的核心特点之一"><a href="#五、依赖管理-Maven的核心特点之一" class="headerlink" title="五、依赖管理(Maven的核心特点之一)"></a><strong>五、依赖管理(Maven的核心特点之一)</strong></h2><p>当一个库 A 依赖于其他库 B. 另一工程 C 想要使用库 A, 那么该工程同样也需要使用到库 B。</p>
<p>使用maven，我们只需要在每个工程的 pom 文件里去定义直接的依赖关系。Maven 则会自动的来接管后续的工作。比如我们在pom.xml中定义了依赖jar包A，那么A所依赖的其他jar包，会被自动下载，不需要我们去定义。是不是很省事？</p>
<p>本文只是初步介绍了下maven 的使用，主要是在maven管理jar包，pom.xml文件的配置方面。还没涉及到maven在项目管理以及自动化构建方面。可参考下面链接拓展学习。</p>
<p><a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="noopener">Apache Maven 入门篇</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/maven/build-automation.html" target="_blank" rel="noopener">Maven - 构建自动化</a></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 4：Redis 集群的搭建与运维</title>
    <url>/2018/08/24/redis-cluster-setup-and-operation/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>集群的搭建可以分为以节点准备、节点握手、分配槽三个步骤。</p>
<h3 id="节点准备"><a href="#节点准备" class="headerlink" title="节点准备"></a>节点准备</h3><p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让 Redis 运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下。</p>
<a id="more"></a>


<h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信，达到感知对方的过程。<br>我们只需要在集群内任意节点上执行 cluster meet 命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6381</span><br></pre></td></tr></table></figure>

<h3 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h3><p>Redis集群把所有的数据映射到16384个槽中。每个 key 会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5641&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二、用-redis-trib-rb-搭建集群"><a href="#二、用-redis-trib-rb-搭建集群" class="headerlink" title="二、用 redis-trib.rb 搭建集群"></a>二、用 redis-trib.rb 搭建集群</h2><p>虽然手动搭建集群可以让我们了解集群建立的流程和细节，单当节点多时，手动搭建比较繁琐，并且容易出错，所以生产环境推荐使用 redis-trib.rb 集群管理工具进行搭建。 redis-trib.rb 提供了集群的创建、检查、修复、均衡等命令行工具，输入 redis-trib.rb 命令可以查看到具体的参数用法。</p>
<p>这里用3台机器，每个机器上安装4个节点，总共12个节点，按1主1从组成集群。</p>
<table>
<thead>
<tr>
<th align="center">服务器</th>
<th align="center">节点实例端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.2.8.94</td>
<td align="center">7000,7001,7002,7003</td>
</tr>
<tr>
<td align="center">10.2.8.95</td>
<td align="center">7004,7005,7006,7007</td>
</tr>
<tr>
<td align="center">10.2.8.96</td>
<td align="center">7008,7009,7010,7011</td>
</tr>
</tbody></table>
<p><strong>准备节点</strong></p>
<p>下面以一台服务器为例，安装4个节点，其余2台机器也采用同样的方式进行安装。</p>
<h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>


<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#service iptables stop #关闭防火墙</span><br><span class="line">#service iptables status #查看状态</span><br></pre></td></tr></table></figure>

<h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"># wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.3.tar.gz #下载安装包</span><br><span class="line"># tar -xf redis-3.2.3.tar.gz #解压安装包</span><br><span class="line"># ln -s redis-3.2.3 redis #建立软链接,方便以后升级维护</span><br><span class="line"># cd redis</span><br><span class="line"># make &amp;&amp; make install </span><br><span class="line"># cd src</span><br><span class="line"># .&#x2F;redis-cli -v #验证安装是否成功</span><br><span class="line"># export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure>
<p>这一步可以参考我的上一篇博客：<a href="https://crazyfzw.github.io/2018/08/10/Redis%20%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4%202%EF%BC%9ARedis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A-Redis-shell-%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Redis环境搭建及Redis shell的使用</a></p>
<h3 id="安装-redis-trib-rb-工具"><a href="#安装-redis-trib-rb-工具" class="headerlink" title="安装 redis-trib.rb 工具"></a>安装 redis-trib.rb 工具</h3><p>redis-trib.rb 是采用Ruby实现的Redis集群管理工具。内部通过Cluster相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用前需要安装Ruby环境。注意由于我们用redis-trib.rb 在一台服务器上就可以操作整个集群了，所以只需要挑选一台服务器安装既可，不需要每天服务器都安装。</p>
<h4 id="1）安装Ruby"><a href="#1）安装Ruby" class="headerlink" title="1）安装Ruby"></a>1）安装Ruby</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 local]# wget https:&#x2F;&#x2F;cache.ruby-lang.org&#x2F;pub&#x2F;ruby&#x2F;2.3&#x2F;ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# tar -xf ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# ln -s ruby-2.3.1 ruby</span><br><span class="line">[root@gdyt-wbredis01 local]# cd ruby</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;configure</span><br><span class="line">[root@gdyt-wbredis01 ruby]# make &amp;&amp; make install</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;ruby  -v</span><br><span class="line">ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-linux]</span><br><span class="line"></span><br><span class="line">[root@gdyt-wbredis01 ruby]# export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:&#x2F;usr&#x2F;local&#x2F;ruby:&#x2F;usr&#x2F;local&#x2F;ruby&#x2F;bin:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure>

<h4 id="2）安装-rubygem-redis-依赖。"><a href="#2）安装-rubygem-redis-依赖。" class="headerlink" title="2）安装 rubygem redis 依赖。"></a>2）安装 rubygem redis 依赖。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ruby]# gem sources --add https:&#x2F;&#x2F;ruby.taobao.org&#x2F; --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]#  gem sources -l</span><br><span class="line">https:&#x2F;&#x2F;ruby.taobao.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]# gem install redis</span><br></pre></td></tr></table></figure>
<p>安装好后执行 redis-trib.rb 命令确认是否安装成功。</p>
<p><img src="/images/2018082404.png" alt=""></p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="1）创建集群配置文件夹"><a href="#1）创建集群配置文件夹" class="headerlink" title="1）创建集群配置文件夹"></a>1）创建集群配置文件夹</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mkdir &#x2F;etc&#x2F;redis&#x2F;redis_cluster -p</span><br></pre></td></tr></table></figure>

<h4 id="2）创建多个实例目录"><a href="#2）创建多个实例目录" class="headerlink" title="2）创建多个实例目录"></a>2）创建多个实例目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 redis_cluster]# mkdir 7000 7001 7002 7003</span><br><span class="line">[root@gdyt-wbredis01 redis_cluster]# ls -l</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7000</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7001</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7002</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7003</span><br></pre></td></tr></table></figure>

<h4 id="3）-配置文件"><a href="#3）-配置文件" class="headerlink" title="3） 配置文件"></a>3） 配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7000&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7001&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7002&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 10.2.8.94 #绑定本机IP</span><br><span class="line">daemonize yes #后台运行</span><br><span class="line">pidfile  &#x2F;var&#x2F;run&#x2F;redis_7000.pid #PID文件</span><br><span class="line">port  7000 #监听端口</span><br><span class="line">cluster-enabled yes #开启集群</span><br><span class="line">cluster-config-file  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;nodes-7000.conf #实例节点配置</span><br><span class="line">cluster-node-timeout 5000 #集群通信超时</span><br><span class="line">appendonly yes #AOF日志开启写</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">cluster-require-full-coverage no #设置为no主节点故障时，不会影响其他节点的可用性</span><br></pre></td></tr></table></figure>


<h4 id="4）用配置文件启动各个节点"><a href="#4）用配置文件启动各个节点" class="headerlink" title="4）用配置文件启动各个节点"></a>4）用配置文件启动各个节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7004&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7005&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7006&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7007&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7008&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7009&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7010&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7011&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="5）配置集群-At-least-6-nodes-are-required-至少需要6个节点"><a href="#5）配置集群-At-least-6-nodes-are-required-至少需要6个节点" class="headerlink" title="5）配置集群(At least 6 nodes are required., 至少需要6个节点)"></a>5）配置集群(At least 6 nodes are required., 至少需要6个节点)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]#redis-trib.rb create  --replicas  1  10.2.8.94:7000  10.2.8.94:7001  10.2.8.94:7002  10.2.8.94:7003  10.2.8.95:7004  10.2.8.95:7005 10.2.8.95:7006 10.2.8.95:7007 10.2.8.96:7008 10.2.8.96:7009 10.2.8.96:7010 10.2.8.96:7011</span><br></pre></td></tr></table></figure>


<p><strong>其中 –replicas 后面的 数字 表示给每个主节点配备几个从节点，这里需要特别注意的是，redis-trib.rb会重新排序列表顺序，来确定主从角色，尽可能的保证主从节点不分配在统一机器下。</strong></p>
<p><img src="/images/2018082401.png" alt=""></p>
<p>可以用 redis-trib.rb 的 info 或 check 来查看或检查集群的信息</p>
<p><img src="/images/2018082402.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-trib.rb check 10.2.8.94:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.2.8.94:7001)</span><br><span class="line">S: 84923706efb5d77511707b8f74abd3f57d3c26a9 10.2.8.94:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b5819808aa06db5ada355e111dda2a129aa3597c</span><br><span class="line">M: 1c864de9ba655958f0ceae2363acfc298d5039e8 10.2.8.96:7009</span><br><span class="line">   slots:13653-16383 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 07a32cf512dd04a9ead49cc7dc1ce6c087c799a5 10.2.8.94:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8c141a332d7bc488ac9236a778791f6b80aec1e3</span><br><span class="line">M: 8c141a332d7bc488ac9236a778791f6b80aec1e3 10.2.8.95:7004</span><br><span class="line">   slots:2731-5460 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 4eeb5d5207f599a7469dd8f031517ae7b69be126 10.2.8.94:7003</span><br><span class="line">   slots:5461-8191 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3 10.2.8.95:7006</span><br><span class="line">   slots:0-2730 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 107fc0afc81a5c1c3a72e72dc0a9832bb543ed13 10.2.8.96:7011</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed</span><br><span class="line">S: 4ba0b34eb289ac7d5222e0e1f55a461ebdc97d66 10.2.8.94:7000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3</span><br><span class="line">M: 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed 10.2.8.95:7005</span><br><span class="line">   slots:10923-13652 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e33c091a22ba1963ad6f17ee4fb8b11b405e553d 10.2.8.96:7008</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 4eeb5d5207f599a7469dd8f031517ae7b69be126</span><br><span class="line">S: 306ac97503a76b662fe5a6515f699e8c47f9f219 10.2.8.95:7007</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1c864de9ba655958f0ceae2363acfc298d5039e8</span><br><span class="line">M: b5819808aa06db5ada355e111dda2a129aa3597c 10.2.8.96:7010</span><br><span class="line">   slots:8192-10922 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>



<h4 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h4><p>通过 -c 参数进入集群模式进行验证后， 在任意一台服务器连接任意实例端口操作数据，将会自动在片区进行操作。</p>
<p><img src="/images/2018082403.png" alt=""></p>
<p>至此，整个集群已经配置完成了。</p>
<h2 id="三、设置密码"><a href="#三、设置密码" class="headerlink" title="三、设置密码"></a>三、设置密码</h2><p>vi /etc/redis/redis_cluster/7000/redis.conf</p>
<p>在文件末尾加入。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth &quot;crazyfzw&quot;</span><br><span class="line">requirepass &quot;crazyfzw&quot;</span><br></pre></td></tr></table></figure>

<p>按照同样的方法给集群的所有节点设置相同的密码（一定要相同），然后通过配置文件重新启动所有服务就可以了。</p>
<p><strong>设置密码后的注意事项：</strong></p>
<p>需要注意的是设置密码后，执行 redis-cli 连接的时候需要一定要指定密码，否则无法执行任何命令，会报错(error) NOAUTH Authentication required.，如下图：</p>
<p><img src="/images/2018082405.png" alt=""></p>
<p>正确的操作应该这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -c -h 10.2.8.94 -p 7000 -a yourpass</span><br></pre></td></tr></table></figure>

<p>*<em>设置密码后 redis-trib.rb 工具将会无法使用，执行相关命令会报错： *</em></p>
<p><img src="/images/2018082406.png" alt=""></p>
<p>解决办法：修改 client.rb 的中的密码。（tip: 可以通过find命令找到文件所在的目录）</p>
<p><img src="/images/2018082407.png" alt=""></p>
<h2 id="四、优化系统"><a href="#四、优化系统" class="headerlink" title="四、优化系统"></a>四、优化系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">#TCP监听队列值</span><br><span class="line">net.core.somaxconn &#x3D; 2048</span><br><span class="line">#内存分配策略，选择1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何；</span><br><span class="line">#默认0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程</span><br><span class="line">vm.overcommit_memory &#x3D; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用配置生效</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Redis不使用透明大页</span><br><span class="line">#加入开机启动</span><br><span class="line"># vi  &#x2F;etc&#x2F;rc.local</span><br><span class="line">echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</span><br><span class="line">&#96;&#96;</span><br></pre></td></tr></table></figure>


<h2 id="五、创建方便运维的脚本"><a href="#五、创建方便运维的脚本" class="headerlink" title="五、创建方便运维的脚本"></a>五、创建方便运维的脚本</h2><p>一般我们出于对成本的考虑，我们会在一台服务器上装几个节点， 所以一旦集群出现故障，需要重启时，需要分别执行命令去启动几个节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<p>特别是生产故障时，这种做法非常不方便，所以可以自己写个 shell 脚本，<br>方便日后在一台机器上通过一个命令就可以管理这台机器上的所有节点。</p>
<p>编写脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 55 25</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Redis实例集群服务启动和停止脚本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">公共参数</span></span><br><span class="line">REDIS_BIN="/usr/local/redis/src/"</span><br><span class="line">LOCAL_IP=`ip addr | grep "inet" | grep  -v "inet6" | awk -F ' ' '&#123;print $2&#125;' | awk -F '/' '&#123;print $1&#125;' | grep -v "127.0.0.1"` #如果IP有多个,需要指定IP</span><br><span class="line">PORT_LIST="7000 7001 7002 7003" #端口需要根据实际情况定义,每个端口使用空格隔开</span><br><span class="line">CONFIG_DIR="/etc/redis/redis_cluster"</span><br><span class="line">PASSWORD="yourpassword"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">	if [ ! -f "$CONFIG_DIR/$port/redis.conf" ]</span><br><span class="line">	then</span><br><span class="line">		echo "$CONFIG_DIR/$port/redis.conf is not exist!"</span><br><span class="line">		exit 2</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH=$REDIS_BIN:$PATH</span><br><span class="line"></span><br><span class="line">function status()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		pid=`ps aux |  grep -v grep  | grep "redis-server $LOCAL_IP:$port" | awk -F ' ' '&#123;print $2&#125;'`</span><br><span class="line">		if [ ! -z "$pid" ]</span><br><span class="line">		then</span><br><span class="line">			echo "redis process [$pid] $LOCAL_IP:$port is run.."</span><br><span class="line">		else</span><br><span class="line">			echo "redis process [$pid] $LOCAL_IP:$port not run.."</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		redis-server $CONFIG_DIR/$port/redis.conf </span><br><span class="line">	done</span><br><span class="line">	status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		redis-cli -h $LOCAL_IP -p $port -a $PASSWORD shutdown</span><br><span class="line">	done	</span><br><span class="line">	status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">	start)</span><br><span class="line">		echo "start redis.."</span><br><span class="line">		start</span><br><span class="line">		;;</span><br><span class="line">	stop)</span><br><span class="line">		echo "stop redis.."</span><br><span class="line">		stop</span><br><span class="line">		;;</span><br><span class="line">	status)</span><br><span class="line">		echo "redis status.."</span><br><span class="line">		status</span><br><span class="line">		;;</span><br><span class="line">	restart)</span><br><span class="line">		echo "restart redis.."</span><br><span class="line">		echo "stop redis.."</span><br><span class="line">		stop</span><br><span class="line">		echo "start redis.."</span><br><span class="line">		start</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo $"Usage: $0 &#123;start|stop|status|restart&#125;"</span><br><span class="line">		exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<p>注册服务，并设置成开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 init.d]# ls -l &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">-rwxr-xr-x 1 root root 1506 8月  17 09:47 &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig --add redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig on redis-server</span><br></pre></td></tr></table></figure>


<p><strong>使用脚本进行启动，停止，重启 redis 服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server start #启动</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server status #状态</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server stop #停止</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server restart #重启</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018082408.png" alt=""></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 3：Redis 的Java 客户端 Jedis</title>
    <url>/2018/08/12/redis-java-client-Jedis/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Jedis 是 Redis 官方推荐的 Java 连接开发工具。Jedis 是一个非常小但又功能健全的 java 客户端。Jedis 是开源的，目前最新版本是 2.9.0 , 兼容 redis 2.8.x 和 3.x.x.版本，Github 地址： <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></p>
<a id="more"></a>

<p><strong>Jedis 提供了哪些支持？</strong></p>
<ul>
<li>排序</li>
<li>连接操作</li>
<li>支持 redis 所有 value 操作相关的命令</li>
<li>支持 redis 提供的五种数据结构及相关命令</li>
<li>事物 (Transactions)</li>
<li>Pipelining</li>
<li>发布/订阅 Publish/Subscribe</li>
<li>连接池 (Connection pooling)</li>
<li>分片 (Sharding )</li>
<li>Lua 脚本</li>
<li>集群 (Redis Cluster)</li>
<li>Persistence control commands</li>
<li>Remote server control commands</li>
</ul>
<h2 id="二、获取-Jedis"><a href="#二、获取-Jedis" class="headerlink" title="二、获取 Jedis"></a>二、获取 Jedis</h2><p>通过 maven 配置依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Jedis-直连-Redis"><a href="#三、Jedis-直连-Redis" class="headerlink" title="三、Jedis 直连 Redis"></a>三、Jedis 直连 Redis</h2><p>直连方式每次都会新建 TCP 连接，使用后再断开连接，对于频繁访问 Redis 的场景显然不是高效的使用方式。生产环境不推荐使用这种方式。</p>
<p><img src="/images/2018081301.png" alt=""></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//生成一个Jedis对象，这个对象负责和指定Redis实例进行通信</span></span><br><span class="line">    jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后通过 jedis 对象就可以调用 redis 支持的命令了，比如</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完之后关闭连接</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际项目推荐使用 try catch finally 的形式来进行代码的书写：一方面可以在 Jedis 出现异常的时候（本身是网络操作），将异常进行捕获或者抛出；另一个方面无论执行成功或者失败，将 Jedis 连接关闭掉。</p>
<p>创建 Jedis 时，还可以调用以下构造函数，指定 客户端连接超时时间、客户端读写超时时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> soTimeout);</span><br></pre></td></tr></table></figure>

<h2 id="四、Jedis-连接池方式"><a href="#四、Jedis-连接池方式" class="headerlink" title="四、Jedis 连接池方式"></a>四、Jedis 连接池方式</h2><p>所有Jedis对象预先放在池子中（JedisPool），每次要连接 Redis，只需要在池子中借，用完了在归还给连接池。生产环境一般都使用这种方式。</p>
<p><img src="/images/2018081302.png" alt=""></p>
<p>Jedis提供了 JedisPool 这个类作为对 Jedis 的连接，同时使用了 Apache 的通用对象池工具 common-pool2 作为资源的管理工具。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.common-pool2 连接池配置</span></span><br><span class="line">GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"><span class="comment">//可以根据需要设置相关属性</span></span><br><span class="line">poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">poolConfig.setMaxIdle(<span class="number">50</span>);</span><br><span class="line">poolConfig.setMinIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.初始化Jedis连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>



<p>此时，获取 Jedis 对象不再是直接生成一个 Jedis 对象进行直连，而是从连接池直接获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//从连接池借用 jedis 对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完后归还连接池</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong>以上代码有点需要注意的是：使用 JedisPool 的时候，jedis.close() 不是关闭连接，而是表示归还连接池。</p>
<p>看下 Jedis 对 close方法的实现就很清楚了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client.isBroken()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnBrokenResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Jedis 对于 close 的实现，会先通过 dataSource 是否为 null 判断是否是使用连接池，若是，则调用归还资源函数，否则才真正执行关闭连接的操作。</p>
<p><strong>GenericObjectPoolConfig 的重要属性如下图所示：</strong><br><img src="/images/2018081303.jpg" alt=""></p>
<h2 id="五、Jedis直连方式和连接池方式对比"><a href="#五、Jedis直连方式和连接池方式对比" class="headerlink" title="五、Jedis直连方式和连接池方式对比"></a>五、Jedis直连方式和连接池方式对比</h2><blockquote>
<p>You shouldn’t use the same instance from different threads because you’ll have strange errors. And sometimes creating lots of Jedis instances is not good enough because it means lots of sockets and connections, which leads to strange errors as well. A single Jedis instance is not threadsafe! To avoid these problems, you should use JedisPool, which is a threadsafe pool of network connections. You can use the pool to reliably create several Jedis instances, given you return the Jedis instance to the pool when done. This way you can overcome those strange errors and achieve great performance.</p>
</blockquote>
<p>单个Jedis对象是线程不安全的，我们不应该在多个线程中使用共用同一个Jedis对象，然而，如果通过直连方式创建多个Jedis对象，又意味着会创建大量的socket以及TCP连接，带来大量的开销。为了避免这个问题，Jedis 为我们提供了一个线程安全的线程池JedisPool，通过连接池的方式，可以预先可靠地创建好多个Jedis连接对象，然后每次需要的时候就从Jedis连接池借用，使用完之后归还即可。这种方式提供了更大的安全性以及灵活性，所以，生产环境推荐使用连接池方式。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直连</td>
<td align="center">简单方便，适用于少量长期连接的场景</td>
<td align="center">1）存在每次新建/关闭 TCP 连接开销<br/> 2）资源无法控制，可能会出现连接泄露  <br/> 3）Jedis对象线程不安全</td>
</tr>
<tr>
<td align="center">连接池</td>
<td align="center">1）无需每次连接都生成Jedis对象，降低开销<br/>2）使用连接池的方式控制和保护资源的使用</td>
<td align="center">相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规则不合理也会出现问题</td>
</tr>
</tbody></table>
<h2 id="六、Pipelining"><a href="#六、Pipelining" class="headerlink" title="六、Pipelining"></a>六、Pipelining</h2><blockquote>
<p>Sometimes you need to send a bunch of different commands. A very cool way to do that, and have better performance than doing it the naive way, is to use pipelining. This way you send commands without waiting for response, and you actually read the responses at the end, which is faster.</p>
</blockquote>
<p>Redis 支持 Pipelining 特性，Pipeline在某些场景下非常有用，比如有时想批量提交多个命令，而且他们对相应结果没有互相依赖，而且对结果响应也无需立即获得，那么久可以利用 Pipelining 实现这种批量处理，一次性发送多条命令并在执行完后一次性将结果返回。pipeline通过减少客户端与redis的通信次数来实现降低往返延时时间。过程大致如下：</p>
<p><img src="/images/2018081304.jpg" alt=""></p>
<p><strong>通过Jedis使用 Pipelining 的示例如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pipeline p = jedis.pipelined();</span><br><span class="line">p.set(<span class="string">"fool"</span>, <span class="string">"bar"</span>); </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">1</span>, <span class="string">"barowitch"</span>);  </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barinsky"</span>);</span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barikoviev"</span>);</span><br><span class="line">Response&lt;String&gt; pipeString = p.get(<span class="string">"fool"</span>);</span><br><span class="line">Response&lt;Set&lt;String&gt;&gt; sose = p.zrange(<span class="string">"foo"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">p.sync(); </span><br><span class="line"><span class="keyword">int</span> soseSize = sose.get().size();</span><br><span class="line">Set&lt;String&gt; setBack = sose.get();</span><br></pre></td></tr></table></figure>


<h2 id="七、发布-订阅（Publish-Subscribe）"><a href="#七、发布-订阅（Publish-Subscribe）" class="headerlink" title="七、发布/订阅（Publish/Subscribe）"></a>七、发布/订阅（Publish/Subscribe）</h2><p>Redis 通过 PUBLISH、SUBSCRIBE 等命令实现了订阅与发布模式，Redis 的 SUBSCRIBE 命令可以让客户端订阅任意数量的频道，每当有新信息 发布到被订阅的频道时， 信息就会被发送给所有订阅指定频道的客户端。</p>
<p>整个模型过程如下图所示：</p>
<p><img src="/images/2018081305.png" alt=""></p>
<p>上图展示了频道 channel1 ，以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系，当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端。</p>
<p><strong>使用场景：</strong></p>
<p>Publish/Subscribe 是目前广泛使用的通信模型，有很多的使用场景，比如内容订阅的的场；<br>；比如分布式架构中实现读写分离的场景，在写入的过程中，就可以使用redis发布订阅，使得写入值及时发布到各个读的程序中，保证数据的完整一致性。场景还有很多，有待挖掘。</p>
<p><strong>在 Jedis 使用 Publish/Subscribe 的示例，可以参考：</strong><a href="https://www.cnblogs.com/xinde123/p/8489054.html" target="_blank" rel="noopener">java实现 redis的发布订阅（简单易懂）</a></p>
<h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><p>[1] 《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://github.com/xetorthio/jedis/wiki/Getting-started" target="_blank" rel="noopener">Jedis WiKi</a><br>[3] <a href="https://xetorthio.github.io/jedis/" target="_blank" rel="noopener">Jedis API</a><br>[4] <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis 源码</a><br>[5] <a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html#id2" target="_blank" rel="noopener">订阅与发布</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 2：Java内存模型-主内存与工作内存的交互协议</title>
    <url>/2018/06/24/memory-model/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>1.为了解决物理内存读写速度慢，与处理器运算速度不匹配的问题，现代操作系统在处理器和物理内存之间加入了高速缓存：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，从而让处理器无需等待缓慢的内存读写。</p>
<p>这种基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也引发了一个新问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，这将可能导致不同处理器缓存的数据不一致的问题，这就需要一种协议来规范并保证内存与高速缓存之间的交互与访问操作。</p>
<a id="more"></a>


<p><img src="/images/2018062501.png" alt=""></p>
<p>2.计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令进行指令重排优化，在多线程环境中，程序的顺序性并不能靠代码的先后顺序来保证。这些重排优化可能会导致程序出现内存可见性问题。</p>
<p>3.并发编程下如何保证程序执行的原子性、可见性、有序性?</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store、write。除了 long 型字段和 double 型字段外，java 内存模型确保访问任意类型字段所对应的内存单元都是原子的。这包括引用其它对象的引用类型的字段。此外，volatile long 和 volatile double 也具有原子性 。（虽然 java 内存模型不保证 non-volatile long 和 non-volatile double 的原子性，但它们在某些场合也具有原子性。）(non-volatile long 在64位 JVM，OS，CPU 下具有原子性)</p>
<p>原子性可以确保获取到的结果值所对应的所有bit位，全部都是由单个线程写入，但不能确保你获得的是任意线程写入之后的最新值。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改后的最新值。对于串行程序来说，可见性是不存存进行操作后才写回到主内存中的，这就可能存在一个线程 A 修改了共享变量 i 的值，还未写回主内存时，另外一个线程 B 又对主内存中同一个共享变量 i 进行操作，但此时 A 线程工作内存中共享变量 i 对线程 B 来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外在多线程环境下，指令重排优化确实会导致程序乱序执行的问题，从而也就导致可见性问题。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。</p>
<h2 id="二、Java内存模型的目的（解决的问题"><a href="#二、Java内存模型的目的（解决的问题" class="headerlink" title="二、Java内存模型的目的（解决的问题)"></a>二、Java内存模型的目的（解决的问题)</h2><p>1.屏蔽各种硬件和操作系统的差异，以实现让 Java 程序在各平台下都能达到一致的访问效果。<br>2.定义程序中各个变量的访问规则，定义了在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。通过这些规则可以解决缓存一致性问题。<br>3.定义了一套规则帮助在并发过程中保证程序执行的 原子性、可见性、有序性这3个特性，帮助解决并发编程可能出现的线程安全问题。</p>
<h2 id="三、Java内存模型提供的解决方案"><a href="#三、Java内存模型提供的解决方案" class="headerlink" title="三、Java内存模型提供的解决方案"></a>三、Java内存模型提供的解决方案</h2><p>在 Java 内存模型中都提供一套解决方案供 Java 工程师在开发过程使用，如原子性问题，除了 JVM 自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用 synchronized 关键字或者重入锁(ReentrantLock)保证程序执行的原子性；而工作内存与主内存同步延迟现象导致的可见性问题，可以使用 synchronized 关键字或者 volatile 关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见；对于指令重排导致的可见性问题和有序性问题，则可以利用 volatile 关键字解决，因为 volatile 的另外一个作用就是禁止重排序优化；除了靠 sychronized 和 volatile 关键字来保证原子性、可见性以及有序性外，JMM 内部还定义一套 happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性，通过这个原则，可以判断数据是否存在竞争、线程是否安全。</p>
<h2 id="四、Java内存模型的包含了哪些内容"><a href="#四、Java内存模型的包含了哪些内容" class="headerlink" title="四、Java内存模型的包含了哪些内容"></a>四、Java内存模型的包含了哪些内容</h2><h3 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1.主内存与工作内存"></a>1.主内存与工作内存</h3><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（工作内存优先存储于寄存器和高速缓存中），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。</p>
<p><img src="/images/2018062502.png" alt=""></p>
<h3 id="2-主内存与工作内存间的交互协议"><a href="#2-主内存与工作内存间的交互协议" class="headerlink" title="2.主内存与工作内存间的交互协议"></a>2.主内存与工作内存间的交互协议</h3><p>*<em>Java内存模型定义了以下八种操作来完成：一个变量从主内存拷贝到工作内存、从工作内存同步到主内存之间的实现细节。<br>*</em></p>
<ul>
<li><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
</li>
<li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p>
</li>
<li><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p>
</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行（如：read a，read b，load b， load a 是允许的）。</p>
<p><strong>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</strong></p>
<ul>
<li><p>不允许 read 和 load、store 和 write 操作之一单独出现</p>
</li>
<li><p>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>
</li>
<li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，lock 和 unlock 必须成对出现。</p>
</li>
<li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</p>
</li>
<li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</p>
</li>
<li><p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</p>
</li>
</ul>
<h3 id="3-先行发生原则-happens-before"><a href="#3-先行发生原则-happens-before" class="headerlink" title="3.先行发生原则(happens-before)"></a>3.先行发生原则(happens-before)</h3><p>若在程序开发中，仅靠 sychronized 和 volatile 关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在 Java 内存模型中，还提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。</p>
<p>该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。按照官方的说法：</p>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。 要想保证操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在一个线程），那么在 A 和 B 之间必须满足 HB 原则，如果没有，将有可能导致重排序。 当缺少 HB 关系时，就可能出现重排序问题。</p>
<ul>
<li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
</li>
<li><p>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作(注意：必须是同一个锁才适用)<br>，在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行；</p>
</li>
<li><p>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
</li>
<li><p>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作；</p>
</li>
<li><p>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
</li>
<li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始；</p>
</li>
<li><p>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作A先行发生于操作 C；</p>
</li>
</ul>
<p>深刻的理解 happen-before，理解某些规则下上一个操作对下一个操作的有序性和操作结果的可见性。同时，通过灵活的使用传递性规则，再对规则进行组合，就可以在不使用 volatile 和 synchronized 的情况下载两个线程间实现变量共享。</p>
<h3 id="4-同步机制之voliate关键字"><a href="#4-同步机制之voliate关键字" class="headerlink" title="4.同步机制之voliate关键字"></a>4.同步机制之voliate关键字</h3><p><strong>volatile 是 Java 虚拟机提供的最轻量级的同步机制。volatile   关键字有如下两个作用:</strong></p>
<ul>
<li>被 volatile 修饰的变量对所有线程可见，当一条线程修改了一个被 volatile 变量的值，新值对于其他线程来说是可以立即得知的。</li>
<li>禁止指令重排序优化。</li>
</ul>
<p>那么 <strong>JMM 是如何保证  volatile 变量的可见性的？通过一下两点：</strong></p>
<ol>
<li><p>线程对 volatile 变量写入后，在执行后续的内存访问之前，线程必须把新值刷新到内存中。</p>
</li>
<li><p>每次使用 volatile 变量之前，都要从内存重新装载变量的值。</p>
</li>
</ol>
<p>正确使用 volatile 保证线程安全的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> isOnline;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUserOnline</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isOnline=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isOnline)&#123;</span><br><span class="line">          System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于对于 boolean 变量的操作属于原子性操作，因此可以通过使用 volatile 修饰，使用该变量对其他线程立即可见，从而达到线程安全的目的。</p>
<p>错误使用 volatile 的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是以上代码不是线程安全的，java里面运算并非原子操作，比如 i++，是分成取值，添加分布执行的，当在执行添加的时候可能其他线程已经改变了i的值，所以这种情况下是无法用 volatile 来保证线程的安全性的。</p>
<p><strong>使用 volatile 必须要满足以下条件：</strong></p>
<ul>
<li>对字段的写操作不依赖于当前值（即运算结果不依赖当前变量的值），或者确保只有单一线程会修改改变了的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束（即读取操作不依赖于其它非 volatile 字段的值）。</li>
</ul>
<p>下面再通过一个例子看下 volatile 在禁止指令重排序的作用</p>
<p>以下程序不是线程安全的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"x"</span>=x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>写两个线程，一个进行 write（叫 writer）,一个进行 read（叫 reader）,运行程序会发现输出 x 的值有时是100，有时却是0。因为在 writer 线程中，编译器可能会在 writer 线程中进行重排序写入操作，这就导致可能会出现 v= true 时，x 扔为0的情况。从而引起线程的不安全。 这种情况下用 volatile 修饰变量 v, 就可以禁止编译器进行指令重排序优化，这样 v=true,时，就可以确保 x=100 已经被执行， 从而保证了线程的安全性。</p>
<p><strong>volatile 的原理和实现机制</strong><br>在 x86处理器下通过工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作 CPU 会做什么事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java代码: instance &#x3D; new Singleton();  &#x2F;&#x2F;instance是volatile变量</span><br><span class="line">汇编代码: 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure>
<p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>（2）它会强制将对缓存的修改操作立即写入主内存；<br>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p>如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><strong>如何考虑选用 synchronized 还是 volatile</strong><br>大多数场景下 volatile 的总开销要比 synchronized  低 ，我们再 volatile  中选择的唯一判断依据就是 volatile 的语义能否满足使用场景的需求，即如果用 volatile  就能解决线程安全的问题，那就选用 volatile，否则才选用  synchronized 。需要注意的是，使用 volatile 的使用必须满足以下两个条件：</p>
<ul>
<li>对字段的写操作不依赖于当前值（即运算结果不依赖当前变量的值），或者确保只有单一线程会修改改变了的值，</li>
<li>变量不需要与其他的状态变量共同参与不变约束（即读取操作不依赖于其它非volatile字段的值）</li>
</ul>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明 第十二章<br><a href="http://ifeve.com/syn-jmm/" target="_blank" rel="noopener">同步和Java内存模型 </a><br><a href="http://ifeve.com/syn-jmm-pre/" target="_blank" rel="noopener">Java内存模型FAQ </a><br><a href="https://blog.csdn.net/javazejian/article/details/72772461#%E5%8F%AF%E8%A7%81%E6%80%A7" target="_blank" rel="noopener">全面理解Java内存模型(JMM)及volatile关键字</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>订阅 Redis 的 key 过期事件实现动态定时任务</title>
    <url>/2019/04/09/redis-keyspace-notifications/</url>
    <content><![CDATA[<h3 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a><a href="#一、需求" title="一、需求"></a>一、需求</h3><ol>
<li>设置了生存时间的Key，在过期时能不能有所提示？</li>
<li>如果能对过期Key有个监听，如何对过期Key进行一个回调处理？</li>
<li>如何使用 Redis 来实现定时任务？</li>
</ol>
<p>比如：</p>
<ul>
<li>处理订单过期自动取消，12306 购票系统超过30分钟没有成功支付的订单会被回收处理;</li>
<li>购买商品15天后默认好评；</li>
<li>外卖系统的送餐超时提醒；</li>
<li>客服与顾客聊天，客服超过多长时间没回复，系统给客服发一个提醒消息；<br>…</li>
</ul>
<a id="more"></a>

<p>这里的定时任务并不是  Crontab 这种如 <code>0 0 23 * * ?</code> (每日23点执行) 定死多长时间执行一次的， 而是某种特定动作触发创建的一个多长时间后执行的任务。比如有100个 用户触发了这个动作，那么就会创建100个定时任务，并且这100个任务由于触发创建的时间不同，执行的时间也很可能不在同一时间。</p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a><a href="#二、思路" title="二、思路"></a>二、思路</h3><p>在 Redis 的 2.8.0 版本之后，其推出了一个新的特性——键空间消息（Redis Keyspace Notifications），它配合 2.0.0 版本之后的 SUBSCRIBE 就能完成这个定时任务的操作了。</p>
<p><strong>Redis 的键空间通知支持  订阅指定 Key 的所有事件  与 订阅指定事件  两种方式。</strong></p>
<blockquote>
<p>Keyspace notifications are implemented sending two distinct type of events for every operation affecting the Redis data space. For instance a DEL operation targeting the key named mykey in database 0 will trigger the delivering of two messages, exactly equivalent to the following two PUBLISH commands:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH <strong>keyspace@0</strong>:mykey del</span><br><span class="line">PUBLISH <strong>keyevent@0</strong>:del mykey</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>通过 Redis 的键空间通知（keyspace notification）可以做到：下单时将订单 id 写入 redis，设置过期时间30分钟，利用 redis 键过期回调提醒，30分钟后可以在回调函数里检查订单状态，如果未支付，则进行处理。</strong></p>
<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a><a href="#三、实现" title="三、实现"></a>三、实现</h3><h4 id="1-修改-redis-conf-开启redis-key过期提醒"><a href="#1-修改-redis-conf-开启redis-key过期提醒" class="headerlink" title="1. 修改 redis.conf 开启redis key过期提醒"></a><a href="#1-修改-redis-conf-开启redis-key过期提醒" title="1. 修改 redis.conf 开启redis key过期提醒"></a>1. 修改 redis.conf 开启redis key过期提醒</h4><blockquote>
<p>By default keyspace events notifications are disabled because while not very sensible the feature uses some CPU power. Notifications are enabled using the notify-keyspace-events of redis.conf or via the CONFIG SET.</p>
</blockquote>
<p>由于键空间通知比较耗CPU, 所以 Redis默认是关闭键空间事件通知的， 需要手动开启 notify-keyspace-events 后才启作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line">K：keyspace事件，事件以__keyspace@&lt;db&gt;__为前缀进行发布；        </span>
<span class="line">E：keyevent事件，事件以__keyevent@&lt;db&gt;__为前缀进行发布；        </span>
<span class="line">g：一般性的，非特定类型的命令，比如del，expire，rename等；       </span>
<span class="line">$：String 特定命令；        </span>
<span class="line">l：List 特定命令；        </span>
<span class="line">s：Set 特定命令；        </span>
<span class="line">h：Hash 特定命令；        </span>
<span class="line">z：Sorted 特定命令；        </span>
<span class="line">x：过期事件，当某个键过期并删除时会产生该事件；        </span>
<span class="line">e：驱逐事件，当某个键因maxmemore策略而被删除时，产生该事件；        </span>
<span class="line">A：g$lshzxe的别名，因此”AKE”意味着所有事件。</span>
</pre></td></tr></table></figure>

<p><strong><code>notify-keyspace-events Ex</code> 表示开启键过期事件提醒</strong></p>
<h4 id="2-继承-JedisPubSub-实现一个消息监听器类"><a href="#2-继承-JedisPubSub-实现一个消息监听器类" class="headerlink" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a><a href="#2-继承-JedisPubSub-实现一个消息监听器类" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a>2. 继承 JedisPubSub 实现一个消息监听器类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span>
<span class="line">    </span>
<span class="line">       <span class="comment">//message.toString()可以获取失效的key</span></span>
<span class="line">      String expiredKey = message.toString();</span>
<span class="line">      <span class="keyword">if</span>(expiredKey.startsWith(<span class="string">"key:prefix"</span>))&#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * TODO</span></span>
<span class="line"><span class="comment">             * 如果是自己想要监控的KEY, 则可以在这里处理业务</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>由于每个key过期都会回调 onPMessage 方法， 所以不建议在 onPMessage  回调方法中直接处理业务， 这里可以通过 MQ 来做缓冲，在 onPMessage 中 把消息直接扔到 MQ 里， 然后再去监听队列消费消息处理具体的业务。</strong></p>
<p>改进版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Resource</span></span>
<span class="line">    <span class="keyword">private</span> ICommonsMqService commonsMqService;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        <span class="keyword">try</span> &#123;</span>
<span class="line">            commonsMqService.sendSingleMessageAsync(<span class="string">"REDIS_TIMEOUT_KEY_QUEUE"</span>, message);</span>
<span class="line">            logger.info(<span class="string">"发送支付超时MQ消息成功：&#123;&#125;"</span>,message);</span>
<span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span>
<span class="line">            logger.error(<span class="string">"发送支付超时MQ消息失败：&#123;&#125;"</span>,e.toString());</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h4 id="3-订阅指定-db-的过期事件"><a href="#3-订阅指定-db-的过期事件" class="headerlink" title="3. 订阅指定 db 的过期事件"></a><a href="#3-订阅指定-db-的过期事件" title="3. 订阅指定 db 的过期事件"></a>3. 订阅指定 db 的过期事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="meta">@Order</span>(value = <span class="number">4</span>)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberRedisKeyTimeout</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SubscriberRedisKeyTimeout.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Resource</span></span>
<span class="line">    RedisKeyExpiredListener redisKeyExpiredListener;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span>
<span class="line"></span>
<span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span>
<span class="line">        Jedis jedis = pool.getResource();</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 订阅线程：接收消息</span></span>
<span class="line"><span class="comment">         * 由于订阅者（subscriber）在进入订阅状态后会阻塞线程，</span></span>
<span class="line"><span class="comment">         * 因此新起一个线程（new Thread()）作为订阅线程</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span>
<span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span>
<span class="line">                <span class="keyword">try</span> &#123;</span>
<span class="line">                    logger.info(<span class="string">"Subscribing. This thread will be blocked."</span>);</span>
<span class="line">                    <span class="comment">//使用subscriber订阅 db0上的key过期事件消息，这一句之后，线程进入订阅模式，阻塞。</span></span>
<span class="line">                     jedis.subscribe(redisKeyExpiredListener, <span class="string">"__keyevent@0__:expired"</span>);</span>
<span class="line">     </span>
<span class="line">                    <span class="comment">//当unsubscribe()方法被调用时，才执行以下代码</span></span>
<span class="line">                    logger.info(<span class="string">"Subscription ended."</span>);</span>
<span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">                    logger.error(<span class="string">"Subscribing failed."</span>, e);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;).start();</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a><a href="#4-测试" title="4. 测试"></a>4. 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJedisExpipreNotice</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span>
<span class="line">        Jedis jedis = pool.getResource();</span>
<span class="line"></span>
<span class="line">        jedis.setex(<span class="string">"REDIS:EXPIPRE:NOTICE:TEST"</span>,<span class="number">5</span>, <span class="string">"测试键过期事件回调"</span>);</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<p>5秒后控制台打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">2019-03-26 17:35:44.248  INFO 20464 --- [ Thread-127] c.p.c.r.b.r.RedisKeyExpiredListener  : 发送聊天会话超时MQ消息成功：REDIS:EXPIPRE:NOTICE:TEST</span>
</pre></td></tr></table></figure>

<h3 id="四、-subscribe-psubscibe-的区别"><a href="#四、-subscribe-psubscibe-的区别" class="headerlink" title="四、 subscribe/psubscibe 的区别"></a><a href="#四、-subscribe-psubscibe-的区别" title="四、 subscribe/psubscibe 的区别"></a>四、 subscribe/psubscibe 的区别</h3><p>Redis 提供了 publish 和  subscribe/psubscibe 指令来实现发布/订阅模型，发布和订阅的目标称为通道(channel)。 subscribe/psubscribe 了一个或多个通道的客户端，可以收到其他客户端向这个通道publish的消息。subscribe和psubscribe的区别是，前者指定具体的通道名称，而后者可以指定一个正则表达式，匹配这个表达式的通道都被订阅。</p>
<p><img src="/images/20190327.svg" alt=""></p>
<p>上图展示了一个带有频道和模式的例子， 其中 <code>tweet.shop.*</code>  模式匹配了 <code>tweet.shop.kindle</code> 频道和 <code>tweet.shop.ipad</code> 频道， 并且有不同的客户端分别用 psubscibe 订阅它们三个：当有信息发送到 <code>tweet.shop.kindle</code> 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅 <code>tweet.shop.*</code>  模式的 client123 和 client256。</p>
<h3 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a><a href="#五、参考文献" title="五、参考文献"></a>五、参考文献</h3><p>[1]<a href="https://redis.io/topics/pubsub" target="_blank" rel="noopener">Redis Pub/Sub</a></p>
<p>[2]<a href="https://redis.io/topics/notifications" target="_blank" rel="noopener">Redis Keyspace Notifications</a></p>
<p>[3]<a href="https://my.oschina.net/itblog/blog/601284?p=1" target="_blank" rel="noopener">Redis的Pub/Sub模式</a></p>
<p>[4]<a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noopener">Redis设计与实现第一版-订阅与发布</a></p>
<p>[5]<a href="https://www.cnblogs.com/tinywan/p/5903988.html" target="_blank" rel="noopener">Redis实践操作之—— keyspace notification（键空间通知</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Pub/Sub</tag>
        <tag>Redis Keyspace Notifications</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 2：Redis环境搭建及Redis shell的使用</title>
    <url>/2018/08/10/redis-shell/</url>
    <content><![CDATA[<h2 id="一、版本选择"><a href="#一、版本选择" class="headerlink" title="一、版本选择"></a>一、版本选择</h2><blockquote>
<p>Redis 借鉴了 Linux 操作系统对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2、4.0）。当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。所以我们在生产环境通常选取偶数版本的 Redis。</p>
</blockquote>
<a id="more"></a>


<p>生产环境推荐选用偶数版本，推荐从 2.6、2.8、3.0、3.2 、4.0 这几个重大版本中选。几个版本的区别可参考 <a href="https://www.cnblogs.com/yangmingxianshen/p/8043851.html" target="_blank" rel="noopener">Redis重大版本</a></p>
<h2 id="二、安装-Redis"><a href="#二、安装-Redis" class="headerlink" title="二、安装 Redis"></a>二、安装 Redis</h2><p>进入 /usr/local 目录</p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081101.png" alt=""></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081102.png" alt=""></p>
<h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p>建立一个名叫 redis 的软链接指向 redis-4.0.0 目录，这样做是为了不把 redis 目录固定在指定版本上，有利于Redis未来版本升级，算是安装软件的一种好习惯。（类型window 系统的快捷方式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s redis-4.0.0 redis</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081103.png" alt=""></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081104.png" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081105.png" alt=""></p>
<p>make install 会将 Redis 的相关运行文件放到 /usr/local/bin/ 下，这样就可以在任意目录下执行 Redis 的命令了。</p>
<p><img src="/images/2018081106.png" alt=""></p>
<p>查看 redis 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -v</span><br></pre></td></tr></table></figure>

<p>显示如下，说明已经安装成功啦。</p>
<p><img src="/images/2018081107.png" alt=""></p>
<p><strong>小结：</strong><br>整个安装过程其实非常简单，总共6步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ tar xzf redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ ln -s redis-4.0.0 redis</span><br><span class="line"></span><br><span class="line">$ cd redis</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h2 id="三、配置、-启动、-操作、-关闭-Redis"><a href="#三、配置、-启动、-操作、-关闭-Redis" class="headerlink" title="三、配置、 启动、 操作、 关闭 Redis"></a>三、配置、 启动、 操作、 关闭 Redis</h2><p>前面已经提到 使用 make install 安装 Redis 之后，src和/usr/local/bin目录下多了几个以redis开头可执行文件，我们称之为RedisShell，这些可执行文件可以做很多事情，比如可以启动和停止Redis、可以检测和修复Redis的持久化文件，还可以检测Redis的性能。 下面是是我们最常用到的 Redis shell 说明：</p>
<table>
<thead>
<tr>
<th align="center">可执行文件</th>
<th align="center">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redis-server</td>
<td align="center">启动 Redis</td>
</tr>
<tr>
<td align="center">redis-cli</td>
<td align="center">Redis 命令行客户端</td>
</tr>
<tr>
<td align="center">redis-benchmark</td>
<td align="center">Redis 基准测试工具</td>
</tr>
<tr>
<td align="center">redis-check-aof</td>
<td align="center">Redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-check-dump</td>
<td align="center">Redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-sentinel</td>
<td align="center">启动 Redis Sentinel</td>
</tr>
</tbody></table>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动 Redis 服务的方法有三种，分别是：默认配置启动、运行配置启动、配置文件启动。生产环境推荐用配置文件启动，因为这种方式提供了更大的灵活性。</p>
<p>下面分别介绍下三种启动方式：</p>
<p><strong>默认配置启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>直接启动无法自定义配置，生产环境应该避免使用这种方式启动 Redis 服务。</p>
<p><strong>运行配置启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --configKey1 configValue1	 --configKey2 configValue2 ...</span><br></pre></td></tr></table></figure>

<p>比如要指定端口（注： Redis 的默认端口是 6379），可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure>

<p><strong>配置文件启动（生产环境推荐使用这种方式）</strong></p>
<p>通常我们会在一台机器上启动多台 Redis，并且将配置管理在集中目录下，习惯性的做法是把 Redis安装目录下的 redis.conf 拷贝到  /opt/redis/ 下，然后作为模板根据需要修改。</p>
<p>然后通过指定该配置文件启动 Redis 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server  &#x2F;opt&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081108.png" alt=""></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作是通过 Redis命令行客户端来完成，有两种方式，一种是交互方式，一种是命令方式，推荐使用交互方式。</p>
<p>在用 redis-cli 连接 Redis服务之前，可以先用 ps -ef |grep redis 看redis是否在服务，以及查看对应的 ip 端口信息。</p>
<p><img src="/images/2018081109.png" alt=""></p>
<p><strong>交互方式（推荐使用这种方式）</strong><br>通过 redis-cli -h{host}- p{port} 的方式连接到Redis服务，之后所有的操作都是通过交互的方式实现，不需要再执行redis-cli了。</p>
<p><img src="/images/2018081110.png" alt=""></p>
<p><strong>命令方式</strong><br>用 redis-cli -h{host} -p{port} {command} 直接得到命令的返回结果。</p>
<p><img src="/images/2018081111.png" alt=""></p>
<h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018081112.png" alt=""></p>
<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>夯实基础 1：ArrayList、Vector、LinkedList 的区别</title>
    <url>/2018/08/30/the-diff-ArrayList-Vector-LinkedList/</url>
    <content><![CDATA[<h2 id="一、集合框架层次结构"><a href="#一、集合框架层次结构" class="headerlink" title="一、集合框架层次结构"></a>一、集合框架层次结构</h2><p>ArrayList、Vector、LinkedList 这三者都是集合框架中的 List，所以要弄清楚它们之间的区别与联系，最好先对集合框架类的层级有个整体直观的认识。</p>
<p>下面是集合框架的简要类图：</p>
<p><img src="/images/2018083001.png" alt=""></p>
<p>从上图可以看到，Collection接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p>
<a id="more"></a>

<ul>
<li><p>List，有序集合，列表中的元素可重复，它提供了方便的访问、插入、删除等操作。</p>
</li>
<li><p>Set，Set是不允许元素重复的，这是和List最明显的区别，也就是不存在两个equals返回true的情况。广泛用于需要保证元素唯一的场合。</p>
</li>
<li><p>Queue/Deque ，则是Java提供的标准队列结构的实现，除了集合的基本功能，它还支持类似 先入先出（FIFO ，First-in-First-Out)储后入先出（LIFO，Last-In-First-Out)等特定行 为。这里不包括 BlockingQueue ，因为通常是并发编程杨合，所以被放置在并发包里。</p>
</li>
</ul>
<p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如AbstractList就集中了各种List操作的 通用部分。这些集合不是完全孤立的，比如，LinkedList本身，既是List，也是 Deque。</p>
<h2 id="二、ArrayList、Vector、LinkedList"><a href="#二、ArrayList、Vector、LinkedList" class="headerlink" title="二、ArrayList、Vector、LinkedList"></a>二、ArrayList、Vector、LinkedList</h2><p>下面可以看一个简化版的类图：</p>
<p><img src="/images/2018083002.png" alt=""></p>
<p>从上图可以看到 ArrayList、Vector、LinkedList 三者都实现了List 接口。因此，它们在功能及用法上都非常的相似，比如都提供按照索引位置进行取值、添加、删除操作，都提供了迭代器用于遍历元素等功能。它们之间的主要区别，来源于底层实现上的不同，所以在行为、性能、线程安全性上有所差别。</p>
<ul>
<li>ArrayList 是一个可改变大小的动态数组，随着元素的添加，会动态的增加容量，因为ArrayList本质上就是一个数组，所以内部的元素可以直接通过get与set方法进行访问。需要注意的是，ArrayList 本身不是线程安全的，所以与Vector 相比，不存在同步的开销，性能上好很多。</li>
</ul>
<ul>
<li><p>Vector 和ArrayList类似，不同的是在方法的前面加了synchronized，因此Vector 是线程安全的。<br>如果你的程序本身是线程安全的（即不存在多个线程之间共享同一个集合/对象），那么不建议选择Vector ，毕竟同步是有额外开销的。</p>
</li>
<li><p>LinkedList 是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。 LinkedList 还实现了 Queue 接口，该接口比List提供了更多的方法,包括 offer()、peek()、poll()等。LinkedList本身，既是List，也是 Deque。</p>
</li>
</ul>
<h2 id="三、性能比较"><a href="#三、性能比较" class="headerlink" title="三、性能比较"></a>三、性能比较</h2><p>下面写个例子对比下 ArrayList、LinkedList 在访问、添加、删除元素方面的差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// ArrayList add</span></span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		arrayList.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  add: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList add</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		linkedList.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList add: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="comment">// ArrayList get</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		arrayList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  get: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList get</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		linkedList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList get: "</span> + duration);</span><br><span class="line">	 	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ArrayList remove</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		arrayList.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  remove: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList remove</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		linkedList.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList remove: "</span> + duration);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在JDK1.7 中的运行效果如下所示：</p>
<p><img src="/images/2018083003.png" alt=""></p>
<p><strong>小结：</strong><br>可以看到，ArrayList 在访问元素比 LinkedList 好，单在添加、删除元素方面 LinkedList 性能更好。 </p>
<h2 id="四、不同容器适合的场景-如何考虑选择"><a href="#四、不同容器适合的场景-如何考虑选择" class="headerlink" title="四、不同容器适合的场景(如何考虑选择)"></a>四、不同容器适合的场景(如何考虑选择)</h2><ul>
<li>Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会先对较差，比如我们在中间插入一个元素，需要移动后续的所有元素。</li>
<li>LinkedList 进行节点的插入、删除却要高效的多，但随机访问性能却要比动态数组慢。</li>
</ul>
<p>所以在开发的过程中，应考虑对应的功能是偏向于插入、删除、还是随机访问比较多，来进行针对性的选择。<strong>如果是插入、删除比较频繁，则选用 LinkedList ；如果随机性访问多，则选择动态数组（Vector 和 ArrayList），然后再结合是否需要线程安全来进一步选择，如果需要线程安全则使用Vector，如果不需要线程安全，则选择 ArrayList 。</strong></p>
<h2 id="五、Vector和ArrayList-的扩容机制"><a href="#五、Vector和ArrayList-的扩容机制" class="headerlink" title="五、Vector和ArrayList 的扩容机制"></a>五、Vector和ArrayList 的扩容机制</h2><p>Vector和ArrayList在随着元素的添加，当数组满时，会请求更大的空间，创建新数组，并拷贝原有数组数据。区别的是，Vector 每次扩容时增加1倍，而ArrayList则是增加 50%。如下面的代码所示：</p>
<p><strong>Vector 的 grow 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *这里可以看到，如果在构造 Vector 的时候指定了 步长 capacityIncrement ，</span></span><br><span class="line"><span class="comment">     *则在原容量基础上增加指定步长，否则增加1倍原容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>ArrayList 的 grow 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="comment">//这里可以看到在原容量的基础上再增加 原容量的一半。</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>最佳实践：</strong><br>值得注意的是，动态扩容会创建新数组，并拷贝原有数组数据到新的数组，所以每次扩容都会带来一定的开销。而默认情况下 ArrayList 和 Vector 的初始容量非常小，在JDK1.7 中默认是10，所以JDK提供了构造函数，支持在创建动态数组的时候指定数组的初始容量。所以<strong>如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销。</strong></p>
<p><strong>ArrayList 的 相应的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Vector 的 相应的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * capacity increment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment"> *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， 创建 ArrayList 和 Vector 时，都可以指定数组的初始容量，并且 Vector  还可以指定数组每次扩容的增量。</p>
<p>下面写个例子测试对比一下使用默认初始容量与指定初始初始容量的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10000000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// arrayList1 add</span></span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">		arrayList1.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"arrayList1  add: "</span> + duration);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// arrayList2 add</span></span><br><span class="line">	<span class="keyword">long</span> startTime2 = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">		arrayList2.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime2 = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration2 = endTime2 - startTime2;</span><br><span class="line">	System.out.println(<span class="string">"arrayList2  add: "</span> + duration2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下所示： </p>
<p><img src="/images/2018083004.png" alt=""></p>
<p>可以看到，如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销，效果还是比较明显的。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">关于Java集合的小抄</a></p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>夯实基础</tag>
        <tag>ArrayList</tag>
        <tag>Vector</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 1：线程模型及Java的线程模型</title>
    <url>/2018/06/19/thred-model/</url>
    <content><![CDATA[<h2 id="一、进程、线程"><a href="#一、进程、线程" class="headerlink" title="一、进程、线程"></a>一、进程、线程</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源(内存地址、文件 I/O 等)拥有的基本单位。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<a id="more"></a>
<h2 id="二、用户态和内核态"><a href="#二、用户态和内核态" class="headerlink" title="二、用户态和内核态"></a>二、用户态和内核态</h2><p>由于进程的调度以及系统资源的分配是离不开操作系统的，所以学习谈线程设计之前，有必要先看下操作系统的体系结构，以 Unix/Linux 的体系架构为例。</p>
<p><img src="/images/2018061901.png" alt=""></p>
<p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux 的设计哲学之一就是：对不同的操作赋予不同的执行等级(有多大能力做多大的事)，用户态(User Mode)和内核态(Kernel Mode)。</p>
<p>运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中有时候会需要切换到内核态执行，常见如以下三种：</p>
<p><strong>1.系统调用：</strong>发一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如 printf()，调用的是 wirte()系统调用来输出字符串，等等。</p>
<p><strong>2.不可知的异常事件：</strong>就会触发从当前用户态执行的进程转向内核态执行相关的异常事件。</p>
<p><strong>3.外围设备的中断：</strong>CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
<p><strong>而在用户态和内核态之间的上下文切换，不可避免的会产生一定的开销，这也是线程设计中必须考虑到的点。</strong></p>
<h2 id="三、线程设计的三个难点"><a href="#三、线程设计的三个难点" class="headerlink" title="三、线程设计的三个难点"></a>三、线程设计的三个难点</h2><p>1、在 CPU 密集型任务、I/O 密集型任务以及充分利用多核 CPU 提升程序性能上找到一个平衡点。<br>2、尽可能支持规模更大的线程数量。<br>3、减少线程在用户态(User Mode)和内核态(Kernel Mode)中切换带来的开销。</p>
<h2 id="四、三种不同的线程模型"><a href="#四、三种不同的线程模型" class="headerlink" title="四、三种不同的线程模型"></a>四、三种不同的线程模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1-用户线程与内核级线程"><a href="#1-用户线程与内核级线程" class="headerlink" title="1.用户线程与内核级线程"></a>1.用户线程与内核级线程</h4><p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<h4 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h4><p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<h4 id="3-多线程模型"><a href="#3-多线程模型" class="headerlink" title="3.多线程模型"></a>3.多线程模型</h4><p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="三种多线程模型："><a href="#三种多线程模型：" class="headerlink" title="三种多线程模型："></a>三种多线程模型：</h3><h4 id="1-使用用户线程实现（多对一模型-M-1）"><a href="#1-使用用户线程实现（多对一模型-M-1）" class="headerlink" title="1.使用用户线程实现（多对一模型 M:1）"></a>1.使用用户线程实现（多对一模型 M:1）</h4><p>多个用户线程映射到一个内核线程，用户线程建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，对内核透明。</p>
<p><img src="/images/2018061902.png" alt=""></p>
<p><strong>优点：</strong></p>
<p>1) 线程的上下文切换都发生在用户空间，避免了模态切换（mode switch），减少了性能的开销。<br>2) 用户线程的创建不受内核资源的限制，可以支持更大规模的线程数量。</p>
<p><strong>缺点：</strong></p>
<p>1) 所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，浪费了其它处理器资源，不支持并行，在多处理器环境下这是不能够被接受的，如果线程因为 I/O 操作陷入了内核态，内核态线程阻塞等待 I/O 数据，则所有的线程都将会被阻塞。</p>
<p>2) 增加了复杂度，所有的线程操作都需要用户程序自己处理，而且在用户空间要想自己实现 “阻塞的时候把线程映射到其他处理器上” 异常困难。</p>
<h4 id="2-使用内核线程实现（一对一模型-1-1）"><a href="#2-使用内核线程实现（一对一模型-1-1）" class="headerlink" title="2.使用内核线程实现（一对一模型 1:1）"></a>2.使用内核线程实现（一对一模型 1:1）</h4><blockquote>
<p>程序使用的是内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程,轻量级进程也是属于用户线程。</p>
</blockquote>
<p>所以这里统一称为用户线程。</p>
<p>每个用户线程都映射到一个内核线程，每个线程都成为一个独立的调度单元，由内核调度器独立调度，一个线程的阻塞不会影响到其他线程，从而保障整个进程继续工作。</p>
<p><img src="/images/2018061903.png" alt=""></p>
<p><strong>优点：</strong></p>
<p>1) 每个线程都成为一个独立的调度单元，使用内核提供的线程调度功能及处理器映射，可以完成线程的切换，并将线程的任务映射到其他处理器上，充分利用多核处理器的优势，实现真正的并行。</p>
<p><strong>缺点：</strong></p>
<p>1) 每创建一个用户级线程都需要创建一个内核级线程与其对应，因此需要消耗一定的内核资源,而内核资源是有限的，所以能创建的线程数量也是有限的。<br>2) 模态切换频繁，各种线程操作，如创建、析构及同步，都需要进行系统调用，需要频繁的在用户态和内核态之间切换，开销大。</p>
<h4 id="3-使用用户线程加轻量级进程混合实现（多对多模型-M-N）"><a href="#3-使用用户线程加轻量级进程混合实现（多对多模型-M-N）" class="headerlink" title="3.使用用户线程加轻量级进程混合实现（多对多模型 M:N）"></a>3.使用用户线程加轻量级进程混合实现（多对多模型 M:N）</h4><p>内核线程和用户线程的数量比为 M : N，这种模型需要内核线程调度器和用户空间线程调度器相互操作，本质上是多个线程被映射到了多个内核线程。</p>
<p><img src="/images/2018061904.png" alt=""></p>
<p><strong>综合了前面两种模型的优点：</strong></p>
<p>1) 用户线程的创建、切换、析构及同步依然发生在用户空间，能创建数量更多的线程，支持更大规模的并发。</p>
<p>2) 大部分的线程上下文切换都发生在用户空间，减少了模态切换带来的开销。</p>
<p>3) 可以使用内核提供的线程调度功能及处理器映射，充分利用多核处理器的优势，实现真正的并行，并降低了整个进程被完全阻塞的风险。</p>
<h2 id="五、Java的线程模型"><a href="#五、Java的线程模型" class="headerlink" title="五、Java的线程模型"></a>五、Java的线程模型</h2><p><strong>一句话总结：Java 的线程是映射到操作系统的原生线程之上的。</strong></p>
<p>JVM 没有限定 Java 线程需要使用哪种线程模型来实现， JVM 只是封装了底层操作系统的差异，而不同的操作系统可能使用不同的线程模型，例如 Linux 和 windows 可能使用了一对一模型，solaris 和 unix 某些版本可能使用多对多模型。所以一谈到 Java 语言的多线程模型，需要针对具体 JVM 实现。</p>
<p>比如 Sun JDK 1.2开始，线程模型都是基于操作系统原生线程模型来实现，它的 Window 版和 Linux 版都是使用系统的 1:1 的线程模型实现的。</p>
<h2 id="六、Java的并发为什么不如GO"><a href="#六、Java的并发为什么不如GO" class="headerlink" title="六、Java的并发为什么不如GO"></a>六、Java的并发为什么不如GO</h2><p>以后再展开补充。</p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明   第十二章第四小节<br> <a href="https://www.cnblogs.com/binyue/p/6555730.html" target="_blank" rel="noopener">Go语言并发机制初探</a><br> <a href="https://www.itency.com/topic/show.do?id=338701" target="_blank" rel="noopener">关于Golang和JVM中并发模型实现的探讨</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>线程模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 1：聊聊 Redis</title>
    <url>/2018/08/01/talk-about-redis/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的数据都放到内存中，因此 Redis 速度很快。除此之外，Redis 还提供了 持久化、主从复制、集群 以及以下几点功能：</p>
<ul>
<li>提供了键过期功能，可以用来实现缓存。</li>
<li>提供了发布订阅功能，可以用来实现消息系统。</li>
<li>支持 Lua 脚本功能，可以根据需要定制自己的 Redis 命令。</li>
<li>提供了简单的事务功能， 能在一定程度上保证事物特性。</li>
<li>提供了流水线（Pipeline）功能， 客户端可以将一批命令一次性传到 Redis，从而减少网络的开销。</li>
</ul>
<a id="more"></a>

<p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。redisObject 最主要的信息如图所示：</p>
<p><img src="/images/20180808000.png" alt=""></p>
<p>其中 type 代表一个 value 对象具体是何种数据类型，encoding 是不同数据类型在redis内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int。</p>
<h2 id="二、Redis提供的五种数据结构"><a href="#二、Redis提供的五种数据结构" class="headerlink" title="二、Redis提供的五种数据结构"></a>二、Redis提供的五种数据结构</h2><p><strong>五种数据结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>字符串类型是 Redis 最基础的数结构。首先键都是字符串类型， 而且其他几种数据结构 都是 在字符串类型基础上构建的。</p>
<p><img src="/images/2018080801.svg" alt=""></p>
<p>上图是string 在 redis 中的宏观样子，它的数据结构如下图所示：</p>
<p><img src="/images/2018080802.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>每种数据类型对应的命令都非常多，以下只列举 string 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set</td>
<td align="center">set key value</td>
<td align="center">设置指定 key 的值</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get key</td>
<td align="center">获取指定 key 的值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del key</td>
<td align="center">删除指定 key 的值</td>
</tr>
<tr>
<td align="center">setex</td>
<td align="center">setex key seconds value</td>
<td align="center">设置健并指定多少秒后过期</td>
</tr>
<tr>
<td align="center">setnx</td>
<td align="center">setnx key value</td>
<td align="center">只有当 key 不存在时才设置成功(setnx 可以作为分布式锁 的一种实现方案)</td>
</tr>
<tr>
<td align="center">mset</td>
<td align="center">mset key1 value1 key2 value2 …</td>
<td align="center">批量设置多个 key-value 对</td>
</tr>
<tr>
<td align="center">mget</td>
<td align="center">mget key1 key2 key3 …</td>
<td align="center">批量获取多个 key 的值</td>
</tr>
<tr>
<td align="center">incr</td>
<td align="center">incr key</td>
<td align="center">对值做自增操作</td>
</tr>
</tbody></table>
<p><strong>mset、mget 等批量操作可以减少网络传输的次数，从而可以提高效率。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>string 的典型使用场景：</strong></p>
<ul>
<li>缓存功能</li>
<li>计数</li>
<li>共享 Session</li>
<li>限速</li>
</ul>
<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>哈希类型是指键值本身又是一个键值对结构，形如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value&#x3D;&#123;&#123; field1， value1&#125;，...&#123; fieldN， valueN&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img src="/images/2018080804.svg" alt=""></p>
<p>下图是字符串和哈希类型的对比：</p>
<p><img src="/images/2018080803.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 hash 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hset</td>
<td align="center">hset key field value</td>
<td align="center">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td align="center">hget</td>
<td align="center">hget key field</td>
<td align="center">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel key field1 field2 …</td>
<td align="center">删除一个或者多个 field</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen key</td>
<td align="center">计算 field 个数</td>
</tr>
<tr>
<td align="center">hmset</td>
<td align="center">hmset key field value field1 field2 …</td>
<td align="center">批量设置一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hmget</td>
<td align="center">hmget key field field1 field2 …</td>
<td align="center">批量获取一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists key field</td>
<td align="center">判断 key 中是否存在某个 field</td>
</tr>
<tr>
<td align="center">hkeys</td>
<td align="center">hkeys key</td>
<td align="center">获取指定 key 中的所有 field</td>
</tr>
<tr>
<td align="center">hvals</td>
<td align="center">hvals key</td>
<td align="center">获取指定 key 中的所有 value</td>
</tr>
<tr>
<td align="center">hgetall</td>
<td align="center">hgetall key</td>
<td align="center">获取指定 key 中的所有 field-value</td>
</tr>
</tbody></table>
<p><strong>在使用 hgetall 时， 如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果只需要获取部分 field，可以使用 hmget，如果一定要获取全部 field-value，可以使用 hscan 命令，该命令会渐进式遍历哈希类型。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>hash 的典型使用场景：</strong><br>比如缓存用户信息。每个用户属性使用一对field-value，但是只用一个键保存。如下图所示：</p>
<p><img src="/images/2018080805.png" alt=""></p>
<p>优点：简单直观，如果使用合理可以减少内存空间的使用。</p>
<p>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>
<h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>列表类型是用来存储多个有序的字符串，支持两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p>
<p><img src="/images/2018080806.svg" alt=""></p>
<p>下图为列表两端插入和弹出操作，a、b、c、d、e五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element），一个列表最多可以存储232-1个元素。</p>
<p><img src="/images/2018080807.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 list 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rpush</td>
<td align="center">rpush key value1 value2 …</td>
<td align="center">从右边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">lpush</td>
<td align="center">lpush key value1 value2 …</td>
<td align="center">从左边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">linsert</td>
<td align="center">linsert key before</td>
<td align="center">在 pivot 前或者后插入一个新元素 value</td>
</tr>
<tr>
<td align="center">lrange</td>
<td align="center">lrange key start end</td>
<td align="center">获取指定索引范围内的所有元素，索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N。 lrange key 0 -1  表示从左到右获取列表的所有元素</td>
</tr>
<tr>
<td align="center">lindex</td>
<td align="center">lindex key index</td>
<td align="center">获取列表指定索引下标的元素，lindex key -1 表示获取列表的最后一个元素</td>
</tr>
<tr>
<td align="center">llen</td>
<td align="center">llen key</td>
<td align="center">获取列表长度</td>
</tr>
<tr>
<td align="center">lpop</td>
<td align="center">lpop key</td>
<td align="center">从列表左侧弹窗元素</td>
</tr>
<tr>
<td align="center">rpop</td>
<td align="center">rpop key</td>
<td align="center">从列表右侧弹出元素</td>
</tr>
<tr>
<td align="center">lrem</td>
<td align="center">lrem key count value</td>
<td align="center">当 count&gt;0 , 从左到右，删除count个值等于 value的元素；当 count&lt;0，从右到左，删除count的绝对值个值等于value的元素；当 count=0，删除所有值等于 value的元素</td>
</tr>
<tr>
<td align="center">ltrim</td>
<td align="center">ltrim key start end</td>
<td align="center">只保留key 从start 到end 的元素</td>
</tr>
<tr>
<td align="center">lset</td>
<td align="center">lset key index newValue</td>
<td align="center">修改指定索引小标的元素</td>
</tr>
</tbody></table>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p><strong>list 的典型使用场景：</strong></p>
<ul>
<li>消息队列</li>
<li>文章列表</li>
</ul>
<p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">·lpush+lpop&#x3D;Stack（栈）</span><br><span class="line">·lpush+rpop&#x3D;Queue（队列）</span><br><span class="line">·lpsh+ltrim&#x3D;CappedCollection（有限集合）</span><br><span class="line">·lpush+ brpop&#x3D; Message Queue（消息队列）</span><br></pre></td></tr></table></figure>

<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>集合类型也是用来保存多个的字符串元素，但和列表类型不同的是，集合中的元素是无序并且不可重复的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p>
<p><img src="/images/2018080809.svg" alt=""></p>
<p><img src="/images/2018080808.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 set 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sadd</td>
<td align="center">sadd key value1 value2 …</td>
<td align="center">添加一个或多个元素</td>
</tr>
<tr>
<td align="center">srem</td>
<td align="center">srem key value1 value2 …</td>
<td align="center">删除一个或多个元素</td>
</tr>
<tr>
<td align="center">scard</td>
<td align="center">scard key</td>
<td align="center">计算元素个数</td>
</tr>
<tr>
<td align="center">sismember</td>
<td align="center">sismember key element</td>
<td align="center">判断元素是否在集合中，返回1表示存在，0 表示不存在</td>
</tr>
<tr>
<td align="center">srandmember</td>
<td align="center">srandmember key count</td>
<td align="center">随机从集合返回count个元素，count 不写默认为1</td>
</tr>
<tr>
<td align="center">spop</td>
<td align="center">spop key</td>
<td align="center">从集合随机弹出元素</td>
</tr>
<tr>
<td align="center">smembers</td>
<td align="center">smembers key</td>
<td align="center">获取所有元素</td>
</tr>
<tr>
<td align="center">sinter</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">suinon</td>
<td align="center">suinon key1 key2 …</td>
<td align="center">求多个集合的并集</td>
</tr>
<tr>
<td align="center">sdiff</td>
<td align="center">sdiff key1 key2 …</td>
<td align="center">求多个集合的差集</td>
</tr>
<tr>
<td align="center">sinterstore</td>
<td align="center">sinterstore key key1 key2 …</td>
<td align="center">求多个集合的交集并保存到key中</td>
</tr>
<tr>
<td align="center">suinonstore</td>
<td align="center">suinonstore key key1 key2 …</td>
<td align="center">求多个集合的并集并保存到key中</td>
</tr>
<tr>
<td align="center">sdiffstore</td>
<td align="center">sdiffstore key key1 key2 …</td>
<td align="center">求多个集合的差集并保存到key中</td>
</tr>
</tbody></table>
<p><strong>smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>set 的典型使用场景：</strong></p>
<ul>
<li>sadd=Tagging（标签）</li>
<li>spop/srandmember=Randomitem（生成随机数，比如抽奖）</li>
<li>sadd+sinter=SocialGraph（社交需求）</li>
</ul>
<p>标签（tag）是集合类型一个比较典型的使用场景。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签。</p>
<h3 id="ZSET（sorted-set）"><a href="#ZSET（sorted-set）" class="headerlink" title="ZSET（sorted set）"></a>ZSET（sorted set）</h3><p>有序集合，保留了集合元素不可重复的特性，并在集合的基础上增加了元素排序功能。需要注意的是，它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。有序集合还提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p>
<p><img src="/images/20180808010.svg" alt=""></p>
<p>下图是一个有序集合的例子，该有序集合包含kris、mike、frank、tim、martin、tom，它们的分数分别是1、91、200、220、250、251。</p>
<p><img src="/images/20180808011.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 zset 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zadd</td>
<td align="center">zadd key score member [score member …]</td>
<td align="center">向有序集合添加一个或多个成员以及分数，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="center">zcard</td>
<td align="center">zcard key</td>
<td align="center">计算成员个数</td>
</tr>
<tr>
<td align="center">zscore</td>
<td align="center">zscore key member</td>
<td align="center">计算某个成员的分数，存在则返回分数，否则返回 nil</td>
</tr>
<tr>
<td align="center">zrank</td>
<td align="center">zrank key element</td>
<td align="center">返回分数从低到高的排名</td>
</tr>
<tr>
<td align="center">zrevrank</td>
<td align="center">zrevrank key count</td>
<td align="center">返回分数从高到低的排名</td>
</tr>
<tr>
<td align="center">zrem</td>
<td align="center">zrem member [member …]</td>
<td align="center">删除一个或多个成员</td>
</tr>
<tr>
<td align="center">zincrby</td>
<td align="center">zincrby key increment member</td>
<td align="center">给key中的member 增加 increment 分</td>
</tr>
<tr>
<td align="center">zrange</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">zremrangebyscore</td>
<td align="center">zremrangebyscore key min max</td>
<td align="center">删除指定分数范围的成员</td>
</tr>
</tbody></table>
<p><strong>zset 同样可以计算集合的交、并、差，以上没有一一列举</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<p><strong>zset 的典型使用场景：</strong></p>
<p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p>
<p>以点赞数位例，主要需要实现以下4个功能</p>
<ul>
<li>添加用户赞数</li>
<li>取消用户赞数</li>
<li>展示获取赞数最多的十个用户</li>
<li>展示用户信息以及用户分数</li>
</ul>
<h2 id="三、Redis的使用场景"><a href="#三、Redis的使用场景" class="headerlink" title="三、Redis的使用场景"></a>三、Redis的使用场景</h2><p>由于 redis 支持多种数据类型，所以适用场景也非常多。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>对于热点数据，缓存的价值非常大。例如，分类栏目(读频率高)等。可以将这些热点数据放到内存中，通过设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 </p>
<h3 id="共享Session（会话缓存）"><a href="#共享Session（会话缓存）" class="headerlink" title="共享Session（会话缓存）"></a>共享Session（会话缓存）</h3><p>在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息。比如我们公司就使用Redis共享Session来实现单点登录。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>数据统计的需求非常普遍，通过原子递增保持计数。例如，应用数、资源数、点赞数、收藏数、分享数等。这种高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作。</p>
<h3 id="排行榜以及热门列表"><a href="#排行榜以及热门列表" class="headerlink" title="排行榜以及热门列表"></a>排行榜以及热门列表</h3><p>例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：比如按照时间、播放量、点击率、点赞数等。可以利用有序集合 zset 实现。</p>
<h3 id="社交列表"><a href="#社交列表" class="headerlink" title="社交列表"></a>社交列表</h3><p>社交属性相关的列表信息，例如，用户点赞列表、用户分享列表、用户收藏列表、用户关注列表、用户粉丝列表等，使用 Hash 类型数据结构是个不错的选择。</p>
<h3 id="记录用户判定信息"><a href="#记录用户判定信息" class="headerlink" title="记录用户判定信息"></a>记录用户判定信息</h3><p>记录一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否评论分享等。</p>
<h3 id="交集、并集和差集"><a href="#交集、并集和差集" class="headerlink" title="交集、并集和差集"></a>交集、并集和差集</h3><p>在某些场景中，例如社交场景，通过交集、并集和差集运算，可以非常方便地实现共同好友，共同关注，共同偏好等社交关系。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>例如验证码只有60秒有效期，超过时间无法使用，或者基于 Oauth2 的 Token 只能在 5 分钟内使用一次，超过时间也无法使用。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中list的数据结构实现是双向链表，所以非常适合应用于消息队列（生产者/消费者模型）。 生产者利用 lpush 命令将数据添加到链表头部，消费者通过 brpop（右端阻塞弹出） 命令将元素从链表尾部取出。并且可以保证消息的有序性。比如可以用这种方式让多个应用更新最新的内容。</p>
<p>不过最好还是用 RabbitMQ 等市面上成熟的消息队列中间件。</p>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>由于Redis的单线程命令处理机制，如果有多个客户端同时执行 setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="四、Redis的数据淘汰策略-内存淘汰机制"><a href="#四、Redis的数据淘汰策略-内存淘汰机制" class="headerlink" title="四、Redis的数据淘汰策略(内存淘汰机制)"></a>四、Redis的数据淘汰策略(内存淘汰机制)</h2><h3 id="内存淘汰的过程"><a href="#内存淘汰的过程" class="headerlink" title="内存淘汰的过程"></a>内存淘汰的过程</h3><p>首先，客户端发起了需要申请更多内存的命令（如set）。</p>
<p>然后，Redis检查内存使用情况，如果已使用的内存大于 maxmemory 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p>
<p>最后，如果上面都没问题，则这个命令执行成功。</p>
<h3 id="8-种淘汰策略"><a href="#8-种淘汰策略" class="headerlink" title="8 种淘汰策略"></a>8 种淘汰策略</h3><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持以下6种策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">noeviction</td>
<td align="center">当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lfu</td>
<td align="center">从所有键中驱逐使用频率最少的键</td>
</tr>
<tr>
<td align="center">volatile-lfu</td>
<td align="center">从已设置过期时间的数据集中挑选使用频率最少的键</td>
</tr>
</tbody></table>
<p>需要注意的是：作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<h3 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h3><p>下面看看几种策略的适用场景</p>
<p>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。</p>
<p>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</p>
<p>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。</p>
<p><strong>推荐用法：</strong><br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h3 id="如何配置最大内存及淘汰策略"><a href="#如何配置最大内存及淘汰策略" class="headerlink" title="如何配置最大内存及淘汰策略"></a>如何配置最大内存及淘汰策略</h3><p>我们通过配置redis.conf中的 maxmemory 这个值来开启内存淘汰功能，以及配置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 100000</span><br><span class="line"></span><br><span class="line">#设置淘汰策略</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>需要注意的是，maxmemory 为0的时候表示我们对Redis的内存使用没有限制。</p>
<p>此外，redis支持动态改配置，无需重启。</p>
<p>设置最大内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set maxmemory 100000</span><br></pre></td></tr></table></figure>

<p>设置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set maxmemory-policy noeviction</span><br></pre></td></tr></table></figure>

<h2 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h2><p>Redis支持RDB和AOF两种持久化机制，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化，从而能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p>
<h3 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据生成快照（Snapshot）以紧凑压缩的二级制文件格式保存到硬盘。</p>
<p>触发RDB持久化过程分为手动触发和自动触发。手动触发分别对应save和bgsave命令，其中save存在阻塞问题，基本已经废弃，Redis内部所有的涉及RDB的操作都采用bgsave的方式。执行save 或 bgsave 将在 redis 安装目录中创建dump.rdb （可配置）文件,如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</p>
<p>可以在redis.conf中做一些 RDB 相关的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 快照的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 存放快照的目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"># 在进行镜像备份时,是否进行压缩。</span><br><span class="line"># yes：压缩，但是需要一些cpu的消耗。</span><br><span class="line"># no：不压缩，需要更多的磁盘空间。</span><br><span class="line">rdbcompression yes</span><br><span class="line">#900秒后且至少1个key发生变化时创建快照  </span><br><span class="line">save 900 1  </span><br><span class="line">#300秒后且至少10个key发生变化时创建快照  </span><br><span class="line">save 300 10  </span><br><span class="line">#60秒后且至少10000个key发生变化时创建快照  </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p><strong>RDB的优点：</strong></p>
<ul>
<li><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p>
</li>
<li><p>Redis加载RDB恢复数据远远快于AOF的方式。</p>
</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p>
</li>
<li><p>一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。例如，每隔30分钟或者更长的时间来创建一次快照，Redis停止工作时（例如意外断电）就可能丢失这30分钟的数据。</p>
</li>
<li><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p>
</li>
</ul>
<h3 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h3><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过 appendfilename 配置设置，默认文件名是 appendonly.aof。保存路径同 RDB 持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。如下图所示：</p>
<p><img src="/images/20180808012.png" alt=""></p>
<p>AOF 工作流程 ：</p>
<p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p>
<p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p>
<p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p>
<p><strong>下面分别讲下每个过程：</strong></p>
<h4 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h4><p>AOF命令写入是吧文本协议格式的内容追加到缓存区。</p>
<p>如以下 set hello world 命令的文本协议格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></table></figure>

<p><strong>采用文本协议格式的原因：</strong><br>文本协议具有可读性，方便直接修改和处理。同时还可以避免二次开销。</p>
<p><strong>先写入缓存区而不是直接写入硬盘的原因：</strong><br>如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。Redis支持三种不同的缓冲区同步文件策略如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，影响 Redis 的高性能，一般不推荐使用。</span><br><span class="line"># appendfsync always </span><br><span class="line"></span><br><span class="line">#完全依赖操作系统的写入，一般为30秒左右一次，性能最好但是数据安全性无法保证，不被推荐。</span><br><span class="line"># appendfsync no  </span><br><span class="line"></span><br><span class="line">#每秒钟强制写入磁盘一次，兼顾性能和数据安全性，在性能和持久化方面做了很好的折中，理论上只有在系统突然宕机的情况下丢失1秒的数据。是受推荐的方式。</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p>
<p>重写的过程主要做了一下事情：</p>
<p>1）进程内已经超时的数据不再写入文件。</p>
<p>2）旧的AOF文件中的无效命令不再写入，如delkey1、hdelkey2、sremkeys、seta111、seta222 等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p>
<p>3）多条写命令可以合并为一个，如：lpushlista、lpushlistb、lpushlistc可以转化为：lpushlistabc。</p>
<p>具体的重写流程如下图所示：</p>
<p><img src="/images/20180808013.png" alt=""></p>
<p>可以通过下面配置设置什么时候开启自动重写：</p>
<p>AOF重写过程可以手动触发（直接调用bgrewriteaof命令）和自动触发：根据配置的auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># AOF文件名  </span><br><span class="line">appendfilename appendonly.aof </span><br><span class="line"></span><br><span class="line">#当进程中BGSAVE或BGREWRITEAOF命令正在执行时不阻止主进程中的fsync()调用（默认为no，当存在延迟问题时需调整为yes）  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">#当AOF增长率为100%且达到了64mb时开始自动重写AOF  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>


<h3 id="重启加载-数据恢复"><a href="#重启加载-数据恢复" class="headerlink" title="重启加载(数据恢复)"></a>重启加载(数据恢复)</h3><p>RDB 和 AOF 文件都可以用于服务器重启时的数据恢复。</p>
<p>下图为 Redis 持久化文件加载流程(即重启阶段恢复数据的流程)：</p>
<p><img src="/images/20180808014.png" alt=""></p>
<p>流程说明：</p>
<p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p>
<p>2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p>
<p>3）加载AOF/RDB文件成功 后，Redis 启动成功。 </p>
<p>4）AOF/RDB文件存在错误时，Redis 启动失败并打印错误信息。</p>
<h2 id="六、Redis-为什么速度快"><a href="#六、Redis-为什么速度快" class="headerlink" title="六、Redis 为什么速度快"></a>六、Redis 为什么速度快</h2><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p>
<ul>
<li><p>纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒。</p>
</li>
<li><p>Redis采用了单线程设计，单线程避免了线程切换和竞态产生消耗。</p>
</li>
<li><p>Redis采用了非阻塞I/O模型，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p>
</li>
<li><p>Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p>
</li>
</ul>
<h2 id="七、Redis-为什么采用单线程"><a href="#七、Redis-为什么采用单线程" class="headerlink" title="七、Redis 为什么采用单线程"></a>七、Redis 为什么采用单线程</h2><p>Redis 为什么采用单线程设计，主要原因如下：</p>
<ul>
<li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li>
<li>采用单线程设计，可以极大简化数据结构和算法的实现，使代码更清晰，处理逻辑更简单。</li>
<li>单线程避免了不必要的线程切换和竞态产生消耗。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，不会出现死锁而导致的性能消耗。</li>
</ul>
<p>采用单线程设计也有一个弊端，就是无法发挥多核CPU性能，如果某个命令执行过长，会造成其他命令的阻塞。</p>
<p>解决的办法是，通过在一个多核的机器上部署多个redis实例，组成master-master，master-slave的形式，实现读写分离。把耗时的读命令完全可以放到slave中来解决。</p>
<h2 id="八、Redis的内部结构"><a href="#八、Redis的内部结构" class="headerlink" title="八、Redis的内部结构"></a>八、Redis的内部结构</h2><p>Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p>
<p>可以通过阅读 <a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a> 来学习。<br>还可以参考下 <a href="http://zhangtielei.com/posts/server.html" target="_blank" rel="noopener">Redis内部数据结构详解</a> 系列博客</p>
<h2 id="九、Redis-集群方案与实现"><a href="#九、Redis-集群方案与实现" class="headerlink" title="九、Redis 集群方案与实现"></a>九、Redis 集群方案与实现</h2><p>后面会单独写篇文章讲 Redis 的 复制、哨兵、集群。</p>
<h2 id="十、Redis-与-Memcached-的差异"><a href="#十、Redis-与-Memcached-的差异" class="headerlink" title="十、Redis 与 Memcached 的差异"></a>十、Redis 与 Memcached 的差异</h2><p>Redis 和 Memcache 都是基于内存的数据存储系统。Redis是一个开源的key-value存储系统，而Memcached是高性能分布式内存缓存服务。那么Redis 与 Memcached 之间有什么区别呢？</p>
<p>Redis的作者Salvatore Sanfilippo曾经对这两种基于内存的数据存储系统进行过比较：</p>
<ul>
<li><p>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p>
</li>
<li><p>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p>
</li>
<li><p>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p>
</li>
</ul>
<h3 id="数据类型支持不同"><a href="#数据类型支持不同" class="headerlink" title="数据类型支持不同"></a>数据类型支持不同</h3><p>Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。</p>
<p>Memcached仅支持简单的key-value结构的数据记录。</p>
<h3 id="内存管理机制不同"><a href="#内存管理机制不同" class="headerlink" title="内存管理机制不同"></a>内存管理机制不同</h3><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
<p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。</p>
<p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题，但是它最大的缺点就是会导致空间浪费，因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
<h3 id="数据持久化支持"><a href="#数据持久化支持" class="headerlink" title="数据持久化支持"></a>数据持久化支持</h3><p>Redis支持内存数据的持久化，而且提供了RDB快照和AOF日志两种主要的持久化策略。</p>
<p>memcached是不支持数据持久化操作的。</p>
<h3 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h3><p>Redis 本身提供了 Cluster，引入Master节点和Slave节点，支持在服务器端构建分布式存储。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>
<p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p>
<h2 id="十一、参考文献"><a href="#十一、参考文献" class="headerlink" title="十一、参考文献"></a>十一、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://redislabs.com/community/ebook/" target="_blank" rel="noopener">《Redis IN ACTION》</a> ah L. Carlson<br>[3] <a href="http://blog.720ui.com/columns/redis_action_all/" target="_blank" rel="noopener">Redis实战 文集</a><br>[4] <a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis应用场景</a><br>[5] <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考</a><br>[6] <a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述Redis和Memcached的差异</a><br>[7] <a href="https://www.zhihu.com/question/19645807" target="_blank" rel="noopener">MongoDB 或者 redis 可以替代 memcached 吗?</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储 2：分布式系统全局唯一ID生成方案</title>
    <url>/2018/07/21/unique-id-generate/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近在 ifeve.com 看到这么一个面试题 “<a href="http://ifeve.com/question/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%9C%89%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%B2%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%8C%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82/" target="_blank" rel="noopener">京东面试题 – 有一个生成唯一串的需求，并发请求量非常大，该如何实现？</a>”。在现实开发中，这也是必须要考虑到的一个点。比如分库分表后主键采用什么策略生成？在分布式系统中如何生成唯一ID标识？</p>
<a id="more"></a>

<p>从业务上来说，常见的如订单号，支付单号等，都需要唯一 ID 做标识，简单的数据库递增是不能满足的，因为这样既会显得不专业，也会不安全，比如你的竞争对手可以今天中午12点下个单记录下订单号，明天中午12点再下个单，通过对比2个订单号大概计算出你们的订单量，这是非常可怕的事情。</p>
<p><strong>那么，业务系统对ID号有哪些要求呢？</strong></p>
<ol>
<li><p>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p>
</li>
<li><p>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，是用B+tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。针对这点，后面根据索引原理展开讲一下。</p>
</li>
<li><p>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</p>
</li>
<li><p>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p>
</li>
</ol>
<p><strong>这里结合索引原理展开讲下为什么ID需要趋势递增</strong><br>InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用选用趋势递增的ID作为主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。如下图所示：</p>
<p><img src="/images/2018072401.png" alt=""></p>
<p>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。否则，如使用身份证号或学号等无序的数作为主键，则每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动大量数据，从而降低写入数据的性能。如下图所示：</p>
<p><img src="/images/2018072402.png" alt=""></p>
<h2 id="二、Twitter的snowflake方案"><a href="#二、Twitter的snowflake方案" class="headerlink" title="二、Twitter的snowflake方案"></a>二、Twitter的snowflake方案</h2><p>snowflake 是 Twitter 开源的分布式ID生成算法，是一种划分命名空间来生成ID的一种算法，结果是一个long型的ID。其核心思想是：把64-bit分别划分成多段。如下图所示：<br><img src="/images/2018072301.png" alt=""></p>
<p>其中，41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给数据中心(IDC)，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<p>这种方式的优缺点是：</p>
<p><strong>优点：</strong></p>
<ul>
<li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li>
<li>可以根据自身业务特性分配bit位，非常灵活。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p>
<p>具体实现的代码可以参看：<a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">https://github.com/twitter/snowflake</a>，遗憾的是 snowflake 已经不再维护，但是还是可以下载  snowflake-2010 tag , 下载的版本是用 scala 实现的。我们可以根据思想，自己用java语言实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==============================Fields===========================================</span></span><br><span class="line">    <span class="comment">/** 开始时间截 (2010/11/4 9:42:54) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdFactory</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Test=============================================</span></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	IdFactory idFactory = <span class="keyword">new</span> IdFactory(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//传入工作ID (0~31),数据中心ID (0~31)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idFactory.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、Flicker-团队的数据库生成方案"><a href="#三、Flicker-团队的数据库生成方案" class="headerlink" title="三、Flicker 团队的数据库生成方案"></a>三、Flicker 团队的数据库生成方案</h2><p>在分布式系统中，为了解决单点故障问题、单点IO性能问题，在分布式系统中，我们的数据库服务器往往也不只一台，那么在多台数据库服务器的情况下如何生成符合要求的ID呢？Flickr团队在2010年撰文介绍的一种主键生成策略(<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>)。这种方案的思想是给不同的机器设置不同的初始值，相同的步长。</p>
<p>比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p>
<p><img src="/images/2018072302.png" alt=""></p>
<p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。机器多的时候要扩容十分复杂。</li>
<li>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h2 id="四、美团的Leaf-segment数据库方案"><a href="#四、美团的Leaf-segment数据库方案" class="headerlink" title="四、美团的Leaf-segment数据库方案"></a>四、美团的Leaf-segment数据库方案</h2><p>Leaf-segment 在使用数据库的方案上做了优化，利用proxy server批量获取，每次获取一段IDs(step决定大小)，然后把这段IDs作为id池缓存起来使用。用完之后再去数据库获取新的号段，从而大大的减轻数据库的压力。解决了原方案每次获取ID都得读写一次数据库，造成数据库压力大的问题。Leaf-segment的总体架构如下：</p>
<p><img src="/images/2018072303.png" alt=""></p>
<p>这种模式有以下优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<p>Leaf-segment 后2点缺点，Leaf-segment做了双buffer优化，以及“一主两从”的高可用容灾。</p>
<h2 id="五、美团的Leaf-snowflake方案"><a href="#五、美团的Leaf-snowflake方案" class="headerlink" title="五、美团的Leaf-snowflake方案"></a>五、美团的Leaf-snowflake方案</h2><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID等生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是非常可怕的。针对这一问题，美团点评提供了 Leaf-snowflake 方案，用于满足对这种安全性有要求的场景。</p>
<p><img src="/images/2018072304.png" alt=""></p>
<p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。相比 snowflake，Leaf-snowflake做了以下2点优化：</p>
<ol>
<li>使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID，一定程度的提高系统的伸缩性和容错性。</li>
<li>解决时钟回拨会可能导致生成重复的ID号的问题。</li>
</ol>
<p>Leaf-snowflake 的架构图如下：</p>
<p><img src="/images/2018072305.png" alt=""></p>
<p><strong>Leaf-snowflake是按照下面几个步骤启动的：</strong></p>
<ol>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ol>
<h2 id="六、微信的序列号生成器seqsvr"><a href="#六、微信的序列号生成器seqsvr" class="headerlink" title="六、微信的序列号生成器seqsvr"></a>六、微信的序列号生成器seqsvr</h2><p>seqsvr 是微信的一个高可用、高可靠的序列号生成器，利用生成的序列号，实现终端与后台的数据增量同步机制。这套同步机制仍然在消息收发、朋友圈通知、好友数据更新等需要数据同步的地方发挥着核心的作用。seqsvr的架构可以分为两层，即StoreSvr和AllocSvr（存储层和缓存中间层）。</p>
<p>架构图如下：</p>
<p><img src="/images/2018072306.png" alt=""></p>
<p>seqsvr 的设计考虑有其殊性，比如按用户id进行切分。但是其实现还有一些容灾设计事非常值得参考的。</p>
<p>具体细节及演进过程可看 <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/</a></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>[1] <a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter snowflake</a></p>
<p>[2] <a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a></p>
<p>[3] <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">微信序列号生成器架构设计及演变</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Apache CXF 实现Web Service</title>
    <url>/2018/04/15/webserver-apache-xcf/</url>
    <content><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1、Web-service的概念："><a href="#1、Web-service的概念：" class="headerlink" title="1、Web service的概念："></a>1、Web service的概念：</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。Web Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署，Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。</p>
<a id="more"></a>

<h3 id="2、Web-Service有以下的优越性："><a href="#2、Web-Service有以下的优越性：" class="headerlink" title="2、Web Service有以下的优越性："></a>2、Web Service有以下的优越性：</h3><p>1）平台无关。不管你使用什么平台，都可以使用Web service。<br>2）编程语言无关。只要遵守相关协议，就可以使用任意编程语言，向其他网站要求Web service。这大大增加了web service的适用性，降低了对程序员的要求。<br>3）对于Webservice提供者来说，部署、升级和维护Web service都非常单纯，不需要考虑客户端兼容问题，而且一次性就能完成。<br>4）对于Webservice使用者来说，可以轻易实现多种数据、多种服务的聚合（mashup），因此能够做出一些以前根本无法想像的事情。</p>
<h3 id="3、Apache-CXF的概念"><a href="#3、Apache-CXF的概念" class="headerlink" title="3、Apache CXF的概念"></a>3、Apache CXF的概念</h3><p>Apache CXF是Apache旗下一个重磅的SOA简易框架，CXF 继承了 Celtix 和 XFire 两大开源项目的精华，提供了多种Binding 、DataBinding、Transport 以及各种 Format 的支持，并且可以根据实际项目的需要，采用代码优先（Code First）或者 WSDL 优先（WSDL First）来轻松地实现 Web Services 的发布和使用。而且可以天然的和Spring进行无缝集成。(CXF不仅支持嵌入式代码中通过jetty发布WebService，也可以通过Web容器发布WebService。)</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><h3 id="1-服务提供方实现"><a href="#1-服务提供方实现" class="headerlink" title="1.服务提供方实现"></a>1.服务提供方实现</h3><h4 id="1-引入jar"><a href="#1-引入jar" class="headerlink" title="1) 引入jar"></a>1) 引入jar</h4><pre><code>可在http://cxf.apache.org/download.html 可在下载，也可以用maven引入</code></pre><h4 id="2）实现接口类和实现类"><a href="#2）实现接口类和实现类" class="headerlink" title="2）实现接口类和实现类"></a>2）实现接口类和实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cxfdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CXFDemoService</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String foo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cxfdemo;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CXFDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">CXFDemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3）通过-Web-容器发布-WebService"><a href="#3）通过-Web-容器发布-WebService" class="headerlink" title="3）通过 Web 容器发布 WebService"></a>3）通过 Web 容器发布 WebService</h4><p>CXF提供了spring的集成，同时还提供了org.apache.cxf.transport.servlet.CXFServlet用于在web容器中发布WebService。 前面的例子中增加了整个apache-cxf的依赖，所以会自动增加对srping的引用。</p>
<h5 id="3-1-只需要写beans配置文件和web-xml文件即可。"><a href="#3-1-只需要写beans配置文件和web-xml文件即可。" class="headerlink" title="3.1)只需要写beans配置文件和web.xml文件即可。"></a>3.1)只需要写beans配置文件和web.xml文件即可。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &lt;!-- CXF --&gt;</span><br><span class="line">&lt;servlet&gt;      </span><br><span class="line">      &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;      </span><br><span class="line">      &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;      </span></span><br><span class="line"><span class="class">          <span class="title">org</span>.<span class="title">apache</span>.<span class="title">cxf</span>.<span class="title">transport</span>.<span class="title">servlet</span>.<span class="title">CXFServlet</span>       </span></span><br><span class="line"><span class="class">      &lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;/<span class="title">servlet</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">CXFServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">webservice</span>/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>在web.xml中增加spring的ContextLoaderListener并配置context-param</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加对spring的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/classes/applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Spring ApplicationContext 载入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-添加bean配置文件-applicationContext-cxf-xml-自定义的名字"><a href="#3-2-添加bean配置文件-applicationContext-cxf-xml-自定义的名字" class="headerlink" title="3.2)添加bean配置文件   applicationContext-cxf.xml (自定义的名字)"></a>3.2)添加bean配置文件   applicationContext-cxf.xml (自定义的名字)</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:jaxws</span>=<span class="string">"http://cxf.apache.org/jaxws"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">xsi:schemaLocation</span>=<span class="string">"   </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/beans/spring-beans.xsd   </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://cxf.apache.org/jaxws </span></span></span><br><span class="line"><span class="tag"><span class="string">      http://cxf.apache.org/schemas/jaxws.xsd"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf.xml"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-extension-soap.xml"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-servlet.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">address</span>=<span class="string">"/CXFDemoService"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">implementor</span>=<span class="string">"#CXFDemoServiceImpl "</span></span></span><br><span class="line"><span class="tag">		<span class="attr">serviceName</span>=<span class="string">"CXFDemoService"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!--有多个可写一起--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">address</span>=<span class="string">"/CXFDemoService2"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">implementor</span>=<span class="string">"#CXFDemoService2Impl "</span></span></span><br><span class="line"><span class="tag">		<span class="attr">serviceName</span>=<span class="string">"CXFDemoService2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>启动Tomcat WebService就已经在web容器中发布了。</strong></p>
<h3 id="2-使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务"><a href="#2-使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务" class="headerlink" title="2.使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务"></a>2.使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        JaxWsProxyFactoryBean factoryBean = <span class="keyword">new</span> JaxWsProxyFactoryBean();  </span><br><span class="line">        factoryBean.setServiceClass(CXFDemoService<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        <span class="comment">//webService提供方的地址</span></span><br><span class="line">        factoryBean.setAddress(<span class="string">"http://localhost:8080/webservice/CXFDemoService"</span>); </span><br><span class="line">        CXFDemoService cXFDemoService= (CXFDemoService)factoryBean.create();  </span><br><span class="line">        String returnResult = cXFDemoService.sayHello(<span class="string">" webService"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"调用结果:"</span>+returnResult );  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>参考文章<br><a href="http://cxshun.iteye.com/blog/1275408" target="_blank" rel="noopener">http://cxshun.iteye.com/blog/1275408</a><br><a href="https://blog.csdn.net/shb_derek1/article/details/8018287" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/8018287</a></p>
]]></content>
      <categories>
        <category>WebService</category>
      </categories>
      <tags>
        <tag>webservice</tag>
      </tags>
  </entry>
  <entry>
    <title>慢谈 Redis 实现分布式锁 以及 Redisson 源码解析</title>
    <url>/2019/08/24/distributed-locks-with-redis/</url>
    <content><![CDATA[<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="# 产生背景"></a><a href="#产生背景" title="# 产生背景"></a># 产生背景</h2><blockquote>
<p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p>
</blockquote>
<p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p>
<p>随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p>
<a id="more"></a>

<h2 id="实现分布式锁的三种选择"><a href="#实现分布式锁的三种选择" class="headerlink" title="# 实现分布式锁的三种选择"></a><a href="#实现分布式锁的三种选择" title="# 实现分布式锁的三种选择"></a># 实现分布式锁的三种选择</h2><ul>
<li>基于数据库实现分布式锁*   基于zookeeper实现分布式锁</li>
<li>基于Redis缓存实现分布式锁</li>
</ul>
<p>以上三种方式都可以实现分布式锁，其中，从健壮性考虑， 用 zookeeper 会比用 Redis 实现更好，但从性能角度考虑，基于 Redis 实现性能会更好，如何选择，还是取决于业务需求。</p>
<h2 id="基于-Redis-实现分布式锁的三种方案"><a href="#基于-Redis-实现分布式锁的三种方案" class="headerlink" title="# 基于 Redis 实现分布式锁的三种方案"></a><a href="#基于-Redis-实现分布式锁的三种方案" title="# 基于 Redis 实现分布式锁的三种方案"></a># 基于 Redis 实现分布式锁的三种方案</h2><ul>
<li>用 Redis 实现分布式锁的正确姿势（实现一）</li>
<li>用 Redisson 实现分布式可重入锁（RedissonLock）（实现二）</li>
<li>用 Redisson 实现分布式锁(红锁 RedissonRedLock)（实现三）</li>
</ul>
<p><strong>本文主要探讨基于 Redis 实现分布式锁的方案，主要分析并对比了以上三种方案，并大致分析了 Redisson 的 RedissonLock 、 RedissonRedLock 源码。</strong></p>
<h2 id="分布式锁需满足四个条件"><a href="#分布式锁需满足四个条件" class="headerlink" title="# 分布式锁需满足四个条件"></a><a href="#分布式锁需满足四个条件" title="# 分布式锁需满足四个条件"></a># 分布式锁需满足四个条件</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li>
<li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li>
</ol>
<h2 id="用-Redis-实现分布式锁的正确姿势（实现一）"><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" class="headerlink" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a># 用 Redis 实现分布式锁的正确姿势（实现一）</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a><a href="#主要思路" title="主要思路"></a>主要思路</h3><p>通过 set key value px milliseconds nx 命令实现加锁， 通过Lua脚本实现解锁。核心实现命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁（unique_value可以是UUID等）</span></span>
<span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span>
<span class="line"></span>
<span class="line"><span class="comment">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span></span>
<span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span>
<span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span>
<span class="line"><span class="keyword">else</span></span>
<span class="line">    <span class="keyword">return</span> <span class="number">0</span></span>
<span class="line">end</span>
</pre></td></tr></table></figure>

<p>这种实现方式主要有以下几个要点：</p>
<ul>
<li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p>
</li>
<li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p>
</li>
<li><p>释放锁时要验证 value 值，防止误解锁；</p>
</li>
<li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p>
</li>
</ul>
<h3 id="完整代码实现如下："><a href="#完整代码实现如下：" class="headerlink" title="完整代码实现如下："></a><a href="#完整代码实现如下：" title="完整代码实现如下："></a>完整代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span>
<span class="line">        </span>
<span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><a href="#加锁代码分析" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>
<h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><a href="#解锁代码分析" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p>
<h3 id="这种方式仍存在单点风险"><a href="#这种方式仍存在单点风险" class="headerlink" title="这种方式仍存在单点风险"></a><a href="#这种方式仍存在单点风险" title="这种方式仍存在单点风险"></a>这种方式仍存在单点风险</h3><p><strong>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</strong></p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。</li>
<li>主从切换，slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</li>
</ol>
<p><strong>所以在这种实现之下，不论Redis的部署架构是单机模式、主从模式、哨兵模式还是集群模式，都存在这种风险。因为Redis的主从同步是异步的。 运行的是，Redis 之父 antirez 提出了 redlock算法 可以解决这个问题。</strong></p>
<h2 id="Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" class="headerlink" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</h2><h3 id="什么是-Redisson"><a href="#什么是-Redisson" class="headerlink" title="什么是 Redisson"></a><a href="#什么是-Redisson" title="什么是 Redisson"></a>什么是 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><a href="#Redisson-分布式重入锁用法" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span>
<span class="line">Config config = <span class="keyword">new</span> Config();</span>
<span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line"><span class="comment">// 2.构造RedissonClient</span></span>
<span class="line">RedissonClient redissonClient = Redisson.create(config);</span>
<span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span>
<span class="line">RLock rLock = redissonClient.getLock(lockKey);</span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    rLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁源码分析"><a href="#加锁源码分析" class="headerlink" title="加锁源码分析"></a><a href="#加锁源码分析" title="加锁源码分析"></a>加锁源码分析</h3><p><strong>1.通过 getLock 方法获取对象</strong></p>
<p><strong>org.redisson.Redisson#getLock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     *  构造并返回一个 RedissonLock 对象 </span></span>
<span class="line"><span class="comment">     * commandExecutor: 与 Redis 节点通信并发送指令的真正实现。需要说明一下，CommandExecutor 实现是通过 eval 命令来执行 Lua 脚本</span></span>
<span class="line"><span class="comment">     * name: 锁的全局名称</span></span>
<span class="line"><span class="comment">     * id: Redisson 客户端唯一标识，实际上就是一个 UUID.randomUUID()</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name, id);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>2.通过tryLock方法尝试获取锁</strong></p>
<p>tryLock方法里的调用关系大致如下：</p>
<p><img src="/images/2019041501.png" alt=""></p>
<p><strong>org.redisson.RedissonLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="comment">//取得最大等待时间</span></span>
<span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span>
<span class="line">    <span class="comment">//记录下当前时间</span></span>
<span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span>
<span class="line">    <span class="comment">//取得当前线程id（判断是否可重入锁的关键）</span></span>
<span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span>
<span class="line">    <span class="comment">//1.尝试申请锁，返回还剩余的锁过期时间</span></span>
<span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">    <span class="comment">//2.如果为空，表示申请锁成功</span></span>
<span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="comment">//3.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span>
<span class="line">    time -= System.currentTimeMillis() - current;</span>
<span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 通过 promise.trySuccess 设置异步执行的结果为null</span></span>
<span class="line"><span class="comment">         * Promise从Uncompleted--&gt;Completed ,通知 Future 异步执行已完成</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    current = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.订阅锁释放事件，并通过await方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：</span></span>
<span class="line"><span class="comment">     * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争</span></span>
<span class="line"><span class="comment">     * 当 this.await返回false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败</span></span>
<span class="line"><span class="comment">     * 当 this.await返回true，进入循环尝试获取锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span>
<span class="line">    <span class="comment">//await 方法内部是用CountDownLatch来实现阻塞，获取subscribe异步执行的结果（应用了Netty 的 Future）</span></span>
<span class="line">    <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span>
<span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span>
<span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span>
<span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    unsubscribe(subscribeFuture, threadId);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;);</span>
<span class="line">        &#125;</span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        <span class="comment">//计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败</span></span>
<span class="line">        time -= System.currentTimeMillis() - current;</span>
<span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">            acquireFailed(threadId);</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 5.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁</span></span>
<span class="line"><span class="comment">         * 获取锁成功，则立马返回true，</span></span>
<span class="line"><span class="comment">         * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回false结束循环</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="comment">// 再次尝试申请锁</span></span>
<span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">            <span class="comment">// 成功获取锁则直接返回true结束循环</span></span>
<span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//超过最大等待时间则返回false结束循环，获取锁失败</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span>
<span class="line">                <span class="comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="comment">//则就在wait time 时间范围内等待可以通过信号量</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//7.更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125; <span class="keyword">finally</span> &#123;</span>
<span class="line">        <span class="comment">//7.无论是否获得锁,都要取消订阅解锁消息</span></span>
<span class="line">        unsubscribe(subscribeFuture, threadId);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>其中 tryAcquire 内部通过调用 tryLockInnerAsync 实现申请锁的逻辑。申请锁并返回锁有效期还剩余的时间，如果为空说明锁未被其它线程申请则直接获取并返回，如果获取到时间，则进入等待竞争逻辑。</p>
<p><strong>org.redisson.RedissonLock#tryLockInnerAsync</strong></p>
<p><strong>加锁流程图：</strong><br><img src="/images/2019041502.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span>
<span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span>
<span class="line">              <span class="comment">// 1.如果缓存中的key不存在，则执行 hset 命令(hset key UUID+threadId 1),然后通过 pexpire 命令设置锁的过期时间(即锁的租约时间)</span></span>
<span class="line">              <span class="comment">// 返回空值 nil ，表示获取锁成功</span></span>
<span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">// 如果key已经存在，并且value也匹配，表示是当前线程持有的锁，则执行 hincrby 命令，重入次数加1，并且设置失效时间</span></span>
<span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">//如果key已经存在，但是value不匹配，说明锁已经被其他线程持有，通过 pttl 命令获取锁的剩余存活时间并返回，至此获取锁失败</span></span>
<span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span>
<span class="line">               <span class="comment">//这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span>
<span class="line">               Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><p>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key；</p>
</li>
<li><p>ARGV[1]就是internalLockLeaseTime，即锁的租约时间（持有锁的有效时间），默认30s；</p>
</li>
<li><p>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值 value，即UUID+threadId。</p>
</li>
</ul>
<h3 id="解锁源码分析"><a href="#解锁源码分析" class="headerlink" title="解锁源码分析"></a><a href="#解锁源码分析" title="解锁源码分析"></a>解锁源码分析</h3><p>unlock 内部通过 get(unlockAsync(Thread.currentThread().getId()))  调用 unlockInnerAsync 解锁。</p>
<p><strong>org.redisson.RedissonLock#unlock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span>
<span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span>
<span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span>
<span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="keyword">throw</span> e;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>get方法利用是 CountDownLatch 在异步调用结果返回前将当前线程阻塞，然后通过 Netty 的 FutureListener 在异步调用完成后解除阻塞，并返回调用结果。</p>
<p><strong>org.redisson.command.CommandAsyncService#get</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;   <span class="comment">//任务还没完成</span></span>
<span class="line">        <span class="comment">// 设置一个单线程的同步控制器</span></span>
<span class="line">        CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span>
<span class="line">        future.onComplete((res, e) -&gt; &#123;</span>
<span class="line">            <span class="comment">//操作完成时，唤醒在await()方法中等待的线程</span></span>
<span class="line">            l.countDown();</span>
<span class="line">        &#125;);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span>
<span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span>
<span class="line">            <span class="keyword">try</span> &#123;</span>
<span class="line">                <span class="comment">//阻塞等待</span></span>
<span class="line">                l.await();</span>
<span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span>
<span class="line">                interrupted = <span class="keyword">true</span>;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span>
<span class="line">            Thread.currentThread().interrupt();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span>
<span class="line">        <span class="keyword">return</span> future.getNow();</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">throw</span> convertException(future);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>org.redisson.RedissonLock#unlockInnerAsync</strong></p>
<p><strong>解锁流程图：</strong><br><img src="/images/2019041503.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span>
<span class="line">            <span class="comment">//如果分布式锁存在，但是value不匹配，表示锁已经被其他线程占用，无权释放锁，那么直接返回空值（解铃还须系铃人）</span></span>
<span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span>
<span class="line">                <span class="string">"return nil;"</span> +</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">             <span class="comment">//如果value匹配，则就是当前线程占有分布式锁，那么将重入次数减1</span></span>
<span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只能更新失效时间，还不能删除</span></span>
<span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span>
<span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span>
<span class="line">                <span class="string">"return 0; "</span> +</span>
<span class="line">            <span class="string">"else "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果为0，这时就可以删除这个KEY，并发布解锁消息，返回1</span></span>
<span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span>
<span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span>
<span class="line">                <span class="string">"return 1; "</span>+</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">            <span class="string">"return nil;"</span>,</span>
<span class="line">            <span class="comment">//这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span>
<span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="解锁消息处理"><a href="#解锁消息处理" class="headerlink" title="解锁消息处理"></a><a href="#解锁消息处理" title="解锁消息处理"></a>解锁消息处理</h3><p><strong>org.redisson.pubsub#onMessage</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_MESSAGE = <span class="number">0L</span>;</span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long READ_UNLOCK_MESSAGE = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockPubSub</span><span class="params">(PublishSubscribeService service)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">super</span>(service);</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 判断是否是解锁消息</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 释放一个信号量，唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            value.getLatch().release();</span>
<span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">                <span class="comment">/**</span></span>
<span class="line"><span class="comment">                 * 如果还有其他Listeners回调，则也唤醒执行</span></span>
<span class="line"><span class="comment">                 */</span></span>
<span class="line">                Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    <span class="keyword">break</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            value.getLatch().release(value.getLatch().getQueueLength());</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><a href="#总结对比" title="总结对比"></a>总结对比</h3><p>通过 Redisson 实现分布式可重入锁（实现二），比纯自己通过set key value px milliseconds nx +lua 实现（实现一）的效果更好些，虽然基本原理都一样，因为通过分析源码可知，RedissonLock<br>是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。   </p>
<p><strong>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</strong></p>
<p><strong>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</strong></p>
<h2 id="redlock算法"><a href="#redlock算法" class="headerlink" title="# redlock算法"></a><a href="#redlock算法" title="# redlock算法"></a># redlock算法</h2><p>Redis 官网对 redLock 算法的介绍大致如下：</p>
<blockquote>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">The Redlock algorithm</a></p>
</blockquote>
<p>在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li><p>获取当前Unix时间，以毫秒为单位。</p>
</li>
<li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p>
</li>
<li><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p>
</li>
<li><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p>
</li>
</ol>
<h2 id="用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" class="headerlink" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</h2><p>这里以三个单机模式为例，需要特别注意的是他们完全互相独立，不存在主从复制或者其他集群协调机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
</pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span>
<span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span>
<span class="line"></span>
<span class="line">Config config2 = <span class="keyword">new</span> Config();</span>
<span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span>
<span class="line"></span>
<span class="line">Config config3 = <span class="keyword">new</span> Config();</span>
<span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span>
<span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span>
<span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span>
<span class="line"></span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    redLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>最核心的变化就是需要构建多个 RLock ,然后根据多个 RLock 构建成一个 RedissonRedLock，因为 redLock 算法是建立在多个互相独立的 Redis 环境之上的（为了区分可以叫为 Redission node），Redission node 节点既可以是单机模式(single)，也可以是主从模式(master/salve)，哨兵模式(sentinal)，或者集群模式(cluster)。这就意味着，不能跟以往这样只搭建 1个 cluster、或 1个 sentinel 集群，或是1套主从架构就了事了，需要为 RedissonRedLock 额外搭建多几套独立的 Redission 节点。 比如可以搭建3个 或者5个 Redission节点，具体可看视资源及业务情况而定。</strong></p>
<p><strong>下图是一个利用多个 Redission node 最终 组成 RedLock分布式锁的例子，需要特别注意的是每个  Redission node 是互相独立的，不存在任何复制或者其他隐含的分布式协调机制。</strong></p>
<p><img src="/images/2019041504.png" alt=""><br><img src="/images/2019041505.png" alt=""></p>
<h2 id="Redisson-实现redlock算法源码分析（RedLock）"><a href="#Redisson-实现redlock算法源码分析（RedLock）" class="headerlink" title="# Redisson 实现redlock算法源码分析（RedLock）"></a><a href="#Redisson-实现redlock算法源码分析（RedLock）" title="# Redisson 实现redlock算法源码分析（RedLock）"></a># Redisson 实现redlock算法源码分析（RedLock）</h2><p><strong>加锁核心代码</strong></p>
<p> <strong>org.redisson.RedissonMultiLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
<span class="line">101</span>
<span class="line">102</span>
<span class="line">103</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span>
<span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        remainTime = unit.toMillis(waitTime);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 1\. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 2\. 遍历所有节点通过EVAL命令执行lua加锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span>
<span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span>
<span class="line">        RLock lock = iterator.next();</span>
<span class="line">        <span class="keyword">boolean</span> lockAcquired;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">try</span> &#123;</span>
<span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                lockAcquired = lock.tryLock();</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span>
<span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span>
<span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span>
<span class="line">            unlockInner(Arrays.asList(lock));</span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             *4\. 如果获取到锁则添加到已获取锁集合中</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            acquiredLocks.add(lock);</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 5\. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span>
<span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span>
<span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                failedLocksLimit = failedLocksLimit();</span>
<span class="line">                acquiredLocks.clear();</span>
<span class="line">                <span class="comment">// reset iterator</span></span>
<span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span>
<span class="line">                    iterator.previous();</span>
<span class="line">                &#125;</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                failedLocksLimit--;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span>
<span class="line">            remainTime -= System.currentTimeMillis() - time;</span>
<span class="line">            time = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span>
<span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span>
<span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span>
<span class="line">            futures.add(future);</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span>
<span class="line">            rFuture.syncUninterruptibly();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p>
<p>[2]<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Distributed locks with Redis 中文版</a></p>
<p>[3]<a href="https://redis.io/commands/set" target="_blank" rel="noopener">SET - Redis</a></p>
<p>[4]<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">EVAL command</a></p>
<p>[5] <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></p>
<p>[6]<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p>
<p>[7]<a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">Redlock实现分布式锁</a></p>
<p>[8]<a href="https://mp.weixin.qq.com/s/iaZcc7QGbGHkZkfLeYp1yg" target="_blank" rel="noopener">Redisson实现Redis分布式锁</a></p>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redisson</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part5：设计模式与范式-创建型</title>
    <url>/2020/10/09/design-pattern-creational-pattern/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p>
<ul>
<li><p>单例模式用来创建全局唯一的对象。</p>
</li>
<li><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。</p>
</li>
<li><p>建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
</li>
<li><p>原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h3><h4 id="处理资源访问冲突"><a href="#处理资源访问冲突" class="headerlink" title="处理资源访问冲突"></a>处理资源访问冲突</h4><p>可以使用单例解决资源访问冲突的问题。</p>
<p>案例：实现了一个往文件中打印日志的 Logger 类</p>
<p>第一版代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;</span><br><span class="line">  private Logger logger &#x3D; new Logger();</span><br><span class="line">  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    logger.log(&quot;Created an order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2466" alt="2b0e6141d10399430c59169af4edc3c2.jpeg"></p>
<p>改造一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2467" alt="203eb5070c3820b48500d4ab95732f29.jpeg"></p>
<p>FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题。</p>
<h5 id="通过类级别的锁解决日志覆盖问题"><a href="#通过类级别的锁解决日志覆盖问题" class="headerlink" title="通过类级别的锁解决日志覆盖问题"></a>通过类级别的锁解决日志覆盖问题</h5><p>把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。</p>
<p>单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line"></span><br><span class="line">  public Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    synchronized(Logger.class) &#123; &#x2F;&#x2F; 类级别的锁</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过单例更优雅的解决日志覆盖问题"><a href="#通过单例更优雅的解决日志覆盖问题" class="headerlink" title="通过单例更优雅的解决日志覆盖问题"></a>通过单例更优雅的解决日志覆盖问题</h5><p>将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private FileWriter writer;</span><br><span class="line">  private static final Logger instance &#x3D; new Logger();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;</span><br><span class="line">    File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);</span><br><span class="line">    writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static Logger getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(String message) &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Logger类的应用示例：</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  public void login(String username, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(username + &quot; logined!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderController &#123;  </span><br><span class="line">  public void create(OrderVo order) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略业务逻辑代码...</span><br><span class="line">    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="表示全局唯一类"><a href="#表示全局唯一类" class="headerlink" title="表示全局唯一类"></a>表示全局唯一类</h4><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。</p>
<p>案例：实现一个唯一递增 ID 号码生成器</p>
<p>如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">public class IdGenerator &#123;</span><br><span class="line">  &#x2F;&#x2F; AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br><span class="line">  &#x2F;&#x2F; 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br><span class="line">  &#x2F;&#x2F; 比如下面会用到的incrementAndGet().</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">long id &#x3D; IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>

<h3 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h3><p>要实现一个单例，主要关下面几个要点：</p>
<ul>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li>
<li>考虑对象创建时的线程安全问题；</li>
<li>考虑是否支持延迟加载；</li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ul>
<h4 id="饿汉式-不支持延迟加载"><a href="#饿汉式-不支持延迟加载" class="headerlink" title="饿汉式(不支持延迟加载)"></a>饿汉式(不支持延迟加载)</h4><p>在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="懒汉式（支持延迟加载、并发度低）"><a href="#懒汉式（支持延迟加载、并发度低）" class="headerlink" title="懒汉式（支持延迟加载、并发度低）"></a>懒汉式（支持延迟加载、并发度低）</h4><p>懒汉式相对于饿汉式的优势是支持延迟加载。给 getInstance() 这个方法加了一把大锁（synchronzed），这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static synchronized IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      instance &#x3D; new IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检测-（支持延迟加载，支持高并发）"><a href="#双重检测-（支持延迟加载，支持高并发）" class="headerlink" title="双重检测 （支持延迟加载，支持高并发）"></a>双重检测 （支持延迟加载，支持高并发）</h4><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">          instance &#x3D; new IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>低版本的JDK 因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。可以通过给 instance 成员变量加上 volatile 关键字，禁止指令重排序解决这个问题。  </p>
<p>需要注意的是高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。</p>
<h4 id="静态内部类-既保证了线程安全，又能做到延迟加载"><a href="#静态内部类-既保证了线程安全，又能做到延迟加载" class="headerlink" title="静态内部类 (既保证了线程安全，又能做到延迟加载)"></a>静态内部类 (既保证了线程安全，又能做到延迟加载)</h4><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p>
<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="评论区给出的一种Spring-源码中的实现"><a href="#评论区给出的一种Spring-源码中的实现" class="headerlink" title="评论区给出的一种Spring 源码中的实现"></a>评论区给出的一种Spring 源码中的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ublic class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance&#x3D;null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;&#x2F;&#x2F;</span><br><span class="line">        Singleton temp&#x3D;instance; &#x2F;&#x2F; 为什么要用局部变量来接收</span><br><span class="line">        if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                temp&#x3D;instance;</span><br><span class="line">                if (null &#x3D;&#x3D; temp) &#123;</span><br><span class="line">                    temp&#x3D;new Singleton();</span><br><span class="line">                    instance&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring源码 如 ReactiveAdapterRegistry。<br>JDK 源码 如 AbstractQueuedSynchronizer。<br>很多地方 都有用 局部变量 来接收 静态的成员变量， 请问下 这么写有什么性能上的优化点吗？</p>
<p>Using localRef, we are reducing the access of volatile variable to just one for positive usecase. If we do not use localRef, then we would have to access volatile variable twice - once for checking null and then at method return time.<br>Accessing volatile memory is quite an expensive affair because it involves reaching out to main memory.<br>参考链接：<a href="https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6" target="_blank" rel="noopener">https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6</a></p>
<h3 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h3><ul>
<li>单例对 OOP 特性的支持不友好</li>
<li>单例会隐藏类之间的依赖关系</li>
<li>单例对代码的扩展性不友好</li>
<li>单例对代码的可测试性不友好</li>
<li>单例不支持有参数的构造函数</li>
</ul>
<h3 id="有何替代的解决方案？"><a href="#有何替代的解决方案？" class="headerlink" title="有何替代的解决方案？"></a>有何替代的解决方案？</h3><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p>
<p>如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<h3 id="如何设计实现一个集群环境下的分布式单例模式？"><a href="#如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="如何设计实现一个集群环境下的分布式单例模式？"></a>如何设计实现一个集群环境下的分布式单例模式？</h3><h4 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h4><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<h4 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h4><p>通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    Long currentThreadId &#x3D; Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, new IdGenerator());</span><br><span class="line">    return instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long getId() &#123;</span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h4><p>这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);</span><br><span class="line">  private static DistributedLock lock &#x3D; new DistributedLock();</span><br><span class="line">  </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static IdGenerator getInstance() </span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      instance &#x3D; storage.load(IdGenerator.class);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchroinzed void freeInstance() &#123;</span><br><span class="line">    storage.save(this, IdGeneator.class);</span><br><span class="line">    instance &#x3D; null; &#x2F;&#x2F;释放对象</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">IdGenerator idGeneator &#x3D; IdGenerator.getInstance();</span><br><span class="line">long id &#x3D; idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>

<h4 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h4><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p>
<h5 id="创建指定数量的对象："><a href="#创建指定数量的对象：" class="headerlink" title="创建指定数量的对象："></a>创建指定数量的对象：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BackendServer &#123;</span><br><span class="line">  private long serverNo;</span><br><span class="line">  private String serverAddress;</span><br><span class="line"></span><br><span class="line">  private static final int SERVER_COUNT &#x3D; 3;</span><br><span class="line">  private static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));</span><br><span class="line">    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));</span><br><span class="line">    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private BackendServer(long serverNo, String serverAddress) &#123;</span><br><span class="line">    this.serverNo &#x3D; serverNo;</span><br><span class="line">    this.serverAddress &#x3D; serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getInstance(long serverNo) &#123;</span><br><span class="line">    return serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BackendServer getRandomInstance() &#123;</span><br><span class="line">    Random r &#x3D; new Random();</span><br><span class="line">    int no &#x3D; r.nextInt(SERVER_COUNT)+1;</span><br><span class="line">    return serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不同类型创建多个对象"><a href="#不同类型创建多个对象" class="headerlink" title="不同类型创建多个对象"></a>不同类型创建多个对象</h5><p>对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">  private static final ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private Logger() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static Logger getInstance(String loggerName) &#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, new Logger());</span><br><span class="line">    return instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void log() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3</span><br><span class="line">Logger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);</span><br><span class="line">Logger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</span><br></pre></td></tr></table></figure>


<h3 id="如何理解单例类对象的唯一性的作用范围是类加载器"><a href="#如何理解单例类对象的唯一性的作用范围是类加载器" class="headerlink" title="如何理解单例类对象的唯一性的作用范围是类加载器"></a>如何理解单例类对象的唯一性的作用范围是类加载器</h3><p>对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）,怎么理解？</p>
<p>java中，两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。单例类对象的唯一性前提也必须保证该类被同一个类加载器加载！</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如 Java 中的 Calendar、DateFormat 类。</p>
<p>工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。</p>
<h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><p>例子： 根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p>
<p>简单工厂的第一种实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    if (parser &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(</span><br><span class="line">              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    IRuleConfigParser parser &#x3D; null;</span><br><span class="line">    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new JsonRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new XmlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new YamlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser &#x3D; new PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p>
<p>简单工厂的第二种实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;</span><br><span class="line">      return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>可以利用多态去掉if分支逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRuleConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createParser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    if (parserFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="line">&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="line">public class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂</span><br><span class="line">  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParserFactory getParserFactory(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());</span><br><span class="line">    return parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h3><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createRuleParser();</span><br><span class="line">  ISystemConfigParser createSystemParser();</span><br><span class="line">  &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="什么时候该用工厂模式？"><a href="#什么时候该用工厂模式？" class="headerlink" title="什么时候该用工厂模式？"></a>什么时候该用工厂模式？</h4><ul>
<li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</p>
</li>
<li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
</li>
</ul>
<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p>
<h4 id="复杂度无法被消除，只能被转移："><a href="#复杂度无法被消除，只能被转移：" class="headerlink" title="复杂度无法被消除，只能被转移："></a>复杂度无法被消除，只能被转移：</h4><ul>
<li>不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起</li>
<li>简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中</li>
<li>工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中</li>
</ul>
<h3 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h3><p>一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。</p>
<p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<p>DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p>
<h3 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p>
<h3 id="如何实现一个简单的DI容器"><a href="#如何实现一个简单的DI容器" class="headerlink" title="如何实现一个简单的DI容器"></a>如何实现一个简单的DI容器</h3><p>一个简单的 DI 容器的实现原理，核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p>
<h4 id="1-最小原型设计"><a href="#1-最小原型设计" class="headerlink" title="1.最小原型设计"></a>1.最小原型设计</h4><p>配置文件beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>最小原型的使用方式跟 Spring 框架非常类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">            &quot;beans.xml&quot;);</span><br><span class="line">    RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-执行入口"><a href="#2-执行入口" class="headerlink" title="2.执行入口"></a>2.执行入口</h4><p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口ClassPathXmlApplicationContext 是接口的实现类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">  Object getBean(String beanId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;</span><br><span class="line">  private BeansFactory beansFactory;</span><br><span class="line">  private BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  public ClassPathXmlApplicationContext(String configLocation) &#123;</span><br><span class="line">    this.beansFactory &#x3D; new BeansFactory();</span><br><span class="line">    this.beanConfigParser &#x3D; new XmlBeanConfigParser();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void loadBeanDefinitions(String configLocation) &#123;</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);</span><br><span class="line">      if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO: log error</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    return beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p>
<h4 id="3-配置文件解析"><a href="#3-配置文件解析" class="headerlink" title="3.配置文件解析"></a>3.配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BeanConfigParser &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(InputStream inputStream);</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(String configContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlBeanConfigParser implements BeanConfigParser &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;</span><br><span class="line">    String content &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(String configContent) &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private String className;</span><br><span class="line">  private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  private Scope scope &#x3D; Scope.SINGLETON;</span><br><span class="line">  private boolean lazyInit &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line"> </span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static enum Scope &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class ConstructorArg &#123;</span><br><span class="line">    private boolean isRef;</span><br><span class="line">    private Class type;</span><br><span class="line">    private Object arg;</span><br><span class="line">    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-核心工厂类设计"><a href="#4-核心工厂类设计" class="headerlink" title="4.核心工厂类设计"></a>4.核心工厂类设计</h4><p>BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeansFactory &#123;</span><br><span class="line">  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;</span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);</span><br><span class="line">    if (beanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    return createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected Object createBean(BeanDefinition beanDefinition) &#123;</span><br><span class="line">    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object bean &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();</span><br><span class="line">      if (args.isEmpty()) &#123;</span><br><span class="line">        bean &#x3D; beanClass.newInstance();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Class[] argClasses &#x3D; new Class[args.size()];</span><br><span class="line">        Object[] argObjects &#x3D; new Object[args.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg &#x3D; args.get(i);</span><br><span class="line">          if (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] &#x3D; arg.getType();</span><br><span class="line">            argObjects[i] &#x3D; arg.getArg();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());</span><br><span class="line">            if (refBeanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] &#x3D; createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      throw new BeanCreationFailureException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。</p>
<h3 id="1-使用场景："><a href="#1-使用场景：" class="headerlink" title="1.使用场景："></a>1.使用场景：</h3><ul>
<li>类的构造函数必填属性很多，通过set设置，没有办法校验必填属性</li>
<li>如果类的属性之间有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验</li>
<li>需要创建不可变对象，不能暴露set方法。<br>（前提是需要传递很多的属性，如果属性很少，可以不需要建造者模式）</li>
</ul>
<h3 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2.实现方式："></a>2.实现方式：</h3><p>把构造函数定义为private，定义public static class Builder 内部类，通过Builder 类的set方法设置属性，调用build方法创建对象。</p>
<p>比如：</p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal;</span><br><span class="line">  private int maxIdle;</span><br><span class="line">  private int minIdle;</span><br><span class="line"></span><br><span class="line">  private ResourcePoolConfig(Builder builder) &#123;</span><br><span class="line">    this.name &#x3D; builder.name;</span><br><span class="line">    this.maxTotal &#x3D; builder.maxTotal;</span><br><span class="line">    this.maxIdle &#x3D; builder.maxIdle;</span><br><span class="line">    this.minIdle &#x3D; builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br><span class="line">  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">    private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    public ResourcePoolConfig build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new ResourcePoolConfig(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxTotal(int maxTotal) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxIdle(int maxIdle) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMinIdle(int minIdle) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="line">ResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(&quot;dbconnectionpool&quot;)</span><br><span class="line">        .setMaxTotal(16)</span><br><span class="line">        .setMaxIdle(10)</span><br><span class="line">        .setMinIdle(12)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<h3 id="3-和工厂模式的区别："><a href="#3-和工厂模式的区别：" class="headerlink" title="3.和工厂模式的区别："></a>3.和工厂模式的区别：</h3><ul>
<li>工厂模式：创建不同的同一类型对象（集成同一个父类或是接口的一组子类），由给定的参数来创建哪种类型的对象；</li>
<li>建造者模式：创建一种类型的复杂对象，通过很多可设置参数，“定制化”的创建对象</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1.什么是原型模式"></a>1.什么是原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p>
<h3 id="2-原型模式的两种实现方法"><a href="#2-原型模式的两种实现方法" class="headerlink" title="2.原型模式的两种实现方法"></a>2.原型模式的两种实现方法</h3><p>原型模式有两种实现方法，深拷贝和浅拷贝。</p>
<ul>
<li>浅拷贝只会复制对象中基本数据类型数据（比如，int、long）和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2468" alt="74bceb7a0736957daaa4abeba6826182.jpeg"></li>
</ul>
<ul>
<li>深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2469" alt="b978d054ab3183b9e0ae461e6abac81b.jpeg"></li>
</ul>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险。</p>
<h3 id="实现深拷贝的两种常见方式"><a href="#实现深拷贝的两种常见方式" class="headerlink" title="实现深拷贝的两种常见方式"></a>实现深拷贝的两种常见方式</h3><p>那如何实现深拷贝呢？</p>
<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。</p>
<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object deepCopy(Object object) &#123;</span><br><span class="line">  ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line">  </span><br><span class="line">  ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">  ObjectInputStream oi &#x3D; new ObjectInputStream(bi);</span><br><span class="line">  </span><br><span class="line">  return oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-如何最快速地clone一个包含10万数据的HashMap散列表"><a href="#3-如何最快速地clone一个包含10万数据的HashMap散列表" class="headerlink" title="3.如何最快速地clone一个包含10万数据的HashMap散列表"></a>3.如何最快速地clone一个包含10万数据的HashMap散列表</h3><p>使用深拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Deep copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">      SearchWord searchWord &#x3D; e.getValue();</span><br><span class="line">      SearchWord newSearchWord &#x3D; new SearchWord(</span><br><span class="line">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class="line">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这种特别大数据量大场景，有没有更快、更省内存的实现方式呢？</p>
<p>方案是：先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。</p>
<p>优化代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">  private long lastUpdateTime &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  public void refresh() &#123;</span><br><span class="line">    &#x2F;&#x2F; Shallow copy</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);</span><br><span class="line">    long maxNewUpdatedTime &#x3D; lastUpdateTime;</span><br><span class="line">    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">      &#125;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime &#x3D; maxNewUpdatedTime;</span><br><span class="line">    currentKeywords &#x3D; newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-什么时候该用深拷贝，什么时候该用还是浅拷贝"><a href="#4-什么时候该用深拷贝，什么时候该用还是浅拷贝" class="headerlink" title="4.什么时候该用深拷贝，什么时候该用还是浅拷贝"></a>4.什么时候该用深拷贝，什么时候该用还是浅拷贝</h3><ul>
<li>当需要复制的对象只包含基本类型数据的时候，或者要考呗的对象是不可变对象的时候 选择使用浅拷贝。</li>
<li>当需要拷贝的对象包含其他对象的时候，使用深拷贝</li>
</ul>
<p>不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间，当数量特别大的时候也可以使用案例的优化方式，但没有充分的理由，在包含对象的时候，不要为了一点点的性能提升而使用浅拷贝。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part1：面向对象-如何写出高质量的代码</title>
    <url>/2020/10/01/design-pattern-object-oriented01/</url>
    <content><![CDATA[<h2 id="学习设计模式的重要性"><a href="#学习设计模式的重要性" class="headerlink" title="学习设计模式的重要性"></a>学习设计模式的重要性</h2><h3 id="学习设计模式可以让读源码、框架事半功倍"><a href="#学习设计模式可以让读源码、框架事半功倍" class="headerlink" title="学习设计模式可以让读源码、框架事半功倍"></a>学习设计模式可以让读源码、框架事半功倍</h3><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p>
<a id="more"></a>

<h3 id="提高复杂代码的设计和开发能力"><a href="#提高复杂代码的设计和开发能力" class="headerlink" title="提高复杂代码的设计和开发能力"></a>提高复杂代码的设计和开发能力</h3><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？</p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p>
<h2 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h2><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p>
<h2 id="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h2><p><img src="/images/20201001.jpg" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p>
<ul>
<li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li>
<li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li>
<li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li>
<li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>
</ul>
<h2 id="面向对象编程的一些基础概念"><a href="#面向对象编程的一些基础概念" class="headerlink" title="面向对象编程的一些基础概念"></a>面向对象编程的一些基础概念</h2><ol>
<li><p>什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p>
</li>
<li><p>什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p>
</li>
<li><p>如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p>
</li>
<li><p>面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p>
</li>
<li><p>什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p>
</li>
</ol>
<h2 id="UML-图只要能表达出设计就可以了"><a href="#UML-图只要能表达出设计就可以了" class="headerlink" title="UML 图只要能表达出设计就可以了"></a>UML 图只要能表达出设计就可以了</h2><p>要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。</p>
<h2 id="封装、抽象、继承、多态-存在的意义"><a href="#封装、抽象、继承、多态-存在的意义" class="headerlink" title="封装、抽象、继承、多态 存在的意义"></a>封装、抽象、继承、多态 存在的意义</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据, 封装存在的意思，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。但是，过度的使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态特性能提高代码的可扩展性和复用性。除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p>
<p>接下来，看个例子如何利用接口类来实现多态特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Iterator arrayIterator = <span class="keyword">new</span> Array();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    Iterator linkedListIterator = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。</p>
<p>具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。</p>
<p>我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p>
<p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p>
<h3 id="面向对象特性的-What-How-Why-模型总结"><a href="#面向对象特性的-What-How-Why-模型总结" class="headerlink" title="面向对象特性的 What/How/Why 模型总结"></a>面向对象特性的 What/How/Why 模型总结</h3><p>##封装<br>What：隐藏信息，保护数据访问。<br>How：暴露有限接口和属性，需要编程语言提供访问控制的语法。<br>Why：提高代码可维护性；降低接口复杂度，提高类的易用性。</p>
<p>##抽象<br>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。<br>How: 通过接口类或者抽象类实现，特殊语法机制非必须。<br>Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。</p>
<p>##继承<br>What: 表示 is-a 关系，分为单继承和多继承。<br>How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。<br>Why: 解决代码复用问题。</p>
<p>##多态<br>What: 子类替换父类，在运行时调用子类的实现。<br>How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。<br>Why: 提高代码扩展性和复用性。</p>
<p>3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。</p>
<h2 id="什么是面向过程编程？什么是面向过程编程语言？"><a href="#什么是面向过程编程？什么是面向过程编程语言？" class="headerlink" title="什么是面向过程编程？什么是面向过程编程语言？"></a>什么是面向过程编程？什么是面向过程编程语言？</h2><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p>
<h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>面向对象编程相比起面向过程编程的优势主要有三个。</p>
<ul>
<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li>
<li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li>
<li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li>
</ul>
<h2 id="怎么考虑选择使用面向过程语言还是面向对象语言？"><a href="#怎么考虑选择使用面向过程语言还是面向对象语言？" class="headerlink" title="怎么考虑选择使用面向过程语言还是面向对象语言？"></a>怎么考虑选择使用面向过程语言还是面向对象语言？</h2><p>使用任何一个编程语言编写的程序，最终执行上都要落实到CPU一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。<br>C语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C语言用数组char a[8]，经过编译以后变成了（基地址＋偏移量）的方式。对于CPU来说，没有运算比加法更快，它的执行效率的算法复杂度是O(1)的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C语言是极好的选择。<br>C语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了OOP等更“智能”的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节, 占用了更大的内存空间, 占用了更多的CPU运算。从这个角度看，OOP这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核600MHz为主流，运行Android系统点击一个界面需要2秒才能响应，那我们现在用的大部分手机程序绝对不是使用JAVA开发的，Android操作系统也不可能建立起这么大的生态。</p>
<h2 id="哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的？"></a>哪些代码设计看似是面向对象，实际是面向过程的？</h2><h3 id="1-滥用-getter、setter-方法"><a href="#1-滥用-getter、setter-方法" class="headerlink" title="1. 滥用 getter、setter 方法"></a>1. 滥用 getter、setter 方法</h3><p>面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p>
<p>在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</p>
<p>Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-滥用全局变量和全局方法"><a href="#2-滥用全局变量和全局方法" class="headerlink" title="2. 滥用全局变量和全局方法"></a>2. 滥用全局变量和全局方法</h3><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性</p>
<h3 id="3-定义数据和方法分离的"><a href="#3-定义数据和方法分离的" class="headerlink" title="3. 定义数据和方法分离的"></a>3. 定义数据和方法分离的</h3><p>这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的</p>
<h2 id="接口vs抽象类的区别？"><a href="#接口vs抽象类的区别？" class="headerlink" title="接口vs抽象类的区别？"></a>接口vs抽象类的区别？</h2><h3 id="1-抽象类的特性"><a href="#1-抽象类的特性" class="headerlink" title="1.抽象类的特性"></a>1.抽象类的特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">    doLog(level, message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, String filepath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.fileWriter = <span class="keyword">new</span> FileWriter(filepath); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MessageQueueLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled,</span></span></span><br><span class="line"><span class="function"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="keyword">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String mesage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）。</p>
</li>
<li><p>我抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作抽象方法。</p>
</li>
<li><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p>
</li>
</ul>
<h3 id="2-接口的特性"><a href="#2-接口的特性" class="headerlink" title="2.接口的特性"></a>2.接口的特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...鉴权逻辑..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...限流逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用Demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">  <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRpcRequest</span><span class="params">(RpcRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        filter.doFilter(req);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">      <span class="comment">// ...处理过滤结果...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略其他处理逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口不能包含属性（也就是成员变量）。</li>
<li>接口只能声明方法，方法不能包含代码实现。</li>
<li>类实现接口的时候，必须实现接口中声明的所有方法。</li>
</ul>
<h3 id="3-抽象类和接口的语法特性小结"><a href="#3-抽象类和接口的语法特性小结" class="headerlink" title="3.抽象类和接口的语法特性小结"></a>3.抽象类和接口的语法特性小结</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p>
<h3 id="4-抽象类和接口的区别"><a href="#4-抽象类和接口的区别" class="headerlink" title="4.抽象类和接口的区别"></a>4.抽象类和接口的区别</h3><p>抽象类更多的是为了代码复用，多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。</p>
<p>而接口就更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或者契约，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。<br>你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<h3 id="5-什么时候该用抽象类？什么时候该用接口？"><a href="#5-什么时候该用抽象类？什么时候该用接口？" class="headerlink" title="5.什么时候该用抽象类？什么时候该用接口？"></a>5.什么时候该用抽象类？什么时候该用接口？</h3><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p>
<p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>
<h2 id="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h2><h3 id="结合一个有关图片存储的实战案例"><a href="#结合一个有关图片存储的实战案例" class="headerlink" title="结合一个有关图片存储的实战案例"></a>结合一个有关图片存储的实战案例</h3><p>下面是 “基于实现的编程”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket代码逻辑...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...; <span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    AliyunImageStore imageStore = <span class="keyword">new</span> AliyunImageStore(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">    String accessToken = imageStore.generateAccessToken();</span><br><span class="line">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的问题分析：</p>
<ol>
<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>
</ol>
<p>2.封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。比如 generateAccessToken 这个特殊的方法就没必要暴露了</p>
<p>3.为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</p>
<p>改造成 “基于接口而非实现编程” 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span></span>;</span><br><span class="line">  <span class="function">Image <span class="title">download</span><span class="params">(String url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    String accessToken = generateAccessToken();</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span>  </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span>&#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">    <span class="comment">//...返回图片的url...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = ...;<span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    ImageStore imageStore = <span class="keyword">new</span> PrivateImageStore(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么基于接口而非实现编程？"><a href="#为什么基于接口而非实现编程？" class="headerlink" title="为什么基于接口而非实现编程？"></a>为什么基于接口而非实现编程？</h3><p>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性</p>
<h3 id="有必要为每个类都定义接口吗？"><a href="#有必要为每个类都定义接口吗？" class="headerlink" title="有必要为每个类都定义接口吗？"></a>有必要为每个类都定义接口吗？</h3><ol>
<li>视业务场景而定，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</li>
<li>某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</li>
</ol>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p>
<ol start="2">
<li>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</li>
</ol>
<p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p>
<h2 id="为何说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#为何说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="为何说要多用组合少用继承？如何决定该用组合还是继承？"></a>为何说要多用组合少用继承？如何决定该用组合还是继承？</h2><h3 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h3><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。<br>比如继承<br><img src="/images/20201002.jpg" alt="3f99fa541e7ec7656a1dd35cc4f28bc6.jpeg"></p>
<h3 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h3><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<h3 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h3><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<h3 id="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"><a href="#如何用组合、接口、委托三个技术手段来避免继承层级过多的问题" class="headerlink" title="如何用组合、接口、委托三个技术手段来避免继承层级过多的问题"></a>如何用组合、接口、委托三个技术手段来避免继承层级过多的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FlyAbility implements Flyable </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span>&#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> EggLayAbility eggLayAbility = <span class="keyword">new</span> EggLayAbility(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part2：面向对象-实战如何写出高质量的代码</title>
    <url>/2020/10/03/design-pattern-object-oriented02/</url>
    <content><![CDATA[<h2 id="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h2><h3 id="1-什么是基于贫血模型的传统开发模式？"><a href="#1-什么是基于贫血模型的传统开发模式？" class="headerlink" title="1.什么是基于贫血模型的传统开发模式？"></a>1.什么是基于贫血模型的传统开发模式？</h3><p>像下面 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo &#x3D; userService.getUserById(userId);</span><br><span class="line">    UserVo userVo &#x3D; [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity &#x3D; userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo &#x3D; [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-什么是基于充血模型的-DDD-开发模式？"><a href="#2-什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="2.什么是基于充血模型的 DDD 开发模式？"></a>2.什么是基于充血模型的 DDD 开发模式？</h3><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<h3 id="3-贫血模型-与-充血模型的代码模式区别"><a href="#3-贫血模型-与-充血模型的代码模式区别" class="headerlink" title="3.贫血模型 与 充血模型的代码模式区别"></a>3.贫血模型 与 充血模型的代码模式区别</h3><p>基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</p>
<h3 id="4-为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#4-为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="4.为什么基于贫血模型的传统开发模式如此受欢迎？"></a>4.为什么基于贫血模型的传统开发模式如此受欢迎？</h3><ol>
<li><p>一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，基于贫血模型的传统开发模式简单够用</p>
</li>
<li><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p>
</li>
<li><p>思维已固化，转型有成本</p>
</li>
</ol>
<h3 id="5-什么时候该选择用贫血模型？什么时候该用充血模型？"><a href="#5-什么时候该选择用贫血模型？什么时候该用充血模型？" class="headerlink" title="5.什么时候该选择用贫血模型？什么时候该用充血模型？"></a>5.什么时候该选择用贫血模型？什么时候该用充血模型？</h3><p>基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p>
<p>对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p>
<h2 id="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h2><h3 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h3><p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p>
<p><img src="/images/or01.jpg" alt="9e91377602ef154eaf866c7e9263a64a.jpeg"></p>
<h4 id="1-充值"><a href="#1-充值" class="headerlink" title="1.充值"></a>1.充值</h4><p>充值用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水</p>
<p><img src="/images/or02.jpg" alt="3915a6544403854d35678c81fe65f014.jpeg"></p>
<h4 id="2-支付"><a href="#2-支付" class="headerlink" title="2. 支付"></a>2. 支付</h4><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。<br><img src="/images/or03.jpg" alt="7eb44e2f8661d1c3debde85f79fb2c5e.jpeg"></p>
<h4 id="3-提现"><a href="#3-提现" class="headerlink" title="3. 提现"></a>3. 提现</h4><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。<br><img src="/images/or04.jpg" alt="66ede1de93d29b86a9194ea0f80d1e43.jpeg"></p>
<h4 id="4-查询余额"><a href="#4-查询余额" class="headerlink" title="4.查询余额"></a>4.查询余额</h4><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p>
<h4 id="5-查询交易流水"><a href="#5-查询交易流水" class="headerlink" title="5.查询交易流水"></a>5.查询交易流水</h4><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p>
<h4 id="钱包系统的设计思路-1"><a href="#钱包系统的设计思路-1" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h4><p>可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p>
<p><img src="/images/or05.jpg" alt="60d3cfec73986b52e3a6ef4fe147e562.jpeg"></p>
<p>以虚拟钱包的设计为例，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</p>
<p><img src="/images/or06.jpg" alt="d1a9aeb6642404f80a62293ab2e45630.jpeg"></p>
<p>充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？<br>虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p>
<p>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</p>
<p>可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p>
<p><img src="/images/or07.jpg" alt="fb356a2589a14f2f3440247e3c7a7718.jpeg"></p>
<h3 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h3><p>是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，省略了具体的代码实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VirtualWalletController &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123; ... &#125; &#x2F;&#x2F;查询余额</span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;出账</span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F;入账</span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123; ...&#125; &#x2F;&#x2F;转账</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWalletBo &#123;&#x2F;&#x2F;省略getter&#x2F;setter&#x2F;constructor方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime;</span><br><span class="line">  private BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWalletBo getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWalletBo walletBo &#x3D; convert(walletEntity);</span><br><span class="line">    return walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    if (balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new NoSufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    BigDecimal balance &#x3D; walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletTransactionEntity transactionEntity &#x3D; new VirtualWalletTransactionEntity();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    Long transactionId &#x3D; transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    try &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; catch (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h3><p>跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。</p>
<p>把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class VirtualWallet &#123; &#x2F;&#x2F; Domain领域模型(充血模型)</span><br><span class="line">  private Long id;</span><br><span class="line">  private Long createTime &#x3D; System.currentTimeMillis();;</span><br><span class="line">  private BigDecimal balance &#x3D; BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet(Long preAllocatedId) &#123;</span><br><span class="line">    this.id &#x3D; preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal balance() &#123;</span><br><span class="line">    return this.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(BigDecimal amount) &#123;</span><br><span class="line">    if (this.balance.compareTo(amount) &lt; 0) &#123;</span><br><span class="line">      throw new InsufficientBalanceException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(BigDecimal amount) &#123;</span><br><span class="line">    if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">      throw new InvalidAmountException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    this.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VirtualWalletService &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过构造函数或者IOC框架注入</span><br><span class="line">  private VirtualWalletRepository walletRepo;</span><br><span class="line">  private VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  public VirtualWallet getVirtualWallet(Long walletId) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    return wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public BigDecimal getBalance(Long walletId) &#123;</span><br><span class="line">    return walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void debit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void credit(Long walletId, BigDecimal amount) &#123;</span><br><span class="line">    VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);</span><br><span class="line">    VirtualWallet wallet &#x3D; convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;</span><br><span class="line">    &#x2F;&#x2F;...跟基于贫血模型的传统开发模式的代码一样...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p>
<p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p>
<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p>
<h3 id="精彩评论：充血模型可以说是业务的精准抽象"><a href="#精彩评论：充血模型可以说是业务的精准抽象" class="headerlink" title="精彩评论：充血模型可以说是业务的精准抽象"></a>精彩评论：充血模型可以说是业务的精准抽象</h3><p>我对DDD的看法就是，它可以把原来最重的service逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。</p>
<p>在维护性上来说，如果项目新进了开发人员，如果是贫血模型的service代码，无论代码如何清晰，注释如何完备，代码结构设计得如何优雅，都没有办法第一时间理解系统的核心业务逻辑，但是如果是充血模型，直接阅读充血模型的行为方法，起码能够很快理解70%左右的业务逻辑，因为充血模型可以说是业务的精准抽象，我想，这就是领域模型驱动能够达到”驱动”效果的由来吧。</p>
<h2 id="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？"></a>实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>1.第一轮寄出分析：<br>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>2.第二轮优化分析<br>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的， 存在 重放攻击问题。我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>3.第三轮优化分析</p>
<p>4.第四轮优化分析</p>
<p><img src="/images/or08.jpg" alt="bde932c73c6636ad85380e4801dbfb60.jpeg"></p>
<p>调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p>
</li>
<li><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p>
</li>
</ol>
<p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p>
<p>3.针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求</p>
<h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.工作中遇到非crud的需求我就会想尽一切办法让他通用，基本需求分析和需求设计的时间占用百分之五十，开发和重构到自认为最优占用百分之五十。比如最简单的验证码功能，几乎每个项目都有，我就封装一套验证码服务，主要功能有你在配置文件里配置好需要被验证码拦截的路径，这里还要考虑到通配符，空格等等细节和可扩展的点，内置图片验证码，极验证，手机验证以及自定义验证码等等，总之我认为如果有机会遇到非crud的需求，一定要好好珍惜，好好把握，把他打造成属于自己的产品，这样会让自己下意识的去想尽一切办法把他做到最优，亲儿子一样的待遇，再也不会无脑cv</p>
<ol start="2">
<li>一句话：使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进。<br>拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：</li>
<li>什么叫接口鉴权？搞清基本概念</li>
<li>接口鉴权最佳实践是什么？技术调研</li>
<li>appid和secret key从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。</li>
<li>appid secretkey存储在什么地方呢？数据存储</li>
<li>用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。</li>
<li>这个功能如何测试？提前想好如何测试</li>
<li>接口鉴权功能何时上线？估计工期</li>
<li>鉴权成功或失败返回码和信息定义？约定返回结果</li>
</ol>
<p>关于防止重放攻击：请求参数中还可以加入nonce（随机正整数），两次请求的nonce不能重复，timestamp和nonce结合进一步防止重放攻击。</p>
<ol start="3">
<li>程序员十倍法则</li>
</ol>
<h2 id="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h2><p>向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p>
<h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p>
<p>例子：我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p>
<p>1.把 URL、AppID、密码、时间戳拼接为一个字符串；<br>2.对字符串通过加密算法加密生成 token；<br>3.将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；<br>4.解析 URL，得到 token、AppID、时间戳等信息；<br>5.从存储中取出 AppID 和对应的密码；<br>6.根据时间戳判断 token 是否过期失效；<br>7.验证两个 token 是否匹配；</p>
<p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p>
<h3 id="2-定义类及其属性和方法"><a href="#2-定义类及其属性和方法" class="headerlink" title="2. 定义类及其属性和方法"></a>2. 定义类及其属性和方法</h3><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p>
<p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage</p>
<p>AuthToken 类相关的功能点有四个：</p>
<ul>
<li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li>
<li>对字符串通过加密算法加密生成 token；</li>
<li>根据时间戳判断 token 是否过期失效；</li>
<li>验证两个 token 是否匹配。</li>
</ul>
<p><img src="/images/or09.jpg" alt="69c8954e0db1a4db99a6094ee359fc9b.jpeg"></p>
<p>Url 类相关的功能点有两个：</p>
<ul>
<li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li>解析 URL，得到 token、AppID、时间戳等信息。<br><img src="/images/or10.jpg" alt="1cc9b95e511bd49fbc23c00ac5c0fed6.jpeg"></li>
</ul>
<p>CredentialStorage 类相关的功能点有一个：</p>
<ul>
<li>从存储中取出 AppID 和对应的密码。</li>
</ul>
<p><img src="/images/or11.jpg" alt="3b6d2c0cadafa723e26cc032c29c8785.jpeg"></p>
<h3 id="3-定义类与类之间的交互关系"><a href="#3-定义类与类之间的交互关系" class="headerlink" title="3. 定义类与类之间的交互关系"></a>3. 定义类与类之间的交互关系</h3><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p>
<p>泛化（Generalization）可以简单理解为继承关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实现（Realization）一般是指接口和实现类之间的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>组合 （Composition）只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系强调部分与整体的关系，其中包括两种情况，关联性强（大雁与翅膀）的与关联性弱（学生与班级）的。（这里将将 UML 定义的 关联、聚合、组合 统一归类为组合）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">组合（Composition）：关联性强（大雁与翅膀）</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">聚合（Aggregation）：关联性弱（学生与班级）</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b &#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b &#x3D; new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">  public void func(B b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-将类组装起来并提供执行入口"><a href="#4-将类组装起来并提供执行入口" class="headerlink" title="4. 将类组装起来并提供执行入口"></a>4. 将类组装起来并提供执行入口</h3><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
<h3 id="评论区的代码实现参考"><a href="#评论区的代码实现参考" class="headerlink" title="评论区的代码实现参考"></a>评论区的代码实现参考</h3><p><a href="https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014" target="_blank" rel="noopener">https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014</a></p>
<p><a href="https://gitee.com/MondayLiu/geek-design" target="_blank" rel="noopener">https://gitee.com/MondayLiu/geek-design</a></p>
<p><a href="https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth" target="_blank" rel="noopener">https://github.com/LiuKay/design-patterns-java/tree/master/src/main/java/com/kay/practice/auth</a></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part6：设计模式与范式-结构型</title>
    <url>/2020/10/09/design-pattern-structural-pattern/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p>
<h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2><p>Proxy Design Pattern</p>
<a id="more"></a>

<h3 id="代理模式的原理与实现"><a href="#代理模式的原理与实现" class="headerlink" title="代理模式的原理与实现"></a>代理模式的原理与实现</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<h3 id="代理模式的具体实现"><a href="#代理模式的具体实现" class="headerlink" title="代理模式的具体实现"></a>代理模式的具体实现</h3><h4 id="1-让代理类和原始类实现同样的接口"><a href="#1-让代理类和原始类实现同样的接口" class="headerlink" title="1.让代理类和原始类实现同样的接口"></a>1.让代理类和原始类实现同样的接口</h4><p>如果原始类已经定义了接口，则代理类实现与原始类同样的接口</p>
<p>案例代码（收集接口的请求信息）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUserController &#123;</span><br><span class="line">  UserVo login(String telephone, String password);</span><br><span class="line">  UserVo register(String telephone, String password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController implements IUserController &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略login逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略register逻辑...</span><br><span class="line">    &#x2F;&#x2F;...返回UserVo数据...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserControllerProxy implements IUserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line">  private UserController userController;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy(UserController userController) &#123;</span><br><span class="line">    this.userController &#x3D; userController;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 委托</span><br><span class="line">    UserVo userVo &#x3D; userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="line">&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="line">IUserController userController &#x3D; new UserControllerProxy(new UserController());</span><br></pre></td></tr></table></figure>

<h4 id="2-让代理类继承原始类的方法来实现代理模式"><a href="#2-让代理类继承原始类的方法来实现代理模式" class="headerlink" title="2.让代理类继承原始类的方法来实现代理模式"></a>2.让代理类继承原始类的方法来实现代理模式</h4><p>如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<p>案例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserControllerProxy extends UserController &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public UserControllerProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo register(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo &#x3D; super.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;UserControllerProxy使用举例</span><br><span class="line">UserController userController &#x3D; new UserControllerProxy();</span><br></pre></td></tr></table></figure>

<h4 id="两种实现方式的对比"><a href="#两种实现方式的对比" class="headerlink" title="两种实现方式的对比"></a>两种实现方式的对比</h4><ul>
<li><p>组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。</p>
</li>
<li><p>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。</p>
</li>
</ul>
<h3 id="动态代理的原理与实现"><a href="#动态代理的原理与实现" class="headerlink" title="动态代理的原理与实现"></a>动态代理的原理与实现</h3><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。</p>
<p>所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。</p>
<p>代码例子：（收集所有类的接口请求信息）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</span><br><span class="line">public class MetricsCollectorProxy &#123;</span><br><span class="line">  private MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  public MetricsCollectorProxy() &#123;</span><br><span class="line">    this.metricsCollector &#x3D; new MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object createProxy(Object proxiedObject) &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);</span><br><span class="line">    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    public DynamicProxyHandler(Object proxiedObject) &#123;</span><br><span class="line">      this.proxiedObject &#x3D; proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">      long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      Object result &#x3D; method.invoke(proxiedObject, args);</span><br><span class="line">      long endTimeStamp &#x3D; System.currentTimeMillis();</span><br><span class="line">      long responseTime &#x3D; endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();</span><br><span class="line">      RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MetricsCollectorProxy使用举例</span><br><span class="line">MetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();</span><br><span class="line">IUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</span><br></pre></td></tr></table></figure>

<p><strong>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</strong></p>
<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><h4 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1. 业务系统的非功能性需求开发"></a>1. 业务系统的非功能性需求开发</h4><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p>
<h4 id="2-代理模式在-RPC中的应用"><a href="#2-代理模式在-RPC中的应用" class="headerlink" title="2. 代理模式在 RPC中的应用"></a>2. 代理模式在 RPC中的应用</h4><p>RPC 框架也可以看作一种代理模式，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>
<h4 id="3-代理模式在缓存中的应用"><a href="#3-代理模式在缓存中的应用" class="headerlink" title="3. 代理模式在缓存中的应用"></a>3. 代理模式在缓存中的应用</h4><p>比如我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。</p>
<p>最简单的实现方法就是给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p>
<p>如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p>
<h2 id="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h2><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，只需要简单了解，见到能认识就可以。</p>
<h3 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h3><p>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：</p>
<blockquote>
<p>Decouple an abstraction from its implementation so that the two can vary independently。</p>
</blockquote>
<p>翻译成中文就是：将抽象和实现解耦，让它们可以独立变化。<br>弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p>
<p>还有另外一种更加简单的理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”它非常类似我们之前讲过的“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>
<h3 id="JDBC利用桥接模式优雅实现数据库切换"><a href="#JDBC利用桥接模式优雅实现数据库切换" class="headerlink" title="JDBC利用桥接模式优雅实现数据库切换"></a>JDBC利用桥接模式优雅实现数据库切换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序</span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;</span><br><span class="line">Connection con &#x3D; DriverManager.getConnection(url);</span><br><span class="line">Statement stmt &#x3D; con.createStatement()；</span><br><span class="line">String query &#x3D; &quot;select * from test&quot;;</span><br><span class="line">ResultSet rs&#x3D;stmt.executeQuery(query);</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">  rs.getString(1);</span><br><span class="line">  rs.getInt(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。</p>
<p>先看下 com.mysql.jdbc.Driver 的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">  static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Construct a new driver and register it with DriverManager</span><br><span class="line">   * @throws SQLException if a database error occurs.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Driver() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; Required for Class.forName().newInstance()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。</p>
<ul>
<li>第一件事情是要求 JVM 查找并加载指定的 Driver 类</li>
<li>第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</li>
</ul>
<p>Drivermanage代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line">  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;</span><br><span class="line">    if (driver !&#x3D; null) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(new DriverInfo(driver));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Connection getConnection(String url, String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2470" alt="812234b0717043a67c2d62ea8e783b40.jpeg"></p>
<p>JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p>
<h3 id="如何实现支持不同类型和渠道的消息推送系统？"><a href="#如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="如何实现支持不同类型和渠道的消息推送系统？"></a>如何实现支持不同类型和渠道的消息推送系统？</h3><p>一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p>
<p>有两个维度，一个是不同规则，一个是不同渠道。</p>
<p>先看下最简单直接的代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum NotificationEmergencyLevel &#123;</span><br><span class="line">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Notification &#123;</span><br><span class="line">  private List&lt;String&gt; emailAddresses;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line">  private List&lt;String&gt; wechatIds;</span><br><span class="line"></span><br><span class="line">  public Notification() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public void setEmailAddress(List&lt;String&gt; emailAddress) &#123;</span><br><span class="line">    this.emailAddresses &#x3D; emailAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTelephones(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setWechatIds(List&lt;String&gt; wechatIds) &#123;</span><br><span class="line">    this.wechatIds &#x3D; wechatIds;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void notify(NotificationEmergencyLevel level, String message) &#123;</span><br><span class="line">    if (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...自动语音电话</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发微信</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class="line">      &#x2F;&#x2F;...发邮件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p>
<p>按这个思路，对代码进行重构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MsgSender &#123;</span><br><span class="line">  void send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TelephoneMsgSender implements MsgSender &#123;</span><br><span class="line">  private List&lt;String&gt; telephones;</span><br><span class="line"></span><br><span class="line">  public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;</span><br><span class="line">    this.telephones &#x3D; telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void send(String message) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WechatMsgSender implements MsgSender &#123;</span><br><span class="line">  &#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Notification &#123;</span><br><span class="line">  protected MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">  public Notification(MsgSender msgSender) &#123;</span><br><span class="line">    this.msgSender &#x3D; msgSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract void notify(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SevereNotification extends Notification &#123;</span><br><span class="line">  public SevereNotification(MsgSender msgSender) &#123;</span><br><span class="line">    super(msgSender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notify(String message) &#123;</span><br><span class="line">    msgSender.send(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UrgencyNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class NormalNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br><span class="line">public class TrivialNotification extends Notification &#123;</span><br><span class="line">  &#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。</p>
<h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>桥接看着就像是面向接口编程这一原则的原旨—将实现与抽象分离。</p>
<p>多个纬度独立变化那个解释倒是比较容易理解。文中举的警报的例子很贴切。紧急程度和警报的方式可以是两个不同的纬度。可以有不同的组合方式。</p>
<p>这与slf4j这一日志门面的设计有异曲同工之妙。slf4j其中有三个核心概念，logger,appender和encoder。分别指这个日志记录器负责哪个类的日志，日志打印到哪里以及日志打印的格式。三个纬度上可以有不同的实现，使用者可以在每一纬度上定义多个实现，配置文件中将各个纬度的某一个实现组合在一起就ok了。</p>
<p>一句话就是，桥接就是面向接口编程的集大成者。面向接口编程只是说在系统的某一个功能上将接口和实现解藕，而桥接是详细的分析系统功能，将各个独立的纬度都抽象出来，使用时按需组合。</p>
<h2 id="装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h2><p>Decorator Pattern</p>
<h3 id="装饰器模式的理解"><a href="#装饰器模式的理解" class="headerlink" title="装饰器模式的理解"></a>装饰器模式的理解</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<h3 id="装饰器的模版代码"><a href="#装饰器的模版代码" class="headerlink" title="装饰器的模版代码"></a>装饰器的模版代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java-IO类库源码对装饰器模式的应用"><a href="#Java-IO类库源码对装饰器模式的应用" class="headerlink" title="Java IO类库源码对装饰器模式的应用"></a>Java IO类库源码对装饰器模式的应用</h3><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2471" alt="507526c2e4b255a45c60722df14f9a05.jpeg"></p>
<p>避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void close() throws IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    throw new IOException(&quot;mark&#x2F;reset not supported&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FilterInputStream extends InputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected FilterInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read() throws IOException &#123;</span><br><span class="line">    return in.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int read(byte b[]) throws IOException &#123;</span><br><span class="line">    return read(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    return in.read(b, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long skip(long n) throws IOException &#123;</span><br><span class="line">    return in.skip(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int available() throws IOException &#123;</span><br><span class="line">    return in.available();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void close() throws IOException &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void mark(int readlimit) &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void reset() throws IOException &#123;</span><br><span class="line">    in.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean markSupported() &#123;</span><br><span class="line">    return in.markSupported();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BufferedInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected BufferedInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现基于缓存的读数据接口...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DataInputStream extends FilterInputStream &#123;</span><br><span class="line">  protected volatile InputStream in;</span><br><span class="line"></span><br><span class="line">  protected DataInputStream(InputStream in) &#123;</span><br><span class="line">    this.in &#x3D; in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;...实现读取基本类型数据的接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2472" alt="5082df8e7d5a4d44a34811b9f562d613.jpeg"></p>
<h3 id="装饰器模式与代理模式的区别"><a href="#装饰器模式与代理模式的区别" class="headerlink" title="装饰器模式与代理模式的区别"></a>装饰器模式与代理模式的区别</h3><ul>
<li>代理模式中，代理类附加的是跟原始类无关的功能，侧重于业务无关的功能，隐藏了实现细节，是不需要使用者关注的</li>
</ul>
<ul>
<li>装饰器模式中，装饰器类附加的是跟原始类相关的增强功能，定制化诉求高，柔和了业务属性，后面可能改动频繁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A impelements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AProxy implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public AProxy(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 新添加的代理逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  void f();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  public void f() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ADecorator implements IA &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public ADecorator(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f() &#123;</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">    a.f();</span><br><span class="line">    &#x2F;&#x2F; 功能增强代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用，对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);</span><br><span class="line">InputStream bin &#x3D; new BufferedInputStream(in);</span><br><span class="line">DataInputStream din &#x3D; new DataInputStream(bin);</span><br><span class="line">int data &#x3D; din.readInt();</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存场景应该使用代理模式还说装饰者模式？"><a href="#添加缓存场景应该使用代理模式还说装饰者模式？" class="headerlink" title="添加缓存场景应该使用代理模式还说装饰者模式？"></a>添加缓存场景应该使用代理模式还说装饰者模式？</h3><ul>
<li><p>对于添加缓存这个应用场景使用哪种模式，要看设计者的意图，如果设计者不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之，如果设计者需要用户自己决定是否使用缓存的功能，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式。</p>
</li>
<li><p>缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活。</p>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>代理模式和装饰者模式都是 代码增强这一件事的落地方案。前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。</li>
</ul>
<ul>
<li>Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.Decorator体现多态性, Proxy体现封装性.reference:<br><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern" target="_blank" rel="noopener">https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern</a></li>
</ul>
<h2 id="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h2><p>Adapter Design Pattern</p>
<h3 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h3><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类适配器: 基于继承</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee &#x3D; adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); &#x2F;&#x2F;委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h3><p>适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。</p>
<h4 id="1-封装有缺陷的接口设计"><a href="#1-封装有缺陷的接口设计" class="headerlink" title="1. 封装有缺陷的接口设计"></a>1. 封装有缺陷的接口设计</h4><p>当我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public static void staticFunction1() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">  public void uglyNamingFunction2() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line"></span><br><span class="line">  public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  </span><br><span class="line">   public void lowPerformanceFunction4() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行重构</span><br><span class="line">public class ITarget &#123;</span><br><span class="line">  void function1();</span><br><span class="line">  void function2();</span><br><span class="line">  void fucntion3(ParamsWrapperDefinition paramsWrapper);</span><br><span class="line">  void function4();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><span class="line">public class CDAdaptor extends CD implements ITarget &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void function1() &#123;</span><br><span class="line">     super.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function2() &#123;</span><br><span class="line">    super.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function3(ParamsWrapperDefinition paramsWrapper) &#123;</span><br><span class="line">     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void function4() &#123;</span><br><span class="line">    &#x2F;&#x2F;...reimplement it...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-统一多个类的接口设计"><a href="#2-统一多个类的接口设计" class="headerlink" title="2. 统一多个类的接口设计"></a>2. 统一多个类的接口设计</h4><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体</p>
<p>例子：假设我们的系统要对用户输入的文本内容做敏感词过滤，，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ASensitiveWordsFilter &#123; &#x2F;&#x2F; A敏感词过滤系统提供的接口</span><br><span class="line">  &#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本</span><br><span class="line">  public String filterSexyWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterPoliticalWords(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BSensitiveWordsFilter  &#123; &#x2F;&#x2F; B敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CSensitiveWordsFilter &#123; &#x2F;&#x2F; C敏感词过滤系统提供的接口</span><br><span class="line">  public String filter(String text, String mask) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="line">public class RiskManagement &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();</span><br><span class="line">  private BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();</span><br><span class="line">  private CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText &#x3D; bFilter.filter(maskedText);</span><br><span class="line">    maskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用适配器模式进行改造</span><br><span class="line">public interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义</span><br><span class="line">  String filter(String text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;</span><br><span class="line">  private ASensitiveWordsFilter aFilter;</span><br><span class="line">  public String filter(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="line">&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="line">public class RiskManagement &#123; </span><br><span class="line">  private List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String filterSensitiveWords(String text) &#123;</span><br><span class="line">    String maskedText &#x3D; text;</span><br><span class="line">    for (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText &#x3D; filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    return maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-替换依赖的外部系统"><a href="#3-替换依赖的外部系统" class="headerlink" title="3. 替换依赖的外部系统"></a>3. 替换依赖的外部系统</h4><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 外部系统A</span><br><span class="line">public interface IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  void fa();</span><br><span class="line">&#125;</span><br><span class="line">public class A implements IA &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例</span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private IA a;</span><br><span class="line">  public Demo(IA a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">Demo d &#x3D; new Demo(new A());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将外部系统A替换成外部系统B</span><br><span class="line">public class BAdaptor implemnts IA &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public BAdaptor(B b) &#123;</span><br><span class="line">    this.b&#x3D; b;</span><br><span class="line">  &#125;</span><br><span class="line">  public void fa() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="line">&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="line">Demo d &#x3D; new Demo(new BAdaptor(new B()));</span><br></pre></td></tr></table></figure>


<h4 id="4-兼容老版本接口"><a href="#4-兼容老版本接口" class="headerlink" title="4. 兼容老版本接口"></a>4. 兼容老版本接口</h4><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Collections &#123;</span><br><span class="line">  public static Emueration emumeration(final Collection c) &#123;</span><br><span class="line">    return new Enumeration() &#123;</span><br><span class="line">      Iterator i &#x3D; c.iterator();</span><br><span class="line">      </span><br><span class="line">      public boolean hasMoreElments() &#123;</span><br><span class="line">        return i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public Object nextElement() &#123;</span><br><span class="line">        return i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-适配不同格式的数据"><a href="#5-适配不同格式的数据" class="headerlink" title="5. 适配不同格式的数据"></a>5. 适配不同格式的数据</h4><p>适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges &#x3D; Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="剖析适配器模式在-Java-日志中的应用（Slf4j）"><a href="#剖析适配器模式在-Java-日志中的应用（Slf4j）" class="headerlink" title="剖析适配器模式在 Java 日志中的应用（Slf4j）"></a>剖析适配器模式在 Java 日志中的应用（Slf4j）</h3><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</p>
<p>如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。比如引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p>
<p>Slf4j 就是为了解决这个问题而产生的，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。</p>
<p>Slf4j 的适配器实现就是一个很好的适配器模式例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; slf4j统一的接口定义</span><br><span class="line">package org.slf4j;</span><br><span class="line">public interface Logger &#123;</span><br><span class="line">  public boolean isTraceEnabled();</span><br><span class="line">  public void trace(String msg);</span><br><span class="line">  public void trace(String format, Object arg);</span><br><span class="line">  public void trace(String format, Object arg1, Object arg2);</span><br><span class="line">  public void trace(String format, Object[] argArray);</span><br><span class="line">  public void trace(String msg, Throwable t);</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled();</span><br><span class="line">  public void debug(String msg);</span><br><span class="line">  public void debug(String format, Object arg);</span><br><span class="line">  public void debug(String format, Object arg1, Object arg2)</span><br><span class="line">  public void debug(String format, Object[] argArray)</span><br><span class="line">  public void debug(String msg, Throwable t);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...省略info、warn、error等一堆接口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; log4j日志框架的适配器</span><br><span class="line">&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="line">&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，</span><br><span class="line">&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="line">package org.slf4j.impl;</span><br><span class="line">public final class Log4jLoggerAdapter extends MarkerIgnoringBase</span><br><span class="line">  implements LocationAwareLogger, Serializable &#123;</span><br><span class="line">  final transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j</span><br><span class="line"> </span><br><span class="line">  public boolean isDebugEnabled() &#123;</span><br><span class="line">    return logger.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object arg1, Object arg2) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String format, Object[] argArray) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      FormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void debug(String msg, Throwable t) &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略一堆接口的实现...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p>
<ul>
<li><p>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p>
</li>
<li><p>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>
</li>
<li><p>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p>
</li>
<li><p>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>
</li>
</ul>
<h2 id="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h2><p>Facade Design Pattern</p>
<h3 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h3><p>接口力度太大，则会不通用，接口力度太小，又影响易用性，门面模式就是用来解决接口的可复用性（通用性）和易用性之间的矛盾的。</p>
<p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。</p>
<blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>具体的做法就是：设计接口的时候还优先考虑复用性设计成比较单一职责的细粒度接口，然后额外根据外部系统的使用场景包装一层，提供一组更加简单易用、更高层的接口，从而让接口更易用。</p>
<p>比如A系统提供了a b c d 4个 接口，现在系统B 完成某个业务功能需要调用系统的 a b d 接口，考虑易用性，提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。这就是门面模式的应用了。</p>
<h3 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h3><h4 id="1-解决易用性问题"><a href="#1-解决易用性问题" class="headerlink" title="1. 解决易用性问题"></a>1. 解决易用性问题</h4><p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p>
<p>实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p>
<h4 id="2-解决性能问题"><a href="#2-解决性能问题" class="headerlink" title="2.解决性能问题"></a>2.解决性能问题</h4><p>通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高客户端的响应速度。</p>
<h4 id="3-解决分布式事务问题"><a href="#3-解决分布式事务问题" class="headerlink" title="3. 解决分布式事务问题"></a>3. 解决分布式事务问题</h4><p>比如这样一个场景，在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</p>
<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
<h3 id="如何组织门面接口和非门面接口？"><a href="#如何组织门面接口和非门面接口？" class="headerlink" title="如何组织门面接口和非门面接口？"></a>如何组织门面接口和非门面接口？</h3><ul>
<li>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。</li>
<li>如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li>
</ul>
<h3 id="适配器模式和门面模式的区别"><a href="#适配器模式和门面模式的区别" class="headerlink" title="适配器模式和门面模式的区别"></a>适配器模式和门面模式的区别</h3><p>适配器模式和门面模式的共同点是，将不好用的接口适配成好用的接口。那他们的区别是什么？</p>
<ul>
<li>适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。是一种“补偿模式”。</li>
<li>门面模式做接口整合，解决的是多接口调用带来的问题。是一种事前行为，是接口设计时该考虑的。</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</li>
<li>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</li>
</ul>
<h2 id="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h2><p>组合模式（Composite Design Pattern）</p>
<h3 id="组合模式的理解："><a href="#组合模式的理解：" class="headerlink" title="组合模式的理解："></a>组合模式的理解：</h3><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>业务场景必须能够表示成树形结构。</p>
<h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。（在这里一般可以抽象出一个抽象类，叶子节点和中间节点（根节点）继承与抽象类，对中间节点（根节点）处理就是递归的调用）</p>
<h3 id="如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="如何设计实现支持递归遍历的文件系统目录树结构？"></a>如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>
<ul>
<li>动态地添加、删除某个目录下的子目录或文件；</li>
<li>统计指定目录下的文件个数；</li>
<li>统计指定目录下的文件总大小。</li>
</ul>
<p>FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FileSystemNode &#123;</span><br><span class="line">  private String path;</span><br><span class="line">  private boolean isFile;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path, boolean isFile) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">    this.isFile &#x3D; isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    if (isFile) &#123;</span><br><span class="line">      File file &#x3D; new File(path);</span><br><span class="line">      if (!file.exists()) return 0;</span><br><span class="line">      return file.length();</span><br><span class="line">    &#125;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class FileSystemNode &#123;</span><br><span class="line">  protected String path;</span><br><span class="line"></span><br><span class="line">  public FileSystemNode(String path) &#123;</span><br><span class="line">    this.path &#x3D; path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract int countNumOfFiles();</span><br><span class="line">  public abstract long countSizeOfFiles();</span><br><span class="line"></span><br><span class="line">  public String getPath() &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class File extends FileSystemNode &#123;</span><br><span class="line">  public File(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    java.io.File file &#x3D; new java.io.File(path);</span><br><span class="line">    if (!file.exists()) return 0;</span><br><span class="line">    return file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Directory extends FileSystemNode &#123;</span><br><span class="line">  private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public Directory(String path) &#123;</span><br><span class="line">    super(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int countNumOfFiles() &#123;</span><br><span class="line">    int numOfFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles +&#x3D; fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long countSizeOfFiles() &#123;</span><br><span class="line">    long sizeofFiles &#x3D; 0;</span><br><span class="line">    for (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    return sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void removeSubNode(FileSystemNode fileOrDir) &#123;</span><br><span class="line">    int size &#x3D; subNodes.size();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; i &lt; size; ++i) &#123;</span><br><span class="line">      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;a.txt</span><br><span class="line">     * &#x2F;wz&#x2F;b.txt</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;</span><br><span class="line">     * &#x2F;wz&#x2F;movies&#x2F;c.avi</span><br><span class="line">     * &#x2F;xzg&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;</span><br><span class="line">     * &#x2F;xzg&#x2F;docs&#x2F;d.txt</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Directory fileSystemTree &#x3D; new Directory(&quot;&#x2F;&quot;);</span><br><span class="line">    Directory node_wz &#x3D; new Directory(&quot;&#x2F;wz&#x2F;&quot;);</span><br><span class="line">    Directory node_xzg &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;&quot;);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    File node_wz_a &#x3D; new File(&quot;&#x2F;wz&#x2F;a.txt&quot;);</span><br><span class="line">    File node_wz_b &#x3D; new File(&quot;&#x2F;wz&#x2F;b.txt&quot;);</span><br><span class="line">    Directory node_wz_movies &#x3D; new Directory(&quot;&#x2F;wz&#x2F;movies&#x2F;&quot;);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    File node_wz_movies_c &#x3D; new File(&quot;&#x2F;wz&#x2F;movies&#x2F;c.avi&quot;);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    Directory node_xzg_docs &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;docs&#x2F;&quot;);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    File node_xzg_docs_d &#x3D; new File(&quot;&#x2F;xzg&#x2F;docs&#x2F;d.txt&quot;);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;&#x2F; files num:&quot; + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(&quot;&#x2F;wz&#x2F; files num:&quot; + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式 Flyweight Design Pattern</p>
<h3 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p>
<h3 id="享元模式的实现"><a href="#享元模式的实现" class="headerlink" title="享元模式的实现"></a>享元模式的实现</h3><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p>
<p>以利用享元模式在棋局游戏中节省内存为例：</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 享元类</span><br><span class="line">public class ChessPieceUnit &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String text;</span><br><span class="line">  private Color color;</span><br><span class="line"></span><br><span class="line">  public ChessPieceUnit(int id, String text, Color color) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.text &#x3D; text;</span><br><span class="line">    this.color &#x3D; color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static enum Color &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...省略其他属性和getter方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPieceUnitFactory &#123;</span><br><span class="line">  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;</span><br><span class="line">    return pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPiece &#123;</span><br><span class="line">  private ChessPieceUnit chessPieceUnit;</span><br><span class="line">  private int positionX;</span><br><span class="line">  private int positionY;</span><br><span class="line"></span><br><span class="line">  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;</span><br><span class="line">    this.chessPieceUnit &#x3D; unit;</span><br><span class="line">    this.positionX &#x3D; positionX;</span><br><span class="line">    this.positionY &#x3D; positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 省略getter、setter方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessBoard &#123;</span><br><span class="line">  private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public ChessBoard() &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init() &#123;</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(1), 0,0));</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(2), 1,0));</span><br><span class="line">    &#x2F;&#x2F;...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;</span><br><span class="line">    &#x2F;&#x2F;...省略...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p>
<h3 id="如何利用享元模式优化文本编辑器的内存占用？"><a href="#如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="如何利用享元模式优化文本编辑器的内存占用？"></a>如何利用享元模式优化文本编辑器的内存占用？</h3><p>以下代码，在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Character &#123;&#x2F;&#x2F;文字</span><br><span class="line">  private char c;</span><br><span class="line"></span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public Character(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, font, size, colorRGB);</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化方案：</strong><br>在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CharacterStyle &#123;</span><br><span class="line">  private Font font;</span><br><span class="line">  private int size;</span><br><span class="line">  private int colorRGB;</span><br><span class="line"></span><br><span class="line">  public CharacterStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    this.font &#x3D; font;</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">    this.colorRGB &#x3D; colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean equals(Object o) &#123;</span><br><span class="line">    CharacterStyle otherStyle &#x3D; (CharacterStyle) o;</span><br><span class="line">    return font.equals(otherStyle.font)</span><br><span class="line">            &amp;&amp; size &#x3D;&#x3D; otherStyle.size</span><br><span class="line">            &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CharacterStyleFactory &#123;</span><br><span class="line">  private static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;</span><br><span class="line">    CharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);</span><br><span class="line">    for (CharacterStyle style : styles) &#123;</span><br><span class="line">      if (style.equals(newStyle)) &#123;</span><br><span class="line">        return style;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    styles.add(newStyle);</span><br><span class="line">    return newStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Character &#123;</span><br><span class="line">  private char c;</span><br><span class="line">  private CharacterStyle style;</span><br><span class="line"></span><br><span class="line">  public Character(char c, CharacterStyle style) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.style &#x3D; style;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Editor &#123;</span><br><span class="line">  private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;</span><br><span class="line">    Character character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="享元模式-VS-单例、缓存、对象池-的区别"><a href="#享元模式-VS-单例、缓存、对象池-的区别" class="headerlink" title="享元模式 VS 单例、缓存、对象池 的区别"></a>享元模式 VS 单例、缓存、对象池 的区别</h3><p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。</p>
<ul>
<li><p>应用单例模式是为了保证对象全局唯一。</p>
</li>
<li><p>应用享元模式是为了实现对象复用，节省内存。享元模式中的“复用”可以理解为“共享使用”。</p>
</li>
<li><p>缓存是为了提高访问效率，而非复用。</p>
</li>
<li><p>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。比如对象池，线程池</p>
</li>
</ul>
<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p>
<h3 id="剖析享元模式在Java-Integer、String中的应用"><a href="#剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="剖析享元模式在Java Integer、String中的应用"></a>剖析享元模式在Java Integer、String中的应用</h3><h4 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h4><p>自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i &#x3D; 56; &#x2F;&#x2F;自动装箱</span><br><span class="line">int j &#x3D; i; &#x2F;&#x2F;自动拆箱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer i &#x3D; 56；底层执行了：Integer i &#x3D; Integer.valueOf(56);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j &#x3D; i; 底层执行了：int j &#x3D; i.intValue();</span><br></pre></td></tr></table></figure>



<p>为什么下面代码的运行结果为 一个 true, 一个false？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i1 &#x3D; 56;</span><br><span class="line">Integer i2 &#x3D; 56;</span><br><span class="line">Integer i3 &#x3D; 129;</span><br><span class="line">Integer i4 &#x3D; 129;</span><br><span class="line">System.out.println(i1 &#x3D;&#x3D; i2);</span><br><span class="line">System.out.println(i3 &#x3D;&#x3D; i4);</span><br></pre></td></tr></table></figure>

<p>这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建，Integer 类的 valueOf() 函数的具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntegerCache 则是生产享元对象的工厂类 （只说名字不叫XXXFactory），代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">        int h &#x3D; 127;</span><br><span class="line">        String integerCacheHighPropValue &#x3D;</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">                i &#x3D; Math.max(i, 127);</span><br><span class="line">                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high &#x3D; h;</span><br><span class="line"></span><br><span class="line">        cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">        int j &#x3D; low;</span><br><span class="line">        for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] &#x3D; new Integer(j++);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。不过 JDK 也提供了方法来让我们可以自定义缓存的最大值(没有提供设置最小值的方法)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure>

<p>除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。比如 Long 类型对应的 LongCache 享元工厂类及 valueOf()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class LongCache &#123;</span><br><span class="line">    private LongCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] &#x3D; new Long(i - 128);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Long valueOf(long l) &#123;</span><br><span class="line">    final int offset &#x3D; 128;</span><br><span class="line">    if (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; &#x2F;&#x2F; will cache</span><br><span class="line">        return LongCache.cache[(int)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面三种创建对象的方式，推荐使用哪种？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer a &#x3D; new Integer(123);</span><br><span class="line">Integer a &#x3D; 123;</span><br><span class="line">Integer a &#x3D; Integer.valueOf(123);</span><br></pre></td></tr></table></figure>

<p>答案是推荐使用后面两种，第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p>
<h4 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s2 &#x3D; &quot;小争哥&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;小争哥&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);  &#x2F;&#x2F;运行结果为：true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);  &#x2F;&#x2F;运行结果为：false</span><br></pre></td></tr></table></figure>

<p>跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2473" alt="2dfc18575c22efccca191c566b24a22d.jpeg"></p>
<h4 id="String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？"><a href="#String-类的享元模式的设计，跟-Integer-类的享元模式的设计有什么不同？" class="headerlink" title="String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？"></a>String 类的享元模式的设计，跟 Integer 类的享元模式的设计有什么不同？</h4><ul>
<li><p>Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。</p>
</li>
<li><p>对于字符串来说，没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）</title>
    <url>/2020/10/08/design-pattern05/</url>
    <content><![CDATA[<p>总结回顾面向对象、设计原则、编程规范、重构技巧等知识点（Part1~Part4）, 因为这部分是核心思想，设计模式只是在这些指导思想下总结出来的招式。理解这些思想原则了才能清楚在什么场景下该用哪种设计模式，用了之后能带来哪些优缺点。</p>
<a id="more"></a>

<h2 id="如何写出高质量的代码"><a href="#如何写出高质量的代码" class="headerlink" title="如何写出高质量的代码"></a>如何写出高质量的代码</h2><p><img src="/images/dp01.png" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p>
<h2 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h2><p><img src="/images/dp02.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b.jpeg"></p>
<h2 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h2><p><img src="/images/dp03.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7.jpeg"></p>
<h3 id="面向对象的四大特性"><a href="#面向对象的四大特性" class="headerlink" title="面向对象的四大特性"></a>面向对象的四大特性</h3><ul>
<li><p>封装<br>封装主要讲如何隐藏信息、保护数据。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p>
</li>
<li><p>抽象<br>抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
</li>
<li><p>继承<br>继承用来表示类之间的 is-a 关系，继承主要是用来解决代码复用的问题。</p>
</li>
<li><p>多态<br>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p>
</li>
</ul>
<h3 id="面向对象-VS-面向过程"><a href="#面向对象-VS-面向过程" class="headerlink" title="面向对象 VS 面向过程"></a>面向对象 VS 面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个：</p>
<ul>
<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li>
<li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li>
<li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li>
</ul>
<p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p>
<h3 id="面向对象分析、设计与编程"><a href="#面向对象分析、设计与编程" class="headerlink" title="面向对象分析、设计与编程"></a>面向对象分析、设计与编程</h3><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。面向对象分析就是要搞清楚做什么，产出是详细的需求描述；面向对象设计就是要搞清楚怎么做，产出是类；面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p>
<p>在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p>
<ul>
<li><p>划分职责进而识别出有哪些类<br>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p>
</li>
<li><p>定义类及其属性和方法<br>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p>
</li>
<li><p>定义类与类之间的交互关系<br>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。（需要注意聚合和组合的区别）</p>
</li>
<li><p>将类组装起来并提供执行入口<br>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
</li>
</ul>
<h3 id="接口-vs-抽象类"><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h3><p>可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p>
<p>接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p>
<p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p>
<p>什么时候该用抽象类？什么时候该用接口？<br>实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p>
<h3 id="基于接口而非实现编程（即基于抽象而非实现编程）"><a href="#基于接口而非实现编程（即基于抽象而非实现编程）" class="headerlink" title="基于接口而非实现编程（即基于抽象而非实现编程）"></a>基于接口而非实现编程（即基于抽象而非实现编程）</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>组合相比继承有哪些优势？<br>继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。但是继承容易出现层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<p>而通过组合、接口、委托三个技术就可以在实现继承功能的同时，解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<p>如何判断该用组合还是继承？<br>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<h3 id="贫血模型-VS-充血模型"><a href="#贫血模型-VS-充血模型" class="headerlink" title="贫血模型 VS 充血模型"></a>贫血模型 VS 充血模型</h3><p>对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。  而对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用。</p>
<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p>
<h2 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h2><p><img src="/images/dp04.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f.jpeg"></p>
<h3 id="1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）"><a href="#1-SOLID-原则：SRP-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）"></a>1.SOLID 原则：SRP 单一职责原则（Single Responsibility Principle）</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li>类依赖的其他类过多或者依赖类的其他类过多；</li>
<li>私有方法过多；</li>
<li>比较难给类起一个合适的名字；</li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>
<h3 id="2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）"><a href="#2-SOLID-原则：OCP-开闭原则（Open-Closed-Principle）" class="headerlink" title="2.SOLID 原则：OCP 开闭原则（Open Closed Principle）"></a>2.SOLID 原则：OCP 开闭原则（Open Closed Principle）</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<p>两点要注意：</p>
<ul>
<li>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li>
<li>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li>
</ul>
<h3 id="3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）"><a href="#3-SOLID-原则：LSP-里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）"></a>3.SOLID 原则：LSP 里式替换原则（Liskov Substitution Principle）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<p>里式替换原则跟多态的区别：</p>
<ul>
<li>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</li>
<li>里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li>
</ul>
<h3 id="4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）"><a href="#4-SOLID-原则：ISP-接口隔离原则（Interface-Segregation-Principle”）" class="headerlink" title="4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）"></a>4.SOLID 原则：ISP 接口隔离原则（Interface Segregation Principle”）</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。</p>
<ul>
<li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li>
<li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li>
<li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</li>
</ul>
<p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）"><a href="#5-DIP-依赖倒置原则-（Dependency-Inversion-Principle）" class="headerlink" title="5.DIP 依赖倒置原则 （Dependency Inversion Principle）"></a>5.DIP 依赖倒置原则 （Dependency Inversion Principle）</h3><p>依赖反转原则也叫作依赖倒置原则。主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p>
<h3 id="6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）"><a href="#6-KISS、YAGNI-原则-（Keep-It-Simple-and-Stupid、You-Ain’t-Gonna-Need-It）" class="headerlink" title="6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）"></a>6.KISS、YAGNI 原则 （Keep It Simple and Stupid、You Ain’t Gonna Need It）</h3><h4 id="Keep-It-Simple-and-Stupid"><a href="#Keep-It-Simple-and-Stupid" class="headerlink" title="Keep It Simple and Stupid"></a>Keep It Simple and Stupid</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段</p>
<p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码；</li>
<li>不要重复造轮子，善于使用已经有的工具类库；</li>
<li>不要过度优化。</li>
</ul>
<h4 id="You-Ain’t-Gonna-Need-It"><a href="#You-Ain’t-Gonna-Need-It" class="headerlink" title="You Ain’t Gonna Need It"></a>You Ain’t Gonna Need It</h4><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p>
<p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p>
<h3 id="7-DRY-原则（Don’t-Repeat-Yourself）"><a href="#7-DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="7.DRY 原则（Don’t Repeat Yourself）"></a>7.DRY 原则（Don’t Repeat Yourself）</h3><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p>
<p>三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，</p>
<ul>
<li>功能语义不重复的代码，并不违反 DRY 原则。</li>
<li>实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。</li>
<li>代码执行重复也算是违反 DRY 原则。</li>
</ul>
<h3 id="8-LOD-迪米特法则（Law-of-Demeter）"><a href="#8-LOD-迪米特法则（Law-of-Demeter）" class="headerlink" title="8.LOD 迪米特法则（Law of Demeter）"></a>8.LOD 迪米特法则（Law of Demeter）</h3><p>迪米特法则的描述为：</p>
<ul>
<li>不该有直接依赖关系的类之间，不要有依赖；</li>
<li>有依赖关系的类之间，尽量只依赖必要的接口。</li>
</ul>
<p>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p>
<ul>
<li><p>高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</p>
</li>
<li><p>松耦合，指的是在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
</li>
</ul>
<h2 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h2><p><img src="/images/dp05.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a.jpeg"></p>
<h3 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1.重构概述"></a>1.重构概述</h3><h4 id="重构的目的：为什么重构（why）？"><a href="#重构的目的：为什么重构（why）？" class="headerlink" title="重构的目的：为什么重构（why）？"></a>重构的目的：为什么重构（why）？</h4><p>重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p>
<h4 id="重构的对象：重构什么（what）？"><a href="#重构的对象：重构什么（what）？" class="headerlink" title="重构的对象：重构什么（what）？"></a>重构的对象：重构什么（what）？</h4><p>可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p>
<ul>
<li>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</li>
<li></li>
<li>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</li>
</ul>
<h4 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p>
<h4 id="重构的方法：如何重构（how）？"><a href="#重构的方法：如何重构（how）？" class="headerlink" title="重构的方法：如何重构（how）？"></a>重构的方法：如何重构（how）？</h4><ul>
<li><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。</p>
</li>
<li><p>小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p>
</li>
</ul>
<h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h3><h4 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h4><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。这个“单元”一般是类或函数，而不是模块或者系统。</p>
<h4 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h4><p>单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。</p>
<h4 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h4><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。</p>
<p>对于单元测试，我们需要建立以下正确的认知：</p>
<ul>
<li>编写单元测试尽管繁琐，但并不是太耗时；</li>
<li>我们可以稍微放低单元测试的质量要求；</li>
<li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li>
<li>写单元测试一般不需要了解代码的实现逻辑；</li>
<li>单元测试框架无法测试多半是代码的可测试性不好。</li>
</ul>
<h4 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h4><ul>
<li>写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。</li>
<li>国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，</li>
<li>没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</li>
</ul>
<h3 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3.代码的可测试性"></a>3.代码的可测试性</h3><h4 id="什么是代码的可测试性？"><a href="#什么是代码的可测试性？" class="headerlink" title="什么是代码的可测试性？"></a>什么是代码的可测试性？</h4><p>所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p>
<h4 id="编写可测试性代码的最有效手段"><a href="#编写可测试性代码的最有效手段" class="headerlink" title="编写可测试性代码的最有效手段"></a>编写可测试性代码的最有效手段</h4><ul>
<li><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p>
</li>
<li><p>除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况</p>
</li>
</ul>
<h4 id="典型的、常见的测试不友好的代码（Anti-Patterns）"><a href="#典型的、常见的测试不友好的代码（Anti-Patterns）" class="headerlink" title="典型的、常见的测试不友好的代码（Anti-Patterns）"></a>典型的、常见的测试不友好的代码（Anti-Patterns）</h4><ul>
<li>代码中包含未决行为逻辑；</li>
<li>滥用可变全局变量；</li>
<li>滥用静态方法；</li>
<li>使用复杂的继承关系；</li>
<li>高度耦合的代码。</li>
</ul>
<h3 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h3><p>解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p>
<h4 id="如何判断代码是否需要解耦？"><a href="#如何判断代码是否需要解耦？" class="headerlink" title="如何判断代码是否需要解耦？"></a>如何判断代码是否需要解耦？</h4><p>间接的衡量：</p>
<ul>
<li>比如改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动</li>
<li>代码的可测试性是否好等等</li>
</ul>
<h4 id="如何给代码进行解耦"><a href="#如何给代码进行解耦" class="headerlink" title="如何给代码进行解耦"></a>如何给代码进行解耦</h4><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。还有一些设计模式，比如观察者模式。</p>
<h3 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h3><p>持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p>
<h4 id="命名与注释"><a href="#命名与注释" class="headerlink" title="命名与注释"></a>命名与注释</h4><ul>
<li><p>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</p>
</li>
<li><p>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p>
</li>
<li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。接口有两种命名方式。</p>
</li>
<li><p>一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</p>
</li>
<li><p>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p>
</li>
<li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</p>
</li>
</ul>
<h4 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h4><ul>
<li>将复杂的逻辑提炼拆分成函数和类；</li>
<li>通过拆分成多个函数的方式来处理参数过多的情况；</li>
<li>通过将参数封装为对象来处理参数过多的情况；</li>
<li>函数中不要使用参数来做代码执行逻辑的控制；</li>
<li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li>
<li>用字面常量取代魔法数；</li>
<li>利用解释性变量来解释复杂表达式。</li>
</ul>
<h4 id="统一代码风格、编码规范"><a href="#统一代码风格、编码规范" class="headerlink" title="统一代码风格、编码规范"></a>统一代码风格、编码规范</h4><p>最好能跟业内推荐的风格、开源项目的代码风格相一致，然后在公司内部形成统一，比如可以参照<br><a href="https://ucc-private-download.oss-cn-beijing.aliyuncs.com/66995068b45c4ebfa74afcfc2e76212c.pdf?Expires=1607054448&OSSAccessKeyId=LTAIvsP3ECkg4Nm9&Signature=KOnMQdpuOGJtZVeyIrGlDxkXIlU%3D" target="_blank" rel="noopener">阿里《Java开发手册（嵩山版）》</a></p>
<h4 id="阿里-Java开发手册（嵩山版）"><a href="#阿里-Java开发手册（嵩山版）" class="headerlink" title="阿里 Java开发手册（嵩山版）"></a>阿里 Java开发手册（嵩山版）</h4><p><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">下载地址</a></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part4：规范与重构</title>
    <url>/2020/10/07/design-pattern-refactoring/</url>
    <content><![CDATA[<h2 id="理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>理论一：什么情况下要重构？到底重构什么？又该如何重构？</h2><h3 id="1-重构的目的："><a href="#1-重构的目的：" class="headerlink" title="1. 重构的目的："></a>1. 重构的目的：</h3><p>为什么重构（why）？<br>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。</p>
<p>对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p>
<a id="more"></a>

<h3 id="2-重构的对象："><a href="#2-重构的对象：" class="headerlink" title="2. 重构的对象："></a>2. 重构的对象：</h3><p>重构什么（what）？按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p>
<p>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</p>
<p>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p>
<h3 id="3-重构的时机："><a href="#3-重构的时机：" class="headerlink" title="3. 重构的时机："></a>3. 重构的时机：</h3><p>什么时候重构（when）？我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p>
<p>平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p>
<h3 id="4-重构的方法："><a href="#4-重构的方法：" class="headerlink" title="4. 重构的方法："></a>4. 重构的方法：</h3><p>如何重构（how）？大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p>
<p>而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p>
<p>idea 可以安装 Alibaba Java Coding Guidelines 来帮助解决一些规范的问题，重构解决一些低级别的错误<br><a href="https://www.cnblogs.com/DDgougou/p/9282554.html" target="_blank" rel="noopener">https://www.cnblogs.com/DDgougou/p/9282554.html</a></p>
<h3 id="评论区精彩评论"><a href="#评论区精彩评论" class="headerlink" title="评论区精彩评论"></a>评论区精彩评论</h3><h4 id="一个重构的案例（步骤）"><a href="#一个重构的案例（步骤）" class="headerlink" title="一个重构的案例（步骤）"></a>一个重构的案例（步骤）</h4><p>前段时间刚重构了一个功能模块。该模块可以说是祖传代码。里面堆砌着各种判断条件，就是所谓的箭头型代码。我接手这个功能重构的<br>1.把代码读一遍和跑一遍，理解里面的需求。尽量画一个流程图。<br>2.建立防护网。将需求拆分之后，针对每个拆分的业务点写单元测试。<br>4.开始重构，解耦逻辑，设计方法的时候尽量让职业单一，类与类之间尽量符合迪米特原则，有依赖关系的类尽量只依赖类的特定方法。我觉得比较基础也是比较重要一点。不要有重复代码。命名要规范，类的各个职业要清晰。重构过程中，其实也要时不时的识别代码的坏味道。尽然是重构，那么肯定要比不重构之前肯定要更好。<br>5.重构完成之后，通过防护网的测试。</p>
<h4 id="重构后的功能一定要可测试"><a href="#重构后的功能一定要可测试" class="headerlink" title="重构后的功能一定要可测试"></a>重构后的功能一定要可测试</h4><p>代码中的坏味道，好比人的头疼脑热。“小病”不管的话，迟早会发展成大病，需要动大手术，甚至病入膏肓。<br>实际中的一些体会：<br>一、在完成一个新需求时，在时间允许的情况下，会经常改进代码，使代码更优雅。<br>二、“重构不改变外部的可见行为“，引入自动化测试非常重要，国内有些团队可能做的不好。因为改动代码可能引入bug，如果没有自动化测试，测起来就会非常费劲，改动的结果不确定。如果测试不方便，谁会愿意修改之前work的代码呢？<br>三、持续集成、自动化测试、持续重构都是很好的工程实践。即使工作的项目中暂时没有使用，也应该有所了解。</p>
<h4 id="写单元测试很重要，谁写谁知道"><a href="#写单元测试很重要，谁写谁知道" class="headerlink" title="写单元测试很重要，谁写谁知道"></a>写单元测试很重要，谁写谁知道</h4><p>最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。</p>
<h2 id="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h2><p>什么是单元测试？为什么要写单元测试？如何编写单元测试？如何在团队中推行单元测试？</p>
<p>那如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合上一节课中我们对重构的定义。</p>
<h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p>
<p>我们常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p>
<h3 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h3><p>写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 TDD 可落地执行的改进方案。</p>
<h4 id="1-单元测试能有效地帮你发现代码中的-bug"><a href="#1-单元测试能有效地帮你发现代码中的-bug" class="headerlink" title="1.单元测试能有效地帮你发现代码中的 bug"></a>1.单元测试能有效地帮你发现代码中的 bug</h4><p>坚持为自己提交的每一份代码，都编写完善的单元测试。可以减少很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，可以因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证代码质量的一个“杀手锏”，也是帮助拉开与其他人差距的一个“小秘密”。</p>
<h4 id="2-写单元测试能帮你发现代码设计上的问题"><a href="#2-写单元测试能帮你发现代码设计上的问题" class="headerlink" title="2.写单元测试能帮你发现代码设计上的问题"></a>2.写单元测试能帮你发现代码设计上的问题</h4><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p>
<h4 id="3-单元测试是对集成测试的有力补充"><a href="#3-单元测试是对集成测试的有力补充" class="headerlink" title="3.单元测试是对集成测试的有力补充"></a>3.单元测试是对集成测试的有力补充</h4><p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p>
<h4 id="4-写单元测试的过程本身就是代码重构的过程？"><a href="#4-写单元测试的过程本身就是代码重构的过程？" class="headerlink" title="4.写单元测试的过程本身就是代码重构的过程？"></a>4.写单元测试的过程本身就是代码重构的过程？</h4><p>设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p>
<h4 id="5-阅读单元测试能帮助你快速熟悉代码"><a href="#5-阅读单元测试能帮助你快速熟悉代码" class="headerlink" title="5.阅读单元测试能帮助你快速熟悉代码"></a>5.阅读单元测试能帮助你快速熟悉代码</h4><p>在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p>
<h4 id="6-单元测试是-TDD-可落地执行的改进方案"><a href="#6-单元测试是-TDD-可落地执行的改进方案" class="headerlink" title="6.单元测试是 TDD 可落地执行的改进方案"></a>6.单元测试是 TDD 可落地执行的改进方案</h4><p>单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点。</p>
<h3 id="如何编写单元测试"><a href="#如何编写单元测试" class="headerlink" title="如何编写单元测试"></a>如何编写单元测试</h3><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。这些框架提供了通用的执行流程（比如执行测试用例的 TestCaseRunner）和工具类库（比如各种 Assert 判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p>
<p>除此之外，对于单元测试，我们需要建立以下正确的认知：</p>
<ul>
<li>编写单元测试尽管繁琐，但并不是太耗时；</li>
<li>我们可以稍微放低对单元测试代码质量的要求；</li>
<li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li>
<li>单元测试不要依赖被测代码的具体实现逻辑；</li>
<li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li>
</ul>
<h3 id="一个单元测试的例子"><a href="#一个单元测试的例子" class="headerlink" title="一个单元测试的例子"></a>一个单元测试的例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Text &#123;</span><br><span class="line">  private String content;</span><br><span class="line"></span><br><span class="line">  public Text(String content) &#123;</span><br><span class="line">    this.content &#x3D; content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将字符串转化成数字，忽略字符串中的首尾空格；</span><br><span class="line">   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Integer toNumber() &#123;</span><br><span class="line">    if (content &#x3D;&#x3D; null || content.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略代码实现...</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要测试 一下Text 类中的 toNumber() 函数的正确性，应该如何编写单元测试呢？</p>
<p>写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p>
<h4 id="罗列出各种正常，异常，以及边界的测试用例"><a href="#罗列出各种正常，异常，以及边界的测试用例" class="headerlink" title="罗列出各种正常，异常，以及边界的测试用例"></a>罗列出各种正常，异常，以及边界的测试用例</h4><ul>
<li>如果字符串只包含数字：“123”，toNumber() 函数输出对应的整数：123。</li>
<li>如果字符串是空或者 null，toNumber() 函数返回：null。</li>
<li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数：123。</li>
<li>如果字符串包含多个首尾空格：“ 123 ”，toNumber() 返回对应的整数：123；</li>
<li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber() 返回 null；</li>
</ul>
<h4 id="将测试用例翻译成代码"><a href="#将测试用例翻译成代码" class="headerlink" title="将测试用例翻译成代码"></a>将测试用例翻译成代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Assert &#123;</span><br><span class="line">  public static void assertEquals(Integer expectedValue, Integer actualValue) &#123;</span><br><span class="line">    if (actualValue !&#x3D; expectedValue) &#123;</span><br><span class="line">      String message &#x3D; String.format(</span><br><span class="line">              &quot;Test failed, expected: %d, actual: %d.&quot;, expectedValue, actualValue);</span><br><span class="line">      System.out.println(message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static boolean assertNull(Integer actualValue) &#123;</span><br><span class="line">    boolean isNull &#x3D; actualValue &#x3D;&#x3D; null;</span><br><span class="line">    if (isNull) &#123;</span><br><span class="line">      System.out.println(&quot;Test succeeded.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;Test failed, the value is not null:&quot; + actualValue);</span><br><span class="line">    &#125;</span><br><span class="line">    return isNull;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TextTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber() &#123;</span><br><span class="line">    Text text &#x3D; new Text(&quot;123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_nullorEmpty() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(null);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot; 123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot; 123 &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsMultiLeadingAndTrailingSpaces() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;  123&quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text3 &#x3D; new Text(&quot;  123  &quot;);</span><br><span class="line">    Assert.assertEquals(new Integer(123), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testToNumber_containsInvalidCharaters() &#123;</span><br><span class="line">    Text text1 &#x3D; new Text(&quot;123a4&quot;);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    Text text2 &#x3D; new Text(&quot;123 4&quot;);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h3><ul>
<li>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；</li>
<li>另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</li>
</ul>
<h3 id="重度依赖数据库的业务代码如何做单元测试"><a href="#重度依赖数据库的业务代码如何做单元测试" class="headerlink" title="重度依赖数据库的业务代码如何做单元测试"></a>重度依赖数据库的业务代码如何做单元测试</h3><ul>
<li>涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</li>
<li>涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</li>
</ul>
<h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>1.以前在开发中，没有写单元测试的意识。开发完功能后，直接去测试一个完整的流程。即前端发请求，服务端处理，看数据库数据。如果功能正确就过。这是从一个功能宏观去考虑测试。而单元测试是更细粒度的测试，它在保证各个“单元”都测试通过的情况下整个功能模块就测试通过了。这样的方式对于我们自己来说对代码可控粒度更细。更能比较清楚的理解某个“单元”在整个功能模块调用链路上的位置，承担什么职责，以及有什么行为。而不是一开始就站在模块宏观角度来思考。通过一个个单元测试的编写，将整个功能模块串联起来，最终达到整个功能模块的全局认知。 这也体现了任务分解的思想。通过单元测试，可以从另外一方面实现对已编写的代码的CodeReview，重新梳理流程。也为以后有重构需求打下基础。目前参与的项目中有单元测试，但是不够完备。可能由于某些原因（开发人员意识问题，团队对单元测试的执行落地程度不够等）。在写单元测试的过程中，遇到单元测试依赖数据库查询问题，因为存在多套环境，如开发环境，仿真环境，线上环境。对于依赖数据查询的单元测试，只能自己造假数据来解决。不知道还有什么好的解决办法。</p>
<p>作者回复：涉及到数据库的确实比较难写单元测试，而且如果重度依赖数据库，业务逻辑又不复杂，单元测试确实没有太大意义。这个时候，集成测试可能更有意义些。</p>
<p>2.如果到了具体的业务代码，该怎么写单元测试呢，单元测试正确标准是什么呢，以sql查询到的结果吗？</p>
<p>作者回复：涉及到数据库的项目，特别是重度依赖数据库的，确实比较难写单元测试。一种方式使用DBUNIT这样的测试框架来解耦合真正的数据库，另一种方式专门维护一个供单元测试用的数据库。</p>
<p>3.单元测试很重要，但是为什么大多人都会放弃？我个人觉得最主要的原因并不是代码量大，难以编写等，而是跑单元测试的次数少。很多单元测试都是为了写而写，写完一次可能都不去运行或者只偶尔运行一两次。如果是每次改完代码，都跑一遍单元测试，单元测试的效果会越来越显现。如果只是为了运行一两次或者干脆为了写而写，很容易就会放弃继续写单元测试。</p>
<p>作者回复：可以集成到代码管理仓库git中，强制跑单元测试成功之后才能提交</p>
<h2 id="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h2><p>写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。</p>
<h3 id="1-什么是代码的可测试性？"><a href="#1-什么是代码的可测试性？" class="headerlink" title="1. 什么是代码的可测试性？"></a>1. 什么是代码的可测试性？</h3><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p>
<h3 id="2-编写可测试性代码的最有效手段"><a href="#2-编写可测试性代码的最有效手段" class="headerlink" title="2. 编写可测试性代码的最有效手段"></a>2. 编写可测试性代码的最有效手段</h3><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方</p>
<h3 id="3-常见的-Anti-Patterns"><a href="#3-常见的-Anti-Patterns" class="headerlink" title="3. 常见的 Anti-Patterns"></a>3. 常见的 Anti-Patterns</h3><p>常见的测试不友好的代码有下面这 5 种：</p>
<ul>
<li>代码中包含未决行为逻辑</li>
<li>滥用可变全局变量</li>
<li>滥用静态方法使用复杂的继承关系</li>
<li>高度耦合的代码</li>
</ul>
<h3 id="4-mock-用一个“假”的服务替换真正的服务"><a href="#4-mock-用一个“假”的服务替换真正的服务" class="headerlink" title="4.mock 用一个“假”的服务替换真正的服务"></a>4.mock 用一个“假”的服务替换真正的服务</h3><p>单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。</p>
<p>那如何来 mock 服务呢？mock 的方式主要有两种，手动 mock 和利用框架 mock。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private Long buyerId;</span><br><span class="line">  private Long sellerId;</span><br><span class="line">  private Long productId;</span><br><span class="line">  private String orderId;</span><br><span class="line">  private Long createTimestamp;</span><br><span class="line">  private Double amount;</span><br><span class="line">  private STATUS status;</span><br><span class="line">  private String walletTransactionId;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; ...get() methods...</span><br><span class="line">  </span><br><span class="line">  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) &#123;</span><br><span class="line">    if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;</span><br><span class="line">      this.id &#x3D; preAssignedId;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.id &#x3D; IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!this.id.startWith(&quot;t_&quot;)) &#123;</span><br><span class="line">      this.id &#x3D; &quot;t_&quot; + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">    this.buyerId &#x3D; buyerId;</span><br><span class="line">    this.sellerId &#x3D; sellerId;</span><br><span class="line">    this.productId &#x3D; productId;</span><br><span class="line">    this.orderId &#x3D; orderId;</span><br><span class="line">    this.status &#x3D; STATUS.TO_BE_EXECUTD;</span><br><span class="line">    this.createTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean execute() throws InvalidTransactionException &#123;</span><br><span class="line">    if ((buyerId &#x3D;&#x3D; null || (sellerId &#x3D;&#x3D; null || amount &lt; 0.0) &#123;</span><br><span class="line">      throw new InvalidTransactionException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    if (status &#x3D;&#x3D; STATUS.EXECUTED) return true;</span><br><span class="line">    boolean isLocked &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">      if (!isLocked) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; 锁定未成功，返回false，job兜底执行</span><br><span class="line">      &#125;</span><br><span class="line">      if (status &#x3D;&#x3D; STATUS.EXECUTED) return true; &#x2F;&#x2F; double check</span><br><span class="line">      long executionInvokedTimestamp &#x3D; System.currentTimestamp();</span><br><span class="line">      if (executionInvokedTimestamp - createdTimestap &gt; 14days) &#123;</span><br><span class="line">        this.status &#x3D; STATUS.EXPIRED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">      String walletTransactionId &#x3D; walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">      if (walletTransactionId !&#x3D; null) &#123;</span><br><span class="line">        this.walletTransactionId &#x3D; walletTransactionId;</span><br><span class="line">        this.status &#x3D; STATUS.EXECUTED;</span><br><span class="line">        return true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.status &#x3D; STATUS.FAILED;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">       RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Transaction 类中的 execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。除此之外，代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。</p>
<p>1.当代码包含依赖第三方系统的RPC调用时怎么写 单元测试<br>我们通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。具体的代码实现如下所示。通过 mock 的方式，我们可以让 moveMoney() 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MockWalletRpcServiceOne extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return &quot;123bac&quot;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MockWalletRpcServiceTwo extends WalletRpcService &#123;</span><br><span class="line">  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  &#x2F;&#x2F; 添加一个成员变量及其set方法</span><br><span class="line">  private WalletRpcService walletRpcService;</span><br><span class="line">  </span><br><span class="line">  public void setWalletRpcService(WalletRpcService walletRpcService) &#123;</span><br><span class="line">    this.walletRpcService &#x3D; walletRpcService;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 删除下面这一行代码</span><br><span class="line">    &#x2F;&#x2F; WalletRpcService walletRpcService &#x3D; new WalletRpcService();</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  &#x2F;&#x2F; 使用mock对象来替代真正的RPC服务</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当代码中包含一些不是我们维护的组件的调用时如何写单元测试</li>
</ol>
<p>如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。这样我们就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了。但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionLock &#123;</span><br><span class="line">  public boolean lock(String id) &#123;</span><br><span class="line">    return RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void unlock() &#123;</span><br><span class="line">    RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  private TransactionLock lock;</span><br><span class="line">  </span><br><span class="line">  public void setTransactionLock(TransactionLock lock) &#123;</span><br><span class="line">    this.lock &#x3D; lock;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public boolean execute() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    try &#123;</span><br><span class="line">      isLocked &#x3D; lock.lock();</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (isLocked) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void testExecute() &#123;</span><br><span class="line">  Long buyerId &#x3D; 123L;</span><br><span class="line">  Long sellerId &#x3D; 234L;</span><br><span class="line">  Long productId &#x3D; 345L;</span><br><span class="line">  Long orderId &#x3D; 456L;</span><br><span class="line">  </span><br><span class="line">  TransactionLock mockLock &#x3D; new TransactionLock() &#123;</span><br><span class="line">    public boolean lock(String id) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void unlock() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);</span><br><span class="line">  transaction.setWalletRpcService(new MockWalletRpcServiceOne());</span><br><span class="line">  transaction.setTransactionLock(mockLock);</span><br><span class="line">  boolean executedResult &#x3D; transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.依赖注入是提高代码可测试性的最有效的手段。</p>
<p>2.可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之</p>
<p>3、未决行为：例时间、随机数。将未决行为重新封装，测试时mock，使用匿名类。</p>
<h2 id="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h2><p>大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，今天我们重点讲解最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合。</p>
<h3 id="“解耦”为何如此重要？"><a href="#“解耦”为何如此重要？" class="headerlink" title="“解耦”为何如此重要？"></a>“解耦”为何如此重要？</h3><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p>
<h3 id="如何判定代码是否需要“解耦”？"><a href="#如何判定代码是否需要“解耦”？" class="headerlink" title="如何判定代码是否需要“解耦”？"></a>如何判定代码是否需要“解耦”？</h3><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p>
<h3 id="如何给代码“解耦”？"><a href="#如何给代码“解耦”？" class="headerlink" title="如何给代码“解耦”？"></a>如何给代码“解耦”？</h3><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p>
<h3 id="设计原则回顾"><a href="#设计原则回顾" class="headerlink" title="设计原则回顾"></a>设计原则回顾</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>
<h4 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h4><p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p>
<h4 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h4><p>继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>
<h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p>
<h2 id="理论五：让你最快速地改善代码质量的20条编程规范"><a href="#理论五：让你最快速地改善代码质量的20条编程规范" class="headerlink" title="理论五：让你最快速地改善代码质量的20条编程规范"></a>理论五：让你最快速地改善代码质量的20条编程规范</h2><h3 id="1-关于命名"><a href="#1-关于命名" class="headerlink" title="1. 关于命名"></a>1. 关于命名</h3><ul>
<li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li>
<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>
<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</li>
<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>
</ul>
<h3 id="2-关于注释"><a href="#2-关于注释" class="headerlink" title="2. 关于注释"></a>2. 关于注释</h3><ul>
<li>关于注释注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>
<li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>
</ul>
<h3 id="3-关于代码风格"><a href="#3-关于代码风格" class="headerlink" title="3.关于代码风格"></a>3.关于代码风格</h3><h4 id="函数、类多大才合适？"><a href="#函数、类多大才合适？" class="headerlink" title="函数、类多大才合适？"></a>函数、类多大才合适？</h4><p>函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。</p>
<h4 id="一行代码多长最合适？"><a href="#一行代码多长最合适？" class="headerlink" title="一行代码多长最合适？"></a>一行代码多长最合适？</h4><p> 最好不要超过 IDE 显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p>
<h4 id="善用空行分割单元块"><a href="#善用空行分割单元块" class="headerlink" title="善用空行分割单元块"></a>善用空行分割单元块</h4><p>对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。</p>
<h4 id="四格缩进还是两格缩进？"><a href="#四格缩进还是两格缩进？" class="headerlink" title="四格缩进还是两格缩进？"></a>四格缩进还是两格缩进？</h4><p>我个人比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。</p>
<h4 id="大括号是否要另起一行？"><a href="#大括号是否要另起一行？" class="headerlink" title="大括号是否要另起一行？"></a>大括号是否要另起一行？</h4><p>我个人还是比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。6. 类中成员的排列顺序在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p>
<h4 id="类中成员的排列顺序"><a href="#类中成员的排列顺序" class="headerlink" title="类中成员的排列顺序"></a>类中成员的排列顺序</h4><p>在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p>
<h3 id="4-关于变成技巧"><a href="#4-关于变成技巧" class="headerlink" title="4.关于变成技巧"></a>4.关于变成技巧</h3><ul>
<li>将复杂的逻辑提炼拆分成函数和类。</li>
<li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li>
<li>函数中不要使用参数来做代码执行逻辑的控制。</li>
<li>函数设计要职责单一。移</li>
<li>除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li>
<li>用字面常量取代魔法数。</li>
<li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li>
</ul>
<p>代码示例<br>1.用解释性变量来解释复杂表达式，以此提高代码可读性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰</span><br><span class="line">boolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line">if (isSummer) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.常量替代魔法数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return (3.1415) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常量替代魔法数字</span><br><span class="line">public static final Double PI &#x3D; 3.1415;</span><br><span class="line">public double CalculateCircularArea(double radius) &#123;</span><br><span class="line">  return PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.调整执行顺序来减少嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重构前的代码</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;</span><br><span class="line">    for (String str : strList) &#123;</span><br><span class="line">      if (str !&#x3D; null) &#123;</span><br><span class="line">        if (str.contains(substr)) &#123;</span><br><span class="line">          matchedStrings.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑</span><br><span class="line">public List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;</span><br><span class="line">  if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  for (String str : strList) &#123;</span><br><span class="line">    if (str !&#x3D; null) &#123;</span><br><span class="line">      if (str.contains(substr)) &#123;</span><br><span class="line">        matchedStrings.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-统一编码规范"><a href="#5-统一编码规范" class="headerlink" title="5.统一编码规范"></a>5.统一编码规范</h3><p>除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</p>
<h3 id="代码分析工具推荐"><a href="#代码分析工具推荐" class="headerlink" title="代码分析工具推荐"></a>代码分析工具推荐</h3><p>代码中的很多低级质量问题不需要人工去审查，java开发有很多现成的工具可以使用，比如：checkstyle，findbugs, pmd, jacaco, sonar等。</p>
<p>Checkstyle,findbugs,pmd是静态代码分析工具，通过分析源代码或者字节码，找出代码的缺陷，比如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。三者都可以集成到gradle等构建工具中。</p>
<p>Jacoco是一种单元测试覆盖率统计工具，也可以集成到gradle等构建工具中，可以生成漂亮的测试覆盖率统计报表，同时Eclipse提供了插件可以EclEmma可以直观的在IDE中查看单元测试的覆盖情况。</p>
<p>Sonar Sonar 是一个用于代码质量管理的平台。可以在一个统一的平台上显示管理静态分析，单元测试覆盖率等质量报告。</p>
<h2 id="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h2><h3 id="如何发现代码质量问题-常规checkList"><a href="#如何发现代码质量问题-常规checkList" class="headerlink" title="如何发现代码质量问题-常规checkList"></a>如何发现代码质量问题-常规checkList</h3><ul>
<li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li>
<li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li>
<li>设计模式是否应用得当？是否有过度设计？</li>
<li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li>
<li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li>
<li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li>
<li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li>
</ul>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2459" alt="041e22cac6ce2ba3481e246c119adfc9.jpeg"></p>
<h3 id="如何发现代码质量问题-业务需求checkList"><a href="#如何发现代码质量问题-业务需求checkList" class="headerlink" title="如何发现代码质量问题-业务需求checkList"></a>如何发现代码质量问题-业务需求checkList</h3><ul>
<li>代码是否实现了预期的业务需求？</li>
<li>逻辑是否正确？是否处理了各种异常情况？日</li>
<li>志打印是否得当？是否方便 debug 排查问题？</li>
<li>接口是否易用？是否支持幂等、事务等？</li>
<li>代码是否存在并发问题？是否线程安全？</li>
<li>性能是否有优化空间，比如，SQL、算法是否可以优化？</li>
<li>是否有安全漏洞？比如输入输出校验是否全面？</li>
<li><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2460" alt="9894233257994a69102afa960692ce98.jpeg"></li>
</ul>
<h3 id="一段有很多问题的ID生成器代码"><a href="#一段有很多问题的ID生成器代码" class="headerlink" title="一段有很多问题的ID生成器代码"></a>一段有很多问题的ID生成器代码</h3><p>为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。</p>
<p>借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在 Java 语言中，我们可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的 ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求 ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID 信息，我们就可以通过请求 ID 来搜索同一个请求的所有日志了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(IdGenerator.class);</span><br><span class="line"></span><br><span class="line">  public static String generate() &#123;</span><br><span class="line">    String id &#x3D; &quot;&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      if (tokens.length &gt; 0) &#123;</span><br><span class="line">        hostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      &#125;</span><br><span class="line">      char[] randomChars &#x3D; new char[8];</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line">      while (count &lt; 8) &#123;</span><br><span class="line">        int randomAscii &#x3D; random.nextInt(122);</span><br><span class="line">        if (randomAscii &gt;&#x3D; 48 &amp;&amp; randomAscii &lt;&#x3D; 57) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;0&#39; + (randomAscii - 48));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 65 &amp;&amp; randomAscii &lt;&#x3D; 90) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;A&#39; + (randomAscii - 65));</span><br><span class="line">          count++;</span><br><span class="line">        &#125; else if (randomAscii &gt;&#x3D; 97 &amp;&amp; randomAscii &lt;&#x3D; 122) &#123;</span><br><span class="line">          randomChars[count] &#x3D; (char)(&#39;a&#39; + (randomAscii - 97));</span><br><span class="line">          count++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      id &#x3D; String.format(&quot;%s-%d-%s&quot;, hostName,</span><br><span class="line">              System.currentTimeMillis(), new String(randomChars));</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h2><p>重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。</p>
<ul>
<li>第一轮重构：提高代码的可读性</li>
<li>第二轮重构：提高代码的可测试性</li>
<li>第三轮重构：编写完善的单元测试</li>
<li>第四轮重构：所有重构完成之后添加注释</li>
</ul>
<h3 id="第一轮重构：提高代码的可读性"><a href="#第一轮重构：提高代码的可读性" class="headerlink" title="第一轮重构：提高代码的可读性"></a>第一轮重构：提高代码的可读性</h3><p>首先，我们要解决最明显、最急需改进的代码可读性问题。具体有下面几点：</p>
<ul>
<li>hostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候；</li>
<li>将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数；</li>
<li>删除代码中的魔法数，比如，57、90、97、122；</li>
<li>将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数；</li>
<li>generate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化；对 IdGenerator 类重命名，并且抽象出对应的接口。</li>
</ul>
<p>第一轮重构后的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IdGenerator &#123;</span><br><span class="line">  String generate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface LogTraceIdGenerator extends IdGenerator &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">      substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">      return substrOfHostName;</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码使用举例</span><br><span class="line">LogTraceIdGenerator logTraceIdGenerator &#x3D; new RandomIdGenerator();</span><br></pre></td></tr></table></figure>


<h3 id="第二轮重构：提高代码的可测试性"><a href="#第二轮重构：提高代码的可测试性" class="headerlink" title="第二轮重构：提高代码的可测试性"></a>第二轮重构：提高代码的可测试性</h3><p>关于代码可测试性的问题，主要包含下面两个方面：</p>
<ul>
<li>generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性；</li>
<li>generate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好。</li>
</ul>
<p>对于第一点，我们已经在第一轮重构中解决了。我们将 RandomIdGenerator 类中的 generate() 静态函数重新定义成了普通函数。调用者可以通过依赖注入的方式，在外部创建好 RandomIdGenerator 对象后注入到自己的代码中，从而解决静态函数调用影响代码可测试性的问题。</p>
<p>对于第二点，我们需要在第一轮重构的基础之上再进行重构。</p>
<ul>
<li>从 getLastfieldOfHostName() 函数中，将逻辑比较复杂的那部分代码剥离出来，定义为 getLastSubstrSplittedByDot() 函数。因为 getLastfieldOfHostName() 函数依赖本地主机名，所以，剥离出主要代码之后这个函数变得非常简单，可以不用测试。我们重点测试 getLastSubstrSplittedByDot() 函数即可。</li>
<li>将 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 这两个函数的访问权限设置为 protected。这样做的目的是，可以直接在单元测试中通过对象来调用两个函数进行测试。</li>
<li>给 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 两个函数添加 Google Guava 的 annotation @VisibleForTesting。这个 annotation 没有任何实际的作用，只起到标识的作用，告诉其他人说，这两个函数本该是 private 访问权限的，之所以提升访问权限到 protected，只是为了测试，只能用于单元测试中。</li>
</ul>
<p>第二轮重构后代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastfieldOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三轮重构：编写完善的单元测试"><a href="#第三轮重构：编写完善的单元测试" class="headerlink" title="第三轮重构：编写完善的单元测试"></a>第三轮重构：编写完善的单元测试</h3><p>经过上面的重构之后，代码存在的比较明显的问题，基本上都已经解决了。我们现在为代码补全单元测试。RandomIdGenerator 类中有 4 个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String generate();</span><br><span class="line">private String getLastfieldOfHostName();</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String getLastSubstrSplittedByDot(String hostName);</span><br><span class="line">@VisibleForTesting</span><br><span class="line">protected String generateRandomAlphameric(int length);</span><br></pre></td></tr></table></figure>

<p>在上一步重构中，为了提高代码的可测试性，我们已经将这两个部分代码跟不可控的组件（本机名、随机函数、时间函数）进行了隔离。所以，我们只需要设计完备的单元测试用例即可。具体的代码实现如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGeneratorTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1.field2.field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field3&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1&quot;, actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1#field2$field3&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;field1#field2#field3&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGetLastSubstrSplittedByDot_nullOrEmpty() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(null);</span><br><span class="line">    Assert.assertNull(actualSubstr);</span><br><span class="line"></span><br><span class="line">    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualSubstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(6);</span><br><span class="line">    Assert.assertNotNull(actualRandomString);</span><br><span class="line">    Assert.assertEquals(6, actualRandomString.length());</span><br><span class="line">    for (char c : actualRandomString.toCharArray()) &#123;</span><br><span class="line">      Assert.assertTrue((&#39;0&#39; &lt; c &amp;&amp; c &lt; &#39;9&#39;) || (&#39;a&#39; &lt; c &amp;&amp; c &lt; &#39;z&#39;) || (&#39;A&#39; &lt; c &amp;&amp; c &lt; &#39;Z&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 此单元测试会失败，因为我们在代码中没有处理length&lt;&#x3D;0的情况</span><br><span class="line">  &#x2F;&#x2F; 这部分优化留在第36、37节课中讲解</span><br><span class="line">  @Test</span><br><span class="line">  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() &#123;</span><br><span class="line">    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();</span><br><span class="line">    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(0);</span><br><span class="line">    Assert.assertEquals(&quot;&quot;, actualRandomString);</span><br><span class="line"></span><br><span class="line">    actualRandomString &#x3D; idGenerator.generateRandomAlphameric(-1);</span><br><span class="line">    Assert.assertNull(actualRandomString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>注释不能太多，也不能太少，主要添加在类和函数上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Id Generator that is used to generate random IDs.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The IDs generated by this class are not absolutely unique,</span><br><span class="line"> * but the probability of duplication is very low.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RandomIdGenerator implements LogTraceIdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate the random ID. The IDs may be duplicated only in extreme situation.</span><br><span class="line">   *</span><br><span class="line">   * @return an random ID</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the local hostname and</span><br><span class="line">   * extract the last field of the name string splitted by delimiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @return the last field of hostname. Returns null if hostname is not obtained.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private String getLastfieldOfHostName() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Get the last field of &#123;@hostName&#125; splitted by delemiter &#39;.&#39;.</span><br><span class="line">   *</span><br><span class="line">   * @param hostName should not be null</span><br><span class="line">   * @return the last field of &#123;@hostName&#125;. Returns empty string if &#123;@hostName&#125; is empty string.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Generate random string which</span><br><span class="line">   * only contains digits, uppercase letters and lowercase letters.</span><br><span class="line">   *</span><br><span class="line">   * @param length should not be less than 0</span><br><span class="line">   * @return the random string. Returns empty string if &#123;@length&#125; is 0</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写 100 段凑活能用的代码，对你的代码能力提高更有帮助。</li>
<li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。</li>
<li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。</li>
<li>高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。</li>
</ul>
<h2 id="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h2><h3 id="1-返回错误码"><a href="#1-返回错误码" class="headerlink" title="1. 返回错误码"></a>1. 返回错误码</h3><p>C 语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而 Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。</p>
<h3 id="2-返回-NULL-值"><a href="#2-返回-NULL-值" class="headerlink" title="2. 返回 NULL 值"></a>2. 返回 NULL 值</h3><p>在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的 NULL 值比返回异常更加合理。</p>
<h3 id="3-返回空对象"><a href="#3-返回空对象" class="headerlink" title="3. 返回空对象"></a>3. 返回空对象</h3><p>返回 NULL 值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用空集合替代NULL</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepo userRepo; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  </span><br><span class="line">  public List&lt;User&gt; getUsers(String telephonePrefix) &#123;</span><br><span class="line">   &#x2F;&#x2F; 没有查找到数据</span><br><span class="line">    return Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getUsers使用示例</span><br><span class="line">List&lt;User&gt; users &#x3D; userService.getUsers(&quot;189&quot;);</span><br><span class="line">for (User user : users) &#123; &#x2F;&#x2F;这里不需要做NULL值判断</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用空字符串替代NULL</span><br><span class="line">public String retrieveUppercaseLetters(String text) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果text中没有大写字母，返回空字符串，而非NULL值</span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; retrieveUppercaseLetters()使用举例</span><br><span class="line">String uppercaseLetters &#x3D; retrieveUppercaseLetters(&quot;wangzheng&quot;);</span><br><span class="line">int length &#x3D; uppercaseLetters.length();&#x2F;&#x2F; 不需要做NULL值判断 </span><br><span class="line">System.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="4-抛出异常对象"><a href="#4-抛出异常对象" class="headerlink" title="4. 抛出异常对象"></a>4. 抛出异常对象</h3><p>尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。</p>
<h3 id="5-针对函数抛出异常的三种处理方式"><a href="#5-针对函数抛出异常的三种处理方式" class="headerlink" title="5.针对函数抛出异常的三种处理方式"></a>5.针对函数抛出异常的三种处理方式</h3><p>对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。</p>
<h4 id="直接吞掉"><a href="#直接吞掉" class="headerlink" title="直接吞掉"></a>直接吞掉</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void func2() &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">    log.warn(&quot;...&quot;, e); &#x2F;&#x2F;吐掉：try-catch打印日志</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接往上抛出-（原封不动地-re-throw）"><a href="#直接往上抛出-（原封不动地-re-throw）" class="headerlink" title="直接往上抛出 （原封不动地 re-throw）"></a>直接往上抛出 （原封不动地 re-throw）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception1 &#123;&#x2F;&#x2F;原封不动的re-throw Exception1</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  func1();</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包裹成新的异常抛出-re-throw"><a href="#包裹成新的异常抛出-re-throw" class="headerlink" title="包裹成新的异常抛出 re-throw"></a>包裹成新的异常抛出 re-throw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void func1() throws Exception1 &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void func2() throws Exception2 &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  try &#123;</span><br><span class="line">    func1();</span><br><span class="line">  &#125; catch(Exception1 e) &#123;</span><br><span class="line">   throw new Exception2(&quot;...&quot;, e); &#x2F;&#x2F; wrap成新的Exception2然后re-throw</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>实战二（下）：重构ID生成器项目中各函数的异常处理代码</h2><h3 id="异常处理代码重构"><a href="#异常处理代码重构" class="headerlink" title="异常处理代码重构"></a>异常处理代码重构</h3><p>重构之前的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; getLastFiledOfHostName();</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFiledOfHostName() &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      logger.warn(&quot;Failed to get the host name.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RandomIdGenerator implements IdGenerator &#123;</span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String generate() throws IdGenerationFailureException &#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      substrOfHostName &#x3D; getLastFieldOfHostName();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">      throw new IdGenerationFailureException(&quot;...&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    long currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">    String randomString &#x3D; generateRandomAlphameric(8);</span><br><span class="line">    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,</span><br><span class="line">            substrOfHostName, currentTimeMillis, randomString);</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getLastFieldOfHostName() throws UnknownHostException&#123;</span><br><span class="line">    String substrOfHostName &#x3D; null;</span><br><span class="line">    String hostName &#x3D; InetAddress.getLocalHost().getHostName();</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new UnknownHostException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String getLastSubstrSplittedByDot(String hostName) &#123;</span><br><span class="line">    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] tokens &#x3D; hostName.split(&quot;\\.&quot;);</span><br><span class="line">    String substrOfHostName &#x3D; tokens[tokens.length - 1];</span><br><span class="line">    return substrOfHostName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected String generateRandomAlphameric(int length) &#123;</span><br><span class="line">    if (length &lt;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char[] randomChars &#x3D; new char[length];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    while (count &lt; length) &#123;</span><br><span class="line">      int maxAscii &#x3D; &#39;z&#39;;</span><br><span class="line">      int randomAscii &#x3D; random.nextInt(maxAscii);</span><br><span class="line">      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;</span><br><span class="line">      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;</span><br><span class="line">      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;</span><br><span class="line">      if (isDigit|| isUppercase || isLowercase) &#123;</span><br><span class="line">        randomChars[count] &#x3D; (char) (randomAscii);</span><br><span class="line">        ++count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(randomChars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.在 generate() 函数中，我们需要捕获 UnknownHostException 异常，并重新包裹成新的异常 IdGenerationFailureException 往上抛出。之所以这么做，有下面三个原因。</p>
<ul>
<li>调用者在使用 generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的。也就说是，这是依赖抽象而非实现编程。</li>
<li>如果 generate() 函数直接抛出 UnknownHostException 异常，实际上是暴露了实现细节。从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常，暴露给更上层的代码，也就是调用 generate() 函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。</li>
<li>UnknownHostException 异常跟 generate() 函数，在业务概念上没有相关性。</li>
</ul>
<p>2.如果函数是 public 的，你无法掌控会被谁调用以及如何调用（有可能某个同事一时疏忽，传递进了 NULL 值，这种情况也是存在的），为了尽可能提高代码的健壮性，我们最好是在 public 函数中做 NULL 值或空字符串的判断。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>1.程序的 bug 往往都出现在一些边界条件和异常情况下，所以说，异常处理得好坏直接影响了代码的健壮性。</p>
<p>2.再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</p>
<p>3.内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</p>
<p>4.能用的代码和优质代码之间最大的区别就在于细节，这就是60分和100分的差别。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part7：设计模式与范式-行为型</title>
    <url>/2020/10/15/design-pattern-behavioral-pattern/</url>
    <content><![CDATA[<h2 id="观察者模式-详解各种应用场景下观察者模式的不同实现方式"><a href="#观察者模式-详解各种应用场景下观察者模式的不同实现方式" class="headerlink" title="观察者模式 详解各种应用场景下观察者模式的不同实现方式"></a>观察者模式 详解各种应用场景下观察者模式的不同实现方式</h2><p>（Observer Design Pattern）</p>
<h3 id="观察者模式的原理"><a href="#观察者模式的原理" class="headerlink" title="观察者模式的原理"></a>观察者模式的原理</h3><p>观察者模式（Observer Design Pattern） 也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
</blockquote>
<p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<a id="more"></a>

<h3 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h3><p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：</p>
<ul>
<li>有同步阻塞的实现方式  </li>
<li>也有异步非阻塞的实现方式；</li>
<li>有进程内的实现方式，也有跨进程的实现方式。</li>
</ul>
<p>其中，进程内的观察者模式： </p>
<ol>
<li>可以通过handleRequest中创建新的线程代码的方式实现异步非阻塞的观察者模式 </li>
<li>更优雅的实现方式：基于 Google Guava EventBus 框架的设计思想去实现观察者模式</li>
</ol>
<p>跨进程的观察者模式（跨系统）：<br>基于消息队列（Message Queue）来实现。</p>
<p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<p>根据不同的应用场景和需求，有完全不同的实现方式。<br>下面给出一种最经典的实现方式代码模版样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">  void registerObserver(Observer observer);</span><br><span class="line">  void removeObserver(Observer observer);</span><br><span class="line">  void notifyObservers(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">  void update(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">  private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerObserver(Observer observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void removeObserver(Observer observer) &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notifyObservers(Message message) &#123;</span><br><span class="line">    for (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverOne implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverTwo implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ConcreteSubject subject &#x3D; new ConcreteSubject();</span><br><span class="line">    subject.registerObserver(new ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(new ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(new Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a>观察者模式的应用场景</h3><p>观察者主要目的是将观察者与被观察者的代码解耦，观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p>
<h3 id="以用户注册成功后需要发放优惠券等操作为例"><a href="#以用户注册成功后需要发放优惠券等操作为例" class="headerlink" title="以用户注册成功后需要发放优惠券等操作为例"></a>以用户注册成功后需要发放优惠券等操作为例</h3><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们需要做下面几件事：</p>
<ol>
<li>发放优惠券</li>
<li>发送欢迎邮件<br>…</li>
</ol>
<p>一开始最简单的代码说这样的， 但是存在一个问题， 比如后面需要添加更多的动作，或者把发放优惠券改成发放体验金，就需要频繁改动 register()函数的代码，违反开闭原则。</p>
<p>这时候如果应用  观察者模式 重构上述代码，则会让代码的拓展性和维护性变得很好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RegObserver &#123;</span><br><span class="line">  void handleRegSuccess(long userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver implements RegObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver implements RegObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改</span><br><span class="line">  public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    for (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</p>
<h3 id="对比一下“生产者-消费者”模型和观察者模式的区别和联系"><a href="#对比一下“生产者-消费者”模型和观察者模式的区别和联系" class="headerlink" title="对比一下“生产者 - 消费者”模型和观察者模式的区别和联系"></a>对比一下“生产者 - 消费者”模型和观察者模式的区别和联系</h3><p>发布订阅和生产消费模型最大的区别在于：发布者（可观测对象）是知道订阅者（观察对象）的存在，因为它需要遍历订阅列表去发布事件；而生产消费模型因为有中间消息代理的存在，生产者和消费者完全不知道对方的存在，完全解耦</p>
<h3 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h3><h4 id="Google-Guava-EventBus"><a href="#Google-Guava-EventBus" class="headerlink" title="Google Guava EventBus"></a>Google Guava EventBus</h4><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p>
<p>用法示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  private EventBus eventBus;</span><br><span class="line">  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式</span><br><span class="line">    eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞模式</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRegObservers(List&lt;Object&gt; observers) &#123;</span><br><span class="line">    for (Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  public void handleRegSuccess(Long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>EventBus、AsyncEventBus：Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。</li>
<li>register() 函数：EventBus 类提供了 register() 函数用来注册观察者。</li>
<li>unregister() 函数：从 EventBus 中删除某个观察者</li>
<li>post() 函数：EventBus 类提供了 post() 函数，用来给观察者发送消息。</li>
</ul>
<h4 id="手把手实现一个-EventBus-框架-1"><a href="#手把手实现一个-EventBus-框架-1" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2474" alt="ce842666fa3dc92bb8f4f2d8e75d12c6.jpeg"></p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2475" alt="bf7ef52a40b1e35b18f369265caca645.jpeg"></p>
<p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p>
<p>整个小框架的代码实现包括 5 个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。具体代码在《设计模式之美》 第57讲。<br><a href="https://time.geekbang.org/column/article/211239" target="_blank" rel="noopener">https://time.geekbang.org/column/article/211239</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p>
<p>2.具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<p>3.观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h2 id="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"><a href="#模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用" class="headerlink" title="模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用"></a>模板模式：剖析模板模式在JDK、Servlet、JUnit等中的应用</h2><p>Template Method Design Pattern</p>
<h3 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h3><p>模板模式，全称是模板方法设计模式，在 GoF 的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p>
<p>一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method1();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    method2();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo &#x3D; ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<p>templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活。</p>
<h3 id="模板模式作的作用"><a href="#模板模式作的作用" class="headerlink" title="模板模式作的作用"></a>模板模式作的作用</h3><p>常用在框架开发中，通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。除此之外，模板模式还可以起到代码复用的作用。</p>
<h4 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h4><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p>
<h5 id="1-Java-InputStream-对模板模式的应用"><a href="#1-Java-InputStream-对模板模式的应用" class="headerlink" title="1.Java InputStream 对模板模式的应用"></a>1.Java InputStream 对模板模式的应用</h5><p>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。</p>
<p>下面以 InputStream 为例， read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  public int read(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    if (b &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;</span><br><span class="line">      throw new IndexOutOfBoundsException();</span><br><span class="line">    &#125; else if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int c &#x3D; read();</span><br><span class="line">    if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] &#x3D; (byte)c;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (; i &lt; len ; i++) &#123;</span><br><span class="line">        c &#x3D; read();</span><br><span class="line">        if (c &#x3D;&#x3D; -1) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] &#x3D; (byte)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public abstract int read() throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ByteArrayInputStream extends InputStream &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码...</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public synchronized int read() &#123;</span><br><span class="line">    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-Java-AbstractList-对模版模式的应用"><a href="#2-Java-AbstractList-对模版模式的应用" class="headerlink" title="2.Java AbstractList 对模版模式的应用"></a>2.Java AbstractList 对模版模式的应用</h5><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。相当于强制了子类必须重写add方法才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    boolean modified &#x3D; false;</span><br><span class="line">    for (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h4><h5 id="1-Java-Servlet-对模版模式的应用"><a href="#1-Java-Servlet-对模版模式的应用" class="headerlink" title="1.Java Servlet 对模版模式的应用"></a>1.Java Servlet 对模版模式的应用</h5><p>HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>
<p>HttpServlet 的 service() 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    if (!(req instanceof HttpServletRequest &amp;&amp;</span><br><span class="line">            res instanceof HttpServletResponse)) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; (HttpServletRequest) req;</span><br><span class="line">    response &#x3D; (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">            &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            if (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[1];</span><br><span class="line">        errArgs[0] &#x3D; method;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>下面看下 基于 Servlet 来开发一个Web项目的 hello world:</strong></p>
<p>如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    this.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(&quot;Hello World.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外,还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p>
<h5 id="2-JUnit-TestCase"><a href="#2-JUnit-TestCase" class="headerlink" title="2.JUnit TestCase"></a>2.JUnit TestCase</h5><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</p>
<p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。TestCase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class TestCase extends Assert implements Test &#123;</span><br><span class="line">  public void runBare() throws Throwable &#123;</span><br><span class="line">    Throwable exception &#x3D; null;</span><br><span class="line">    setUp();</span><br><span class="line">    try &#123;</span><br><span class="line">      runTest();</span><br><span class="line">    &#125; catch (Throwable running) &#123;</span><br><span class="line">      exception &#x3D; running;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">      &#125; catch (Throwable tearingDown) &#123;</span><br><span class="line">        if (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception !&#x3D; null) throw exception;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Sets up the fixture, for example, open a network connection.</span><br><span class="line">  * This method is called before a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void setUp() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Tears down the fixture, for example, close a network connection.</span><br><span class="line">  * This method is called after a test is executed.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  protected void tearDown() throws Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式与Callback回调函数有何区别和联系？"></a>模板模式与Callback回调函数有何区别和联系？</h3><h4 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h4><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>
<h4 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。在一些框架、类库、组件等的设计中经常会用到。</p>
<p>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>
<h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p>
<h5 id="一个经典的回调回调代码样例"><a href="#一个经典的回调回调代码样例" class="headerlink" title="一个经典的回调回调代码样例"></a>一个经典的回调回调代码样例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ICallback &#123;</span><br><span class="line">  void methodToCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BClass &#123;</span><br><span class="line">  public void process(ICallback callback) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    BClass b &#x3D; new BClass();</span><br><span class="line">    b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象</span><br><span class="line">      @Override</span><br><span class="line">      public void methodToCallback() &#123;</span><br><span class="line">        System.out.println(&quot;Call back me.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p>
<h5 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h5><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。</p>
<p>JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;</span><br><span class="line"> return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(sql, &quot;SQL must not be null&quot;);</span><br><span class="line"> Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);</span><br><span class="line"> if (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public T doInStatement(Statement stmt) throws SQLException &#123;</span><br><span class="line">   ResultSet rs &#x3D; null;</span><br><span class="line">   try &#123;</span><br><span class="line">    rs &#x3D; stmt.executeQuery(sql);</span><br><span class="line">    ResultSet rsToUse &#x3D; rs;</span><br><span class="line">    if (nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">     rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return rse.extractData(rsToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">    JdbcUtils.closeResultSet(rs);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String getSql() &#123;</span><br><span class="line">   return sql;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return execute(new QueryStatementCallback());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line"> Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line"></span><br><span class="line"> Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());</span><br><span class="line"> Statement stmt &#x3D; null;</span><br><span class="line"> try &#123;</span><br><span class="line">  Connection conToUse &#x3D; con;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;</span><br><span class="line">    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class="line">   conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">  &#125;</span><br><span class="line">  stmt &#x3D; conToUse.createStatement();</span><br><span class="line">  applyStatementSettings(stmt);</span><br><span class="line">  Statement stmtToUse &#x3D; stmt;</span><br><span class="line">  if (this.nativeJdbcExtractor !&#x3D; null) &#123;</span><br><span class="line">   stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  T result &#x3D; action.doInStatement(stmtToUse);</span><br><span class="line">  handleWarnings(stmt);</span><br><span class="line">  return result;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (SQLException ex) &#123;</span><br><span class="line">  &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock</span><br><span class="line">  &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  stmt &#x3D; null;</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">  con &#x3D; null;</span><br><span class="line">  throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> finally &#123;</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h5><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Button button &#x3D; (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    System.out.println(&quot;I am clicked.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。</p>
<h4 id="回调函数的区别和联系"><a href="#回调函数的区别和联系" class="headerlink" title="回调函数的区别和联系"></a>回调函数的区别和联系</h4><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>
<p>组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p>
<ul>
<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>
<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>
<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>
</ul>
<p>小结：</p>
<ul>
<li><p>共同点：<br>回调函数跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。</p>
</li>
<li><p>不同点：<br>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p>
</li>
</ul>
<h2 id="策略模式-如何避免冗长的if-else-switch分支判断代码？"><a href="#策略模式-如何避免冗长的if-else-switch分支判断代码？" class="headerlink" title="策略模式 如何避免冗长的if-else/switch分支判断代码？"></a>策略模式 如何避免冗长的if-else/switch分支判断代码？</h2><p>Strategy Design Pattern</p>
<h3 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h3><blockquote>
<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p>
<h3 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h3><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p>
<ul>
<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li>
<li>策略的创建由工厂类来完成，封装策略创建的细节。</li>
<li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li>
</ul>
<h4 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h4><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">  void algorithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    &#x2F;&#x2F;具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h4><p>策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<p>如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的。则可以事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(&quot;A&quot;, new ConcreteStrategyA());</span><br><span class="line">    strategies.put(&quot;B&quot;, new ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return strategies.get(type);</span><br></pre></td></tr></table></figure>

<p>如果策略是由状态的，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，则可以按下面传统的方式创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type.equals(&quot;A&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyA();</span><br><span class="line">    &#125; else if (type.equals(&quot;B&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3.策略的使用"></a>3.策略的使用</h4><p>策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<p>“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略接口：EvictionStrategy</span><br><span class="line">&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span><br><span class="line">&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory</span><br><span class="line"></span><br><span class="line">public class UserCache &#123;</span><br><span class="line">  private Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  public UserCache(EvictionStrategy eviction) &#123;</span><br><span class="line">    this.eviction &#x3D; eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略 </span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; null;</span><br><span class="line">    Properties props &#x3D; new Properties();</span><br><span class="line">    props.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));</span><br><span class="line">    String type &#x3D; props.getProperty(&quot;eviction_type&quot;);</span><br><span class="line">    evictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略 (在种事先需要知道使用哪种策略，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。)</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    EvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();</span><br><span class="line">    UserCache userCache &#x3D; new UserCache(evictionStrategy);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用策略模式组合工厂模式避免分支判断"><a href="#利用策略模式组合工厂模式避免分支判断" class="headerlink" title="利用策略模式组合工厂模式避免分支判断"></a>利用策略模式组合工厂模式避免分支判断</h3><p>下面是一种非常常见的 if-else 场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    double discount &#x3D; 0.0;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125;</span><br><span class="line">    return discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。重构代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 策略的定义</span><br><span class="line">public interface DiscountStrategy &#123;</span><br><span class="line">  double calDiscount(Order order);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的创建</span><br><span class="line">public class DiscountStrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的使用</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    return discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。总结下本质，就是是借助“查表法”，根据 type查表来替代根据 type 分支判断。</p>
<h3 id="如何实现一个支持给不同大小文件排序的小程序？"><a href="#如何实现一个支持给不同大小文件排序的小程序？" class="headerlink" title="如何实现一个支持给不同大小文件排序的小程序？"></a>如何实现一个支持给不同大小文件排序的小程序？</h3><p>案例：写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。</p>
<p>最小原型原则，先实现个最基础的版本，然后再在这个基础上进行迭代优化。</p>
<p>1.0 版本的思路：将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      quickSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      externalSort(filePath);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      concurrentExternalSort(filePath);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      mapreduceSort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void quickSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 快速排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void externalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void concurrentExternalSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 多线程外部排序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void mapreduceSort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用MapReduce多机排序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SortingTool &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Sorter sorter &#x3D; new Sorter();</span><br><span class="line">    sorter.sortFile(args[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行拆分重构,版本2.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ISortAlg &#123;</span><br><span class="line">  void sort(String filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QuickSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcurrentExternalSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapReduceSort implements ISortAlg &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void sort(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SortAlgFactory &#123;</span><br><span class="line">  private static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    algs.put(&quot;QuickSort&quot;, new QuickSort());</span><br><span class="line">    algs.put(&quot;ExternalSort&quot;, new ExternalSort());</span><br><span class="line">    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());</span><br><span class="line">    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ISortAlg getSortAlg(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return algs.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg;</span><br><span class="line">    if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);</span><br><span class="line">    &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; [100GB, ~)</span><br><span class="line">      sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写完全没问题。但如果特别想将 if-else 分支判断移除掉，可以进一步优化<br>出下面。 </p>
<p>3.0版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sorter &#123;</span><br><span class="line">  private static final long GB &#x3D; 1000 * 1000 * 1000;</span><br><span class="line">  private static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));</span><br><span class="line">    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sortFile(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略校验逻辑</span><br><span class="line">    File file &#x3D; new File(filePath);</span><br><span class="line">    long fileSize &#x3D; file.length();</span><br><span class="line">    ISortAlg sortAlg &#x3D; null;</span><br><span class="line">    for (AlgRange algRange : algs) &#123;</span><br><span class="line">      if (algRange.inRange(fileSize)) &#123;</span><br><span class="line">        sortAlg &#x3D; algRange.getAlg();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class AlgRange &#123;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line">    private ISortAlg alg;</span><br><span class="line"></span><br><span class="line">    public AlgRange(long start, long end, ISortAlg alg) &#123;</span><br><span class="line">      this.start &#x3D; start;</span><br><span class="line">      this.end &#x3D; end;</span><br><span class="line">      this.alg &#x3D; alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ISortAlg getAlg() &#123;</span><br><span class="line">      return alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean inRange(long size) &#123;</span><br><span class="line">      return size &gt;&#x3D; start &amp;&amp; size &lt; end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>重构后，把可变的部分隔离到了策略工厂类和 Sorter 类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</strong></p>
<p>有没办法在添加新策略的时候避免对策略工厂类的修改呢？ </p>
<p>具体是这么做的：可以通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。</p>
<p>一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p>
<h2 id="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"><a href="#职责链模式：框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="职责链模式：框架中常用的过滤器、拦截器是如何实现的？"></a>职责链模式：框架中常用的过滤器、拦截器是如何实现的？</h2><p>模板模式、策略模式、职责链模式 这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h3 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h3><p>Chain Of Responsibility Design Pattern</p>
<blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
</blockquote>
<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p>
<h4 id="实现方式一举例：-基于抽象类实现"><a href="#实现方式一举例：-基于抽象类实现" class="headerlink" title="实现方式一举例：(基于抽象类实现)"></a>实现方式一举例：(基于抽象类实现)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor &#x3D; successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void handle() &#123;</span><br><span class="line">    boolean handled &#x3D; doHandle();</span><br><span class="line">    if (successor !&#x3D; null &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract boolean doHandle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head &#x3D; null;</span><br><span class="line">  private Handler tail &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">      head &#x3D; handler;</span><br><span class="line">      tail &#x3D; handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head !&#x3D; null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现方式二举例：（基于接口实现）"><a href="#实现方式二举例：（基于接口实现）" class="headerlink" title="实现方式二举例：（基于接口实现）"></a>实现方式二举例：（基于接口实现）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled &#x3D; handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。</p>
<h3 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h3><h4 id="实现可灵活扩展算法的敏感信息过滤框架"><a href="#实现可灵活扩展算法的敏感信息过滤框架" class="headerlink" title="实现可灵活扩展算法的敏感信息过滤框架"></a>实现可灵活扩展算法的敏感信息过滤框架</h4><p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface SensitiveWordFilter &#123;</span><br><span class="line">  boolean doFilter(Content content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SexyWordFilter implements SensitiveWordFilter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean doFilter(Content content) &#123;</span><br><span class="line">    boolean legal &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="line"></span><br><span class="line">public class SensitiveWordFilterChain &#123;</span><br><span class="line">  private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addFilter(SensitiveWordFilter filter) &#123;</span><br><span class="line">    this.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.</span><br><span class="line">  public boolean filter(Content content) &#123;</span><br><span class="line">    for (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      if (!filter.doFilter(content)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();</span><br><span class="line">    filterChain.addFilter(new AdsWordFilter());</span><br><span class="line">    filterChain.addFilter(new SexyWordFilter());</span><br><span class="line">    filterChain.addFilter(new PoliticalWordFilter());</span><br><span class="line"></span><br><span class="line">    boolean legal &#x3D; filterChain.filter(new Content());</span><br><span class="line">    if (!legal) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不发表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 发表</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>职责链模式降低了代码的复杂性：<br>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p>
<p>职责链模式让代码满足开闭原则，提高了代码的扩展性：<br>当需要添加新的过滤算法进来的时候，只需要新添加一个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。</p>
<p>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</p>
<h3 id="框架中常用的过滤器、拦截器是如何实现的？"><a href="#框架中常用的过滤器、拦截器是如何实现的？" class="headerlink" title="框架中常用的过滤器、拦截器是如何实现的？"></a>框架中常用的过滤器、拦截器是如何实现的？</h3><p>责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。</p>
<h4 id="Servlet-Filter-对职责链模式对应用"><a href="#Servlet-Filter-对职责链模式对应用" class="headerlink" title="Servlet Filter 对职责链模式对应用"></a>Servlet Filter 对职责链模式对应用</h4><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。</p>
<p>Servlet Filter 的工作原理<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2478" alt="3296abd63a61ebdf4eff3a6530979e21.jpeg"></p>
<h5 id="项目中该如何使用-Servlet-Filter-呢"><a href="#项目中该如何使用-Servlet-Filter-呢" class="headerlink" title="项目中该如何使用 Servlet Filter 呢?"></a>项目中该如何使用 Servlet Filter 呢?</h5><p>如下面的代码示例所示，添加一个过滤器，我们只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; 在创建Filter时自动调用，</span><br><span class="line">    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在销毁Filter时自动调用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在web.xml配置文件中如下配置：</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Servlet-Filter-的底层实现"><a href="#Servlet-Filter-的底层实现" class="headerlink" title="Servlet Filter 的底层实现"></a>Servlet Filter 的底层实现</h5><p>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。</p>
<p>Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class ApplicationFilterChain implements FilterChain &#123;</span><br><span class="line">  private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter</span><br><span class="line">  private int n; &#x2F;&#x2F;filter的个数</span><br><span class="line">  private ApplicationFilterConfig[] filters;</span><br><span class="line">  private Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">    if (pos &lt; n) &#123;</span><br><span class="line">      ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br><span class="line">      Filter filter &#x3D; filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, this);&#x2F;&#x2F;这行就是递归调用了我们客户端自定义的Filter的方法</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; filter都处理完毕后，执行servlet</span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFilter(ApplicationFilterConfig filterConfig) &#123;</span><br><span class="line">    for (ApplicationFilterConfig filter:filters)</span><br><span class="line">      if (filter&#x3D;&#x3D;filterConfig)</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">    if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容</span><br><span class="line">      ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, 0, newFilters, 0, n);</span><br><span class="line">      filters &#x3D; newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] &#x3D; filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationFilterChain 的实现主要是 在FilterChai 的 doFilter 方法里面 递归调用。Filter 的  doFilter 方法。</p>
<h4 id="Spring-Interceptor-对职责链模式对应用"><a href="#Spring-Interceptor-对职责链模式对应用" class="headerlink" title="Spring Interceptor 对职责链模式对应用"></a>Spring Interceptor 对职责链模式对应用</h4><p>Spring Interceptor，翻译成中文就是拦截器。与 Servlet Filter 一样，都可以实现对 HTTP 请求进行拦截处理。</p>
<p>Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2477" alt="febaa9220cb9ad2f0aafd4e5c3c19868.jpeg"></p>
<p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p>
<h5 id="项目中该如何实现-Spring-Interceptor呢？"><a href="#项目中该如何实现-Spring-Interceptor呢？" class="headerlink" title="项目中该如何实现 Spring Interceptor呢？"></a>项目中该如何实现 Spring Interceptor呢？</h5><p>LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LogInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 继续后续的处理</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;这里总是被执行.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Interceptor-的底层实现"><a href="#Spring-Interceptor-的底层实现" class="headerlink" title="Spring Interceptor 的底层实现"></a>Spring Interceptor 的底层实现</h5><p>andlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"> private final Object handler;</span><br><span class="line"> private HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, null);</span><br><span class="line">     return false;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">   throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    try &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">    &#125; catch (Throwable ex2) &#123;</span><br><span class="line">     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？"><a href="#AOP、Servlet-Filter、Spring-Interceptor-该怎么选择？" class="headerlink" title="AOP、Servlet Filter、Spring Interceptor 该怎么选择？"></a>AOP、Servlet Filter、Spring Interceptor 该怎么选择？</h3><p>其实要实现一个鉴权的过滤器，通过以上3种方式都是可以去实现的，然而从粒度，场景，和方式上边有有所区别，主要采取用哪个，还是有业务来决定去用，没有统一的参考标准。比如要对所有的web接口，进行统一的权限处理，不需要区分动作，写或者读，所有一视同仁，这种情况下，servlet的更加适合。针对一些存在状态的，比如做一些统一的去参数转换，cookie转uid之类，以及通用检验uid是否符合当前权限，则很用mvc较好，而aop粒度就可以分的更加细致了，在一些更新需要，查询不需要的，如分控，日志记录等，就比较适合。</p>
<p>三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>职责链模式常用在框架开发中，用来实现框架的过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p>
</li>
<li><p>通过 Servlet Filter、Spring Interceptor 两个实际的例子，展示了在框架开发中职责链模式具体是怎么应用的。可以看到，职责链模式除了上面介绍的两种经典实现外，在实际使用中代码还是笔记灵活的，代码实现会根据不同的需求有所变化。</p>
</li>
</ul>
<h2 id="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"><a href="#状态模式：游戏、工作流引擎中常用的状态机是如何实现的？" class="headerlink" title="状态模式：游戏、工作流引擎中常用的状态机是如何实现的？"></a>状态模式：游戏、工作流引擎中常用的状态机是如何实现的？</h2><p>Finite State Machine</p>
<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>
<h3 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h3><p>状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<p>举例说明比如：马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2479" alt="5aa0310b9b3ea08794cfc2f376c8f96c.jpeg"></p>
<h3 id="举例说明状态及的三种实现方式"><a href="#举例说明状态及的三种实现方式" class="headerlink" title="举例说明状态及的三种实现方式"></a>举例说明状态及的三种实现方式</h3><h4 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SUPER;</span><br><span class="line">      this.score +&#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.CAPE;</span><br><span class="line">      this.score +&#x3D; 200;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      this.currentState &#x3D; State.FIRE;</span><br><span class="line">      this.score +&#x3D; 300;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    if (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 100;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 200;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      this.currentState &#x3D; State.SMALL;</span><br><span class="line">      this.score -&#x3D; 300;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。</p>
<h4 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h4><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2480" alt="4f4ea3787bd955918578181e18173491.jpeg"></p>
<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Event &#123;</span><br><span class="line">  GOT_MUSHROOM(0),</span><br><span class="line">  GOT_CAPE(1),</span><br><span class="line">  GOT_FIRE(2),</span><br><span class="line">  MET_MONSTER(3);</span><br><span class="line"></span><br><span class="line">  private int value;</span><br><span class="line"></span><br><span class="line">  private Event(int value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue() &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private State currentState;</span><br><span class="line"></span><br><span class="line">  private static final State[][] transitionTable &#x3D; &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private static final int[][] actionTable &#x3D; &#123;</span><br><span class="line">          &#123;+100, +200, +300, +0&#125;,</span><br><span class="line">          &#123;+0, +200, +300, -100&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -200&#125;,</span><br><span class="line">          &#123;+0, +0, +0, -300&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void executeEvent(Event event) &#123;</span><br><span class="line">    int stateValue &#x3D; currentState.getValue();</span><br><span class="line">    int eventValue &#x3D; event.getValue();</span><br><span class="line">    this.currentState &#x3D; transitionTable[stateValue][eventValue];</span><br><span class="line">    this.score +&#x3D; actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h4><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p>
<p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。</p>
<p>IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IMario &#123; &#x2F;&#x2F;所有状态类的接口</span><br><span class="line">  State getName();</span><br><span class="line">  &#x2F;&#x2F;以下是定义的事件</span><br><span class="line">  void obtainMushRoom();</span><br><span class="line">  void obtainCape();</span><br><span class="line">  void obtainFireFlower();</span><br><span class="line">  void meetMonster();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SmallMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SmallMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SuperMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SuperMario implements IMario &#123;</span><br><span class="line">  private MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  public SuperMario(MarioStateMachine stateMachine) &#123;</span><br><span class="line">    this.stateMachine &#x3D; stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public State getName() &#123;</span><br><span class="line">    return State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + 300);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    stateMachine.setCurrentState(new SmallMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略CapeMario、FireMario类...</span><br><span class="line"></span><br><span class="line">public class MarioStateMachine &#123;</span><br><span class="line">  private int score;</span><br><span class="line">  private IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态</span><br><span class="line"></span><br><span class="line">  public MarioStateMachine() &#123;</span><br><span class="line">    this.score &#x3D; 0;</span><br><span class="line">    this.currentState &#x3D; new SmallMario(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainMushRoom() &#123;</span><br><span class="line">    this.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainCape() &#123;</span><br><span class="line">    this.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void obtainFireFlower() &#123;</span><br><span class="line">    this.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void meetMonster() &#123;</span><br><span class="line">    this.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public State getCurrentState() &#123;</span><br><span class="line">    return this.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setScore(int score) &#123;</span><br><span class="line">    this.score &#x3D; score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setCurrentState(IMario currentState) &#123;</span><br><span class="line">    this.currentState &#x3D; currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态模式的代码实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。</p>
<p>针对这个问题，可以在接口和实现类中间加一层抽象类解决此问题，抽象类实现状态接口，状态类继承抽象类，只需要重写需要的方法即可。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h4 id="状态机的三个组成-状态、事件、动作"><a href="#状态机的三个组成-状态、事件、动作" class="headerlink" title="状态机的三个组成 状态、事件、动作"></a>状态机的三个组成 状态、事件、动作</h4><p>状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<h4 id="状态的三种实现方式的使用场景"><a href="#状态的三种实现方式的使用场景" class="headerlink" title="状态的三种实现方式的使用场景"></a>状态的三种实现方式的使用场景</h4><ul>
<li><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>
</li>
<li><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>
</li>
<li><p>第三种实现方式叫状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
</li>
</ul>
<h2 id="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"><a href="#迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？" class="headerlink" title="迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？"></a>迭代器模式：相比直接遍历集合数据，使用迭代器有哪些优势？</h2><p>Iterator Design Pattern</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p>
<p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2481" alt="cb72b5921681ac13d4fc05237597d2ec.jpeg"></p>
<h3 id="自己如何开发一个迭代器"><a href="#自己如何开发一个迭代器" class="headerlink" title="自己如何开发一个迭代器"></a>自己如何开发一个迭代器</h3><p>定义接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 接口定义方式一</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口定义方式二 (Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据)</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  E next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">  &#x2F;&#x2F;...省略其他接口函数...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;xzg&quot;);</span><br><span class="line">    names.add(&quot;wang&quot;);</span><br><span class="line">    names.add(&quot;zheng&quot;);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用迭代器有哪些优势？"><a href="#使用迭代器有哪些优势？" class="headerlink" title="使用迭代器有哪些优势？"></a>使用迭代器有哪些优势？</h3><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p>
<ul>
<li><p>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</p>
</li>
<li><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</p>
</li>
<li><p>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
</li>
</ul>
<h3 id="遍历集合的同时，为什么不能增删集合元素？"><a href="#遍历集合的同时，为什么不能增删集合元素？" class="headerlink" title="遍历集合的同时，为什么不能增删集合元素？"></a>遍历集合的同时，为什么不能增删集合元素？</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext();</span><br><span class="line">  void next();</span><br><span class="line">  E currentItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  private int cursor;</span><br><span class="line">  private ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;</span><br><span class="line">    this.cursor &#x3D; 0;</span><br><span class="line">    this.arrayList &#x3D; arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">    return cursor &lt; arrayList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void next() &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public E currentItem() &#123;</span><br><span class="line">    if (cursor &gt;&#x3D; arrayList.size()) &#123;</span><br><span class="line">      throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">  Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public Iterator iterator() &#123;</span><br><span class="line">    return new ArrayIterator(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    names.add(&quot;a&quot;);</span><br><span class="line">    names.add(&quot;b&quot;);</span><br><span class="line">    names.add(&quot;c&quot;);</span><br><span class="line">    names.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(&quot;a&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行到第 57 行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2482" alt="d86223f2b0f996ebb2b21e5abbeceae9.jpeg"></p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><p>Visitor Design Pattern</p>
<blockquote>
<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>
</blockquote>
<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<h3 id="访问者模式实现举例"><a href="#访问者模式实现举例" class="headerlink" title="访问者模式实现举例"></a>访问者模式实现举例</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2483" alt="c42c636c5384da5bd5343618305db865.jpeg"></p>
<p>设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath &#x3D; filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line"></span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Extractor extractor &#x3D; new Extractor();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor &#x3D; new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p>
<p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p>
<p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p>
<h2 id="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"><a href="#备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？" class="headerlink" title="备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？"></a>备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？</h2><p>Memento Design Pattern</p>
<h3 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h3><p>备忘录模式，也叫快照（Snapshot）模式</p>
<blockquote>
<p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p>
</blockquote>
<p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p>
<p>备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p>
<h2 id="命令模式：如何利用命令模式实现一个手游后端架构？"><a href="#命令模式：如何利用命令模式实现一个手游后端架构？" class="headerlink" title="命令模式：如何利用命令模式实现一个手游后端架构？"></a>命令模式：如何利用命令模式实现一个手游后端架构？</h2><p>Command Design Pattern</p>
<blockquote>
<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>
</blockquote>
<p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p>
<p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>
<h2 id="解释器模式：如何设计实现一个自定义接口告警规则功能？"><a href="#解释器模式：如何设计实现一个自定义接口告警规则功能？" class="headerlink" title="解释器模式：如何设计实现一个自定义接口告警规则功能？"></a>解释器模式：如何设计实现一个自定义接口告警规则功能？</h2><p>解释器模式的英文翻译是 Interpreter Design Pattern</p>
<blockquote>
<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>
</blockquote>
<p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<h2 id="中介模式：什么时候用中介模式？什么时候用观察者模式？"><a href="#中介模式：什么时候用中介模式？什么时候用观察者模式？" class="headerlink" title="中介模式：什么时候用中介模式？什么时候用观察者模式？"></a>中介模式：什么时候用中介模式？什么时候用观察者模式？</h2><p>中介模式的英文翻译是 Mediator Design Pattern。</p>
<h3 id="中介模式的原理与实现"><a href="#中介模式的原理与实现" class="headerlink" title="中介模式的原理与实现"></a>中介模式的原理与实现</h3><blockquote>
<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>
</blockquote>
<p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2502" alt="4376d541bf17a029f37aa76009ef3a9f.jpeg"></p>
<h3 id="中介模式与观察者模式的区别"><a href="#中介模式与观察者模式的区别" class="headerlink" title="中介模式与观察者模式的区别"></a>中介模式与观察者模式的区别</h3><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美-笔记Part3：设计原则</title>
    <url>/2020/10/05/design-pattern-design-principle/</url>
    <content><![CDATA[<h2 id="设计原则概述"><a href="#设计原则概述" class="headerlink" title="设计原则概述"></a>设计原则概述</h2><p>SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，SRP单一职责原则 Single Responsibility Principle； KISS保持简单 Keep It Simple and Stupid； YAGNI不需要原则 You Ain’t Gonna Need It ； DRY 不要重复原则 Don’t Repeat Yourself ； LOD 迪米特法则 Law of Demeter。</p>
<a id="more"></a>

<p>设计原则和思想比设计模式更加普适和重要。可以这样说，设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。掌握了代码的设计原则和思想，我们才能更清楚的了解，为什么要用某种设计模式，才能更恰到好处地应用设计模式。</p>
<h2 id="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h2><p>单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p>
<h3 id="1-如何理解单一职责原则（SRP）？"><a href="#1-如何理解单一职责原则（SRP）？" class="headerlink" title="1. 如何理解单一职责原则（SRP）？"></a>1. 如何理解单一职责原则（SRP）？</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p>
<h3 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2. 如何判断类的职责是否足够单一？"></a>2. 如何判断类的职责是否足够单一？</h3><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：类中的代码行数、函数或者属性过多；类依赖的其他类过多，或者依赖类的其他类过多；私有方法过多；比较难给类起一个合适的名字；类中大量的方法都是集中操作类中的某几个属性。</p>
<h3 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3. 类的职责是否设计得越单一越好？"></a>3. 类的职责是否设计得越单一越好？</h3><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h2 id="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>理论二：开闭原则，如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h2><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试。</p>
<h3 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1.如何理解“对扩展开放、对修改关闭”？"></a>1.如何理解“对扩展开放、对修改关闭”？</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p>
<h3 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2. 如何做到“对扩展开放、修改关闭”？"></a>2. 如何做到“对扩展开放、修改关闭”？</h3><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p>
<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h4 id="通过多态实现"><a href="#通过多态实现" class="headerlink" title="通过多态实现"></a>通过多态实现</h4><p>例子：API 接口监控告警的代码</p>
<p>改造前的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private AlertRule rule;</span><br><span class="line">  private Notification notification;</span><br><span class="line"></span><br><span class="line">  public Alert(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略AlertRule&#x2F;Notification属性和构造函数...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 改动一：添加参数timeoutCount</span><br><span class="line">  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) &#123;</span><br><span class="line">    long tps &#x3D; requestCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 改动二：添加接口超时处理逻辑</span><br><span class="line">    long timeoutTps &#x3D; timeoutCount &#x2F; durationOfSeconds;</span><br><span class="line">    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">弊端：一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改</span><br></pre></td></tr></table></figure>

<p>使用多态改造后的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Alert &#123;</span><br><span class="line">  private List&lt;AlertHandler&gt; alertHandlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public void addAlertHandler(AlertHandler alertHandler) &#123;</span><br><span class="line">    this.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    for (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class AlertHandler &#123;</span><br><span class="line">  protected AlertRule rule;</span><br><span class="line">  protected Notification notification;</span><br><span class="line">  public AlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    this.rule &#x3D; rule;</span><br><span class="line">    this.notification &#x3D; notification;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract void check(ApiStatInfo apiStatInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public TpsAlertHandler(AlertRule rule, Notification notification) &#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    long tps &#x3D; apiStatInfo.getRequestCount()&#x2F; apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;</span><br><span class="line">  public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;</span><br><span class="line">    super(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void check(ApiStatInfo apiStatInfo) &#123;</span><br><span class="line">    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？具体的使用代码我也写在这里了。其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  public Alert getAlert() &#123; return alert; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 饿汉式单例</span><br><span class="line">  private static final ApplicationContext instance &#x3D; new ApplicationContext();</span><br><span class="line">  private ApplicationContext() &#123;</span><br><span class="line">    initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  public static ApplicationContext getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略设置apiStatInfo数据值的代码</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果这时需要添加其他规则警告，只需按如下进行改动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Alert &#123; &#x2F;&#x2F; 代码未改动... &#125;</span><br><span class="line">public class ApiStatInfo &#123;&#x2F;&#x2F;省略constructor&#x2F;getter&#x2F;setter方法</span><br><span class="line">  private String api;</span><br><span class="line">  private long requestCount;</span><br><span class="line">  private long errorCount;</span><br><span class="line">  private long durationOfSeconds;</span><br><span class="line">  private long timeoutCount; &#x2F;&#x2F; 改动一：添加新字段</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AlertHandler &#123; &#x2F;&#x2F;代码未改动... &#125;</span><br><span class="line">public class TpsAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">public class ErrorAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;代码未改动...&#125;</span><br><span class="line">&#x2F;&#x2F; 改动二：添加新的handler</span><br><span class="line">public class TimeoutAlertHandler extends AlertHandler &#123;&#x2F;&#x2F;省略代码...&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationContext &#123;</span><br><span class="line">  private AlertRule alertRule;</span><br><span class="line">  private Notification notification;</span><br><span class="line">  private Alert alert;</span><br><span class="line">  </span><br><span class="line">  public void initializeBeans() &#123;</span><br><span class="line">    alertRule &#x3D; new AlertRule(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    notification &#x3D; new Notification(&#x2F;*.省略参数.*&#x2F;); &#x2F;&#x2F;省略一些初始化代码</span><br><span class="line">    alert &#x3D; new Alert();</span><br><span class="line">    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    &#x2F;&#x2F; 改动三：注册handler</span><br><span class="line">    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略其他未改动代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();</span><br><span class="line">    &#x2F;&#x2F; ...省略apiStatInfo的set字段代码</span><br><span class="line">    apiStatInfo.setTimeoutCount(289); &#x2F;&#x2F; 改动四：设置tiemoutCount值</span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p>
<h4 id="通过接口实现"><a href="#通过接口实现" class="headerlink" title="通过接口实现"></a>通过接口实现</h4><p>例子通过 Kafka 来发送异步消息：</p>
<p>对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这一部分体现了抽象意识</span><br><span class="line">public interface MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class KafkaMessageQueue implements MessageQueue &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class RocketMQMessageQueue implements MessageQueue &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public interface MessageFromatter &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public class JsonMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">public class ProtoBufMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  private MessageQueue msgQueue; &#x2F;&#x2F; 基于接口而非实现编程</span><br><span class="line">  public Demo(MessageQueue msgQueue) &#123; &#x2F;&#x2F; 依赖注入</span><br><span class="line">    this.msgQueue &#x3D; msgQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; msgFormatter：多态、依赖注入</span><br><span class="line">  public void sendNotification(Notification notification, MessageFormatter msgFormatter) &#123;</span><br><span class="line">    &#x2F;&#x2F;...    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"><a href="#通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）" class="headerlink" title="通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）"></a>通过各种设计模式实现（比如，装饰、策略、模板、职责链、状态）</h4><h3 id="3-如何在项目中合理应用开闭原则？"><a href="#3-如何在项目中合理应用开闭原则？" class="headerlink" title="3.如何在项目中合理应用开闭原则？"></a>3.如何在项目中合理应用开闭原则？</h3><p>1.最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。这样可以避免过度设计。</p>
<p>2.代码的扩展性会跟可读性相冲突，很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p>
<h2 id="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h2><p>Liskov Substitution Principle</p>
<blockquote>
<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。<br>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p>
</blockquote>
<p>中文描述：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<h3 id="里式替换原则的理解"><a href="#里式替换原则的理解" class="headerlink" title="里式替换原则的理解"></a>里式替换原则的理解</h3><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<h3 id="符合里式替换原则的代码示例"><a href="#符合里式替换原则的代码示例" class="headerlink" title="符合里式替换原则的代码示例"></a>符合里式替换原则的代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Transporter &#123;</span><br><span class="line">  private HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  public Transporter(HttpClient httpClient) &#123;</span><br><span class="line">    this.httpClient &#x3D; httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...use httpClient to send request</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SecurityTransporter extends Transporter &#123;</span><br><span class="line">  private String appId;</span><br><span class="line">  private String appToken;</span><br><span class="line"></span><br><span class="line">  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) &#123;</span><br><span class="line">    super(httpClient);</span><br><span class="line">    this.appId &#x3D; appId;</span><br><span class="line">    this.appToken &#x3D; appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Response sendRequest(Request request) &#123;</span><br><span class="line">    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(&quot;app-id&quot;, appId);</span><br><span class="line">      request.addPayload(&quot;app-token&quot;, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;    </span><br><span class="line">  public void demoFunction(Transporter transporter) &#123;    </span><br><span class="line">    Reuqest request &#x3D; new Request();</span><br><span class="line">    &#x2F;&#x2F;...省略设置request中数据值的代码...</span><br><span class="line">    Response response &#x3D; transporter.sendRequest(request);</span><br><span class="line">    &#x2F;&#x2F;...省略其他逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 里式替换原则</span><br><span class="line">Demo demo &#x3D; new Demo();</span><br><span class="line">demo.demofunction(new SecurityTransporter(&#x2F;*省略参数*&#x2F;););</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p>
<h3 id="哪些代码违背了里式替换原则"><a href="#哪些代码违背了里式替换原则" class="headerlink" title="哪些代码违背了里式替换原则"></a>哪些代码违背了里式替换原则</h3><h4 id="1-子类违背父类声明要实现的功能"><a href="#1-子类违背父类声明要实现的功能" class="headerlink" title="1. 子类违背父类声明要实现的功能"></a>1. 子类违背父类声明要实现的功能</h4><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p>
<h4 id="2-子类违背父类对输入、输出、异常的约定"><a href="#2-子类违背父类对输入、输出、异常的约定" class="headerlink" title="2. 子类违背父类对输入、输出、异常的约定"></a>2. 子类违背父类对输入、输出、异常的约定</h4><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p>
<p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p>
<h4 id="3-子类违背父类注释中所罗列的任何特殊说明"><a href="#3-子类违背父类注释中所罗列的任何特殊说明" class="headerlink" title="3. 子类违背父类注释中所罗列的任何特殊说明"></a>3. 子类违背父类注释中所罗列的任何特殊说明</h4><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p>
<h3 id="判断子类的设计实现是否违背里式替换原则的小窍门"><a href="#判断子类的设计实现是否违背里式替换原则的小窍门" class="headerlink" title="判断子类的设计实现是否违背里式替换原则的小窍门"></a>判断子类的设计实现是否违背里式替换原则的小窍门</h3><p>拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p>
<p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p>
<h3 id="里式替换与多态的区别"><a href="#里式替换与多态的区别" class="headerlink" title="里式替换与多态的区别"></a>里式替换与多态的区别</h3><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。</p>
<p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</p>
<p>而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p>
<h2 id="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h2><h3 id="1-如何理解“接口隔离原则”"><a href="#1-如何理解“接口隔离原则”" class="headerlink" title="1.如何理解“接口隔离原则”"></a>1.如何理解“接口隔离原则”</h3><p>Interface Segregation Principle</p>
<h4 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 API 接口集合</h4><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p>
<p>例子：服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">  boolean register(String cellphone, String password);</span><br><span class="line">  boolean login(String cellphone, String password);</span><br><span class="line">  UserInfo getUserInfoById(long id);</span><br><span class="line">  UserInfo getUserInfoByCellphone(String cellphone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RestrictedUserService &#123;</span><br><span class="line">  boolean deleteUserByCellphone(String cellphone);</span><br><span class="line">  boolean deleteUserById(long id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService, RestrictedUserService &#123;</span><br><span class="line">  &#x2F;&#x2F; ...省略实现代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 API 接口或函数</h4><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p>
<p>比如一下代码 count() 函数功能不够单一，包含了很多不同的统计功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Statistics &#123;</span><br><span class="line">  private Long max;</span><br><span class="line">  private Long min;</span><br><span class="line">  private Long average;</span><br><span class="line">  private Long sum;</span><br><span class="line">  private Long percentile99;</span><br><span class="line">  private Long percentile999;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter等方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Statistics count(Collection&lt;Long&gt; dataSet) &#123;</span><br><span class="line">  Statistics statistics &#x3D; new Statistics();</span><br><span class="line">  &#x2F;&#x2F;...省略计算逻辑...</span><br><span class="line">  return statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Long max(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">public Long min(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125; </span><br><span class="line">public Long average(Colletion&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#x2F;&#x2F; ...省略其他统计函数...</span><br></pre></td></tr></table></figure>


<h4 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h4><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p>
<p>例子：我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    private ConfigSource configSource; &#x2F;&#x2F;配置中心（比如zookeeper）</span><br><span class="line">    private String address;</span><br><span class="line">    private int timeout;</span><br><span class="line">    private int maxTotal;</span><br><span class="line">    &#x2F;&#x2F;省略其他配置: maxWaitMillis,maxIdle,minIdle...</span><br><span class="line"></span><br><span class="line">    public RedisConfig(ConfigSource configSource) &#123;</span><br><span class="line">        this.configSource &#x3D; configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return this.address;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他get()、init()方法...</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">      &#x2F;&#x2F;从configSource加载配置到address&#x2F;timeout&#x2F;maxTotal...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略... &#125;</span><br></pre></td></tr></table></figure>

<p>现在，有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。但是，因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。</p>
<p>实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig &#123; &#x2F;&#x2F;...省略其他属性和方法... &#125;</span><br><span class="line"></span><br><span class="line">public class ScheduledUpdater &#123;</span><br><span class="line">    private final ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    private long initialDelayInSeconds;</span><br><span class="line">    private long periodInSeconds;</span><br><span class="line">    private Updater updater;</span><br><span class="line"></span><br><span class="line">    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) &#123;</span><br><span class="line">        this.updater &#x3D; updater;</span><br><span class="line">        this.initialDelayInSeconds &#x3D; initialDelayInSeconds;</span><br><span class="line">        this.periodInSeconds &#x3D; periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">  ConfigSource configSource &#x3D; new ZookeeperConfigSource(&#x2F;*省略参数*&#x2F;);</span><br><span class="line">  public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">  public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">  public static final MySqlConfig mysqlConfig &#x3D; new MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater &#x3D; new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater &#x3D; new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接着，有一个新的监控需求，期望输出项目的配置信息到一个固定的 HTTP 地址，比如：<a href="http://127.0.0.1:2389/config" target="_blank" rel="noopener">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。</p>
<p>在原来代码的基础上拓展后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface Updater &#123;</span><br><span class="line">  void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Viewer &#123;</span><br><span class="line">  String outputInPlainText();</span><br><span class="line">  Map&lt;String, String&gt; output();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisConfig implemets Updater, Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class KafkaConfig implements Updater &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public void update() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MysqlConfig implements Viewer &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略其他属性和方法...</span><br><span class="line">  @Override</span><br><span class="line">  public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">  private String host;</span><br><span class="line">  private int port;</span><br><span class="line">  private Map&lt;String, List&lt;Viewer&gt;&gt; viewers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public SimpleHttpServer(String host, int port) &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line">  </span><br><span class="line">  public void addViewers(String urlDirectory, Viewer viewer) &#123;</span><br><span class="line">    if (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    this.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void run() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    ConfigSource configSource &#x3D; new ZookeeperConfigSource();</span><br><span class="line">    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);</span><br><span class="line">    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);</span><br><span class="line">    public static final MySqlConfig mysqlConfig &#x3D; new MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(redisConfig, 300, 300);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater &#x3D;</span><br><span class="line">            new ScheduledUpdater(kafkaConfig, 60, 60);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer &#x3D; new SimpleHttpServer(“127.0.0.1”, 2389);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则</p>
<h3 id="2-接口隔离原则与单一职责原则的区别"><a href="#2-接口隔离原则与单一职责原则的区别" class="headerlink" title="2.接口隔离原则与单一职责原则的区别"></a>2.接口隔离原则与单一职责原则的区别</h3><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h2 id="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h2><h3 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h3><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p>
<h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p>
<h3 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h3><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p>
<p>现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，如果你熟悉 Java Spring 框架，你可能会说，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。</p>
<h3 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h3><blockquote>
<p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p>
</blockquote>
<p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>
<p>例子：<br>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</p>
<h2 id="理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？"><a href="#理论六：为何-KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？"></a>理论六：为何 KISS、YAGNI原则看似简单，却经常被用错？</h2><p>KISS 原则的英文描述有好几个版本，比如下面这几个。</p>
<blockquote>
<p>Keep It Simple and Stupid.<br>Keep It Short and Simple.Keep<br>It Simple and Straightforward.</p>
</blockquote>
<p>KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。</p>
<h3 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h3><ul>
<li><p>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</p>
</li>
<li><p>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</p>
</li>
<li><p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p>
</li>
</ul>
<h3 id="YAGNI-原则"><a href="#YAGNI-原则" class="headerlink" title="YAGNI 原则"></a>YAGNI 原则</h3><blockquote>
<p>You Ain’t Gonna Need It。</p>
</blockquote>
<p>直译就是：你不会需要它,实际上，这条原则的核心思想就是：不要做过度设计。</p>
<p>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</p>
<p>比如，我们不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，我们经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。我发现，有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p>
<h2 id="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h2><h3 id="DRY-原则（Don’t-Repeat-Yourself）"><a href="#DRY-原则（Don’t-Repeat-Yourself）" class="headerlink" title="DRY 原则（Don’t Repeat Yourself）"></a>DRY 原则（Don’t Repeat Yourself）</h3><p>原则我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p>
<h3 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h3><ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>模块化</li>
<li>业务与非业务逻辑分离</li>
<li>通用代码下沉继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h2 id="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h2><p>Law of Demeter</p>
<blockquote>
<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>
</blockquote>
<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>
<p><strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</strong></p>
<h3 id="如何理解“高内聚、松耦合”？"><a href="#如何理解“高内聚、松耦合”？" class="headerlink" title="如何理解“高内聚、松耦合”？"></a>如何理解“高内聚、松耦合”？</h3><ol>
<li>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</li>
</ol>
<h3 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2. 如何理解“迪米特法则”？"></a>2. 如何理解“迪米特法则”？</h3><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<h3 id="3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"><a href="#3-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？" class="headerlink" title="3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？"></a>3. “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？</h3><p>目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。</p>
<h2 id="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h2><p>以 分兑换系统的开发实战 为例：</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"><a href="#1-我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中" class="headerlink" title="1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中"></a>1. 我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中</h4><p>你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。</p>
<h4 id="2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"><a href="#2-通过产品的线框图、用户用例（user-case-）或者叫用户故事（user-story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。" class="headerlink" title="2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。"></a>2. 通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</h4><p>用户用例有点儿类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。<br>比如，有关积分有效期的用户用例，我们可以进行如下的设计：</p>
<ul>
<li>用户在获取积分的时候，会告知积分的有效期；</li>
<li>用户在使用积分的时候，会优先使用快过期的积分；</li>
<li>用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；</li>
<li>用户在查询总可用积分的时候，会排除掉过期的积分。</li>
</ul>
<h4 id="3-大致梳理出需求功能点"><a href="#3-大致梳理出需求功能点" class="headerlink" title="3. 大致梳理出需求功能点"></a>3. 大致梳理出需求功能点</h4><ul>
<li>积分赚取和兑换规则</li>
<li>积分消费和兑换规则</li>
<li>积分及其明细查询</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="1-合理地将功能划分到不同模块"><a href="#1-合理地将功能划分到不同模块" class="headerlink" title="1. 合理地将功能划分到不同模块"></a>1. 合理地将功能划分到不同模块</h4><p>除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p>
<p>可以这样划分：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p>
<h4 id="2-设计模块与模块之间的交互关系"><a href="#2-设计模块与模块之间的交互关系" class="headerlink" title="2. 设计模块与模块之间的交互关系"></a>2. 设计模块与模块之间的交互关系</h4><p>比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好</p>
<p>比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。</p>
<p>除此之外，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。</p>
<h4 id="3-设计模块的接口、数据库、业务模型"><a href="#3-设计模块的接口、数据库、业务模型" class="headerlink" title="3. 设计模块的接口、数据库、业务模型"></a>3. 设计模块的接口、数据库、业务模型</h4><p>务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p>
</li>
<li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p>
</li>
<li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p>
</li>
</ol>
<h2 id="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h2><p>我们平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）。</p>
<p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p>
<h3 id="针对积分系统，我们先来看，如何设计数据库。"><a href="#针对积分系统，我们先来看，如何设计数据库。" class="headerlink" title="针对积分系统，我们先来看，如何设计数据库。"></a>针对积分系统，我们先来看，如何设计数据库。</h3><p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2453" alt="e9562c46bcb8fc45634f0d870c4778c4.jpeg"></p>
<h3 id="如何设计积分系统的接口"><a href="#如何设计积分系统的接口" class="headerlink" title="如何设计积分系统的接口"></a>如何设计积分系统的接口</h3><p>为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2454" alt="7b9008f6bc107add2b21d3dba901deaf.jpeg"></p>
<h3 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h3><p>从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型，对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。</p>
<h3 id="为什么要分-MVC-三层开发？"><a href="#为什么要分-MVC-三层开发？" class="headerlink" title="为什么要分 MVC 三层开发？"></a>为什么要分 MVC 三层开发？</h3><ul>
<li>分层能起到代码复用的作用</li>
<li>分层能起到隔离变化的作用</li>
<li>分层能起到隔离关注点的作用</li>
<li>分层能提高代码的可测试性</li>
<li>分层能应对系统的复杂性</li>
</ul>
<h3 id="BO、VO、Entity-存在的意义是什么？"><a href="#BO、VO、Entity-存在的意义是什么？" class="headerlink" title="BO、VO、Entity 存在的意义是什么？"></a>BO、VO、Entity 存在的意义是什么？</h3><p>对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因。</p>
<p>1.VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。</p>
<p>2.VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</p>
<p>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</p>
<h3 id="VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set"><a href="#VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set" class="headerlink" title="VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set"></a>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</h3><ol>
<li><p>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set</p>
</li>
<li><p>Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p>
</li>
</ol>
<h2 id="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看。</p>
<h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要。</p>
<h4 id="1-功能性需求分析"><a href="#1-功能性需求分析" class="headerlink" title="1.功能性需求分析"></a>1.功能性需求分析</h4><ul>
<li>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。</li>
<li>统计信息的类型：max、min、avg、percentile、count、tps 等。</li>
<li>统计信息显示格式：Json、Html、自定义显示格式。</li>
<li>统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端</li>
</ul>
<p>借助设计产品的时候，经常用到的线框图，把最终数据的显示样式画出来<br><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2455" alt="f04b341ad5fda418ae24f166d0a4dde5.jpeg"></p>
<p>实际上，从线框图中，我们还能挖掘出了下面几个隐藏的需求。</p>
<ul>
<li>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</li>
<li>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 12 月 11 日 00 点到 12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等。</li>
<li>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件。</li>
</ul>
<h4 id="2-非功能性需求分析"><a href="#2-非功能性需求分析" class="headerlink" title="2.非功能性需求分析"></a>2.非功能性需求分析</h4><h5 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h5><p>在开发这样一个技术框架的时候，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是我们应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p>
<h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件</p>
<h5 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h5><p>要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。</p>
<h5 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h5><p>为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等。</p>
<h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p>借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础。</p>
<p>，我们可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以 JSON 的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多。</p>
<p>首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。在原型系统的代码实现中，我们可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。</p>
<p>最小原型的代码实现如下所示。其中，recordResponseTime() 和 recordTimestamp() 两个函数分别用来记录接口请求的响应时间和访问时间。startRepeatedReport() 函数以指定的频率统计数据并输出结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Metrics &#123;</span><br><span class="line">  &#x2F;&#x2F; Map的key是接口名称，value对应接口请求的响应时间或时间戳；</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; responseTimes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private Map&lt;String, List&lt;Double&gt;&gt; timestamps &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  private ScheduledExecutorService executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">  public void recordResponseTime(String apiName, double responseTime) &#123;</span><br><span class="line">    responseTimes.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    responseTimes.get(apiName).add(responseTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void recordTimestamp(String apiName, double timestamp) &#123;</span><br><span class="line">    timestamps.putIfAbsent(apiName, new ArrayList&lt;&gt;());</span><br><span class="line">    timestamps.get(apiName).add(timestamp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startRepeatedReport(long period, TimeUnit unit)&#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : responseTimes.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiRespTimes &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;max&quot;, max(apiRespTimes));</span><br><span class="line">          stats.get(apiName).put(&quot;avg&quot;, avg(apiRespTimes));</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : timestamps.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;Double&gt; apiTimestamps &#x3D; entry.getValue();</span><br><span class="line">          stats.putIfAbsent(apiName, new HashMap&lt;&gt;());</span><br><span class="line">          stats.get(apiName).put(&quot;count&quot;, (double)apiTimestamps.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, period, unit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private double max(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">  private double avg(List&lt;Double&gt; dataset) &#123;&#x2F;&#x2F;省略代码实现&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private Metrics metrics &#x3D; new Metrics();</span><br><span class="line">  </span><br><span class="line">  public UserController() &#123;</span><br><span class="line">    metrics.startRepeatedReport(60, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void register(UserVo user) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;regsiter&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;register&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public UserVo login(String telephone, String password) &#123;</span><br><span class="line">    long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    metrics.recordTimestamp(&quot;login&quot;, startTimestamp);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    long respTime &#x3D; System.currentTimeMillis() - startTimestamp;</span><br><span class="line">    metrics.recordResponseTime(&quot;login&quot;, respTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于最新的原型进一步考虑"><a href="#基于最新的原型进一步考虑" class="headerlink" title="基于最新的原型进一步考虑"></a>基于最新的原型进一步考虑</h3><p>图可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题。</p>
<p><img src="evernotecid://B93CACCF-EBD1-4485-9709-207B83E62B19/appyinxiangcom/22404617/ENResource/p2456" alt="926561b82b49c937dcf4a2b9e6b35c16.jpeg"></p>
<p>把整个框架分为四个模块：数据采集、存储、聚合统计、显示。每个模块负责的工作简单罗列如下。</p>
<ul>
<li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。数据采集过程要高度容错，不能影响到接口本身的可用性。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，我们也要尽量考虑其易用性。</li>
<li>存储：负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程异步完成。</li>
<li>聚合统计：负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps 等。为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。</li>
<li>显示：负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等。</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol>
<li>对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。</li>
</ol>
<p>2.对于复杂框架的设计，很多人往往觉得无从下手。今天我们分享了几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p>
<p>3.面向对象分析、设计和实现的时候，我们讲到设计阶段最终输出的是类的设计，</p>
<h2 id="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h2><p>即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式。所以，我们应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0……版本中继续迭代优化。</p>
<ul>
<li>数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。</li>
<li>存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，我们暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行。</li>
<li>聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps。</li>
<li>显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔 n 秒统计显示上 m 秒的数据（比如，间隔 60s 统计上 60s 的数据）。邮件每日统计上日的数据。</li>
</ul>
<h3 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h3><p>先大致识别出下面几个接口或类：</p>
<ul>
<li>MetricsCollector 类负责提供 API，来采集接口请求的原始数据。我们可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个 MetricsCollector 的实现方式。</li>
<li>MetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来存储。</li>
<li>Aggregator 类负责根据原始数据计算统计数据。</li>
<li>ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，我们暂时还不能确定。</li>
</ul>
<h3 id="2-定义类及类与类之间的关系"><a href="#2-定义类及类与类之间的关系" class="headerlink" title="2. 定义类及类与类之间的关系"></a>2. 定义类及类与类之间的关系</h3><p>接下来就是定义类及属性和方法，定义类与类之间的关系：</p>
<p>大致地识别出几个核心的类之后，我的习惯性做法是，先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。在设计类、类与类之间交互的时候，我会不断地用之前学过的设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS 原则、DRY 原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。</p>
<p>MetricsCollector 代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MetricsCollector &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125; &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;&#x2F;&#x2F;基于接口而非实现编程</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;依赖注入</span><br><span class="line">  public MetricsCollector(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;用一个函数代替了最小原型中的两个函数</span><br><span class="line">  public void recordRequest(RequestInfo requestInfo) &#123;</span><br><span class="line">    if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    metricsStorage.saveRequestInfo(requestInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestInfo &#123;</span><br><span class="line">  private String apiName;</span><br><span class="line">  private double responseTime;</span><br><span class="line">  private long timestamp;</span><br><span class="line">  &#x2F;&#x2F;...省略constructor&#x2F;getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MetricsStorage、RedisMetricsStorage 代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MetricsStorage &#123;</span><br><span class="line">  void saveRequestInfo(RequestInfo requestInfo);</span><br><span class="line"></span><br><span class="line">  List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimeInMillis, long endTimeInMillis);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimeInMillis, long endTimeInMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisMetricsStorage implements MetricsStorage &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略属性和构造函数等...</span><br><span class="line">  @Override</span><br><span class="line">  public void saveRequestInfo(RequestInfo requestInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimestamp, long endTimestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aggregator 代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Aggregator &#123;</span><br><span class="line">  public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long durationInMillis) &#123;</span><br><span class="line">    double maxRespTime &#x3D; Double.MIN_VALUE;</span><br><span class="line">    double minRespTime &#x3D; Double.MAX_VALUE;</span><br><span class="line">    double avgRespTime &#x3D; -1;</span><br><span class="line">    double p999RespTime &#x3D; -1;</span><br><span class="line">    double p99RespTime &#x3D; -1;</span><br><span class="line">    double sumRespTime &#x3D; 0;</span><br><span class="line">    long count &#x3D; 0;</span><br><span class="line">    for (RequestInfo requestInfo : requestInfos) &#123;</span><br><span class="line">      ++count;</span><br><span class="line">      double respTime &#x3D; requestInfo.getResponseTime();</span><br><span class="line">      if (maxRespTime &lt; respTime) &#123;</span><br><span class="line">        maxRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      if (minRespTime &gt; respTime) &#123;</span><br><span class="line">        minRespTime &#x3D; respTime;</span><br><span class="line">      &#125;</span><br><span class="line">      sumRespTime +&#x3D; respTime;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      avgRespTime &#x3D; sumRespTime &#x2F; count;</span><br><span class="line">    &#125;</span><br><span class="line">    long tps &#x3D; (long)(count &#x2F; durationInMillis * 1000);</span><br><span class="line">    Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(RequestInfo o1, RequestInfo o2) &#123;</span><br><span class="line">        double diff &#x3D; o1.getResponseTime() - o2.getResponseTime();</span><br><span class="line">        if (diff &lt; 0.0) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">        &#125; else if (diff &gt; 0.0) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int idx999 &#x3D; (int)(count * 0.999);</span><br><span class="line">    int idx99 &#x3D; (int)(count * 0.99);</span><br><span class="line">    if (count !&#x3D; 0) &#123;</span><br><span class="line">      p999RespTime &#x3D; requestInfos.get(idx999).getResponseTime();</span><br><span class="line">      p99RespTime &#x3D; requestInfos.get(idx99).getResponseTime();</span><br><span class="line">    &#125;</span><br><span class="line">    RequestStat requestStat &#x3D; new RequestStat();</span><br><span class="line">    requestStat.setMaxResponseTime(maxRespTime);</span><br><span class="line">    requestStat.setMinResponseTime(minRespTime);</span><br><span class="line">    requestStat.setAvgResponseTime(avgRespTime);</span><br><span class="line">    requestStat.setP999ResponseTime(p999RespTime);</span><br><span class="line">    requestStat.setP99ResponseTime(p99RespTime);</span><br><span class="line">    requestStat.setCount(count);</span><br><span class="line">    requestStat.setTps(tps);</span><br><span class="line">    return requestStat;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RequestStat &#123;</span><br><span class="line">  private double maxResponseTime;</span><br><span class="line">  private double minResponseTime;</span><br><span class="line">  private double avgResponseTime;</span><br><span class="line">  private double p999ResponseTime;</span><br><span class="line">  private double p99ResponseTime;</span><br><span class="line">  private long count;</span><br><span class="line">  private long tps;</span><br><span class="line">  &#x2F;&#x2F;...省略getter&#x2F;setter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsoleReporter、EmailReporterv 代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">public class ConsoleReporter &#123;</span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">  public ConsoleReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.executor &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 第4个代码逻辑：定时触发第1、2、3代码逻辑的执行；</span><br><span class="line">  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) &#123;</span><br><span class="line">    executor.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 第1个代码逻辑：根据给定的时间区间，从数据库中拉取数据；</span><br><span class="line">        long durationInMillis &#x3D; durationInSeconds * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          &#x2F;&#x2F; 第2个代码逻辑：根据原始数据，计算得到统计数据；</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第3个代码逻辑：将统计数据显示到终端（命令行或邮件）；</span><br><span class="line">        System.out.println(&quot;Time Span: [&quot; + startTimeInMillis + &quot;, &quot; + endTimeInMillis + &quot;]&quot;);</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        System.out.println(gson.toJson(stats));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0, periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class EmailReporter &#123;</span><br><span class="line">  private static final Long DAY_HOURS_IN_SECONDS &#x3D; 86400L;</span><br><span class="line"></span><br><span class="line">  private MetricsStorage metricsStorage;</span><br><span class="line">  private EmailSender emailSender;</span><br><span class="line">  private List&lt;String&gt; toAddresses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage) &#123;</span><br><span class="line">    this(metricsStorage, new EmailSender(&#x2F;*省略参数*&#x2F;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) &#123;</span><br><span class="line">    this.metricsStorage &#x3D; metricsStorage;</span><br><span class="line">    this.emailSender &#x3D; emailSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addToAddress(String address) &#123;</span><br><span class="line">    toAddresses.add(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startDailyReport() &#123;</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.DATE, 1);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">    calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">    calendar.set(Calendar.SECOND, 0);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">    Date firstTime &#x3D; calendar.getTime();</span><br><span class="line">    Timer timer &#x3D; new Timer();</span><br><span class="line">    timer.schedule(new TimerTask() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        long durationInMillis &#x3D; DAY_HOURS_IN_SECONDS * 1000;</span><br><span class="line">        long endTimeInMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;</span><br><span class="line">        Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;</span><br><span class="line">                metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);</span><br><span class="line">        Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet()) &#123;</span><br><span class="line">          String apiName &#x3D; entry.getKey();</span><br><span class="line">          List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();</span><br><span class="line">          RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);</span><br><span class="line">          stats.put(apiName, requestStat);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: 格式化为html格式，并且发送邮件</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, firstTime, DAY_HOURS_IN_SECONDS * 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将类组装起来并提供执行入口<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    MetricsStorage storage &#x3D; new RedisMetricsStorage();</span><br><span class="line">    ConsoleReporter consoleReporter &#x3D; new ConsoleReporter(storage);</span><br><span class="line">    consoleReporter.startRepeatedReport(60, 60);</span><br><span class="line"></span><br><span class="line">    EmailReporter emailReporter &#x3D; new EmailReporter(storage);</span><br><span class="line">    emailReporter.addToAddress(&quot;wangzheng@xzg.com&quot;);</span><br><span class="line">    emailReporter.startDailyReport();</span><br><span class="line"></span><br><span class="line">    MetricsCollector collector &#x3D; new MetricsCollector(storage);</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));</span><br><span class="line">    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(100000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Review-设计与实现-以及问题分析"><a href="#Review-设计与实现-以及问题分析" class="headerlink" title="Review 设计与实现 以及问题分析"></a>Review 设计与实现 以及问题分析</h3><ul>
<li><p>Aggregator 类是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算。当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化。</p>
</li>
<li><p>ConsoleReporter、EmailReporterConsoleReporter 和 EmailReporter 中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 DRY 原则。而且整个类负责的事情比较多，职责不是太单一。特别是显示部分的代码，可能会比较复杂（比如 Email 的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好。</p>
</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的 Unix 系统，第一版很简单、粗糙，代码不到 1 万行。所以，迭代思维很重要，不要刚开始就追求完美。</p>
</li>
<li><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 6 ：垃圾回收机制</title>
    <url>/2018/07/17/garbage-collection/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>垃圾收集 Garbage Collection 通常被称为“GC”。 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.</p>
<a id="more"></a>

<h2 id="二、GC-算法与垃圾收集器总结"><a href="#二、GC-算法与垃圾收集器总结" class="headerlink" title="二、GC 算法与垃圾收集器总结"></a>二、GC 算法与垃圾收集器总结</h2><p><img src="/images/gc01.png" alt="垃圾回收机制总结"></p>
<p>下图是 HotSpot 虚拟机的垃圾收集器（图片来源于 <a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/our-collectors</a>）<br><img src="/images/gc02.jpg" alt=""></p>
<p>查看JDK使用的是什么垃圾收集器，可使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line">java -XX:+PrintGCDetails -version</span><br></pre></td></tr></table></figure>
<p>运行结果示例：<br><img src="/images/gc03.jpg" alt=""></p>
<p><a href="http://www.ityouknow.com/jvm/2017/08/29/GC-garbage-collection.html" target="_blank" rel="noopener">GC 算法 垃圾收集器-纯洁的微笑</a></p>
<h2 id="三、垃圾回收的时机与过程"><a href="#三、垃圾回收的时机与过程" class="headerlink" title="三、垃圾回收的时机与过程"></a>三、垃圾回收的时机与过程</h2><p>不同的垃圾回收器的回收过程其实是有些差别的，下面分别以以 CMS垃圾回收器 以及 G1 垃圾回收器为例。</p>
<h3 id="CMS收集器的GC过程"><a href="#CMS收集器的GC过程" class="headerlink" title="CMS收集器的GC过程"></a>CMS收集器的GC过程</h3><p><img src="/images/gc04.jpg" alt=""><br><img src="/images/gc05.jpg" alt=""></p>
<h3 id="G1收集器的GC过程"><a href="#G1收集器的GC过程" class="headerlink" title="G1收集器的GC过程"></a>G1收集器的GC过程</h3><p><strong>G1把内存分成一块块的Region，每块的Region的大小都是一样的。G1 保留了 YoungGC 并加上了一种全新的Mixed GC用于收集老年代。G1中没有Full GC，G1中的Full GC是通过调用serialOldGC进行全堆扫描实现的（包括eden、survivor、old、perm）。</strong></p>
<p>1.YoungGC年轻代收集<br>在分配一般对象（非巨型对象）时，当所有eden region使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC。每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。</p>
<p>2.Mixed GC<br>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>
<p>3.有两种情况会出现 G1 Full GC<br>G1的初衷就是要避免Full GC的出现。但如果出现以下两种情况，G1会停止应用程序的执行(Stop-The-World)，退化成使用单线程的内存回收算法(调用serialOldGC)进行垃圾回收, 性能会非常差，应用程序停顿时间会很长。</p>
<ul>
<li><p>拷贝存活对象晋升失败，无法找到可用的空闲分区，GC日志记录为to-space exhausted。或者分配巨型对象无法在老年代找到连续足够的分区</p>
</li>
<li><p>当发生第一个条件后，G1会尝试增加堆使用量，如果扩展失败，那么会触发安全措施机制同时发生 调用serialOldGC 进行 Full GC</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/59861022" target="_blank" rel="noopener">深入剖析JVM：G1收集器+回收流程+推荐用例</a></p>
<h3 id="HotSpot-VM-的-GC分类"><a href="#HotSpot-VM-的-GC分类" class="headerlink" title="HotSpot VM 的 GC分类"></a>HotSpot VM 的 GC分类</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p>
<blockquote>
<p><del>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</del></p>
</blockquote>
<p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p>
<p><img src="/images/gc06.jpg" alt=""></p>
<p><strong>总结：</strong><br>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h2 id="四、GC日志分析"><a href="#四、GC日志分析" class="headerlink" title="四、GC日志分析"></a>四、GC日志分析</h2><p><a href="http://www.ityouknow.com/jvm/2017/09/18/GC-Analysis.html" target="_blank" rel="noopener">Java GC 分析</a></p>
<h2 id="五、Java-服务-GC-参数调优案例"><a href="#五、Java-服务-GC-参数调优案例" class="headerlink" title="五、Java 服务 GC 参数调优案例"></a>五、Java 服务 GC 参数调优案例</h2><p><a href="http://www.ityouknow.com/jvm/2017/09/19/GC-tuning.html" target="_blank" rel="noopener">Java 服务 GC 参数调优案例</a></p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><p><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">Our Collectors</a><br><a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">GC 的分分类</a><br><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" target="_blank" rel="noopener">JVM垃圾回收</a><br><a href="https://zhuanlan.zhihu.com/p/59861022" target="_blank" rel="noopener">深入剖析JVM：G1收集器+回收流程+推荐用例</a><br><a href="http://www.ityouknow.com/jvm/2017/08/29/GC-garbage-collection.html" target="_blank" rel="noopener">GC 算法 垃圾收集器-纯洁的微笑</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 7 ：JVM监控与调优</title>
    <url>/2018/07/18/jvm-gc-optimize/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Java所提倡的自动内存管理最终可以归结为自动的解决两个问题：给对象分配内存以及回收分配给对象的内存，对JVM参数进行合理的设置, 可以提升GC的效率，从而提升系统的性能。</p>
<a id="more"></a>

<h2 id="二、JVM监控与性能分析工具"><a href="#二、JVM监控与性能分析工具" class="headerlink" title="二、JVM监控与性能分析工具"></a>二、JVM监控与性能分析工具</h2><p><img src="/images/jvmgctool.png" alt="JVM性能分析工具"></p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p>
<p>命令格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps [option] [hostid]</span><br></pre></td></tr></table></figure>

<p>jps option参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID,省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是Jar包，输出Jar路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody></table>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>[option] : 操作参数</li>
<li>LVMID : 本地虚拟机进程ID</li>
<li>[interval] : 连续输出的时间间隔</li>
<li>[count] : 连续输出的次数</li>
</ul>
<p>Jstat option参数:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间以及类装载所消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
</tbody></table>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
<p>命令格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br></pre></td></tr></table></figure>

<p>jinfo option 参数:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-flag</td>
<td>输出指定args参数的值</td>
</tr>
<tr>
<td>-flags</td>
<td>不需要args参数，输出所有JVM参数的值</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性，等同于System.getProperties()</td>
</tr>
</tbody></table>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>
<p>jmap option参数:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成Java堆转储快照。格式为：-dump:[live, ]format=b,file=filename,其中live子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer县城执行finalize方法的对象。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-heap</td>
<td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td>
</tr>
</tbody></table>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure>

<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack [option] LVMID</span><br></pre></td></tr></table></figure>

<p>jstack option 参数：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<h2 id="三、JVM-参数调优"><a href="#三、JVM-参数调优" class="headerlink" title="三、JVM 参数调优"></a>三、JVM 参数调优</h2><p>Java所提倡的自动内存管理最终可以归结为自动的解决两个问题：给对象分配内存以及回收分配给对象的内存，对JVM参数进行合理的设置, 可以提升GC的效率，从而提升系统的性能。</p>
<h3 id="GC优化的两个目的："><a href="#GC优化的两个目的：" class="headerlink" title="GC优化的两个目的："></a>GC优化的两个目的：</h3><h4 id="将进入老年代的对象数量降到最低"><a href="#将进入老年代的对象数量降到最低" class="headerlink" title="将进入老年代的对象数量降到最低"></a>将进入老年代的对象数量降到最低</h4><p>除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。</p>
<h4 id="减少Full-GC的执行时间"><a href="#减少Full-GC的执行时间" class="headerlink" title="减少Full GC的执行时间"></a>减少Full GC的执行时间</h4><p>Full GC的执行时间比Young GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。如果通过减小老年代内存来减少Full GC时间，可能会引起OutOfMemoryError或者导致Full GC的频率升高。另外，如果通过增加老年代内存来降低Full GC的频率，Full GC的时间可能因此增加。因此，你需要把老年代的大小设置成一个“合适”的值。</p>
<h3 id="GC调优的主要参数"><a href="#GC调优的主要参数" class="headerlink" title="GC调优的主要参数"></a>GC调优的主要参数</h3><p>JVM内存各个代的大小，会直接影响 Yong GC 和 Full GC 触发的时机和触发的频率。在代大小的调优上，最关键的参数为：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存大小</td>
<td>-Xms -Xmx</td>
<td>-Xms是启动JVM时堆内存的大小，-Xmn是堆内存的最大限制。通常设置为相同的值，避免运行时要不断的扩展JVM空间，造成性能上的损失</td>
</tr>
<tr>
<td>新生代空间大小</td>
<td>-Xmn</td>
<td>新生代大小 如：-Xmn256m 设置JVM的新生代内存大小（－Xmn 是将NewSize与MaxNewSize设为一致。 256m）</td>
</tr>
<tr>
<td></td>
<td>-XX:NewRatio</td>
<td>新生代和老年代的内存比，如:NewRatio等于2，则新生代:老年代=1:2，因此，NewRatio的值设置得越大，则老年代空间越大，新生代空间越小。</td>
</tr>
<tr>
<td></td>
<td>-XX:SurvivorRatio</td>
<td>新生代中 Eden区和Survivor区的内存比例，默认为 8</td>
</tr>
<tr>
<td>年龄设置</td>
<td>-XX:MaxTenuringThreshold</td>
<td>对象经历多少次 Yong GC 后 进入 Old Space. 默认 15</td>
</tr>
</tbody></table>
<blockquote>
<p>在进行GC优化时最常用的参数是-Xms,-Xmx和-XX:NewRatio。-Xms和-Xmx参数通常是必须的，所以NewRatio的值将对GC性能产生重要的影响。有些人可能会问如何设置永久代内存大小，你可以用-XX:PermSize和-XX:MaxPermSize参数来设置方法区的大小，但是要记住，只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。</p>
</blockquote>
<ol>
<li><p>避免新生代设置过小</p>
<ul>
<li>Yong GC 频率过高，Yong GC 的对象会过早进入老年代，若此时进入老年代的对象大于老年代剩余空间，将会触发 Full GC</li>
<li>可能导致Yong GC 的对象直接进入老年代，若此时进入老年代的对象大于老年代剩余空间，将会触发 Full GC</li>
</ul>
</li>
<li><p>避免新生代设置过大</p>
<ul>
<li>Old Space 变小， Full GC频繁发生</li>
<li>Yong GC 耗时大幅度增长</li>
</ul>
</li>
<li><p>避免 Survivor区过小/过大</p>
<ul>
<li><p>调大 SurvivorRatio 值， 即 Eden 空间变大，Survivor 空间变小， Yong GC 的频率会下降，但如有 Yong GC 后的对象没有被回收且大于 Survivor 空间，则会直接放入 Old Space, 引发 Full GC 的频率提高</p>
</li>
<li><p>调小 SurvivorRatio 值， 即 Eden 空间变小， Yong GC 频繁发生。 Survicor 空间变大， 可以存储更多存货的对象，减少直接进入Old Space 的几率</p>
</li>
</ul>
</li>
<li><p>适当设置新生代对象的存活周期，可充分的回收对象，避免对象进入 Old Space</p>
</li>
</ol>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>《深入理解Java虚拟机》 – 周志明 第4章<br><a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">6个JDK命令行工具的使用</a><br><a href="http://www.ityouknow.com/jvm/2017/09/29/How-to-optimize-Java-GC.html" target="_blank" rel="noopener">如何优化 Java GC </a><br><a href="https://cloud.tencent.com/developer/article/1513803" target="_blank" rel="noopener">JVM 内存区域大小参数设置</a><br><a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">Jvm 系列(四):Jvm 调优-命令篇</a><br><a href="http://www.ityouknow.com/jvm/2017/09/19/GC-tuning.html" target="_blank" rel="noopener">Java 服务 GC 参数调优案例</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Java多线程-基础篇</title>
    <url>/2020/11/01/concurrent-base/</url>
    <content><![CDATA[<h2 id="进程与线程基本概念"><a href="#进程与线程基本概念" class="headerlink" title="进程与线程基本概念"></a>进程与线程基本概念</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>在现代操作系统中，进程是操作系统进行资源分配的基本单位(内存地址、文件 I/O 等)，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。</p>
<p>线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<a id="more"></a>

<h3 id="图解进程和线程的关心"><a href="#图解进程和线程的关心" class="headerlink" title="图解进程和线程的关心"></a>图解进程和线程的关心</h3><p><img src="/images/con01.jpg" alt="6dfd0cc256d503449d4eb2c27d727e4c.png"></p>
<p><a href="https://crazyfzw.github.io/2018/07/11/jvm-memory-division/">Java 虚拟机 3：Java内存模型-内存区域划分以及对象创建的过程</a></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。</p>
<p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p>举例说明 线程 A - B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.先挂起线程A，将其在cpu中的状态保存在内存中。</span><br><span class="line">2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</span><br><span class="line">3.当B执行完，根据程序计数器中指向的位置恢复线程A。</span><br></pre></td></tr></table></figure>

<p>上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>并发：一个时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行</p>
<p>并行：一个时间段和时间点上都有多个线程或进程在执行。<br>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>
<h2 id="Java多线程入门类和接口"><a href="#Java多线程入门类和接口" class="headerlink" title="Java多线程入门类和接口"></a>Java多线程入门类和接口</h2><p>JDK提供了Thread类和Runnable接口来让我们实现自己的“线程”类。</p>
<ul>
<li>继承Thread类，并重写run方法；</li>
<li>实现Runnable接口的run方法；</li>
</ul>
<p>使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>
<p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;MyThread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread myThread &#x3D; new MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程并进入就绪状态(Ready)，然后等到这个线程第一次得到时间片时再自动调用run()方法。</p>
<p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<br>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>接着我们来看一下Runnable接口(JDK 1.8 +)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Runnable是一个函数式接口，这意味着我们可以使用Java 8的函数式编程来简化代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static class MyThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;MyThread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new MyThread()).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Java 8 函数式编程，可以省略MyThread类</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Java 8 匿名内部类&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h3><p>使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>
<p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p>
<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的是，Callable提供的方法是有返回值的，而且支持泛型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看一个简单的使用demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义Callable</span><br><span class="line">class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计算需要一秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        Task task &#x3D; new Task();</span><br><span class="line">        Future&lt;Integer&gt; result &#x3D; executor.submit(task);</span><br><span class="line">        &#x2F;&#x2F; 注意调用get方法会阻塞当前线程，直到得到结果。</span><br><span class="line">        &#x2F;&#x2F; 所以实际编码中建议使用可以设置超时时间的重载get方法。</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future接口只有几个比较简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract interface Future&lt;V&gt; &#123;</span><br><span class="line">    public abstract boolean cancel(boolean paramBoolean);</span><br><span class="line">    public abstract boolean isCancelled();</span><br><span class="line">    public abstract boolean isDone();</span><br><span class="line">    public abstract V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    public abstract V get(long paramLong, TimeUnit paramTimeUnit)</span><br><span class="line">            throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类来供我们使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义Callable，与上面一样</span><br><span class="line">class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计算需要一秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用</span><br><span class="line">        ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new Task());</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java中用ThreadGroup来表示线程组，我们可以使用线程组对线程进行批量控制。</p>
<p>ThreadGroup和Thread的关系就如同他们的字面意思一样简单粗暴，每个Thread必然存在于一个ThreadGroup中，Thread不能独立于ThreadGroup存在。执行main()方法线程的名字是main，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。</p>
<p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p>
<p>ThreadGroup源码中的成员变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadGroup implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    private final ThreadGroup parent; &#x2F;&#x2F; 父亲ThreadGroup</span><br><span class="line">    String name; &#x2F;&#x2F; ThreadGroupr 的名称</span><br><span class="line">    int maxPriority; &#x2F;&#x2F; 线程最大优先级</span><br><span class="line">    boolean destroyed; &#x2F;&#x2F; 是否被销毁</span><br><span class="line">    boolean daemon; &#x2F;&#x2F; 是否守护线程</span><br><span class="line">    boolean vmAllowSuspension; &#x2F;&#x2F; 是否可以中断</span><br><span class="line"></span><br><span class="line">    int nUnstartedThreads &#x3D; 0; &#x2F;&#x2F; 还未启动的线程</span><br><span class="line">    int nthreads; &#x2F;&#x2F; ThreadGroup中线程数目</span><br><span class="line">    Thread threads[]; &#x2F;&#x2F; ThreadGroup中的线程</span><br><span class="line"></span><br><span class="line">    int ngroups; &#x2F;&#x2F; 线程组数目</span><br><span class="line">    ThreadGroup groups[]; &#x2F;&#x2F; 线程组数组</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 私有构造函数</span><br><span class="line">    private ThreadGroup() &#123; </span><br><span class="line">        this.name &#x3D; &quot;system&quot;;</span><br><span class="line">        this.maxPriority &#x3D; Thread.MAX_PRIORITY;</span><br><span class="line">        this.parent &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认是以当前ThreadGroup传入作为parent  ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。</span><br><span class="line">    public ThreadGroup(String name) &#123;</span><br><span class="line">        this(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    public ThreadGroup(ThreadGroup parent, String name) &#123;</span><br><span class="line">        this(checkParentAccess(parent), parent, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有构造函数，主要的构造函数</span><br><span class="line">    private ThreadGroup(Void unused, ThreadGroup parent, String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.maxPriority &#x3D; parent.maxPriority;</span><br><span class="line">        this.daemon &#x3D; parent.daemon;</span><br><span class="line">        this.vmAllowSuspension &#x3D; parent.vmAllowSuspension;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">        parent.add(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程组的常用方法：</p>
<p>1.获取当前的线程组名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup().getName()</span><br></pre></td></tr></table></figure>

<p>2.复制线程组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前的线程组</span><br><span class="line">ThreadGroup threadGroup &#x3D; Thread.currentThread().getThreadGroup();</span><br><span class="line">&#x2F;&#x2F; 复制一个线程组到一个线程数组（获取Thread信息）</span><br><span class="line">Thread[] threads &#x3D; new Thread[threadGroup.activeCount()];</span><br><span class="line">threadGroup.enumerate(threads);</span><br></pre></td></tr></table></figure>
<p>3.线程组统一异常处理示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadGroupDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadGroup threadGroup1 &#x3D; new ThreadGroup(&quot;group1&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 继承ThreadGroup并重新定义以下方法</span><br><span class="line">            &#x2F;&#x2F; 在线程成员抛出unchecked exception</span><br><span class="line">            &#x2F;&#x2F; 会执行此方法</span><br><span class="line">            public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">                System.out.println(t.getName() + &quot;: &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个线程是threadGroup1的一员</span><br><span class="line">        Thread thread1 &#x3D; new Thread(threadGroup1, new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; 抛出unchecked异常</span><br><span class="line">                throw new RuntimeException(&quot;测试异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>Java中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级是多少还是由操作系统决定。</p>
<p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p>
<p><img src="/images/con02.jpg" alt="f8c98e1047e8c73aed81e2072d12de98.png"></p>
<p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    &#x2F;&#x2F; 先验证优先级的合理性</span><br><span class="line">    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if((g &#x3D; getThreadGroup()) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span><br><span class="line"></span><br><span class="line">        if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line"></span><br><span class="line">            newPriority &#x3D; g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority &#x3D; newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法Thread类的setPriority()来设定线程的优先级示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a &#x3D; new Thread();</span><br><span class="line">        System.out.println(&quot;我是默认线程优先级：&quot;+a.getPriority());</span><br><span class="line">        Thread b &#x3D; new Thread();</span><br><span class="line">        b.setPriority(10);</span><br><span class="line">        System.out.println(&quot;我是设置过的线程优先级：&quot;+b.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">我是默认线程优先级：5</span><br><span class="line">我是设置过的线程优先级：10</span><br></pre></td></tr></table></figure>

<p>Java中的优先级来说不是特别的可靠，Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。</p>
<h2 id="Java线程的状态及主要转化方法"><a href="#Java线程的状态及主要转化方法" class="headerlink" title="Java线程的状态及主要转化方法"></a>Java线程的状态及主要转化方法</h2><h3 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h3><p>线程的状态在 JDK 1.5 之后以枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p>
<ul>
<li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li>
<li>RUNNABLE，就绪状态包括(Running 和 Ready），表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li>
<li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；</li>
<li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；</li>
<li>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li>
<li>TERMINATED，终止状态，表示线程已经执行完成。</li>
</ul>
<p>Thread.State 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEW,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 就绪状态（包括Running 和 Ready），表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span><br><span class="line">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span><br><span class="line">     * 使用 synchronized 标记的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BLOCKED,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span><br><span class="line">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span><br><span class="line">     * Object.notify() 或 Object.notifyAll()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span><br><span class="line">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span><br><span class="line">     * Thread.join(long timeout) 就会进入此状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 终止状态，表示线程已经执行完成</span><br><span class="line">     *&#x2F;</span><br><span class="line">     TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/con03.jpg" alt="2deb191023e464dd5ba70eb99517638c.png"></p>
<h3 id="BLOCKED-和-WAITING-的区别"><a href="#BLOCKED-和-WAITING-的区别" class="headerlink" title="BLOCKED 和 WAITING 的区别"></a>BLOCKED 和 WAITING 的区别</h3><p>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别:</p>
<ul>
<li>BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；</li>
</ul>
<p>-而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</p>
<h3 id="调用-start-和-run-启动线程的区别"><a href="#调用-start-和-run-启动线程的区别" class="headerlink" title="调用 start() 和 run() 启动线程的区别"></a>调用 start() 和 run() 启动线程的区别</h3><ul>
<li><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法.</p>
</li>
<li><p>它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p>
</li>
</ul>
<p>Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态验证，不等于 NEW 的状态会抛出异常</span><br><span class="line">    if (threadStatus !&#x3D; 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line">    &#x2F;&#x2F; 通知线程组，此线程即将启动</span><br><span class="line">    group.add(this);</span><br><span class="line">    boolean started &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started &#x3D; true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> &#x2F;&#x2F; 忽略其他方法......</span><br><span class="line">  private Runnable target;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      if (target !&#x3D; null) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="Thread常用方法-join-和-yield-的区别"><a href="#Thread常用方法-join-和-yield-的区别" class="headerlink" title="Thread常用方法 join() 和 yield() 的区别"></a>Thread常用方法 join() 和 yield() 的区别</h3><ul>
<li><p>join()：使当前线程等待另一个线程执行完毕或超时之后再继续执行，内部调用的是Object类的wait方法实现的，比如：在一个线程中调用other.join()，这时候当前线程会让出执行权给other线程，直到other线程执行完或者过了超时时间之后再继续执行当前线程：</p>
</li>
<li><p>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用，使同优先级或更高优先级的线程有执行的机会,yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。不可靠，因为线程调度器不一定会采纳 yield() 出让 CPU 时间片的建议</p>
</li>
</ul>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>内部调用的是Object类的wait方法实现的, 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 超时时间不能小于 0</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 等于 0 表示无限等待，直到线程执行完为之</span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断子线程 (其他线程) 为活跃线程，则一直等待</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环判断</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，在未使用 join() 时，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadExampleWithJoin &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 6; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;子线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start(); &#x2F;&#x2F; 开启线程</span><br><span class="line">        &#x2F;&#x2F;thread.join(2000);  &#x2F;&#x2F; 等待子线程先执行 2 秒钟</span><br><span class="line">        thread.join();&#x2F;&#x2F;等待子线程先执行完毕后再执行</span><br><span class="line">        &#x2F;&#x2F; 主线程执行</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;主线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/con04.jpg" alt="30d3b398722f5e62800047c5ce503c2e.png"></p>
<p>从结果可以看出，在未使用 join() 时主子线程会交替执行。</p>
<p>然后我们再把 join() 方法加入到代码中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadExampleWithJoin &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 6; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;子线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start(); &#x2F;&#x2F; 开启线程</span><br><span class="line">        thread.join();&#x2F;&#x2F;等待子线程先执行完毕后再执行</span><br><span class="line">        &#x2F;&#x2F;thread.join(2000); &#x2F;&#x2F;则等待子线程先执行 2 秒钟</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 主线程执行</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;主线程睡眠：&quot; + i + &quot;秒。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/con05.jpg" alt="3b1ec400424c5999a335a6ebcfd8c76d.png"></p>
<p>从执行结果可以看出，加 join() 方法之后，主线程会先等子线程执行完之后才继续执行。</p>
<p>如果使用 thread.join(2000)，则运行结果如下<br><img src="/images/con06.jpg" alt="02a269c85a34854ff450c3e09dc6b94f.png"></p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用，使同优先级或更高优先级的线程有执行的机会,yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。不可靠，因为线程调度器不一定会采纳 yield() 出让 CPU 时间片的建议</p>
<p>Thread 的源码可以知道 yield() 为本地方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure>

<p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p>
<p>比如我们执行这段包含了 yield() 方法的代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadExampleWithYield &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; +</span><br><span class="line">                            Thread.currentThread().getName() + &quot; I：&quot; + i);</span><br><span class="line">                    if (i &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                        Thread.yield();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 &#x3D; new Thread(runnable, &quot;T1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(runnable, &quot;T2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/con07.jpg" alt="7c3a9142eed1a56119c7b89c29d0e098.png"><br><img src="/images/con08.jpg" alt="30433da2def8bbfb044770a14b24fd3a.png"></p>
<p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为 yield() 执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU时间片的建议。</p>
<h2 id="Java线程间的通信方式"><a href="#Java线程间的通信方式" class="headerlink" title="Java线程间的通信方式"></a>Java线程间的通信方式</h2><ul>
<li>锁与同步</li>
<li>等待/通知机制 Java多线程的等待/通知机制是基于Object类的wait()方法和notify(), notifyAll()方法来实现的。</li>
<li>信号量 JDK提供了一个类似于“信号量”功能的类Semaphore</li>
<li>管道 基于“管道流”的通信方式。JDK提供了PipedWriter、 PipedReader、 PipedOutputStream、 PipedInputStream。</li>
<li>ThreadLocal类</li>
</ul>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Java多线程-非阻塞同步-CAS</title>
    <url>/2020/11/03/concurrent-cas/</url>
    <content><![CDATA[<h2 id="乐观锁与悲观锁的概念"><a href="#乐观锁与悲观锁的概念" class="headerlink" title="乐观锁与悲观锁的概念"></a>乐观锁与悲观锁的概念</h2><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p>
<p>悲观锁：<br>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。互斥同步锁就属于悲观锁，比如， synchronized. 与 ReentrantLock.</p>
<p>乐观锁：<br>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p>
<p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。</p>
<a id="more"></a>


<p><strong>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</strong></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步是阻塞同步，这是一种悲观的并发策略，总是认为只要不加锁那就肯定会出现问题，无论共享数据是否真多会出现竞争，它都要进行加锁。</p>
<p>而随着硬件指令集的发展，CAS得与实现，做法是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）</p>
<p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。所以这里的预期值E本质上指的是“旧值”</p>
<p>以一个简单的例子来解释这个过程：<br>1.如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6;<br>2.我们使用CAS来做这个事情；<br>3.首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6；<br>4.如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。</p>
<p>在这个例子中，i就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了i为5之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？<br>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。CAS 常常会搭配自旋使用</p>
<h2 id="Java实现CAS的原理-Unsafe类"><a href="#Java实现CAS的原理-Unsafe类" class="headerlink" title="Java实现CAS的原理 - Unsafe类"></a>Java实现CAS的原理 - Unsafe类</h2><p>CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。</p>
<p>在Java中，有一个Unsafe类，它在sun.misc包中。它里面是一些native方法，其中就有几个关于CAS的：</p>
<p>JDK1.7中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset,</span><br><span class="line">                                                 Object expected,</span><br><span class="line">                                                 Object x);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line"> * holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line"> * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,</span><br><span class="line">                                               long expected,</span><br><span class="line">                                               long x);</span><br></pre></td></tr></table></figure>

<p>在 JDK11 中，则改成一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">    @HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line"> @HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure>

<p>可以看出两个版本都是 native 的，Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p>
<p>Linux的X86下主要是通过cmpxchgl这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用lock指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同。</p>
<h2 id="JDK提供的原子操作类-AtomicInteger源码简析"><a href="#JDK提供的原子操作类-AtomicInteger源码简析" class="headerlink" title="JDK提供的原子操作类-AtomicInteger源码简析"></a>JDK提供的原子操作类-AtomicInteger源码简析</h2><p>由于 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器 BootStrap ClassLoader 加载的 Class 才能访问它)，所以，JDK给我们提供了一些原子类的Java API来间接使用它，这些原子工具类在java.util.concurrent.atomic包下面。在JDK 11中，有如下17个类：<br><img src="/images/cas01.jpg" alt="f0f475e608bc2a584e4d6214bab2b4d0.png"></p>
<p>从名字就可以看得出来这些类大概的用途：</p>
<p>原子更新基本类型<br>原子更新数组<br>原子更新引用<br>原子更新字段（属性）</p>
<p>这里我们以AtomicInteger类的getAndAdd(int delta)方法为例，来看看Java是如何实现原子操作的。</p>
<p>先看看这个方法的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return U.getAndAddInt(this, VALUE, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v &#x3D; getIntVolatile(o, offset);对象o是this，也就是一个AtomicInteger对象。然后offset是一个常量VALUE。这个常量是在AtomicInteger类中声明的：</span><br><span class="line">    &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @HotSpotIntrinsicCandidate</span><br><span class="line">    public final boolean weakCompareAndSetIntRelease(Object o, long offset, int expected, int x) &#123;</span><br><span class="line">        return this.compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @HotSpotIntrinsicCandidate</span><br><span class="line">    public final native boolean compareAndSetInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>
<p>所以其实AtomicInteger类的getAndAdd(int delta)方法最终其实是调用的我们之前说到了CAS native方法来来实现的：对象o是this，也就是一个AtomicInteger对象。然后offset是对象字段偏移量。是通过 U.objectFieldOffset(AtomicInteger.class, “value”) 取得的。</p>
<p>CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。这里使用的是do-while循环。这种循环不多见，它的目的是保证循环体内的语句至少会被执行一遍。这样才能保证return 的值v是我们期望的值。 </p>
<p>而在JDk1.8 之前，比如JDK1.7中说通过for循环实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JDK1.7中</span><br><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;openjdk-mirror&#x2F;jdk7u-jdk&#x2F;blob&#x2F;master&#x2F;src&#x2F;share&#x2F;classes&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;atomic&#x2F;AtomicInteger.java</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Atomically adds the given value to the current value.</span><br><span class="line">     *</span><br><span class="line">     * @param delta the value to add</span><br><span class="line">     * @return the previous value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current &#x3D; get();</span><br><span class="line">            int next &#x3D; current + delta;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，两个版本最终其实是调用的我们之前说到了CAS native方法。那为什么要经过一层weakCompareAndSetInt呢？</p>
<blockquote>
<p>而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p>
</blockquote>
<h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><h3 id="ABA问题及解决"><a href="#ABA问题及解决" class="headerlink" title="ABA问题及解决"></a>ABA问题及解决</h3><p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p>
<p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。</p>
<p>AtomicStampedReference类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">        expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">        ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">          newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它通控制变量的把那本来保证CAS的正确性，不过目前来说这个功能比较鸡肋，因为大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，该用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。</p>
<blockquote>
<p>解决思路是让JVM支持处理器提供的pause指令：<br>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多</p>
</blockquote>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>有两种解决方案：</p>
<ul>
<li><p>使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</p>
</li>
<li><p>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Java多线程-AQS及通信工具类</title>
    <url>/2020/11/08/concurrent-aqs/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-简介"><a href="#AQS-简介" class="headerlink" title="AQS 简介"></a>AQS 简介</h3><p>AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器，从字面意思上理解:</p>
<ul>
<li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li>
<li>队列：使用先进先出（FIFO）队列存储数据；</li>
<li>同步：实现了同步的功能。</li>
</ul>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们常用到的同步类 ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p>
<a id="more"></a>

<p><img src="/images/aqs01.jpg" alt="e8860a5e5c273c648ff38504afa98c63.png"></p>
<p>AQS 采用了模版方法实现，子类只需要根据需要去实现自己关心的protected 方法即可造出符合我们自己需求的同步器。</p>
<h3 id="AQS-的数据结构"><a href="#AQS-的数据结构" class="headerlink" title="AQS 的数据结构"></a>AQS 的数据结构</h3><p>AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改版state的protected方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final int getState() &#123;</span><br><span class="line">    return this.state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    this.state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return STATE.compareAndSet(this, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三种叫做均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。</p>
<p>而AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。但它并不是直接储存线程，而是储存拥有线程的Node节点。其数据结构如图：</p>
<p><img src="/images/aqs02.jpg" alt="e3144b5ad4ae0bf1b473687efa2d487e.png"></p>
<h3 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h3><p>资源有两种共享模式，或者说两种同步方式：</p>
<ul>
<li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li>
<li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</li>
</ul>
<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p>
<p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在共享模式下等待</span><br><span class="line">    static final Node SHARED &#x3D; new Node();</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在独占模式下等待</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）已被取消</span><br><span class="line">    static final int CANCELLED &#x3D; 1; </span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span><br><span class="line">    static final int SIGNAL &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）在等待某一条件</span><br><span class="line">    static final int CONDITION &#x3D; -2;</span><br><span class="line">    &#x2F;*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*&#x2F;</span><br><span class="line">    static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 等待状态，取值范围，-3，-2，-1，0，1</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev; &#x2F;&#x2F; 前驱结点</span><br><span class="line">    volatile Node next; &#x2F;&#x2F; 后继结点</span><br><span class="line">    volatile Thread thread; &#x2F;&#x2F; 结点对应的线程</span><br><span class="line">    Node nextWaiter; &#x2F;&#x2F; 等待队列里下一个等待条件的结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断共享模式的方法</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">        this.nextWaiter &#x3D; mode;</span><br><span class="line">        this.thread &#x3D; thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其它方法忽略，可以参考具体的源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS里面的addWaiter私有方法</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用了Node的这个构造函数</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 其它代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。</p>
<h3 id="AQS的主要方法源码解析"><a href="#AQS的主要方法源码解析" class="headerlink" title="AQS的主要方法源码解析"></a>AQS的主要方法源码解析</h3><h4 id="使用模版方法定好算法骨架"><a href="#使用模版方法定好算法骨架" class="headerlink" title="使用模版方法定好算法骨架"></a>使用模版方法定好算法骨架</h4><p>AQS的设计是基于模板方法模式的，AQS主要定义了下面几个模版方法来获取资源：</p>
<ul>
<li>acquire ：独占模式，不可中断</li>
<li>acquireInterruptibly：独占模式，可中断（在线程中断时可能会抛出InterruptedException）</li>
<li>acquireShared：共享模式，不可中断</li>
<li>acquireSharedInterruptibly：共享模式，可中断 （在线程中断时可能会抛出InterruptedException）</li>
</ul>
<p>下面以 acquire 为例看下AQS的模版方法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取独占资源</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自旋不间断的从等待队列用头节点尝试获取资源（独占方式）</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;留给子类去实现</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">  throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，AQS 已经定义好对应的获取锁的代码模版(算法骨架)，子类可以根据需要去实现对应的方法即可，比如 Semaphore 只需要实现 tryAcquire 即可。通过使用模版方法，让AQS实现基本功能的同时又保持了良好的扩展性。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;留给子类去实现</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">      throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的方法（似的用法在 AbstractList的addall实现。提供默认的方法method1…method4方法，每个方法直接抛出异常，使用模板方法的时候强制重写用到的method方法，用不到的method不用重写。）</p>
<p>AQS 预留给子类进行扩展的方法主要有下面几个：</p>
<ul>
<li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
</ul>
<p>子类根据需要去实现即可。</p>
<h4 id="以独占方式获取资源为例"><a href="#以独占方式获取资源为例" class="headerlink" title="以独占方式获取资源为例"></a>以独占方式获取资源为例</h4><p><strong>AQS获取资源的流程：</strong><br><img src="/images/aqs03.jpg" alt="a7f37bf6e341e74f6c60d06c511aa2ca.png"></p>
<p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p>
<p>如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 生成该线程对应的Node节点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 将Node插入队列中</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F; 使用CAS尝试，如果成功就返回</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自旋CAS插入等待队列</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p>
<p>现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 拿到资源后，将head指向该结点。</span><br><span class="line">                &#x2F;&#x2F; 所以head所指的结点，就是当前获取到资源的那个结点或null。</span><br><span class="line">                setHead(node); </span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果自己可以休息了，就进入waiting状态，直到被unpark()</span><br><span class="line">            &#x2F;&#x2F;parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())   </span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的。</p>
<h4 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果状态是负数，尝试把它设置为0</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    &#x2F;&#x2F; 得到头结点的后继结点head.next</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    &#x2F;&#x2F; 如果这个后继结点为空或者状态大于0</span><br><span class="line">    &#x2F;&#x2F; 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 等待队列中所有还有用的结点，都向前移动</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果后继结点不为空，</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h2><p>我们常用到的通信工具类主要都是依靠借助AQS实现的（如semaphore、CountDownLatch、CyclicBarrier），实现的方式就是前面所说的根据需要去实现AQS预留的一些拓展方法：</p>
<p>AQS 预留给子类进行扩展的方法主要有下面几个：</p>
<ul>
<li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
</ul>
<p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p>
<p><img src="/images/aqs33.jpg" alt="4d7f25b785c31cfd82f66d85270a98be.png"></p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><h4 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h4><p>Java提供了经典信号量Semaphore的实现，它通过控制一定数量的许可（permit）的方式，来达到限制通用资源访问的目的。Semaphore往往用于资源有限的场景中，用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。例如：控制并发的线程数。</p>
<p>可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>比如：控制并发的线程数</p>
<p>比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。</p>
<p>比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Semaphore是通过一个计数器(记录许可证的数量)来实现的：<br>1.线程通过acquire()方法获取许可证(计数器的值减1)，只有获取到许可证才可以继续执行下去，否则阻塞当前线程。<br>2.线程通过release()方法归还许可证(计数器的值加1)。<br>3.如果许可证减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p>
<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acquire()  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line"></span><br><span class="line">acquire(int permits)  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断、或超时之前线程一直处于阻塞状态。</span><br><span class="line">    </span><br><span class="line">acquireUninterruptibly() </span><br><span class="line">获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。</span><br><span class="line">    </span><br><span class="line">tryAcquire()</span><br><span class="line">尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。</span><br><span class="line"></span><br><span class="line">tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。</span><br><span class="line"></span><br><span class="line">release()</span><br><span class="line">释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br><span class="line"></span><br><span class="line">hasQueuedThreads()</span><br><span class="line">等待队列里是否还存在等待线程。</span><br><span class="line"></span><br><span class="line">getQueueLength()</span><br><span class="line">获取等待队列里阻塞的线程数。</span><br><span class="line"></span><br><span class="line">drainPermits()</span><br><span class="line">清空令牌把可用令牌数置为0，返回清空令牌的数量。</span><br><span class="line">The </span><br><span class="line">availablePermits()</span><br><span class="line">返回可用的令牌数量。</span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1、假如有一个落魄的停车场只能容纳3辆车。<br>2、当一辆车进入停车场后，显示牌的剩余车位数 -1.<br>3、每有一辆车驶出停车场后，显示牌的剩余车位 +1。<br>4、停车场剩余车位不足时，车辆只能在外面等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    static class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private int value;</span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        public MyThread(int value, Semaphore semaphore) &#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.semaphore &#x3D; semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire(); &#x2F;&#x2F; 获取permit</span><br><span class="line"></span><br><span class="line">                System.out.println(String.format(&quot;车辆 粤A***%d 驶入, 还剩%d个车位，还有%d个车辆在等待&quot;,</span><br><span class="line">                        value, semaphore.availablePermits(), semaphore.getQueueLength()));</span><br><span class="line">                &#x2F;&#x2F; 睡眠随机时间，打乱释放顺序</span><br><span class="line">                Random random &#x3D; new Random();</span><br><span class="line">                Thread.sleep(random.nextInt(1000));</span><br><span class="line">                System.out.println(String.format(&quot;车辆 粤A%d 已经驶出&quot;, value));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally&#123;</span><br><span class="line">                semaphore.release(); &#x2F;&#x2F; 释放permit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(3);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(new MyThread(i, semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/images/aqs04.jpg" alt="7edc671804e6e24a7bdde6803dc0b005.png"></p>
<p>结果分析：最开始是A<strong><em>3, A</em></strong>0, A<strong><em>4 这辆车获得了资源车位，而其它车辆进入了等待队列。然后当A</em></strong>0辆驶出释放车位后，在排队的车辆粤A***2才得以获取了刚释放的车位。</p>
<p>总结：Semaphore往往用于资源有限的场景中，去限制线程的数量。最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;非公平的构造函数</span><br><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过fair参数决定公平性</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Semaphore有两个构造函数：</p>
<ul>
<li><p>参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。</p>
</li>
<li><p>fair，用于指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列排队。</p>
</li>
</ul>
<p>acquire源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">        FairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                if (hasQueuedPredecessors())</span><br><span class="line">                    return -1;</span><br><span class="line">                int available &#x3D; getState();</span><br><span class="line">                int remaining &#x3D; available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，如果remaining &lt;0 即获取许可后，许可数小于0，则获取失败，在doAcquireSharedInterruptibly方法中线程会将自身阻塞，然后入列。</p>
<p>release源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();</span><br><span class="line">        int next &#x3D; current + releases;</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow</span><br><span class="line">           throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看出释放许可就是将AQS中state的值加1。然后通过doReleaseShared唤醒等待队列的第一个节点。可以看出Semaphore使用的是AQS的共享模式，等待队列中的第一个节点，如果第一个节点成功获取许可，又会唤醒下一个节点，以此类推。</p>
<h3 id="CountDownLatch（倒计数门闸锁）"><a href="#CountDownLatch（倒计数门闸锁）" class="headerlink" title="CountDownLatch（倒计数门闸锁）"></a>CountDownLatch（倒计数门闸锁）</h3><h4 id="功能概述-1"><a href="#功能概述-1" class="headerlink" title="功能概述"></a>功能概述</h4><p>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。</p>
<p>CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>主任务开始之前的一些前期准备工作：<br>在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等</p>
<p>倒数计时器：<br>比如：一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。 只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。<br>它可以使得点火线程，等待所有检查线程全部完工后，再执行</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为需要等待线程的数量。</p>
<ul>
<li>主线程调用CountDownLatch的await()方法会阻塞当前线程(即:主线程在闭锁上等待)，直到计数器的值为0</li>
<li>当一个工作线程完成了自己的任务后，调用CountDownLatch的countDown()方法，计数器的值就会减1。</li>
<li>当计数器值为0时，说明所有的工作线程都执行完了，此时，在闭锁上等待的主线程就可以恢复执行任务。</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p> 使用 CountDownLatch实现在游戏开始前的前置任务，任务完成后游戏自动开始，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，游戏才开始</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义前置任务线程</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, CountDownLatch countDownLatch) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Random random &#x3D; new Random();</span><br><span class="line">                Thread.sleep(random.nextInt(1000));</span><br><span class="line">                System.out.println(task + &quot; - 任务完成&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 假设有三个模块需要加载</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 主任务</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;等待数据加载...&quot;);</span><br><span class="line">                System.out.println(String.format(&quot;还有%d个前置任务&quot;, countDownLatch.getCount()));</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(&quot;数据加载完成，正式开始游戏！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 前置任务</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, countDownLatch)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, countDownLatch)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/images/aqs05.jpg" alt="2e7ccffac954ad808ddd0725b65bfaff.png"></p>
<p>总结：CountDownLatch这个类的作用是，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。比如某个线程A等待若干个其他线程执行完任务之后，它才执行。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; 构造方法：</span><br><span class="line">public CountDownLatch(int count)</span><br><span class="line"></span><br><span class="line">public void await() &#x2F;&#x2F; 等待</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) &#x2F;&#x2F; 超时等待</span><br><span class="line">public void countDown() &#x2F;&#x2F; count - 1</span><br><span class="line">public long getCount() &#x2F;&#x2F; 获取当前还有多少count</span><br></pre></td></tr></table></figure>

<p>await方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg); &#x2F;&#x2F;doAcquireSharedInterruptibly 主要实现线程的入列与阻塞</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>countDown方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared(); &#x2F;&#x2F;主要实现唤醒第一个节点，第一个节点有会唤醒第二个节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier-（可重用的倒计数栅栏）"><a href="#CyclicBarrier-（可重用的倒计数栅栏）" class="headerlink" title="CyclicBarrier （可重用的倒计数栅栏）"></a>CyclicBarrier （可重用的倒计数栅栏）</h3><h4 id="功能概述-2"><a href="#功能概述-2" class="headerlink" title="功能概述"></a>功能概述</h4><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>和CountDownLatch相似，也是等待某些线程都做完以后再执行。</p>
<p>与CountDownLatch区别是：<br>前面提到了CountDownLatch一旦计数值count被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障，使计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批1 0个线程后，计数器就会归零，然后接着凑齐下一批10个线程。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>CyclicBarrier：一组线程互相等待，当它们都达到各自await()指定的barrier时，它们再同时继续执行各自下面的代码。</p>
<p>经典使用场景是公交发车，比如每辆公交车只要上满 4 个人就发车，后面来的人都会排队依次遵循相应的标准。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量,在CyclicBarrier的内部定义了一个Lock对象（使用ReentrantLock来实现的），每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待。如果是，执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回。</p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>案例一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    static class TaskThread extends Thread &#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        public TaskThread(CyclicBarrier barrier) &#123;</span><br><span class="line">            this.barrier &#x3D; barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 到达栅栏 A 就位&quot;);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 走出栅栏 A&quot;);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 到达栅栏 B&quot;);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(&quot;选手&quot;+getName() + &quot; 走出栅栏 B&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int threadNum &#x3D; 3;</span><br><span class="line">        CyclicBarrier barrier &#x3D; new CyclicBarrier(threadNum, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 人员就位到齐设备自动打开栅栏&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            new TaskThread(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/images/aqs06.jpg" alt="283e5359775239b91165d4c52187cc04.png"></p>
<p>结果分析：<br>一开始选手到达栅栏A后会被阻塞，待选手都到齐后，栅栏A会自动打开，所有选手同时执行 barrier.await() 的动作，然后优先到达栅栏B后又会被阻塞，待选手都到达栅栏B后，栅栏B会自动打开，所有选手同时执行后面的动作</p>
<p>案例二：如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; 假设总共三个关卡</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Random random &#x3D; new Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                    System.out.println(String.format(&quot;关卡%d的任务%s完成&quot;, i, task));</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                cyclicBarrier.reset(); &#x2F;&#x2F; 重置屏障</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;本关卡所有前置任务完成，开始游戏...&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, cyclicBarrier)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/aqs07.jpg" alt="b24501a2fa80be6bc622f7485fc85dfa.png"></p>
<p>前面提到了CountDownLatch一旦计数值count被降为0后，就不能再重新设置了，它只能起一次“屏障”的作用。而CyclicBarrier拥有CountDownLatch的所有功能，还可以使用reset()方法重置屏障。</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br><span class="line">public int getParties() &#123;</span><br><span class="line">    return parties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction这个Runnable对象，方便处理更复杂的业务场景。</p>
<p>await源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); &#x2F;&#x2F; cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dowait源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        final Generation g &#x3D; generation;</span><br><span class="line"> </span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int index &#x3D; --count;</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; tripped</span><br><span class="line">            boolean ranAction &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command &#x3D; barrierCommand;</span><br><span class="line">                if (command !&#x3D; null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction &#x3D; true;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos &#x3D; trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not</span><br><span class="line">                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to</span><br><span class="line">                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">            if (g !&#x3D; generation)</span><br><span class="line">                return index;</span><br><span class="line"> </span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当最后一个线程到达屏障点，也就是执行dowait方法时，会在return 0 返回之前调用finally块中的breakBarrier方法。</p>
<p>breakBarrier源代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken &#x3D; true;</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CycliBarrier对象可以重复使用，重用之前应当调用CyclicBarrier对象的reset方法。<br>reset源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reset() &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        breakBarrier();   &#x2F;&#x2F; break the current generation</span><br><span class="line">        nextGeneration(); &#x2F;&#x2F; start a new generation</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结对比Semaphore、CountDownLatch、CyclicBarrier"><a href="#总结对比Semaphore、CountDownLatch、CyclicBarrier" class="headerlink" title="总结对比Semaphore、CountDownLatch、CyclicBarrier"></a>总结对比Semaphore、CountDownLatch、CyclicBarrier</h3><ul>
<li><p>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
</li>
<li><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待。CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用。</p>
</li>
<li><p>CyclicBarrier和CoutDownLatch的底层实现也存在一点区别，CountDownLatch底层是直接通过组合一个继承了AQS的同步组件来实现的，而CyclicBarrier并没有直接借助AQS的同步组件，而是通过组合ReentrantLock这把锁来实现的（ReentrantLock的底层实现依然使用的AQS来实现的，归根结底，CyclicBarrier的底层实现也是AQS）。<br>由于CyclicBarrier是使用ReentrantLock来实现的，因此它有个属性是lock。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/98593407" target="_blank" rel="noopener">Semaphore 使用及原理</a><br><a href="https://www.cnblogs.com/nullzx/p/5270233.html" target="_blank" rel="noopener">Java并发包中Semaphore的工作原理、源码分析及使用示例</a><br><a href="http://concurrent.redspider.group/article/02/10.html" target="_blank" rel="noopener">CAS与原子操作</a><br><a href="http://concurrent.redspider.group/article/03/17.html" target="_blank" rel="noopener">通信工具类</a><br><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></p>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Java多线程-ThreadPoolExecutor</title>
    <url>/2020/11/13/concurrent-thread-pool-executor/</url>
    <content><![CDATA[<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><blockquote>
<p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
</blockquote>
<p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<a id="more"></a>


<h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="方式一：通过-Executor-框架的工具类-Executors-来实现："><a href="#方式一：通过-Executor-框架的工具类-Executors-来实现：" class="headerlink" title="方式一：通过 Executor 框架的工具类 Executors 来实现："></a>方式一：通过 Executor 框架的工具类 Executors 来实现：</h3><p>主要是通过下面个方法：</p>
<ul>
<li><p>newFixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li><p>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
</li>
<li><p>newCachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
</li>
<li><p>newScheduledThreadPool：调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p>
</li>
</ul>
<h3 id="方式二：直接通过-ThreadPoolExecutor-来实现-（推荐使用这种）"><a href="#方式二：直接通过-ThreadPoolExecutor-来实现-（推荐使用这种）" class="headerlink" title="方式二：直接通过 ThreadPoolExecutor 来实现 （推荐使用这种）"></a>方式二：直接通过 ThreadPoolExecutor 来实现 （推荐使用这种）</h3><p><img src="/images/tp01.jpg" alt="59cd25bb4a864c8906c0b85a74dafbba.jpeg"></p>
<h3 id="《阿里-Java-开发手册》中关于线程以及线程池的使用有两个强制建议："><a href="#《阿里-Java-开发手册》中关于线程以及线程池的使用有两个强制建议：" class="headerlink" title="《阿里 Java 开发手册》中关于线程以及线程池的使用有两个强制建议："></a>《阿里 Java 开发手册》中关于线程以及线程池的使用有两个强制建议：</h3><ul>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li>
<li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</li>
</ul>
<p><img src="/images/tp02.jpg" alt="10e9feb4c6cddfcee5cd9cc09e3f1951.png"></p>
<p><strong>我们在项目中最好还是直接ThreadPoolExecutor，并且 Executors 也是在ThreadPoolExecutor 的基础上做了一层封装，所以很有必要学习下 ThreadPoolExecutor 的工作原理以及几个重要的参数设置。</strong></p>
<h2 id="ThreadPoolExecutor构造方法及几个重要参数"><a href="#ThreadPoolExecutor构造方法及几个重要参数" class="headerlink" title="ThreadPoolExecutor构造方法及几个重要参数"></a>ThreadPoolExecutor构造方法及几个重要参数</h2><p>一共有四个构造方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; 五个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-1</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-2</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 七个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>
<ul>
<li><p>int corePoolSize：该线程池中核心线程数最大值</p>
<blockquote>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>
</blockquote>
</li>
<li><p>int maximumPoolSize：该线程池中线程总数最大值</p>
<blockquote>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
</blockquote>
</li>
<li><p>long keepAliveTime：非核心线程闲置超时时长</p>
<blockquote>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p>
</blockquote>
</li>
<li><p>TimeUnit unit：keepAliveTime的单位</p>
<blockquote>
<p>TimeUnit是一个枚举类型 ，包括以下属性：<br>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000<br>MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</p>
</blockquote>
</li>
<li><p>BlockingQueue workQueue： 阻塞队列，维护着等待执行的 Runnable 任务对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用的几个阻塞队列：</span><br><span class="line"></span><br><span class="line">- LinkedBlockingQueue</span><br><span class="line">链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line"></span><br><span class="line">- ArrayBlockingQueue</span><br><span class="line">数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line"></span><br><span class="line">- SynchronousQueue</span><br><span class="line">同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line"></span><br><span class="line">- DelayQueue</span><br><span class="line">延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>还有两个非必须的参数:</p>
<ul>
<li><p>ThreadFactory threadFactory :<br>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略属性</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s &#x3D; System.getSecurityManager();</span><br><span class="line">        group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix &#x3D; &quot;pool-&quot; +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            &quot;-thread-&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RejectedExecutionHandler handler：饱和策略<br>拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</span><br><span class="line"></span><br><span class="line">- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</span><br></pre></td></tr></table></figure>
<p>当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。</p>
</li>
</ul>
<h2 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a>一个简单的线程池 Demo</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolExecutorDemo &#123;</span><br><span class="line">    private static final int CORE_POOL_SIZE &#x3D; 5;</span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 10;</span><br><span class="line">    private static final int QUEUE_CAPACITY &#x3D; 100;</span><br><span class="line">    private static final Long KEEP_ALIVE_TIME &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    static class MyRunnable implements Runnable &#123;</span><br><span class="line">        private String command;</span><br><span class="line">        public MyRunnable(String s) &#123;</span><br><span class="line">            this.command &#x3D; s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; Start. Time &#x3D; &quot; + new Date());</span><br><span class="line">            processCommand();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; End. Time &#x3D; &quot; + new Date());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void processCommand() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return this.command;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用阿里巴巴推荐的创建线程池的方式</span><br><span class="line">        &#x2F;&#x2F;通过ThreadPoolExecutor构造函数自定义参数创建</span><br><span class="line">        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">            Runnable worker &#x3D; new MyRunnable(&quot;&quot; + i);</span><br><span class="line">            &#x2F;&#x2F;执行Runnable</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;终止线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        while (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="/images/tp03.jpg" alt="3feae6853d5148f6246658398db6ce0a.png"></p>
<h2 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h2><p>处理任务的核心方法是execute，我们看看 JDK 1.8 源码中ThreadPoolExecutor是如何处理线程任务的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><br><span class="line">   private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK 1.8 </span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();   </span><br><span class="line">    int c &#x3D; ctl.get();&#x2F;&#x2F;&#x2F;&#x2F; ctl 中保存的线程池当前的一些状态信息</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       if (addWorker(command, true))</span><br><span class="line">           return;</span><br><span class="line">       c &#x3D; ctl.get(); </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 2.1 二次检查线程池的状态，如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            &#x2F;&#x2F; 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br><span class="line">    &#x2F;&#x2F; 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor execute的整个处理过程如下图所示：<br><img src="/images/tp04.jpg" alt="cfa38f8aebb0f43f2017e674077a219b.png"></p>
<p>总结一下处理流程有下面几个步骤：</p>
<ol>
<li><p>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。</p>
</li>
<li><p>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</p>
</li>
<li><p>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。</p>
</li>
<li><p>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.《并发编程的艺术》<br>2. <a href="http://concurrent.redspider.group/article/03/12.html" target="_blank" rel="noopener">线程池原理</a><br>3. <a href="https://blog.csdn.net/programmer_at/article/details/79799267" target="_blank" rel="noopener">java线程池实现原理与源码分析（jdk1.8）</a><br>4. <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br>5. <a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">聊聊并发（三）——JAVA线程池的分析和使用</a></p>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Java多线程-阻塞队列</title>
    <url>/2020/11/20/concurrent-blocking-queue/</url>
    <content><![CDATA[<h2 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h2><p>在生产者-消费者模式中，为了使生产者消费者解藕，需要一个存放元素的容器，使生产者可以只关心往队列里添加元素下，消费者只关系从队列中取出元素进程处理。</p>
<p>而且这个队列必须要满足两点：</p>
<ul>
<li>线程安全</li>
<li>缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者</li>
</ul>
<p>JDK 为此设计了 阻塞队列(BlockingQueue)，并提供了几个基于 BlockingQueue 接口 实现的一些线程安全的阻塞队列。</p>
<a id="more"></a>


<h2 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法:"></a>BlockingQueue的操作方法:</h2><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th>功能分类</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</p>
</li>
<li><p>返回特殊值：插入方法会返回是否成功，成功则返回 true。移除方法，则是从队列里拿出一个元素，如果没有则返回 null</p>
</li>
<li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到拿到数据，或者- 响应中断退出。当队列空时，消费者线程试图从队列里 take 元素，队列也会阻塞消费者线程，直到队列可用。</p>
</li>
<li><p>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</p>
</li>
</ul>
<p>需要特别注意的是：</p>
<ul>
<li>不能往阻塞队列中插入null,会抛出空指针异常。</li>
<li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li>
</ul>
<h2 id="JDK-提供的阻塞队列"><a href="#JDK-提供的阻塞队列" class="headerlink" title="JDK 提供的阻塞队列"></a>JDK 提供的阻塞队列</h2><p>JDK 定义了 BlockingQueue 接口，并在Java util.concurrent 下提供了一些实现类。</p>
<p><img src="/images/bq01.jpg" alt="0aa769cbe5c1e7beb7730c803df1285f.png"></p>
<p>JDK7 主要提供了 7 个阻塞队列，分别是：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
</ul>
<p>根据是否是有界，是否有加锁，数据结构，汇总表格如下：</p>
<table>
<thead>
<tr>
<th>阻塞队列</th>
<th>有界性</th>
<th>锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁(CAS实现)</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody></table>
<h2 id="阻塞队列的实现原理-以-ArrayBlockingQueue-为例子"><a href="#阻塞队列的实现原理-以-ArrayBlockingQueue-为例子" class="headerlink" title="阻塞队列的实现原理 以 ArrayBlockingQueue 为例子"></a>阻塞队列的实现原理 以 ArrayBlockingQueue 为例子</h2><p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p>
<p>构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    &#x2F;&#x2F;..省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">     &#x2F;&#x2F;..省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                      Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     &#x2F;&#x2F;..省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是非公平锁。Collection 可以传入最初包含的元素的集合。</p>
<p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器 Condition，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p>
<p>下面是初始化代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数据元素数组</span><br><span class="line">final Object[] items;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个待取出元素索引</span><br><span class="line">int takeIndex;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个待添加元素索引</span><br><span class="line">int putIndex;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;元素个数</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内部锁</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费者监视器 Condition for waiting takes </span><br><span class="line">private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产者监视器 Condition for waiting puts </span><br><span class="line">private final Condition notFull; </span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    this(capacity, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed)</span><br><span class="line"> * capacity and the specified access policy.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @param fair if &#123;@code true&#125; then queue accesses for threads blocked</span><br><span class="line"> *        on insertion or removal, are processed in FIFO order;</span><br><span class="line"> *        if &#123;@code false&#125; the access order is unspecified.</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items &#x3D; new Object[capacity];</span><br><span class="line">    lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">    notEmpty &#x3D; lock.newCondition();</span><br><span class="line">    notFull &#x3D;  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 操作的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    &#x2F;&#x2F; 1.自旋拿锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 2.判断队列是否满了</span><br><span class="line">        while (count &#x3D;&#x3D; items.length)</span><br><span class="line">            &#x2F;&#x2F; 2.1如果满了，阻塞该线程，并标记为notFull线程，</span><br><span class="line">            &#x2F;&#x2F; 等待notFull的唤醒，唤醒之后继续执行while循环。</span><br><span class="line">            notFull.await(); &#x2F;&#x2F;底层是通过LockSupport.park 调用 UNSAFE.park() 实现</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 3.如果没有满，则进入队列</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入队并通过 notEmpty.signal() 唤醒一个消费者线程</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; assert items[putIndex] &#x3D;&#x3D; null;</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    items[putIndex] &#x3D; x;</span><br><span class="line">    if (++putIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        putIndex &#x3D; 0;</span><br><span class="line">    count++;</span><br><span class="line">    &#x2F;&#x2F; 4 唤醒一个等待的线程</span><br><span class="line">    notEmpty.signal();  &#x2F;&#x2F;底层是通过LockSupport.unpark 调用 UNSAFE.unpark(thread) 实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结put的流程：</p>
<ol>
<li><p>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p>
</li>
<li><p>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</p>
</li>
<li><p>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p>
</li>
<li><p>唤醒一个标记为notEmpty（消费者）的线程。</p>
</li>
</ol>
<p>take操作的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">       &#x2F;&#x2F;用while 而不用 if 是为了唤醒后重新判断一次，避免count状态发生变化</span><br><span class="line">        while (count &#x3D;&#x3D; 0)       </span><br><span class="line">            notEmpty.await(); &#x2F;&#x2F;底层是通过LockSupport.park 调用 UNSAFE.park() 实现</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从队列取出一个元素并通过 notFull.signal 唤醒生产者线程</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; assert items[takeIndex] !&#x3D; null;</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x &#x3D; (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] &#x3D; null;</span><br><span class="line">    if (++takeIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        takeIndex &#x3D; 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs !&#x3D; null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); &#x2F;&#x2F;底层是通过LockSupport.unpark 调用 UNSAFE.unpark(thread) 实现</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p>
<ol>
<li><p>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p>
</li>
<li><p>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</p>
</li>
</ol>
<p>3.如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p>
<ol start="4">
<li>唤醒一个标记为notFull（生产者）的线程。</li>
</ol>
<p>需要注意：</p>
<ol>
<li><p>put和take操作都需要先获取锁，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</p>
</li>
<li><p>就算拿到锁了之后，也不一定会顺利进行put/take操作，需要判断队列是否可用（是否满/空），如果不可用，则会被阻塞，并释放锁。</p>
</li>
<li><p>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，依然需要拿到锁才能继续往下执行，否则，自旋拿锁</p>
</li>
<li><p>await 前面用while 而不用 if 是为了唤醒后重新判断一次，避免count状态发生变化。这里是有讲究的，因为这个线程被唤醒后条件里的值很可能已经改变了，不再满足了，如果用 if，线程唤醒后会根据程序计数器的记录直接执行if后面的逻辑，而用while 可以确保再判断一次。</p>
</li>
</ol>
<p>通过上面代码可以看到， put, take 内部是用在没有成功之前是会一直阻塞的。下面看下 offer 和 poll 对比下</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the tail of this queue if it is</span><br><span class="line"> * possible to do so immediately without exceeding the queue&#39;s capacity,</span><br><span class="line"> * returning &#123;@code true&#125; upon success and &#123;@code false&#125; if this queue</span><br><span class="line"> * is full.  This method is generally preferable to method &#123;@link #add&#125;,</span><br><span class="line"> * which can fail to insert an element only by throwing an exception.</span><br><span class="line"> *</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; items.length)</span><br><span class="line">            return false; </span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count &#x3D;&#x3D; 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可以看到 通过 offer 方法插入的话是会立马返回结果  true / false, 而通过 poll 从队列删除元素 成功会直接返回元素对象， 失败会返回 null.</p>
<h2 id="案例：实现一个简单的在生产者消费者模型"><a href="#案例：实现一个简单的在生产者消费者模型" class="headerlink" title="案例：实现一个简单的在生产者消费者模型"></a>案例：实现一个简单的在生产者消费者模型</h2><p>通过 ArrayBlockingQueue 实现一个最简单的在生产者-消费者模型：</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayBlockingQueueDemo &#123;</span><br><span class="line">    private int queueSize &#x3D; 10;</span><br><span class="line">    private ArrayBlockingQueue&lt;Integer&gt; queue &#x3D; new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayBlockingQueueDemo test &#x3D; new ArrayBlockingQueueDemo();</span><br><span class="line">        Producer producer &#x3D; test.new Producer();</span><br><span class="line">        Consumer consumer &#x3D; test.new Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void consume() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    Thread.sleep(new Random().nextInt(2000));</span><br><span class="line">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot; + queue.size() + &quot;个元素&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Producer extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void produce() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot; + (queueSize - queue.size()));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="/images/bq02.jpg" alt="157e3e8fd16022e3003be6f8e750f981.png"></p>
<h2 id="高并发下无界队列容易产生OOM问题"><a href="#高并发下无界队列容易产生OOM问题" class="headerlink" title="高并发下无界队列容易产生OOM问题"></a>高并发下无界队列容易产生OOM问题</h2><p>队列按实现可以分为有界队列，与无界队列。在高并发环境，生产者的生产速度往往比消费者速度快很多，如果使用无界队列，队列无限扩大，容易吃掉内存导致 OOM。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>案例：在高并发环境下使用无界队列 ConcurrentLinkedQueue，生产者速度比消费者速度快，导致OOM。用 Jprofiler 分析dump下来的内存镜像如下所示。</p>
<p><img src="/images/bq03.jpg" alt="5c104305c6715eb84ee00d4b51584101.png"></p>
<p>看下 ConcurrentLinkedQueue 的 offer 方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the tail of this queue.</span><br><span class="line"> * As the queue is unbounded, this method will never return &#123;@code false&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    for (Node&lt;E&gt; t &#x3D; tail, p &#x3D; t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q &#x3D; p.next;</span><br><span class="line">        if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; p is last node</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Successful CAS is the linearization point</span><br><span class="line">                &#x2F;&#x2F; for e to become an element of this queue,</span><br><span class="line">                &#x2F;&#x2F; and for newNode to become &quot;live&quot;.</span><br><span class="line">                if (p !&#x3D; t) &#x2F;&#x2F; hop two nodes at a time</span><br><span class="line">                    casTail(t, newNode);  &#x2F;&#x2F; Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p &#x3D;&#x3D; q)</span><br><span class="line">            &#x2F;&#x2F; We have fallen off list.  If tail is unchanged, it</span><br><span class="line">            &#x2F;&#x2F; will also be off-list, in which case we need to</span><br><span class="line">            &#x2F;&#x2F; jump to head, from which all live nodes are always</span><br><span class="line">            &#x2F;&#x2F; reachable.  Else the new tail is a better bet.</span><br><span class="line">            p &#x3D; (t !&#x3D; (t &#x3D; tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            &#x2F;&#x2F; Check for tail updates after two hops.</span><br><span class="line">            p &#x3D; (p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到由于是没有限制的，offer 的结果永远都是成功的，这样队列就会无限扩张而吃掉内存，导致OOM。</p>
<h3 id="在JDK提供的线程安全的内置队列分类"><a href="#在JDK提供的线程安全的内置队列分类" class="headerlink" title="在JDK提供的线程安全的内置队列分类"></a>在JDK提供的线程安全的内置队列分类</h3><table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>无锁(CAS实现)</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁(CAS实现)</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody></table>
<p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p>
<p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p>
<p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。<strong>在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue</strong></p>
<p><strong>总结：在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列推荐使用在ArrayBlockingQueue</strong></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://concurrent.redspider.group/article/03/13.html" target="_blank" rel="noopener">阻塞队列</a><br>2.<a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">聊聊并发（七）——Java中的阻塞队列</a><br>3.<a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">高性能队列——Disruptor</a></p>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
