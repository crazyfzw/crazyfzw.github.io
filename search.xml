<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用Apktool获取别人APP中的图片及布局资源进行学习</title>
    <url>/2016/04/19/Apktool/</url>
    <content><![CDATA[<p>当我们看到一款UI布局很漂亮的APP，想要了解别人是怎么实现的时候，就可以通过Apktool工具来反编译别人的apk，从而获取图片及布局资源来进行学习。</p>
<p>其实我们下载到的Android 应用，是可以直接把后缀名改成zip的，然后解压zip就可以得到对应的文件目录</p>
<p><img src="/images/2016041901.jpg" alt=""></p>
<a id="more"></a>



<p>其中，res为所有资源文件，META-INF为签名信息，classes.dex为java源码编译后生成的字节码。</p>
<p>原以为这样轻松的就可以拿到别人的布局源码了，实则不然，点开res/layout下的一个布局文件看看</p>
<p><img src="/images/2016041902.jpg" alt=""></p>
<p>然后发现里面都是XML文件经过编译的机器码。那么怎么获取别人的布局文件呢?这时，Apktool就派上用场了。</p>
<h3 id="首先下载安装Apktool："><a href="#首先下载安装Apktool：" class="headerlink" title="首先下载安装Apktool："></a>首先下载安装Apktool：</h3><p>下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">http://ibotpeaches.github.io/Apktool/install/</a></p>
<p><img src="/images/2016041903.jpg" alt=""></p>
<h3 id="下载对应版本"><a href="#下载对应版本" class="headerlink" title="下载对应版本"></a>下载对应版本</h3><p><em>1.</em> 将wrapper script右键选择连接另存为得到apktool.bat文件， </p>
<ol start="2">
<li><p>在 <a href="https://bitbucket.org/iBotPeaches/apktool/downloads" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads</a><br>下载最新版本的apktool.jar包如现在最新的apktool_2.1.0.jar，并删除版本号重名名为apktool.jar</p>
</li>
<li><p>将apktool.bat、apktool.jar、及想要编译的apk文件放在同一文件夹下</p>
</li>
<li><p>通过cmd进入对应目录运行apktool.bat  d -f [apk文件 ]  [输出文件夹]就可以得到相应的布局资源文件了，截图如下</p>
</li>
</ol>
<p><img src="/images/2016041904.jpg" alt=""></p>
<p><img src="/images/2016041905.jpg" alt=""></p>
<p>这时打开res下的文件目录会发现有很多abc及notfication开头的文件，这些文件是自动生成的，并不是开发者真正写的布局文件，我们需要看的是其他xml文件,如黄色部分。</p>
<p><img src="/images/2016041906.jpg" alt=""></p>
<p>点开就可以看到相应的xml布局源码了</p>
<p><img src="/images/2016041907.jpg" alt=""></p>
<p>如果想要看别人java源码，学习别人功能的实现的话，就要用到dex2jar及jd-gui了，</p>
<p>其中dex2jar可以将apk改成zip加压后得到的classes.dex文件反编译成jar文件。</p>
<p>jd-gui：可以查看dex2jar转换出来的jar文件，就是我们想要的java源码了。</p>
<p>想看详细用法的可以参考：<a href="http://blog.csdn.net/ithomer/article/details/6727581" target="_blank" rel="noopener">Android APK反编译详解</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Apktool</tag>
        <tag>反编译</tag>
        <tag>apktool.jar</tag>
        <tag>apktool.bat</tag>
        <tag>获取APP的布局文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Material Design之利用CollapsingToolbarLayout轻松实现知乎日报新闻详情页顶部效果（带banner的toolbar伸缩折叠效果）</title>
    <url>/2016/05/07/CollapsingToolbarLayout/</url>
    <content><![CDATA[<p>我们都知道CoordinatorLayout+AppBarLayout可以轻松实现滚动隐藏ToolBar的效果，今天我要写的是CollapsingToolbarLayout+CoordinatorLayout+AppBarLayout实现带Banner的Toolbar折叠效果————向上滚动时，Banner会随着滚动手势向上收缩至隐藏，Banner上的文字（实际上是CollapsingToolbarLayout上的文字）会逐渐缩小最后显示在Toolbar上，向下滚动时，Banner会逐渐显示并还原为原来大小，同时文字也会最近变大重回原来的位置。</p>
<a id="more"></a>


<p>知乎日报新闻详情页就用了这种效果，那赶紧看下面Gif效果图吧：</p>
<p><img src="/images/2016050701.gif" alt=""></p>
<p><strong>实现方法：</strong></p>
<h2 id="1-布局xml："><a href="#1-布局xml：" class="headerlink" title="1.布局xml："></a>1.布局xml：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"256dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar_layout"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:contentScrim</span>=<span class="string">"@color/toolbarcolor"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:expandedTitleMarginStart</span>=<span class="string">"38dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:src</span>=<span class="string">"@drawable/skill"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseParallaxMultiplier</span>=<span class="string">"0.7"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v4.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scrollbars</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/webview"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span><span class="tag">&lt;/<span class="name">WebView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.v4.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>CollapsingToolbarLayout中的属性：</strong></p>
<p><strong>A：contentScrim</strong> - 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。</p>
<p><strong>B：expandedTitleMarginStart</strong> - 设置扩张时候(还没有收缩时)title与左边的距离。</p>
<p><strong>C：layout_scrollFlags:设置滚动表现：</strong></p>
<ul>
<li>1) Scroll, 表示向下滚动列表时候,CollapsingToolbarLayout会滚出屏幕并且消失</li>
<li>2) exitUntilCollapsed, 表示这个layout会一直滚动离开屏幕范围,直到它收折成它的最小高度.</li>
<li>3) enterAlways: 一旦向上滚动这个view就可见。</li>
<li>4) enterAlwaysCollapsed: 这个flag定义的是已经消失之后何时再次显示。假设你定义了一个最小高度（minHeight）同时enterAlways也定义了， 那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。  </li>
</ul>
<p><strong>ImageView及Toolbar中的属性：</strong></p>
<p>A: layout_collapseMode=”parallax”,这是控制滚出屏幕范围的效果的</p>
<ul>
<li><p>1) pin,确保Toolbar在view折叠的时候仍然被固定在屏幕的顶部。</p>
</li>
<li><p>2) parallax,设置为这个模式时，在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果, 通常和layout_collapseParallaxMultiplier(设置视差因子，值为0~1)搭配使用。</p>
</li>
</ul>
<h2 id="2-主要java代码："><a href="#2-主要java代码：" class="headerlink" title="2.主要java代码："></a>2.主要java代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line">        getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">        toolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                onBackPressed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CollapsingToolbarLayout必须把title设置到CollapsingToolbarLayout上，设置到Toolbar上则不会显示</span></span><br><span class="line">        CollapsingToolbarLayout mCollapsingToolbarLayout = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar_layout);</span><br><span class="line">        mCollapsingToolbarLayout.setTitle(<span class="string">"Bar Brother 徒手健身"</span>);</span><br><span class="line">        <span class="comment">//通过CollapsingToolbarLayout修改字体颜色</span></span><br><span class="line">        mCollapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);<span class="comment">//设置还没收缩时状态下字体颜色</span></span><br><span class="line">        mCollapsingToolbarLayout.setCollapsedTitleTextColor(Color.WHITE);<span class="comment">//设置收缩后Toolbar上字体的颜色</span></span><br><span class="line">        <span class="comment">//toolbar navigationicon 改变返回按钮颜色</span></span><br><span class="line">        <span class="keyword">final</span> Drawable upArrow = getResources().getDrawable(R.drawable.abc_ic_ab_back_mtrl_am_alpha);</span><br><span class="line">        upArrow.setColorFilter(getResources().getColor(R.color.white), PorterDuff.Mode.SRC_ATOP);</span><br><span class="line">        getSupportActionBar().setHomeAsUpIndicator(upArrow);</span><br><span class="line"></span><br><span class="line">        mWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">        <span class="comment">//设置支持js</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//!!设置跳转的页面始终在当前WebView打开</span></span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</span><br><span class="line">        mWebView.loadUrl(<span class="string">"https://"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>源码可在我的Github下载：<a href="https://github.com/crazyfzw/CollapsingToolbarLayoutDemo" target="_blank" rel="noopener">https://github.com/crazyfzw/CollapsingToolbarLayoutDemo</a></p>
<p>参考：</p>
<p>   <a href="http://developer.android.com/intl/ko/reference/android/support/design/widget/CollapsingToolbarLayout.html" target="_blank" rel="noopener">http://developer.android.com/intl/ko/reference/android/support/design/widget/CollapsingToolbarLayout.html</a></p>
<p>   <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html</a></p>
<p>推荐：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2015/0531/2958.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/developer/2015/0531/2958.html</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>CollapsingToolbarLay</tag>
        <tag>可伸缩折叠的Toolbar</tag>
        <tag>Collapsing</tag>
        <tag>Toolbar</tag>
        <tag>layout_collapseMode</tag>
      </tags>
  </entry>
  <entry>
    <title>DrawerLayout+NavigationView打造Google原生Material Design风格侧滑菜单</title>
    <url>/2016/05/30/DrawerLayout-NavigationView/</url>
    <content><![CDATA[<p>最近做的一个项目需要用到侧滑菜单，在GitHub上找了下，有个很热门的drawer Library，<a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="noopener">https://github.com/mikepenz/MaterialDrawer</a>，用起来挺方便的，使用方法也详细。但还是想自己动手写一个，因为Google在SDK中增加了DrawerLayout，NavigationView，实现侧滑菜单还是挺方便的。</p>
<a id="more"></a>


<p>先看下gif效果图：</p>
<p><img src="/images/2016053001.gif" alt=""></p>
<p><strong>实现步骤：</strong></p>
<h2 id="1-写主布局-activity-main-xml"><a href="#1-写主布局-activity-main-xml" class="headerlink" title="1.写主布局 activity_main.xml"></a>1.写主布局 activity_main.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_drawerlayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第一个位置 主界面内容 main content--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/content_main"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第二个位置  来放Drawerlayout中的内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_navigationview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:itemTextColor</span>=<span class="string">"@color/selector_nav_menu_textcolor"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"left"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里注意一下，主界面的内容一定要放在DrawerLayout的第一个位置，第二个位置应该放置的是Drawer的菜单内容，可以有多种方式自定义，我这里使用的是NavigationView。</p>
<p><strong>NavigationView有几个属性需要注意的：</strong></p>
<ul>
<li><p>app:headerLayout：    可以指定自己定义的布局作为NavigationView的头部</p>
</li>
<li><p>app:menu：            指定Nav中的Menu菜单项布局</p>
</li>
<li><p>app:itemTextColor：   用来设置Nav中，menu item的颜色选择器。在选择器中可以定义文字被选中状态的颜色以及正常状态下的颜色</p>
</li>
</ul>
<p>如本例的  selector_nav_menu_textcolor.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- pink theme--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@color/main_pink_light"</span> <span class="attr">android:state_checked</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@color/main_black_grey"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义Drawer的头部，即NavigationView的header，-eg本例-navigation-header-xml"><a href="#2-自定义Drawer的头部，即NavigationView的header，-eg本例-navigation-header-xml" class="headerlink" title="2.自定义Drawer的头部，即NavigationView的header， eg本例 navigation_header.xml"></a>2.自定义Drawer的头部，即NavigationView的header， eg本例 navigation_header.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"220dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/nav_header"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.crazyfzw.materialdrawer.CircleImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userAvater"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:civ_border_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:civ_border_color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userName"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"4dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/text__white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"crazyfzw"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/current_userSignature"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"5dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/text__white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"野蛮体魄"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面用到的CircleImageView是GitHub上一个热门的开源控件，这里给出地址：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a>，当然你也可以extend ImageView去自定义</p>
<h2 id="3-自定义Drawer的菜单选项，即NavigationView中的menu，eg本例-menu-menu-navigation-xml"><a href="#3-自定义Drawer的菜单选项，即NavigationView中的menu，eg本例-menu-menu-navigation-xml" class="headerlink" title="3.自定义Drawer的菜单选项，即NavigationView中的menu，eg本例 menu/menu_navigation.xml"></a>3.自定义Drawer的菜单选项，即NavigationView中的menu，eg本例 menu/menu_navigation.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group1"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_home_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_home"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_home"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_file_download_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_offline_manager"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_offline_manager"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group2"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_star_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_favorites"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_favorites"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_history_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_histories"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_histories"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_people_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_following"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_following"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_account_balance_wallet_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_pay"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_growth_process"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@+id/nav_group3"</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_color_lens_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_theme"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orderInCategory</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/title_theme_store"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_black_24dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/nav_settings"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orderInCategory</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/nav_settings"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:checkable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这里的group用来分组，android:checkableBehavior=”single”用来指明选项菜单只能单选。android:checkable=”true”指定item项是否可选，图标的话，这里推荐使用google官方的 <a href="https://design.google.com/icons/" target="_blank" rel="noopener">Material icons</a></p>
<h2 id="4-最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码"><a href="#4-最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码" class="headerlink" title="4.最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码"></a>4.最后一步就是用java在activity中把自定义的布局添加进来并初始化DrawerLayout了，这里给出MainAtivity的主要代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">       setSupportActionBar(toolbar);</span><br><span class="line"></span><br><span class="line">       mDrawerLayout = (DrawerLayout) findViewById(R.id.id_drawerlayout);</span><br><span class="line">       mNavigationView = (NavigationView) findViewById(R.id.id_navigationview);</span><br><span class="line"></span><br><span class="line">       ActionBarDrawerToggle mActionBarDrawerToggle = <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, mDrawerLayout, toolbar, R.string.open, R.string.close);</span><br><span class="line">       mActionBarDrawerToggle.syncState();</span><br><span class="line">       mDrawerLayout.setDrawerListener(mActionBarDrawerToggle);</span><br><span class="line">       mNavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">       mNavigationView.inflateMenu(R.menu.menu_navigation);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置NavigationView中menu的item被选中后要执行的操作</span></span><br><span class="line">       onNavgationViewMenuItemSelected(mNavigationView);</span><br><span class="line"></span><br><span class="line">       View navheaderView = mNavigationView.getHeaderView(<span class="number">0</span>);  <span class="comment">//获取头部布局</span></span><br><span class="line"></span><br><span class="line">       currentUserAvater = (CircleImageView) navheaderView.findViewById(R.id.current_userAvater);</span><br><span class="line">       currentUserName = (TextView) navheaderView.findViewById(R.id.current_userName);</span><br><span class="line">       currentUserSignature = (TextView) navheaderView.findViewById(R.id.current_userSignature);</span><br><span class="line"></span><br><span class="line">       currentUserAvater.setImageResource(R.drawable.default_avater);</span><br><span class="line">       currentUserName.setText(<span class="string">"crazyfzw"</span>);</span><br><span class="line">       currentUserSignature.setText(<span class="string">"平静温和地前进"</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add item select listener</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mNav</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNavgationViewMenuItemSelected</span><span class="params">(NavigationView mNav)</span> </span>&#123;</span><br><span class="line">       mNav.setNavigationItemSelectedListener(<span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">               String msgString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">switch</span> (menuItem.getItemId()) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 在这里添加对应菜单选择后的事件处理，如</span></span><br><span class="line">                  <span class="comment">// case R.id.nav_menu_home:</span></span><br><span class="line">                  <span class="comment">//    msgString = (String) menuItem.getTitle();</span></span><br><span class="line">                  <span class="comment">//     break;</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Menu item点击后选中，并关闭Drawerlayout</span></span><br><span class="line">               menuItem.setChecked(<span class="keyword">true</span>);</span><br><span class="line">               mDrawerLayout.closeDrawers();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里我用的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">NavigationView.inflateMenu(R.menu.menu_navigation);</span><br></pre></td></tr></table></figure>
<p>来添加自定义的NavigationView头部，及菜单布局，当然，你也可以用上面题到的静态属性app:headerLayout：及app:menu：指定,上面代码中有个地方需要特别注意了，就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View navheaderView &#x3D; mNavigationView.getHeaderView(0);</span><br><span class="line">currentUserName &#x3D; (TextView) navheaderView.findViewById(R.id.current_userName);</span><br></pre></td></tr></table></figure>

<p>这里如果直接用findViewById()获取NavigationView的中的控件会出现空指针异常，如图：</p>
<p><img src="/images/2016053002.jpg" alt=""><br><img src="/images/2016053003.jpg" alt=""></p>
<p>因为在activity刚创建的时候，Dawer其实是没有打开的，所以布局没有初始化加载进来，这时去findViewById()自然会找不到了。解决的办法是通过NavigationView.getHeaderView(0);获取到navheaderView，然互在通过navheaderView.findViewById()就可以找到相应的空间了。</p>
<p>当然你也可以在在inflateHeaderView的同时取到这个navheaderView，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View navheaderView &#x3D; mNavigationView.inflateHeaderView(R.layout.navigation_header);</span><br><span class="line">currentUserName &#x3D; (TextView) navheaderView.findViewById(R.id.current_userName);</span><br></pre></td></tr></table></figure>


<p>本案例的源码可以到我的GitHub上下载或者Star： <a href="https://github.com/crazyfzw/MaterialDrawer" target="_blank" rel="noopener">https://github.com/crazyfzw/MaterialDrawer</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DrawerLayout</tag>
        <tag>NavigationView</tag>
        <tag>inflateHeaderView</tag>
        <tag>MaterialDrawer</tag>
        <tag>抽屉侧滑菜单</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储 1：数据库索引的原理及使用策略</title>
    <url>/2018/07/18/RDBMS-INDEX/</url>
    <content><![CDATA[<p>本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时最经常用到的索引。</p>
<a id="more"></a>

<h2 id="一、数据库索引的原理"><a href="#一、数据库索引的原理" class="headerlink" title="一、数据库索引的原理"></a>一、数据库索引的原理</h2><blockquote>
<p>这部分内容主要来源于互联网上关于索引的主流文章，本人在理解的基础上梳理整合成本部分内容，当是个人的一篇学习笔记，参考的文章可见参考文献一栏。</p>
</blockquote>
<h3 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助数据库高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>说白了，索引就是一种可以应用高效查询算法的数据结构。</p>
<p>之所以要建立索引，其实就是为了构建一种数据结构，然后可以在上面应用一种高效的查询算法，最终提高数据的查询速度。</p>
<p>所以在讲索引的数据结构之前不妨先了解下比较常见的查询算法及其所要求的特定数据结构。</p>
<h3 id="2-常见的查询算法"><a href="#2-常见的查询算法" class="headerlink" title="2. 常见的查询算法"></a>2. 常见的查询算法</h3><h4 id="2-1-顺序查找（linear-search-）"><a href="#2-1-顺序查找（linear-search-）" class="headerlink" title="2.1 顺序查找（linear search ）"></a>2.1 顺序查找（linear search ）</h4><p>最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量大时效率极低。 </p>
<p>数据结构：有序或无序队列 </p>
<p>复杂度：O(n) </p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-二分查找（binary-search）"><a href="#2-2-二分查找（binary-search）" class="headerlink" title="2.2 二分查找（binary search）"></a>2.2 二分查找（binary search）</h4><p>比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 </p>
<p>数据结构：有序数组 </p>
<p>复杂度：O(logn) </p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-二叉排序树查找"><a href="#2-3-二叉排序树查找" class="headerlink" title="2.3 二叉排序树查找"></a>2.3 二叉排序树查找</h4><p>二叉排序树的特点是：</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>它的左、右子树也分别为二叉排序树。</p>
<p>搜索的原理：</p>
<p>若b是空树，则搜索失败，否则;</p>
<p>若x等于b的根节点的数据域之值，则查找成功；否则：</p>
<p>若x小于b的根节点的数据域之值，则搜索左子树；否则：</p>
<p>查找右子树。</p>
<p>数据结构：二叉排序树 </p>
<p>时间复杂度： O(log2N)</p>
<h4 id="2-4-索引是为了应用某种高级查找算法而建立的一种数据结构："><a href="#2-4-索引是为了应用某种高级查找算法而建立的一种数据结构：" class="headerlink" title="2.4 索引是为了应用某种高级查找算法而建立的一种数据结构："></a>2.4 索引是为了应用某种高级查找算法而建立的一种数据结构：</h4><p>稍微分析以上查找算法会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上。但是数据库存储的数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h3 id="3-多叉平衡查找树（B-tree-和-B-Tree）"><a href="#3-多叉平衡查找树（B-tree-和-B-Tree）" class="headerlink" title="3. 多叉平衡查找树（B-tree 和 B+Tree）"></a>3. 多叉平衡查找树（B-tree 和 B+Tree）</h3><p>上面讲到了二叉树，它的搜索时间复杂度为O(log2N)，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p>
<h4 id="3-1-B-Tree"><a href="#3-1-B-Tree" class="headerlink" title="3.1 B-Tree"></a>3.1 B-Tree</h4><blockquote>
<p>具体讲解之前，有一点，再次强调下：B-树，也就是B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解，有人可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-tree指的就是B树。特此说明。</p>
</blockquote>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。</p>
<p>下图是一个B-Tree示例：</p>
<p><img src="/images/2018071801.png" alt="image"></p>
<p>那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">     <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     foreach(node.key)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">          <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">  &#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure>

<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，这也是索引会降低增删改数据性能的原因。</p>
<h4 id="3-2-B-Tree"><a href="#3-2-B-Tree" class="headerlink" title="3.2 B+Tree"></a>3.2 B+Tree</h4><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而 B 树的叶子节点并没有包括全部需要查找的信息)</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。所有的内节点点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的内节点也包含需要查找的有效信息)</p>
<p>下图是一个简单的B+Tree示意</p>
<p><img src="/images/2018071802.png" alt="image"></p>
<h3 id="4-为什么索引用B-Tree实现"><a href="#4-为什么索引用B-Tree实现" class="headerlink" title="4. 为什么索引用B+Tree实现"></a>4. 为什么索引用B+Tree实现</h3><p>这里必须强调的是，数据库索引实际上用的是带有顺序的B+Tree。在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 </p>
<p>如下图所示：</p>
<p><img src="/images/2018071803.png" alt="image"></p>
<p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能。如图如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？"><a href="#4-1-为什么索引采用B-Tree-B-Tree的性能会比采用红黑树好？" class="headerlink" title="4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？"></a>4.1 为什么索引采用B+Tree/B-Tree的性能会比采用红黑树好？</h4><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<h4 id="4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？"><a href="#4-2-为什么索引采用B-Tree的性能会比采用B-Tree好？" class="headerlink" title="4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？"></a>4.2 为什么索引采用B+Tree的性能会比采用B-Tree好？</h4><p>B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmax&#x3D;floor(pagesize&#x2F;(keysize+datasize+pointsize))</span><br></pre></td></tr></table></figure>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>因为B+Tree 的内节点只存储只存储key，不存储Data，所以出度越大，索引性能越好。</p>
<h3 id="5-B-Tree-的查找过程"><a href="#5-B-Tree-的查找过程" class="headerlink" title="5. B+Tree 的查找过程"></a>5. B+Tree 的查找过程</h3><p>B-树和B+树查找过程基本一致。</p>
<p>下面以 B+Tree 树的数据结构举例说下查找过程：</p>
<p><img src="/images/20180718.jpg" alt="image"></p>
<p>如上图 B + Tree 的数据结构。是由一个一个的磁盘块组成的树形结构，每个磁盘块由数据项和指针组成。所有的数据都是存放在叶子节点，非叶子节点不存放数据。</p>
<p><strong>查找过程：</strong><br>以磁盘块1为例，指针 P1 表示小于17的磁盘块，P2 表示在 17~35 之间的磁盘块，P3 则表示大于35的磁盘块。</p>
<p>比如要查找数据项99，首先将磁盘块1 load 到内存中，发生 1 次 IO。接着通过二分查找发现 99 大于 35，所以找到了 P3 指针。通过P3 指针发生第二次 IO 将磁盘块4加载到内存。再通过二分查找发现大于87，通过 P3 指针发生了第三次 IO 将磁盘块11 加载到内存。最后再通过一次二分查找找到了数据项99。</p>
<p>由此可见，如果一个几百万的数据查询只需要进行三次 IO 即可找到数据，那么整个效率将是非常高的。</p>
<p>观察树的结构，发现查询需要经历几次 IO 是由树的高度来决定的，而树的高度又由磁盘块，数据项的大小决定的。</p>
<p>磁盘块越大，数据项越小那么数的高度就越低。这也就是为什么索引字段要尽可能小的原因。</p>
<h3 id="6-MySQL索引实现"><a href="#6-MySQL索引实现" class="headerlink" title="6. MySQL索引实现"></a>6. MySQL索引实现</h3><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h4 id="6-1-MyISAM索引实现"><a href="#6-1-MyISAM索引实现" class="headerlink" title="6.1 MyISAM索引实现"></a>6.1 MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，这种索引方式称称为“非聚集索引”。</p>
<p>下图是MyISAM索引的原理图：</p>
<p><img src="/images/2018071804.png" alt="image"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/images/2018071805.png" alt="image"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h4 id="6-2-InnoDB索引实现"><a href="#6-2-InnoDB索引实现" class="headerlink" title="6.2 InnoDB索引实现"></a>6.2 InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。键值的逻辑顺序决定了表中相应行的物理顺序，这种索引方式称称为“聚集索引”。</p>
<p>如下图所示：<br><img src="/images/2018071806.png" alt="image"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="/images/2018071807.png" alt="image"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="7-聚集索引与非聚集索引的区别"><a href="#7-聚集索引与非聚集索引的区别" class="headerlink" title="7. 聚集索引与非聚集索引的区别"></a>7. 聚集索引与非聚集索引的区别</h3><p>前面已经通过MySQL索引实现中已经讲到InnoDB索引实现用的是“聚集索引”，而MyISAM索引实现的实现用的是“非聚集索引”，那么 聚集索引与非聚集索引到底有什么区别呢？</p>
<p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</strong></p>
<h4 id="7-1-聚集索引"><a href="#7-1-聚集索引" class="headerlink" title="7.1 聚集索引"></a>7.1 聚集索引</h4><p>聚集索引表记录的排列顺序与索引的排列顺序一致</p>
<p><strong>优点：</strong>查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。</p>
<p><strong>缺点：</strong>对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，从而降低了执行速度。</p>
<h4 id="7-2-非聚集索引"><a href="#7-2-非聚集索引" class="headerlink" title="7.2 非聚集索引"></a>7.2 非聚集索引</h4><p>叶节点的data域存放的是数据记录的地址。数据存储在一个地方，索引存储在另一个地方，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>
<p><strong>优点：</strong>对数据更新影响较小。</p>
<p><strong>缺点：</strong>聚集索引检索效率比聚集索引低,必须先查到查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>
<h4 id="7-3-如何选择使用聚集索引或非聚集索引（很重要）："><a href="#7-3-如何选择使用聚集索引或非聚集索引（很重要）：" class="headerlink" title="7.3 如何选择使用聚集索引或非聚集索引（很重要）："></a>7.3 如何选择使用聚集索引或非聚集索引（很重要）：</h4><table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody></table>
<h2 id="二、如何设计索引"><a href="#二、如何设计索引" class="headerlink" title="二、如何设计索引"></a>二、如何设计索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，数据库在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p>
<h3 id="1-一般两种情况下不建议建索引："><a href="#1-一般两种情况下不建议建索引：" class="headerlink" title="1. 一般两种情况下不建议建索引："></a>1. 一般两种情况下不建议建索引：</h3><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Index Selectivity &#x3D; 字段对应不重复的值 &#x2F; 表总记录数</span><br></pre></td></tr></table></figure>

<p>显然选择性的取值范围为(0, 1]，值越大，即选择性越高的索引价值越大，这是由B+Tree的性质决定的。</p>
<p>例如，可以应用求一个字段的Selectivity，判断是否有必要给这个这个字段加索引，以及</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0000 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<h3 id="2-设计索引一般需要考虑以下3点："><a href="#2-设计索引一般需要考虑以下3点：" class="headerlink" title="2. 设计索引一般需要考虑以下3点："></a>2. 设计索引一般需要考虑以下3点：</h3><ol>
<li>看数据量，根据记录数，看是否有建索引的必要；</li>
<li>根据计算字段的索引选择性判断给某个字段加索引是否比较有价值；</li>
<li>看能否使用前缀索引取代全列索引，综合考虑索引选择性与key的长度，做个折中，尽可能使得前缀索引的选择性接近全列索引，同时又减段索引key的长度，从而减少了索引文件的大小和维护开销。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM Table1;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引建上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Table1</span><br><span class="line">ADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM Table1 WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>有一点需要注意的是：前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h2 id="三、索引使用的注意事项-策略及优化"><a href="#三、索引使用的注意事项-策略及优化" class="headerlink" title="三、索引使用的注意事项(策略及优化)"></a>三、索引使用的注意事项(策略及优化)</h2><p>并不是建立索引就能显著提高查询速度，在索引的使用过程中，存在一些使用细节和注意事项，因为稍不留心，就可能导致在查询过程中索引失效。</p>
<p>一下列举一些需要注意的事项：</p>
<h3 id="1-不要在列上使用函数"><a href="#1-不要在列上使用函数" class="headerlink" title="1. 不要在列上使用函数"></a>1. 不要在列上使用函数</h3><p>不要在列上使用函数，这将导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where year(publish_time) &lt; 2018</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where publish_time &lt; &#39;2018-01-01&#39;</span><br></pre></td></tr></table></figure>


<h3 id="2-不要在列上进行计算"><a href="#2-不要在列上进行计算" class="headerlink" title="2. 不要在列上进行计算"></a>2. 不要在列上进行计算</h3><p>不要在列上进行运算，这也将导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where id &#x2F; 100 &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where id &#x3D; 1 * 100</span><br></pre></td></tr></table></figure>

<h3 id="3-尽量避免使用-或-not-in或-lt-gt-等否定操作符"><a href="#3-尽量避免使用-或-not-in或-lt-gt-等否定操作符" class="headerlink" title="3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符"></a>3. 尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</h3><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt;操作符，<br>这些负向查询也会导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where id not in (1,3,4);</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where id in (2,5,6);</span><br></pre></td></tr></table></figure>

<h3 id="4-尽量避免使用-or-来连接条件"><a href="#4-尽量避免使用-or-来连接条件" class="headerlink" title="4. 尽量避免使用 or 来连接条件"></a>4. 尽量避免使用 or 来连接条件</h3><p>应该尽量避免在 where 子句中使用 or来连接条件，因为这会导致索引失效而进行全表扫描。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id&#x3D; 1 or id &#x3D;2</span><br></pre></td></tr></table></figure>

<p>应改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from CRM_CUSTOMER_INFO where id in(1,2)</span><br></pre></td></tr></table></figure>

<h3 id="5-字段的默认值不要为-null"><a href="#5-字段的默认值不要为-null" class="headerlink" title="5. 字段的默认值不要为 null"></a>5. 字段的默认值不要为 null</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。</p>
<p>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p>
<h3 id="6-不要让数据库帮我们做隐式类型转换"><a href="#6-不要让数据库帮我们做隐式类型转换" class="headerlink" title="6. 不要让数据库帮我们做隐式类型转换"></a>6. 不要让数据库帮我们做隐式类型转换</h3><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where telno&#x3D;1888888888</span><br></pre></td></tr></table></figure>

<p>这样虽然可以查出数据，但是会导致全表扫描。</p>
<p>应改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from user where telno&#x3D;&#39;1888888888&#39;</span><br></pre></td></tr></table></figure>

<h3 id="7-前导模糊查询会导致索引失效"><a href="#7-前导模糊查询会导致索引失效" class="headerlink" title="7. 前导模糊查询会导致索引失效"></a>7. 前导模糊查询会导致索引失效</h3><p>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。</p>
<h3 id="8-数据区分不明显的不建议创建索引"><a href="#8-数据区分不明显的不建议创建索引" class="headerlink" title="8. 数据区分不明显的不建议创建索引"></a>8. 数据区分不明显的不建议创建索引</h3><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段</p>
<h3 id="9-可以用复合索引替代多个单列索引"><a href="#9-可以用复合索引替代多个单列索引" class="headerlink" title="9. 可以用复合索引替代多个单列索引"></a>9. 可以用复合索引替代多个单列索引</h3><p>MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。</p>
<p>假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：</p>
<p>select * from news where news_year = 2017 and news_month = 1<br>事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。</p>
<h3 id="10-覆盖索引的好处"><a href="#10-覆盖索引的好处" class="headerlink" title="10. 覆盖索引的好处"></a>10. 覆盖索引的好处</h3><p>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p>
<h3 id="11-范围查询对多列查询的影响"><a href="#11-范围查询对多列查询的影响" class="headerlink" title="11. 范围查询对多列查询的影响"></a>11. 范围查询对多列查询的影响</h3><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</p>
<p>举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：</p>
<p>select * from news where publish_time &gt;= ‘2017-01-02’ and publish_time &lt;= ‘2017-01-08’ and enable = 1<br>这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。</p>
<p>对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。</p>
<p>例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from news where news_weekth &#x3D; 1 and enable &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。</p>
<h3 id="12-复合索引（联合索引）"><a href="#12-复合索引（联合索引）" class="headerlink" title="12. 复合索引（联合索引）"></a>12. 复合索引（联合索引）</h3><p>首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：</p>
<p>第一个字段一定是有序的<br>当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>5</td>
</tr>
</tbody></table>
<p>其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。</p>
<h3 id="13-复合索引的最左前缀原理"><a href="#13-复合索引的最左前缀原理" class="headerlink" title="13. 复合索引的最左前缀原理"></a>13. 复合索引的最左前缀原理</h3><p>在复合索引的基础上，再来详细介绍一下联合索引的查询。还是复合索引中的例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：</p>
<p>以下的查询方式都可以用到索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where a&#x3D;1；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2；</span><br><span class="line">select * from table where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</span><br></pre></td></tr></table></figure>
<p>上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。</p>
<p>如果查询语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where a&#x3D;1 and c&#x3D;3； 那么只会用到索引a。</span><br></pre></td></tr></table></figure>

<p>如果查询语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and c&#x3D;3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。</span><br></pre></td></tr></table></figure>
<p>如果用到了最左前缀，但是顺序颠倒会用到索引吗？</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where b&#x3D;2 and a&#x3D;1；</span><br><span class="line">select * from table where b&#x3D;2 and a&#x3D;1 and c&#x3D;3；</span><br></pre></td></tr></table></figure>
<p>如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。</p>
<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1] MySQL索引背后的数据结构及算法原理 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>[2] 从B树、B+树、B* 树谈到 R树 <a href="https://blog.csdn.net/v_july_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6530142</a><br>[3] 聚集索引和非聚集索引 <a href="https://www.cnblogs.com/aspnethot/articles/1504082.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspnethot/articles/1504082.html</a><br>[4] 你知道数据库索引的工作原理吗？<a href="http://www.ituring.com.cn/article/986" target="_blank" rel="noopener">http://www.ituring.com.cn/article/986</a><br>[5] 如何设计索引 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/" target="_blank" rel="noopener">http://blog.720ui.com/2017/mysql_core_03_how_use_index/</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>索引原理</tag>
        <tag>数据库索引</tag>
        <tag>B+Tree</tag>
        <tag>B-Tree</tag>
        <tag>索引使用的注意事项</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView+SwipeRefreshLayout实现下拉刷新列表</title>
    <url>/2016/04/12/RecyclerView-SwipeRefreshLayout/</url>
    <content><![CDATA[<h2 id="一：RecyclerView的用法："><a href="#一：RecyclerView的用法：" class="headerlink" title="一：RecyclerView的用法："></a>一：RecyclerView的用法：</h2><p> <strong>RecyclerView是google在2014年I/O大会上提出新的用于取代ListView的组件，是 android-support-v7-21 版本中新增的一个 Widgets，它的灵活性与可替代性比listview更好。</strong></p>
<a id="more"></a>



<p> 使用 RecyclerView首先应该认识两个要点：</p>
<p><strong>1. Adapter：</strong>使用RecyclerView之前，需要继承RecyclerView.Adapter定义一个自己的适配器，作用是将数据与每一个item的界面进行绑定，注意，与ListView不同，这里不在是使用传统的ArrayAdapter、SimpleAdapter、BaseAdapter。</p>
<p><strong>2.LayoutManager：</strong> 控制每个Item项的布局显示。</p>
<p>目前SDK中提供了三种自带的LayoutManager:<br>LinearLayoutManager（可以实现垂直滚动的线性列表、水平线滚动性列表）<br>GridLayoutManager    （可以实现垂直Grid列表、水平线Grid列表列表）<br>StaggeredGridLayoutManager (可以实现瀑布流列表)</p>
<p>RecyclerView的详细用法可以参考：</p>
<p><a href="http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" target="_blank" rel="noopener">http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html</a></p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2004.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2004.html</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45059587</a></p>
<h2 id="二：SwipeRefreshLayout的用法："><a href="#二：SwipeRefreshLayout的用法：" class="headerlink" title="二：SwipeRefreshLayout的用法："></a>二：SwipeRefreshLayout的用法：</h2><p>SwipeRefreshLayout也是一个下拉刷新控件，已经被加在在support v4兼容包下，两个要点：</p>
<p><strong>1.</strong> 只要在需要刷新的控件最外层加上SwipeRefreshLayout，然后他的child首先是可滚动的view，如RecyclerView、ListView等</p>
<p><strong>2.</strong> 实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。</p>
<p>SwipeRefreshLayout的详细用法可以参考：</p>
<p><a href="http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html" target="_blank" rel="noopener">http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html</a></p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1028/1861.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1028/1861.html</a></p>
<h2 id="三、下面我通过RecyclerView-SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法："><a href="#三、下面我通过RecyclerView-SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法：" class="headerlink" title="三、下面我通过RecyclerView+SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法："></a>三、下面我通过RecyclerView+SwipeRefreshLayout实现下拉刷新的垂直列表来演示RecyclerView及SwipeRefreshLayout的用法：</h2><p>运行效果图gif：</p>
<p><img src="/images/2016041201.gif" alt=""></p>
<h3 id="1-在build-gradle-中添加依赖"><a href="#1-在build-gradle-中添加依赖" class="headerlink" title="1. 在build.gradle 中添加依赖"></a>1. 在build.gradle 中添加依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;com.android.support:recyclerview-v7:22.2.0&#39;</span><br></pre></td></tr></table></figure>

<p>这里只要是recyclerview-v7:21.0.+就可以了。</p>
<h3 id="2-创建布局文件"><a href="#2-创建布局文件" class="headerlink" title="2. 创建布局文件"></a>2. 创建布局文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_swiperefreshlayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_recyclerview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-继承RecyclerView-Adapter创建自己的Adapter"><a href="#3-继承RecyclerView-Adapter创建自己的Adapter" class="headerlink" title="3.继承RecyclerView.Adapter创建自己的Adapter."></a>3.继承RecyclerView.Adapter创建自己的Adapter.</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecyclerViewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyRecyclerViewAdapter</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据集</span></span><br><span class="line">    <span class="keyword">public</span> String[] datass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.在构造函数中取得数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerViewAdapter</span><span class="params">(String[] datas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.datass = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span>  <span class="title">OnItemClickListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> positon)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnItemClickListener mOnItemClickListener;</span><br><span class="line">    <span class="comment">//添加接口和设置Adapter的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(OnItemClickListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mOnItemClickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///3.创建新View，被LayoutManager所调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个View，简单起见直接使用系统提供的布局，就是一个TextView</span></span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(android.R.layout.simple_list_item_1,parent,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//创建一个ViewHolder</span></span><br><span class="line">        ViewHolder viewHolder= <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.将数据与界面进行绑定的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        holder.textView.setText(datass[position]);</span><br><span class="line">        <span class="keyword">if</span> (mOnItemClickListener!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            holder.itemView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    mOnItemClickListener.onItemClick(holder.itemView, position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.返回数据的长度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datass.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.自定义的ViewHolder，取得每个Item的的所有界面元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TextView textView;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            textView = (TextView) itemView.findViewById(android.R.id.text1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout-OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh-方法中。"><a href="#4-在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout-OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh-方法中。" class="headerlink" title="4.在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。"></a>4.在Activity中找到RecyclerView并绑定自定义的Adapter显示列表，实现SwipeRefreshLayout.OnRefreshListener接口，并找到SwipeRefreshLayout组件注册监听事件。注意：下拉刷新的数据更新逻辑代码应该写在onRefresh()方法中。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">SwipeRefreshLayout</span>.<span class="title">OnRefreshListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> SwipeRefreshLayout swipeRefreshLayout;</span><br><span class="line">    <span class="keyword">private</span> MyRecyclerViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line"></span><br><span class="line">        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</span><br><span class="line">        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)</span><br><span class="line">                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示垂直的RecyclerView</span></span><br><span class="line">        initVerticalRecyclerView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置SwipeRefreshLayout实现下拉刷新效果</span></span><br><span class="line">        swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.id_swiperefreshlayout);</span><br><span class="line">        <span class="comment">//设置进度条颜色，最多设置4种循环显示</span></span><br><span class="line">        swipeRefreshLayout.setColorSchemeResources(android.R.color.white,</span><br><span class="line">                android.R.color.holo_green_light,</span><br><span class="line">                android.R.color.holo_orange_light, android.R.color.holo_red_light);</span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVerticalRecyclerView</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.id_recyclerview);</span><br><span class="line">        <span class="comment">//创建一个垂直的线性布局管理器</span></span><br><span class="line">        LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>,LinearLayoutManager.VERTICAL,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到RecyclerView，并设置布局管理器</span></span><br><span class="line">        mRecyclerView.setLayoutManager(layoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果确定每个item项的高度是固定的，设置这个选项可以提高性能</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建或取得数据集，数据推荐还是时有List集合</span></span><br><span class="line">        <span class="keyword">final</span> String[] datas = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;datas.length; i++)&#123;</span><br><span class="line">            datas[i]=<span class="string">"item"</span>+i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建adapter并且制定数据集</span></span><br><span class="line">        adapter = <span class="keyword">new</span> MyRecyclerViewAdapter(datas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为RecyclerView绑定Adapter</span></span><br><span class="line">        mRecyclerView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在Adapter中添加好事件后，变可以在这里注册事件实现监听了</span></span><br><span class="line">        adapter.setOnItemClickListener(<span class="keyword">new</span> MyRecyclerViewAdapter.OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> positon)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getBaseContext(), <span class="string">"item"</span>+positon, Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 刷新时模拟数据的变化</span></span><br><span class="line">        <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">                    adapter.datass[i] = <span class="string">"new"</span> + temp;</span><br><span class="line">                &#125;</span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/crazyfzw/RecyclerViewDemo" target="_blank" rel="noopener">完整源码可以到我的github下载：https://github.com/crazyfzw/RecyclerViewDemo</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>SwipeRefreshLayout</tag>
        <tag>下拉刷新</tag>
        <tag>RecyclerView+SwipeRefreshLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>为RecyclerView的不同item项实现不同的布局(添加分类Header)</title>
    <url>/2016/04/22/RecyclerView-withHeader/</url>
    <content><![CDATA[<p>最近在做一个应用的时候，需要为GridLayoutManager添加头部header，然后自然而然就想到了用不同的itemType去加载不同的布局。</p>
<h2 id="1-实现多item布局，用不同的itemType去加载不同的布局。"><a href="#1-实现多item布局，用不同的itemType去加载不同的布局。" class="headerlink" title="1.实现多item布局，用不同的itemType去加载不同的布局。"></a>1.实现多item布局，用不同的itemType去加载不同的布局。</h2><p>主要思路就是先定义好标识itemType的常量，然后重写getItemViewType()方法，根据不同的位置（position）返回不同的Type，接着在onCreateViewHolder()中根据参数viewType去判断该item项应该 inflate 哪个布局文件，并返回相应的ViewHolder实例(这里ViewHolder是根据不同的item布局预先自定义好的不同的ViewHolder)</p>
<a id="more"></a>



<p>比如我的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecyclerCardviewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerView</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> ITEM_TYPE &#123;</span><br><span class="line">        ITEM_TYPE_Theme,</span><br><span class="line">        ITEM_TYPE_Video</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据集</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; mdatas;</span><br><span class="line">    <span class="keyword">private</span> TextView themeTitle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerCardviewAdapter</span><span class="params">(List&lt;Integer&gt; datas)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.mdatas = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewType == ITEM_TYPE.ITEM_TYPE_Theme.ordinal())&#123;</span><br><span class="line"></span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.videothemelist,parent,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThemeVideoHolder(view);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(viewType == ITEM_TYPE.ITEM_TYPE_Video.ordinal())&#123;</span><br><span class="line"></span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.videocardview,parent,<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> VideoViewHolder(view);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> ThemeVideoHolder)&#123;</span><br><span class="line"></span><br><span class="line">           themeTitle.setText(<span class="string">"励志"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> VideoViewHolder)&#123;</span><br><span class="line">            ((VideoViewHolder)holder).videologo.setImageResource(R.drawable.lianzai_02);</span><br><span class="line">            ((VideoViewHolder)holder).videovname.setText(<span class="string">"励志，俄小伙练习街头健身一年的体型变化，Dear Hard Work！"</span>);</span><br><span class="line">            ((VideoViewHolder)holder).videoviewed.setText(<span class="string">"2780次"</span>);</span><br><span class="line">            ((VideoViewHolder)holder).videocomment.setText(<span class="string">"209条"</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> position % <span class="number">5</span> == <span class="number">0</span> ? ITEM_TYPE.ITEM_TYPE_Theme.ordinal() : ITEM_TYPE.ITEM_TYPE_Video.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mdatas.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeVideoHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThemeVideoHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            themeTitle = (TextView) itemView.findViewById(R.id.hometab1_theme_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ImageView videologo;</span><br><span class="line">        <span class="keyword">public</span> TextView videovname;</span><br><span class="line">        <span class="keyword">public</span> TextView videoviewed;</span><br><span class="line">        <span class="keyword">public</span> TextView videocomment;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VideoViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            videologo = (ImageView) itemView.findViewById(R.id.videologo);</span><br><span class="line">            videoviewed = (TextView) itemView.findViewById(R.id.videoviewed);</span><br><span class="line">            videocomment = (TextView) itemView.findViewById(R.id.videocomment);</span><br><span class="line">            videovname = (TextView) itemView.findViewById(R.id.videoname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，使用的是 LayoutManager 中发 LinearLayoutManager，效果图如下:</p>
<p><img src="/images/2016042201.jpg" alt=""></p>
<p>但是，当我们把 LayoutManager 改成GridLayoutManager的时候你就出现了不是我们期待的效果，如下图：</p>
<p><img src="/images/2016042202.jpg" alt=""></p>
<p>What the hell is going on? 什么鬼？怎么添加的header随着其他item项以cell的形式出现在网格上。仔细想一想，发现了下面代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridLayoutManager layoutManager &#x3D; new GridLayoutManager(this,2, GridLayoutManager.VERTICAL,false);</span><br></pre></td></tr></table></figure>

<p>哦！原来我们在创建GridLayoutManager的时候需要设定每行显示多少个item项，我们这里设置的是2，而我们添加的header是以item项的形式添加进来的，所以也会以cell的形式出现。那么，有没有办法让header这个item占据两个cell，单独霸占一行呢？答案是肯定的，我们可以通过setSpanSizeLookup抽象类中的getSpanSize()方法的返回值来设定每个item项占据多少个单元格 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gridManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getItemViewType(position) == ITEM_TYPE.ITEM_TYPE_Theme.ordinal()</span><br><span class="line">                        ? gridManager.getSpanCount() : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，这段代码在自定义Adapter中应该添加在何处呢？放在onAttachedToRecyclerView()中再合适不过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</span><br><span class="line">        <span class="keyword">if</span>(manager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">            <span class="keyword">final</span> GridLayoutManager gridManager = ((GridLayoutManager) manager);</span><br><span class="line">            gridManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> getItemViewType(position) == ITEM_TYPE.ITEM_TYPE_Theme.ordinal()</span><br><span class="line">                            ? gridManager.getSpanCount() : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时就可以实现我想要的效果了，运行效果图如下：</p>
<p><img src="/images/2016042203.jpg" alt=""></p>
<p>代码我已经抽离出来放到我的Github了：<a href="https://github.com/crazyfzw/RecycleViewWithHeader" target="_blank" rel="noopener">https://github.com/crazyfzw/RecycleViewWithHeader</a></p>
<h2 id="2-最后说一下为什么为什么用RecyclerView取代ListView。"><a href="#2-最后说一下为什么为什么用RecyclerView取代ListView。" class="headerlink" title="2.最后说一下为什么为什么用RecyclerView取代ListView。"></a>2.最后说一下为什么为什么用RecyclerView取代ListView。</h2><p>用过ListView的都知道，在ListView中若要复用视图缓存，就要在getView()方法中手动判断convertView是否为空，若不为空则复用视图缓存，若为空则重新加载视图，而RecyclerView相当于对ListView的Adapter进行了再次封装，把ListView手动判断是否有缓存的代码封装到RecyclerView内部，使这部分逻辑不可见，我们只需要通过getItemCount()方法告诉RecyclerView有多少项数据，然后在onCreateViewHolder()中加载item布局实例化ViewHolder，然后在onBindViewHolder()中完成数据的绑定即可。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>多Item布局实现</tag>
        <tag>为RecyclerView添加头部</tag>
        <tag>getSpanSize</tag>
        <tag>GridLayoutManager</tag>
      </tags>
  </entry>
  <entry>
    <title>Tablayout+Viewpager+Fragment实现滑动Tab</title>
    <url>/2016/04/09/Tablayout-Viewpager-Fragment-Tab/</url>
    <content><![CDATA[<p>实现活动Tab的方式有很多种，今天我们要用的是使用Google 提供的Design support library 库中的Tablayout去实现，Tablayout是Google I/O 2015 退出8个新的组件之一，可以轻松的结合Viewpager和Fragment实现滑动tab菜单。</p>
<a id="more"></a>


<p>运行效果截图：</p>
<p><img src="/images/20160101.jpg" alt=""></p>
<p><img src="/images/20160102.jpg" alt=""></p>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="1-添加支持类"><a href="#1-添加支持类" class="headerlink" title="1.添加支持类"></a>1.添加支持类</h3><p>在build.gradle(Module:app)中通过以下代码添加支持类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile 'com.android.support:appcompat-v7:22.2.0'</span><br><span class="line">  compile 'com.android.support:design:22.2.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-创建Sliding-Tabs-Layout（主布局文件）"><a href="#2-创建Sliding-Tabs-Layout（主布局文件）" class="headerlink" title="2.创建Sliding Tabs Layout（主布局文件）"></a>2.创建Sliding Tabs Layout（主布局文件）</h3><p>用android.support.design.widget.TabLayout创建tab布局，用android.support.v4.view.ViewPager显示关联tab的Fragment.<br>eg:main_content.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tab_layout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--app:tabMode="scrollable"--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建Fragment："><a href="#3-创建Fragment：" class="headerlink" title="3.创建Fragment："></a>3.创建Fragment：</h3><p>为每个tab项创建一个对应的fragment用于展示内容。eg:与tab1对应的fragment_tab1.xml代码如下：</p>
<h4 id="3-1Fragment布局"><a href="#3-1Fragment布局" class="headerlink" title="3.1Fragment布局"></a>3.1Fragment布局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.crazyfzw.tablayoutviewpager.TabFragment1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Update blank fragment layout --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"tab1页内容"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在本例中，我们再创建两个这样布局的fragment_tab2.xml、fragment_tab3.xml.</p>
<h4 id="3-2创建fragment布局文件对应的逻辑类Fragment-java用于展示tab的内容"><a href="#3-2创建fragment布局文件对应的逻辑类Fragment-java用于展示tab的内容" class="headerlink" title="3.2创建fragment布局文件对应的逻辑类Fragment.java用于展示tab的内容"></a>3.2创建fragment布局文件对应的逻辑类Fragment.java用于展示tab的内容</h4><p>eg:这里TabFragment1.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TabFragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_PARAM1 = <span class="string">"param1"</span>;</span><br><span class="line">    <span class="keyword">private</span> String mParam1;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TabFragment1 <span class="title">newInstance</span><span class="params">(String param1)</span> </span>&#123;</span><br><span class="line">        TabFragment1 fragment = <span class="keyword">new</span> TabFragment1();</span><br><span class="line">        Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">        args.putString(ARG_PARAM1, param1);</span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TabFragment1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParam1 = getArguments().getString(ARG_PARAM1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        View myview = inflater.inflate(R.layout.fragment_tab1, container, <span class="keyword">false</span>);</span><br><span class="line">        textView = (TextView) myview.findViewById(R.id.textView1);</span><br><span class="line">        textView.setText(mParam1);</span><br><span class="line">        <span class="keyword">return</span> myview;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>同样，为了演示本例创建相似的TabFragment2java、TabFragment3.java</p>
<h3 id="4-创建ViewPager的适配器"><a href="#4-创建ViewPager的适配器" class="headerlink" title="4.创建ViewPager的适配器:"></a>4.创建ViewPager的适配器:</h3><p>实现FragmentPagerAdapter接口并重载其中的方法，用于控制tab与内容页content的关系。其中getPageTitle(int position)方法为每个tab取得标题title,而getItem(int position)方法决定每个tab显示哪个fragment.</p>
<p>eg:MyViewPagerAdapter.java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentStatePagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Fragment&gt; myFragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; myFragmentTitles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewPagerAdapter</span><span class="params">(FragmentManager fm, Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, String title)</span> </span>&#123;</span><br><span class="line">        myFragments.add(fragment);</span><br><span class="line">        myFragmentTitles.add(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragments.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFragmentTitles.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最后一步，在Activity中把ViewPager-与PagerAdapter绑定，然后让用setupWithViewPager-viewPager-方法把pager与tab关联在一起。"><a href="#5-最后一步，在Activity中把ViewPager-与PagerAdapter绑定，然后让用setupWithViewPager-viewPager-方法把pager与tab关联在一起。" class="headerlink" title="5.最后一步，在Activity中把ViewPager 与PagerAdapter绑定，然后让用setupWithViewPager(viewPager)方法把pager与tab关联在一起。"></a>5.最后一步，在Activity中把ViewPager 与PagerAdapter绑定，然后让用setupWithViewPager(viewPager)方法把pager与tab关联在一起。</h3><p>主要两步:<br>A:找到ViewPager控件并setAdapter(adapter);<br>B：找到tablayout控件并用用setupWithViewPager(viewPager)方法把pager与tab关联在一起。</p>
<p>eg:本例Mainactivity.java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TabLayout tabLayout;</span><br><span class="line">    <span class="keyword">private</span> ViewPager viewPager;</span><br><span class="line">    <span class="keyword">private</span> MyViewPagerAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tabLayout = (TabLayout) findViewById(R.id.tab_layout);</span><br><span class="line">        viewPager = (ViewPager) findViewById(R.id.pager);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setupViewPager(viewPager);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">        adapter = <span class="keyword">new</span> MyViewPagerAdapter(getSupportFragmentManager(), <span class="keyword">this</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment1().newInstance(<span class="string">"Page1"</span>), <span class="string">"Tab 1"</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment2().newInstance(<span class="string">"Page2"</span>), <span class="string">"Tab 2"</span>);</span><br><span class="line">        adapter.addFragment(<span class="keyword">new</span> TabFragment3().newInstance(<span class="string">"Page3"</span>), <span class="string">"Tab 3"</span>);</span><br><span class="line">        viewPager.setAdapter(adapter);</span><br><span class="line">        tabLayout.setupWithViewPager(viewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行就可以了。</p>
<p><strong>注意：</strong><br>运行的时候在 adapter.addFragment(new TabFragment1().newInstance(“Page1”),”Tab1”);<br>中很可能会出现错误，无法将子类abFragment1的对象转化为Fragment对象。提示cannot convert from Tab1Fragment(android.support.v4.app.Fragment) to Fragment(android.app.Fragment).这是因为导入包不一致，一般的问题在于：这里或者PaperAdapter中导入的是android.support.v4.app.Fragment，而Fragment的子类Tab1Fragment中导入的是android.app.Fragment，包不同所以无法转换，这里统一导入android.support.v4.app.Fragment就可以解决了。</p>
<p>本例源码可以到我的github去下载 <a href="https://github.com/crazyfzw/TablayoutViewpager" target="_blank" rel="noopener">https://github.com/crazyfzw/TablayoutViewpager</a></p>
<p><strong>参考文献：</strong></p>
<p><a href="https://developer.android.com/intl/zh-cn/reference/android/support/design/widget/TabLayout.html" target="_blank" rel="noopener">https://developer.android.com/intl/zh-cn/reference/android/support/design/widget/TabLayout.html</a><br><a href="https://github.com/codepath/android_guides/wiki/ViewPager-with-FragmentPagerAdapter" target="_blank" rel="noopener">https://github.com/codepath/android_guides/wiki/ViewPager-with-FragmentPagerAdapter</a><br><a href="http://blog.csdn.net/jason0539/article/details/9712273" target="_blank" rel="noopener">http://blog.csdn.net/jason0539/article/details/9712273</a></p>
<p>若想实现带图标的滑动tab或者更详细的Tablayout推荐参考<br><a href="https://github.com/codepath/android_guides/wiki/Google-Play-Style-Tabs-using-TabLayout#design-support-library" target="_blank" rel="noopener">https://github.com/codepath/android_guides/wiki/Google-Play-Style-Tabs-using-TabLayout#design-support-library</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android.support.v4.a</tag>
        <tag>Tablayout</tag>
        <tag>ViewPager</tag>
        <tag>Fragment</tag>
        <tag>滑动tab</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云ECS：Java WEB环境搭建</title>
    <url>/2017/11/02/aliyun-ecs-java-web-setup/</url>
    <content><![CDATA[<p>前些时间，买了个 阿里云 ECS，详细配置为 1vCPU、1GB 内存、40GB系统盘、20GB SSD，搭载的是 CentOS 7.4 系统。这里仅记录下在 ECS 上搭建 Java WEB 环境的过程。</p>
<a id="more"></a>

<h2 id="一、远程连接服务器"><a href="#一、远程连接服务器" class="headerlink" title="一、远程连接服务器"></a>一、远程连接服务器</h2><p>我这里使用的是 Xshell + Xftp 组合。Xshell 用来远程访问并控制终端，Xftp  基本上只用于传输文件。</p>
<p><img src="/images/2017110601.png" alt=""></p>
<p><img src="/images/2017110602.png" alt=""></p>
<p><img src="/images/2017110603.png" alt=""></p>
<h2 id="二、-格式化和挂载数据盘-这里以-dev-xvdb为例"><a href="#二、-格式化和挂载数据盘-这里以-dev-xvdb为例" class="headerlink" title="二、 格式化和挂载数据盘   (这里以/dev/xvdb为例)"></a>二、 格式化和挂载数据盘   (这里以/dev/xvdb为例)</h2><p>这里需要注意的是单独购买的数据盘需要先挂载数据盘，然后才能格式化。随实例一起购买的数据盘，无需挂载，直接格式化。</p>
<p>1.查看分区    df -h</p>
<p>2.查看数据盘  fdisk -l    </p>
<p>3.使用 fdisk命令分区 </p>
<p>  &emsp;1）运行 fdisk /dev/xvdb，对数据盘进行分区。根据提示，依次输入 n，p，1，两次回车，wq，分区就开始了</p>
<p>  &emsp;2）运行 fdisk -l 命令，查看新的分区是否已经建好</p>
<p>4.格式化新分区</p>
<p>  &emsp;1）运行 mkfs.ext3 /dev/xvdb1，对新分区进行格式化。格式化所需时间取决于数据盘大小。您也可自主决定选用其他文件格式，如 ext4 等</p>
<p>  &emsp;2）运行 echo /dev/xvdb1 /mnt ext3 defaults 0 0 &gt;&gt; /etc/fstab 写入新分区信息，完成后，可以使用 cat /etc/fstab 命令查看</p>
<p>5.挂载新分区<br>  运行 mount /dev/xvdb1 /mnt 挂载新分区，然后执行 df -h 查看分区。如果出现数据盘信息，说明挂载成功，可以使用新分区了</p>
<h2 id="三、安装JDK"><a href="#三、安装JDK" class="headerlink" title="三、安装JDK"></a>三、安装JDK</h2><p>这里可以通过 wget 命令去在线下载，然后再用 tar 命令解压到指定目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.linuxeye.com&#x2F;jdk&#x2F;jdk-8u141-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>


<p>因为我本地已经有tomcat 以及jdk 了，所以为了方便，直接通过 Xftp 上传到指定目录</p>
<p><img src="/images/2017110604.png" alt=""></p>
<p>接着设<strong>置 JDK 的环境变量</strong>，步骤如下：</p>
<ol>
<li>先用 vi  /etc/profile 打开配置文件</li>
<li>然后 按 i 键进入编辑模式</li>
<li>接着插入下面的信息，指定jdk目录</li>
<li>接着按 Esc 键退出编辑模式，输入 :wq 保存并关闭文件，如果不小心写错，不想保存，则可以通过:q!退出。</li>
<li>最后，通过 source /etc/profile 加载环境变量</li>
<li>输入 java -version 查看jdk版本，验证是否安装成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;jdk1.7.0_60</span><br><span class="line">export CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p><img src="/images/2017110605.png" alt=""></p>
<p><img src="/images/2017110606.png" alt=""></p>
<h2 id="四、安装-Tomcat"><a href="#四、安装-Tomcat" class="headerlink" title="四、安装 Tomcat"></a>四、安装 Tomcat</h2><p>tomcat 的安装更简单， 基本上传到指定目录，在 server.xml 改下端口就行了。</p>
<p><img src="/images/2017110607.png" alt=""></p>
<h2 id="五、开放端口"><a href="#五、开放端口" class="headerlink" title="五、开放端口"></a>五、开放端口</h2><p>需要格外注意的是 CentOS 7.4 系统默认开启了防火墙。需要配置安全组 放行 80、443 或 8080 端口入方向规则。</p>
<p>参考  《ECS安全组实践 》 <a href="https://help.aliyun.com/document_detail/51170.html?spm=5176.product25365.6.742.0SxQKm" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/51170.html?spm=5176.product25365.6.742.0SxQKm</a></p>
<p><img src="/images/2017110608.png" alt=""></p>
<p><img src="/images/2017110609.jpg" alt=""></p>
<h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>通过 tomcat 下的 startup.sh 启动下 tomcat，就可以验证了。</p>
<p><img src="/images/2017110610.png" alt=""></p>
<p><img src="/images/2017110611.png" alt=""></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>[1]<a href="https://help.aliyun.com/document_detail/51376.html?spm=5176.doc51170.6.717.2smpOG" target="_blank" rel="noopener">Linux 格式化和挂载数据盘</a></p>
<p>[2]<a href="https://help.aliyun.com/document_detail/51376.html?spm=5176.doc51170.6.717.2smpOG" target="_blank" rel="noopener">手工部署Java Web项目</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>阿里云ECS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松实现APP自动检测更新</title>
    <url>/2016/08/24/app-auto-update/</url>
    <content><![CDATA[<p><strong>概述：</strong>为了以快速并且节约的方式让APP更新版本，通常需要在APP内增加自动检测更新新版本的功能。</p>
<h2 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h2><p><img src="/images/2016082401.jpg" alt="">)<img src="/images/2016082402.jpg" alt="">)<img src="/images/2016082403.jpg" alt="">)<img src="/images/2016082404.jpg" alt="">  </p>
<a id="more"></a>





<h2 id="实现：4个步骤"><a href="#实现：4个步骤" class="headerlink" title="实现：4个步骤"></a>实现：4个步骤</h2><p><img src="/images/2016082405.png" alt=""> </p>
<h3 id="1-在服务端放置存储版本信息的文件"><a href="#1-在服务端放置存储版本信息的文件" class="headerlink" title="1.在服务端放置存储版本信息的文件"></a>1.在服务端放置存储版本信息的文件</h3><p>  一般以json格式保存必要的信息：apk文件下载地址、版本号、更新内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "url":"http://crazyfzw.github.io/demo/auto-update-version/new-version-v2.0.apk",</span><br><span class="line">  "versionCode":2,</span><br><span class="line">  "updateMessage":"[1]新增视频弹幕功能<span class="tag">&lt;<span class="name">br</span>/&gt;</span>[2]优化离线缓存功能<span class="tag">&lt;<span class="name">br</span>/&gt;</span>[3]增强了稳定性"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-继承AsyncTask创建一个异步任务去下载版本信息文件"><a href="#2-继承AsyncTask创建一个异步任务去下载版本信息文件" class="headerlink" title="2.继承AsyncTask创建一个异步任务去下载版本信息文件"></a>2.继承AsyncTask创建一个异步任务去下载版本信息文件</h3><p> 从服务器取得版本信息，与本地apk对比版本号，判断是否有更新，若有，则以Dialog让用户选择是否更新，若用户选择更新，则调用服务去完成apk文件的下载</p>
<p><strong>CheckVersionInfoTask.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckVersionInfoTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CheckVersionInfoTask"</span>;</span><br><span class="line">    <span class="keyword">private</span> ProgressDialog dialog;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mShowProgressDialog;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_INFO_URL = <span class="string">"http://crazyfzw.github.io/demo/auto-update-version/update.json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckVersionInfoTask</span><span class="params">(Context context, <span class="keyword">boolean</span> showProgressDialog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mShowProgressDialog = showProgressDialog;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化显示Dialog</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mShowProgressDialog) &#123;</span><br><span class="line">            dialog = <span class="keyword">new</span> ProgressDialog(mContext);</span><br><span class="line">            dialog.setMessage(mContext.getString(R.string.check_new_version));</span><br><span class="line">            dialog.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在后台任务(子线程)中检查服务器的版本信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getVersionInfo(VERSION_INFO_URL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台任务执行完毕后，解除Dialog并且解析return返回的结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dialog != <span class="keyword">null</span> &amp;&amp; dialog.isShowing()) &#123;</span><br><span class="line">            dialog.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(result)) &#123;</span><br><span class="line">            parseJson(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从服务器取得版本信息</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">       "url":"http://crazyfzw.github.io/demo/auto-update-version/new-version-v2.0.apk",</span></span><br><span class="line"><span class="comment">        "versionCode":2,</span></span><br><span class="line"><span class="comment">       "updateMessage":"[1]新增视频弹幕功能&lt;br/&gt;[2]优化离线缓存功能&lt;br/&gt;[3]增强了稳定性"</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVersionInfo</span><span class="params">(String urlStr)</span></span>&#123;</span><br><span class="line">        HttpURLConnection uRLConnection = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buffer = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">            uRLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            uRLConnection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            is = uRLConnection.getInputStream();</span><br><span class="line">            buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = buffer.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                strBuilder.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            result = strBuilder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"http post error"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (uRLConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                uRLConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JSONObject obj = <span class="keyword">new</span> JSONObject(result);</span><br><span class="line">            String apkUrl = obj.getString(<span class="string">"url"</span>);                 <span class="comment">//APK下载路径</span></span><br><span class="line">            String updateMessage = obj.getString(<span class="string">"updateMessage"</span>);<span class="comment">//版本更新说明</span></span><br><span class="line">            <span class="keyword">int</span> apkCode = obj.getInt(<span class="string">"versionCode"</span>);              <span class="comment">//新版APK对于的版本号</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取得已经安装在手机的APP的版本号 versionCode</span></span><br><span class="line">            <span class="keyword">int</span> versionCode = getCurrentVersionCode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对比版本号判断是否需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (apkCode &gt; versionCode) &#123;</span><br><span class="line"></span><br><span class="line">                    showDialog(updateMessage, apkUrl);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mShowProgressDialog) &#123;</span><br><span class="line">                Toast.makeText(mContext, mContext.getString(R.string.there_no_new_version), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"parse json error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得当前版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentVersionCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mContext.getPackageManager().getPackageInfo(mContext.getPackageName(), <span class="number">0</span>).versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示对话框提示用户有新版本，并且让用户选择是否更新版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadUrl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">(String content, <span class="keyword">final</span> String downloadUrl)</span> </span>&#123;</span><br><span class="line">            AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(mContext);</span><br><span class="line">            builder.setTitle(R.string.dialog_choose_update_title);</span><br><span class="line">            builder.setMessage(Html.fromHtml(content))</span><br><span class="line">                    .setPositiveButton(R.string.dialog_btn_confirm_download, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//下载apk文件</span></span><br><span class="line">                            goToDownloadApk(downloadUrl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(R.string.dialog_btn_cancel_download, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            AlertDialog dialog = builder.create();</span><br><span class="line">            <span class="comment">//点击对话框外面,对话框不消失</span></span><br><span class="line">            dialog.setCanceledOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">            dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用intent启用DownloadService服务去下载AKP文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadUrl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goToDownloadApk</span><span class="params">(String downloadUrl)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(mContext, DownloadApkService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        intent.putExtra(<span class="string">"apkUrl"</span>, downloadUrl);</span><br><span class="line">        mContext.startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注：其中用到的 StorageUtils.getCacheDirectory(context) 是用于取得应用在手机缓存目录</p>
<p><strong>StorageUtils.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"StorageUtils"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTERNAL_STORAGE_PERMISSION = <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StorageUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns application cache directory. Cache directory will be created on SD card</span></span><br><span class="line"><span class="comment">     * ("/Android/data/[app_package_name]/cache") if card is mounted and app has appropriate permission. Else -</span></span><br><span class="line"><span class="comment">     * Android defines cache directory on device's file system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getCacheDirectory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        File appCacheDir = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) &#123;</span><br><span class="line">            appCacheDir = getExternalCacheDir(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appCacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            appCacheDir = context.getCacheDir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appCacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Can't define system cache directory! The app should be re-installed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appCacheDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getExternalCacheDir</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        File dataDir = <span class="keyword">new</span> File(<span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"Android"</span>), <span class="string">"data"</span>);</span><br><span class="line">        File appCacheDir = <span class="keyword">new</span> File(<span class="keyword">new</span> File(dataDir, context.getPackageName()), <span class="string">"cache"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!appCacheDir.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appCacheDir.mkdirs()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Unable to create external cache directory"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> File(appCacheDir, <span class="string">".nomedia"</span>).createNewFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Can't create \".nomedia\" file in application external cache directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appCacheDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasExternalStoragePermission</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> perm = context.checkCallingOrSelfPermission(EXTERNAL_STORAGE_PERMISSION);</span><br><span class="line">        <span class="keyword">return</span> perm == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-创建服务-Service-完成apk文件的下载，下载完成后调用系统的安装程序完成安装"><a href="#3-创建服务-Service-完成apk文件的下载，下载完成后调用系统的安装程序完成安装" class="headerlink" title="3.创建服务(Service)完成apk文件的下载，下载完成后调用系统的安装程序完成安装"></a>3.创建服务(Service)完成apk文件的下载，下载完成后调用系统的安装程序完成安装</h3><p><strong>DownloadApkService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadApkService</span> <span class="keyword">extends</span> <span class="title">IntentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">10</span> * <span class="number">1024</span>; <span class="comment">//缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DownloadService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> NotificationManager mNotifyManager;</span><br><span class="line">    <span class="keyword">private</span> NotificationCompat.Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadApkService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"DownloadApkService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在onHandleIntent中下载apk文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化通知，用于显示下载进度</span></span><br><span class="line">        mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        mBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line">        String appName = getString(getApplicationInfo().labelRes);</span><br><span class="line">        <span class="keyword">int</span> icon = getApplicationInfo().icon;</span><br><span class="line">        mBuilder.setContentTitle(appName).setSmallIcon(icon);</span><br><span class="line"></span><br><span class="line">        String urlStr = intent.getStringExtra(<span class="string">"apkUrl"</span>); <span class="comment">//从intent中取得apk下载路径</span></span><br><span class="line"></span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立下载连接</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            urlConnection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            urlConnection.setDoOutput(<span class="keyword">false</span>);</span><br><span class="line">            urlConnection.setConnectTimeout(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            urlConnection.setReadTimeout(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            urlConnection.setRequestProperty(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip, deflate"</span>);</span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以文件流读取数据</span></span><br><span class="line">            <span class="keyword">long</span> bytetotal = urlConnection.getContentLength(); <span class="comment">//取得文件长度</span></span><br><span class="line">            <span class="keyword">long</span> bytesum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> byteread = <span class="number">0</span>;</span><br><span class="line">            in = urlConnection.getInputStream();</span><br><span class="line">            File dir = StorageUtils.getCacheDirectory(<span class="keyword">this</span>); <span class="comment">//取得应用缓存目录</span></span><br><span class="line">            String apkName = urlStr.substring(urlStr.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, urlStr.length());<span class="comment">//取得apK文件名</span></span><br><span class="line">            File apkFile = <span class="keyword">new</span> File(dir, apkName);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(apkFile);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> oldProgress = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((byteread = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bytesum += byteread;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, byteread);</span><br><span class="line">                <span class="keyword">int</span> progress = (<span class="keyword">int</span>) (bytesum * <span class="number">100L</span> / bytetotal);</span><br><span class="line">                <span class="comment">// 如果进度与之前进度相等，则不更新，如果更新太频繁，则会造成界面卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (progress != oldProgress) &#123;</span><br><span class="line">                    updateProgress(progress);</span><br><span class="line">                &#125;</span><br><span class="line">                oldProgress = progress;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下载完成,调用installAPK开始安装文件</span></span><br><span class="line">            installAPk(apkFile);</span><br><span class="line">            Log.d(<span class="string">"调试"</span>,<span class="string">"download apk finish"</span>);</span><br><span class="line">            mNotifyManager.cancel(NOTIFICATION_ID);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"download apk file error"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时更新下载进度条显示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> progress</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> progress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"正在下载:" + progress + "%"</span></span><br><span class="line">        mBuilder.setContentText(<span class="keyword">this</span>.getString(R.string.dialog_choose_update_content, progress)).setProgress(<span class="number">100</span>, progress, <span class="keyword">false</span>);</span><br><span class="line">        PendingIntent pendingintent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent(), PendingIntent.FLAG_CANCEL_CURRENT);</span><br><span class="line">        mBuilder.setContentIntent(pendingintent);</span><br><span class="line">        mNotifyManager.notify(NOTIFICATION_ID, mBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用系统安装程序安装下载好的apk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apkFile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installAPk</span><span class="params">(File apkFile)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        <span class="comment">//如果没有设置SDCard写权限，或者没有sdcard,apk文件保存在内存中，需要授予权限才能安装</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] command = &#123;<span class="string">"chmod"</span>, <span class="string">"777"</span>, apkFile.toString()&#125;; <span class="comment">//777代表权限 rwxrwxrwx</span></span><br><span class="line">            ProcessBuilder builder = <span class="keyword">new</span> ProcessBuilder(command);</span><br><span class="line">            builder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        intent.setDataAndType(Uri.fromFile(apkFile), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-最后一步，new并execute我们写好的异步任务就行了。"><a href="#4-最后一步，new并execute我们写好的异步任务就行了。" class="headerlink" title="4.最后一步，new并execute我们写好的异步任务就行了。"></a>4.最后一步，new并execute我们写好的异步任务就行了。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new CheckVersionInfoTask(MainActivity.this, true).execute();</span><br></pre></td></tr></table></figure>


<p><strong>注：记得在AndroidManifest.xml中生明权限及注册Service哦</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</span><br><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>本案例完整源码：<a href="https://github.com/crazyfzw/AppAutoCheckUpdate" target="_blank" rel="noopener">https://github.com/crazyfzw/AppAutoCheckUpdate</a></p>
<h2 id="用到的相关知识："><a href="#用到的相关知识：" class="headerlink" title="用到的相关知识："></a>用到的相关知识：</h2><p>异步任务AsysTask的相关用法：郭霖的Android AsyncTask完全解析，带你从源码的角度彻底理解</p>
<p>自动启动线程执行耗时任务并会自动停止的服务 IntentService的用法：Android理解：IntentService</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>APP自动更新</tag>
        <tag>Android auto update</tag>
        <tag>应用自动检测更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 3 ：Java的类加载机制</title>
    <url>/2018/07/05/classloader/</url>
    <content><![CDATA[<h2 id="一、Class文件"><a href="#一、Class文件" class="headerlink" title="一、Class文件"></a>一、Class文件</h2><p>在开始讲类加载机制之前，不妨先来了解一下 java 中的这个 ”类“。我们都知道 java 最著名的优点之一就是 摆脱了硬件平台的束缚，实现了”一次编写、到处运行“，那么 java 是怎么做到这种跨平台的呢？答案是通过  虚拟机 + “字节码”。</p>
<a id="more"></a>


<ol>
<li><p>java程序在编译时并不直接编译成依赖于平台的特定机器语言，而是编译成与平台无关的”字节码”，由java虚拟机来执行，java虚拟机执行的时候才将字节码翻译成目标平台对应的机器指令代码。</p>
</li>
<li><p>不同平台的不同虚拟机都可以载入和执行这种平台无关的“字节码”。</p>
</li>
</ol>
<p>这种具有特定的二进制文件格式的“字节码”就是 “Class文件”，即类加载机制中的“类”。</p>
<p><img src="/images/2018071001.png" alt=""></p>
<p>class文件一组以8位字节为单位的二进制流，由无符号数和表两种数据类型组成组成，无符号数实质上就是不同大小的字节，u1、u2、u4、u8分别代表1、2、4、8个字节；表是由多个无符号数或者其他表作为数据项构成的复合数据类型。</p>
<p>*<em>class类文件由以下部分组成： *</em></p>
<ul>
<li>魔数</li>
<li>次版本</li>
<li>主版本</li>
<li>常量池</li>
<li>类访问标识</li>
<li>此类信息常量池索引</li>
<li>父类信息常量池索引</li>
<li>接口集合常量池索引</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>类属性集合</li>
</ul>
<h2 id="二、类的生命周期"><a href="#二、类的生命周期" class="headerlink" title="二、类的生命周期"></a>二、类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图：<br><img src="/images/2018071002.png" alt=""></p>
<p>图中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段不一定：它在某些情况下可以在初始化阶段之后才开始，这是为了支持Java语言的运行时绑定（也称为动态绑定）。</p>
<h2 id="三、类加载的时机"><a href="#三、类加载的时机" class="headerlink" title="三、类加载的时机"></a>三、类加载的时机</h2><p>类加载的时机主要还是依赖于初始化的时机。虚拟机规定有且仅有5种情况会触发类的初始化 ，而在初始化之前，自然是要先经过加载、验证、准备的，所以类加载的时机依主要还是看什么情况下会触发类的初始化。下文中会详细讲下类初始化的触发条件。</p>
<h2 id="四、类加载的过程"><a href="#四、类加载的过程" class="headerlink" title="四、类加载的过程"></a>四、类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>把数据从 Class 文件加载到内存，有预加载和运行时加载2种：</p>
<p><strong>1、预加载：</strong>虚拟机启动时，会加载 JAVA_HOME/lib/ 下的 rt.jar 中 .class 文件，这个 jar 包里面的内容是程序运行时非常可能会用到的基础类，像 java.lang.<em>、java.util.</em>、java.io.*等，因此随着虚拟机一起加载。可以写一个空的main函数，设置虚拟机参数为 “-XX:+TraceClassLoading”，运行一下 </p>
<p><img src="/images/2018071003.png" alt=""></p>
<p><img src="/images/2018071004.png" alt=""><br>…</p>
<p><strong>2、运行时加载：</strong>虚拟机会根据类的全限定名在内存中查找是否已经加载了这个类，如果没有，则会通过委托机制（双亲委派模型，后面会细讲）加载这个类。在加载阶段，虚拟机做了以下3件事情：</p>
<p>1) 根据全限定名 获取 .class 文件的二进制字节流；<br>2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段主要会完成下面4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<p><strong>1.文件格式验证</strong><br>验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机处理。</p>
<ul>
<li><p>是否以魔数 0xCAFEBABE 开头</p>
</li>
<li><p>主次版本号是否在当前虚拟机处理范围之内，紧接着魔数的4个字节存储的是 Class 文件的版本号：第5和第6是次版本号，第7和弟8个字节是主版本号。高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件。比如：在JDK1.7下编译生成的Class文件，那么JDK1.7及以上的版本能运行这个 Class 文件，但是JDK1.6乃更低的JDK版本是无法运行 Class文件的。</p>
</li>
<li><p>常量池中的常量是否有不被支持的常量类型；</p>
</li>
<li><p>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；</p>
</li>
<li><p>CONSTANTUtf8info型的常量中是否有不符合UTF8编码的数据；</p>
</li>
<li><p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</p>
<p>等等</p>
</li>
</ul>
<p><strong>2.元数据验证</strong><br>主要目的是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<ul>
<li>这个类是否有父类；</li>
<li>这个类的父类是否继承了不准许被继承的类；</li>
<li>如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法；</li>
<li>类中的字段方法是否与父类产生矛盾。<br>等等</li>
</ul>
<p><strong>3.字节码验证</strong></p>
<p>对方法体进行校验，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作；</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上；</li>
<li>保证方法体中的类型转换是有效的。<br>等等</li>
</ul>
<p><strong>4.符号引用验证</strong><br>目的是确保解析动作能正常进行，如果无法通过符号引用验证，抛出  java.lang.NoSuchFieldError、java.lang.NoSuchMethodError、java.lang.IIegalAccessError 等。</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否找到相应的类；</li>
<li>在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段；</li>
<li>符号引用中的类、字段、方法的访问性是否被当前类访问。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。关于这点，有两个地方注意一下：</p>
<p>1、这时候只会对类变量（被static修饰的变量）进行内存分配，而不会给实例变量分配内存，，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中；</p>
<p>2、在准备阶段，对于非final修饰的static变量，设置的初始值为数据类型的零值，对于 被final修饰的 static变量，则会直接赋予所指定的值。<br>比如”public static int value = 123;”，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；而”public static final int value = 123;”就不一样了，在准备阶段，虚拟机就会给value直接赋值为123。</p>
<p>基本数据类型的零值如下表：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>short</td>
<td>(short) 0</td>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
<td>reference</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>(byte) 0</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。那么，符号引用与直接引用又有什么区别呢？</p>
<p><strong>1、符号引用</strong><br>符号引用以一组符号来描述所引用的目标，定义在java虚拟机规范中的Class文件格式中，它与虚拟机实现的内存布局无关，引用的目标并不一定加载到内存中。</p>
<p>符号引用包含了下面3种信息：</p>
<ul>
<li><p>类和接口的全限定名</p>
</li>
<li><p>字段的名称和描述符</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
</ul>
<p>下面写个简单的例子，然后先用 javac 编译出二进制字节码，然后再用 jdk 自带的反编译工具 javap 反编译输出常量表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018071005.png" alt=""></p>
<p>结果如下：<br><img src="/images/2018071006.png" alt=""></p>
<p>Constant Pool 的结果中，带”Utf8”的就是符号引用，比如 #8 为 n, #9 为 I, 表示的是 int 型的变量 n。</p>
<p><strong>2、直接引用</strong><br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，如果有了直接引用，那引用的目标必定已经存在在内存中了。同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 java 程序代码（或者说是字节码）</p>
<p><strong>初始化阶段主要做了以下2件事：</strong></p>
<ol>
<li><p>给静态变量赋予指定的值，需要注意区别的是，在准备阶段，给静态变量设置的初始值是类型的零值，到了初始化阶段才会赋予程序实际指定的值。</p>
</li>
<li><p>执行静态代码块</p>
</li>
</ol>
<p>注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()方法，其他线程都要阻塞等待，直至活动线程执行<clinit>()方法完毕。因此如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程不会再次进入<clinit>()方法了，因为同一个类加载器下，一个类只会初始化一次。</p>
<p><strong>初始化的时机（触发条件）</strong><br>虚拟机规定有且仅有以下5种情况会触发类的初始化  （而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>使用 new 关键字实例化对象的时候，读取或设置一个类的静态字段（该字段不被 final 修饰）的时候，以及调用一个类的静态方法的时候；</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候；</li>
<li>当初始化一个类的时候,如果发现其父类还没有进行过初始化，则需要先初始化其父类；</li>
<li>当虚拟机启动的时候,用户需要指定一个要执行的主类(包含 main 方法的那个类)，虚拟机需要先初始化这个主类；</li>
<li>当使用JDK1.7的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REFgetStatic、REFputStatic、REF_invokeStatic 的方法句柄,并且这个方法句柄所对应的类没有进行过初始化。</li>
</ol>
<p>以上5种称为对类的主动引用，只有主动引用才会触发对类的初始化，除此之外，所有引用类的方式都不会触发初始化，称为被动引用，常见的有下面3种：</p>
<p><strong>1、通过子类引用父类静态字段，不会导致子类初始。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071007.png" alt=""></p>
<p><strong>2、通过数组定义引用类，不会触发此类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] supArr= <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071008.png" alt=""></p>
<p><strong>3、引用常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类，因此也不会触发类的初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD =  <span class="string">"Hello World"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstCLass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018071009.png" alt=""></p>
<h2 id="五、类与类加载器"><a href="#五、类与类加载器" class="headerlink" title="五、类与类加载器"></a>五、类与类加载器</h2><p>Java 代码要想运行，首先需要将源代码进行编译生成 .class 文件，然后把 .class 字节码文件加载到 JVM  中运行，实现这个加载动作的程序就是类加载器。在类加载阶段，类加载器负责通过一个类的全限定名来获取此类的二进制字节流。</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限定于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗点说就是：比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个.class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。</p>
<p>Java为我们提供了3种原生的类加载器：分别是启动类加载器（Bootstrap ClassLoader）、拓展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）。除此之外，用户还可以根据自己的需要自定义类加载器。</p>
<p>下面分别详细介绍下3种原生的类加载器：</p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>启动类加载器，又称引导类加载器。区别于那些由独立于虚拟机外部、由java语言实现的类加载器，启动类加载器使用C++实现，是虚拟机自身的一部分。主要负责加载 <JAVA_HOME>\lib 目录下 rt.jar、resources.jar、charsets.jar 等 java 核心类库。</p>
<p>通过下面代码我们可以查看启动类加载器的扫描路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;    </span><br><span class="line">            System.out.println(urls[i].toExternalForm());    </span><br><span class="line">        &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="/images/2018071301.png" alt=""></p>
<h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><p>扩展类加载器，由 sun.misc.Launcher$ExtClassLoader 实现，主要负责加载 Java 的扩展类库，默认加载 JAVA_HOME/jre/lib/ext/ 目录下的所有 Jar 包或者由 java.ext.dirs 系统属性指定的 Jar 包。</p>
<p>通过下面代码我们可以查看启动类加载器的扫描路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Program Files\Java\jdk1.8.0_91\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>


<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p>应用程序类加载器，又称系统类加载器。由 sun.misc.Launcher$AppClassLoader 实现，负责在 JVM 启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH 操作系统属性所指定的 JAR 类包和类路径。调用 ClassLoader.getSystemClassLoader() 可以获取该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器。</p>
<p>执行以下代码即可获得 classpath 加载路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br></pre></td></tr></table></figure>


<h3 id="3种原生类加载器的关系"><a href="#3种原生类加载器的关系" class="headerlink" title="3种原生类加载器的关系"></a>3种原生类加载器的关系</h3><p><img src="/images/2018071401.png" alt=""></p>
<p>需要注意2点：</p>
<ul>
<li>AppClassloader 的父加载器是 ExtClassloader。</li>
<li>ExtClassloader 的父加载器为 null，但是要注意的是 ExtClassloader 的父加载器并不是 BootstrapClassloader。</li>
</ul>
<p>执行以下代码验证下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">		  System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>根据结果可以看出：Application ClassLoader 是系统类加载器；Application ClassLoader 的父加载器确实是 Extension ClassLoader。那么为什么 ExtClassLoader 的父加载器为 null 呢？原因是因为 Bootstrap ClassLoader 以外的ClassLoader 都是Java实现的，因此这些 ClassLoader 势必在 Java 堆中有一份实例在，所以 Extension ClassLoader 和 Application ClassLoader 都能打印出实现类。但是Bootstrap ClassLoader 是JVM的一部分，是用 C++ 写的，不属于Java，自然在Java堆中也没有自己的空间， BootstrapClassloader 对 Java 不可见，所以就返回null了。</p>
<h2 id="六、双亲委派模型（类的加载机制：委托机制）"><a href="#六、双亲委派模型（类的加载机制：委托机制）" class="headerlink" title="六、双亲委派模型（类的加载机制：委托机制）"></a>六、双亲委派模型（类的加载机制：委托机制）</h2><p>Java 类加载器使用的是委托机制，也就是一个类加载器在加载一个类时候会首先尝试委派给父类加载器来加载。类加载器之间的层次关系如下图所示，称为类加载器的双亲委派模型。</p>
<p><img src="/images/2018071402.png" alt=""></p>
<h3 id="双亲委派模型的工作过程："><a href="#双亲委派模型的工作过程：" class="headerlink" title="双亲委派模型的工作过程："></a>双亲委派模型的工作过程：</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，并且每一个层次的类加载器都是如此，因此所有的加载请求，最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈无法完成这个加载请求（它的搜索范围中没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p>下面从源码看如何实现委托机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(Stringname,<span class="keyword">boolean</span> resolve)  </span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException  </span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  </span><br><span class="line">           <span class="comment">// 首先从jvm缓存查找该类</span></span><br><span class="line">           Class c = findLoadedClass(name); <span class="comment">// (1)</span></span><br><span class="line">           <span class="keyword">if</span> (c ==<span class="keyword">null</span>) &#123;  </span><br><span class="line">               longt0 = System.nanoTime();  </span><br><span class="line">               <span class="keyword">try</span> &#123;  <span class="comment">//然后委托给父类加载器进行加载</span></span><br><span class="line">                   <span class="keyword">if</span> (parent !=<span class="keyword">null</span>) &#123;  </span><br><span class="line">                       c = parent.loadClass(name,<span class="keyword">false</span>);  (<span class="number">2</span>)</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果父类加载器为null,则委托给BootStrap加载器加载</span></span><br><span class="line">                       c = findBootstrapClassOrNull(name);  (<span class="number">3</span>)</span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundExceptione) &#123;  </span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found  </span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader  </span></span><br><span class="line">               &#125;  </span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c ==<span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">// 若仍然没有找到则调用findclass查找</span></span><br><span class="line">                   <span class="comment">// to find the class.  </span></span><br><span class="line">                   longt1 = System.nanoTime();  </span><br><span class="line">                   c = findClass(name);  (<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats  </span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 -t0);  </span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">               resolveClass(c);  <span class="comment">//（5）</span></span><br><span class="line">           &#125;  </span><br><span class="line">           returnc;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码（1）表示从 JVM 缓存查找该类，如果该类之前被加载过，则直接从 JVM 缓存返回该类。</p>
<p>代码（2）表示如果 JVM 缓存不存在该类，则看当前类加载器是否有父加载器，若有则委托父类加载器进行加载，否者调用（3），委托 BootStrapClassloader 进行加载，如果还是没有找到，则调用当前 Classloader 的 findclass 方法进行查找。</p>
<p>代码（5）则是当字节码加载到内存后进行链接操作，对文件格式和字节码验证，并为 static 字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等。</p>
<p>从上面源码知道要想修改类加载委托机制，实现自己的载入策略，可以通过覆盖 ClassLoader 的 findClass 方法或者覆盖 loadClass 方法来实现。</p>
<h3 id="为什么要使用委托加载机制"><a href="#为什么要使用委托加载机制" class="headerlink" title="为什么要使用委托加载机制?"></a>为什么要使用委托加载机制?</h3><ol>
<li><p>避免重复加载，当父类加载器已经加载了该类的时候，就没有必要子 ClassLoader 再加载一次。</p>
</li>
<li><p>Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，存放于rt.jar中，无论哪一个类加载器要去加载这个类，最终都是由Bootstrap ClassLoader去加载，因此Object类在程序的各种类加载器环境中都是一个类。相反，如果没有双亲委派模型，由各个类自己去加载的话，如果用户自己编写了一个java.lang.Object，并放在CLASSPATH下，那系统中将会出现多个不同的Object类，Java体系中最基础的行为也将无法保证，应用程序也将会变得一片混乱。</p>
</li>
</ol>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明 第六章、第七章<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html</a><br><a href="http://www.infoq.com/cn/articles/cf-Java-class-loader" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/cf-Java-class-loader</a><br><a href="http://ifeve.com/jvm-classloader/" target="_blank" rel="noopener">http://ifeve.com/jvm-classloader/</a><br><a href="https://gitbook.cn/books/5a7719e7367c47172bea2b53/index.html" target="_blank" rel="noopener">https://gitbook.cn/books/5a7719e7367c47172bea2b53/index.html</a><br><a href="http://www.cnblogs.com/xrq730/p/4845144.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4845144.html</a><br><a href="http://www.cnblogs.com/xrq730/p/4844915.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4844915.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
        <tag>类加载</tag>
        <tag>classLoder</tag>
        <tag>JVM</tag>
        <tag>类的生命周期</tag>
        <tag>双亲委派模型</tag>
        <tag>委托机制</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题解决</title>
    <url>/2018/06/13/cross-domain-solution/</url>
    <content><![CDATA[<h2 id="一、跨域的由来"><a href="#一、跨域的由来" class="headerlink" title="一、跨域的由来"></a>一、跨域的由来</h2><p>为了保证用户信息的安全，防止恶意的网站窃取数据，目前，所有浏览器都实行了同源策略，要求域名、协议、端口必须都相同才属于同源，只有同源才可以访问其他页面的对象，否则将受到以下限制：</p>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p>
<a id="more"></a>

<h2 id="二、微服务之后跨域问题更普遍存在"><a href="#二、微服务之后跨域问题更普遍存在" class="headerlink" title="二、微服务之后跨域问题更普遍存在"></a>二、微服务之后跨域问题更普遍存在</h2><p>在现在前后端分离，分布式服务、微服务化之后，我们将复杂的业务拆分成细小的服务组件，部署到不同的主机下，往往存在不同的域名。因此，跨域问题，就更普遍存在了。</p>
<h2 id="三、跨域问题解决方法"><a href="#三、跨域问题解决方法" class="headerlink" title="三、跨域问题解决方法"></a>三、跨域问题解决方法</h2><h3 id="1-使用代理页面实现跨域"><a href="#1-使用代理页面实现跨域" class="headerlink" title="1. 使用代理页面实现跨域"></a>1. 使用代理页面实现跨域</h3><p>该方法可以解决所有跨域获取 DOM，跨域调用 js方法等，如刷新父级页面、关闭窗口等。典型的例子就如iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信的问题。常见报错：</p>
<p><img src="/images/2018061301.png" alt=""></p>
<p><strong>实现原理：</strong>在目标页面 A 的同级目录下新建一个代理页面 spyA，然后在调用的页面中通过 iframe 加载代理页面 spyA ，使它在加载的过程中被执行，而且它与目标页面是同源的，所以不存在跨域问题，可以利用这个代理页面避开跨域访问问题，在代理页面可以获取DOM及执行函数等操作。（我喜欢把这个代理页面称为间谍页面，你可以通过这个间谍页面做一些无法直接做到的事情）</p>
<p><strong>A.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> main window <span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>    </span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span></span><br><span class="line">    /**</span><br><span class="line"><span class="actionscript">     *to <span class="keyword">do</span> something you want <span class="keyword">in</span> here</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    $(<span class="string">"#btn"</span>).val(<span class="string">"really?"</span>);  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A.html main<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"I am a Butten"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1/B.html"</span> <span class="attr">name</span>=<span class="string">"myframe"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>B.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> iframe window,Open in A.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>  </span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">callSpyA</span><span class="params">()</span></span>&#123;  </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(exec_obj)==<span class="string">'undefined'</span>)&#123;  </span></span><br><span class="line"><span class="javascript">        exec_obj = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </span></span><br><span class="line"><span class="actionscript">        exec_obj.name = <span class="string">'tmp_frame'</span>;  </span></span><br><span class="line"><span class="actionscript">        exec_obj.src = <span class="string">'http://localhost:8080/spyA.html'</span>;  </span></span><br><span class="line"><span class="actionscript">        exec_obj.style.display = <span class="string">'none'</span>;  </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(exec_obj);  </span></span><br><span class="line"><span class="actionscript">    &#125;<span class="keyword">else</span>&#123;  </span></span><br><span class="line"><span class="javascript">        exec_obj.src = <span class="string">'http://localhost:8080/spyA.html?'</span> + <span class="built_in">Math</span>.random();  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>B.html iframe<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"exec main function"</span> <span class="attr">onclick</span>=<span class="string">"callSpyA()"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>


<p><strong>spyA.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> spy page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个代理页面，用于代替完成一些受跨域限制无法直接做到的事情  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">       <span class="comment">&lt;!-- do something --&gt;</span></span></span></span><br><span class="line">        parent.parent.doSomething(); </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>
### 2.使用 window.postMessage 方法实现跨域

<p>HTML5 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p><strong>实现原理：</strong>是通过 message 事件监听对方消息， 当需要跨域调用时，直接通 window.postMessage 发送通知， 然后目标页面监听到消息后在监听方法里面做一些操作。（通过 window.postMessage 还读写其他窗口的 LocalStorage）</p>
<p><strong>A.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;    </span></span><br><span class="line"><span class="actionscript">                <span class="comment">// event.origin属性可以过滤不是发给本窗口的消息 </span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (event.origin == <span class="string">'http://a.com'</span>)   </span></span><br><span class="line">               /**</span><br><span class="line"><span class="actionscript">                  *to <span class="keyword">do</span> something you want <span class="keyword">in</span> here</span></span><br><span class="line">                */</span><br><span class="line"><span class="actionscript">                    alert(event.data); <span class="comment">//输出：Hello   </span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>


<p><strong>B.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://a.com/A.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow.postMessage(<span class="string">'Hello'</span>,      <span class="string">"http://a.com"</span>);    </span></span><br><span class="line">            &#125;;    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<br/>
### 3. 通过 搭建中间转发层 或者 Nginx 反向代理 实现跨域

<p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>
<p>但是由于同源策略只是对浏览器的一种安全策略，所以我们可以绕过浏览器实现跨域，通过搭建中间层在服务端转发前端请求到真正的目的地址，或者通过 Niginx 反响代理，利用Nginx解析URL地址的时候进行判断，将请求转发的具体的服务器上。</p>
<p><img src="/images/2018061302.png" alt=""></p>
<br/>
### 4. 通过 CORS 实现跨域
CORS 全称为 Cross Origin Resource Sharing（跨域资源共享），CORS 支持所有类型的 HTTP 请求，CORS 需要浏览器和服务器同时支持，但是整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，但用户不会有感觉。因此，实现 CORS 通信的关键是服务端。服务端只需添加相关响应头信息，即可实现客户端发出 AJAX 跨域请求。

<p>值得高心的是， SpringMVC 4.2 中已经增加了增加 CORS 的支持，通过 @CrossOrigin 注解可以轻松实现跨域，可以加在整个 controller 上，也可以单独加在某个方法前面。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(<span class="string">"http://crazyfzw.com"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"toList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toList</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">	String rfUrl = PropertiesUtil.getSystem(<span class="string">"edrfUrl"</span>);</span><br><span class="line">	request.setAttribute(<span class="string">"rfUrl"</span>,rfUrl);</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">"/web/workforminfo/workforminfo_list"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br/>
## 四、参考文献：   

<p>1.<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></p>
<p>2.<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p>
<p>3.<a href="https://blog.csdn.net/isea533/article/details/50449907" target="_blank" rel="noopener">Spring MVC 4.2 增加 CORS 支持</a></p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>浏览器跨域</tag>
        <tag>cross-origin</tag>
        <tag>postMessage</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储 3：分库与分表</title>
    <url>/2018/07/29/database-sharding/</url>
    <content><![CDATA[<h2 id="一、分库与分表是为了解决什么问题（目的）"><a href="#一、分库与分表是为了解决什么问题（目的）" class="headerlink" title="一、分库与分表是为了解决什么问题（目的）"></a>一、分库与分表是为了解决什么问题（目的）</h2><p>随着业务的增长，表数据的增加，查询一次所消耗的时间会变得越来越长，甚至会造成数据库的单点压力。当数据库已经成为系统性能的瓶颈，这时，通过分库分表，可以减小数据库的单库单表负担，提高查询性能，缩短查询时间，从而提升系统的响应速度。</p>
<a id="more"></a>


<h2 id="二、分库分表方案应该尽量避免的两个问题"><a href="#二、分库分表方案应该尽量避免的两个问题" class="headerlink" title="二、分库分表方案应该尽量避免的两个问题"></a>二、分库分表方案应该尽量避免的两个问题</h2><ol>
<li>数据迁移</li>
<li>热点数据</li>
</ol>
<h2 id="三、垂直拆分"><a href="#三、垂直拆分" class="headerlink" title="三、垂直拆分"></a>三、垂直拆分</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块以及表的相关性来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</p>
<p>比如以一个订单系统吧为例：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。如下图：</p>
<p><img src="/images/2018073001.png" alt=""></p>
<p><strong>小结：</strong></p>
<p>数据库的 CPU、内存、磁盘 IO 、连接资源、网络带宽都是有限的，所以单个物理机上容易出现资源竞争和性能瓶颈。通过垂直分库，一方面，可以解决数据库单点压力过大的问题，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。另一方面，数据库层面的拆分们也有利于我们针对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。因此，垂直分库是大型分布式系统中优化数据库架构的重要手段。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>垂直分表在日常开发和设计中比较常见。垂直拆分，其实就是“大表拆小表”，把表的列字段进行拆分，即一张字段比较多的表拆分为多张表，这样使得行数据变小。一方面，可以减少客户端程序和数据库之间的网络传输的字节数，因为生产环境共享同一个网络带宽，随着并发查询的增多，有可能造成带宽瓶颈从而造成阻塞。另一方面，一个数据块能存放更多的数据，在查询时就会减少 I/O 次数。</p>
<p>通常就是建立“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：</p>
<p><img src="/images/2018073002.png" alt=""></p>
<p><strong>拆分策略：</strong></p>
<ol>
<li><p>将不常用的字段单独拆分到另外一张扩展表，例如前面讲解到的用户家庭地址，这个字段是可选字段，在数据库操作的时候除了个人信息外，并不需要经常读取或是更改这个字段的值。</p>
</li>
<li><p>将大文本的字段单独拆分到另外一张扩展表，例如 BLOB 和 TEXT 字符串类型的字段，以及 TINYBLOB、 MEDIUMBLOB、 LONGBLOB、 TINYTEXT、 MEDIUMTEXT、 LONGTEXT字符串类型。这样可以减少客户端程序和数据库之间的网络传输的字节数。</p>
</li>
<li><p>将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。举个例子，假设用户表的设计中，还存在“最后登录时间”字段，每次用户登录时会被更新。这张用户表会存在频繁的更新操作，此外，每次更新时会导致该表的查询缓存被清空。所以，可以把这个字段放到另一个表中，这样查询缓存会增加很多性能。对于需要经常关联查询的字段，建议放在同一张表中。不然在联合查询的情况下，会带来数据库额外压力。</p>
</li>
</ol>
<p><strong>小结：</strong></p>
<p>拆分字段的操作应该在数据库表设计阶段就做好。尽量避免在发展过程中做垂直分表，因为做字段拆分后，需要改以前的映射实体以及查询语句，会额外带来一定的成本和风险。</p>
<h2 id="四、水平拆分"><a href="#四、水平拆分" class="headerlink" title="四、水平拆分"></a>四、水平拆分</h2><p>垂直拆分只是解决了单库压力的问题。依然可能存在单表数据量过大影响查询性能的问题。若确实存在，则这时就应该考虑水平拆分。</p>
<p>水平分表也称为横向分表，是一种把单表按某个规则把数据分散到多个表的拆分方式，以此来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。</p>
<p>如下图所示：比如：把单表1亿数据按某个规则拆分，分别存储到10个相同结果的表，每个表的数据是1千万，拆分出来的表，可以综合实际情况考虑是放在同一个库中，还是分别放至到不同数据库中，即同时进行水平拆库操作，如下图所示：</p>
<p><img src="/images/2018073003.png" alt=""></p>
<p><strong>水平分表策略</strong></p>
<p>常见的水平分表策略归纳起来，可以总结为随机分表和连续分表两种情况。例如，取模切分、Hash切分就属于随机分表，而按时间维度切分、ID 范围切分则属于连续分表。</p>
<h3 id="连续切分（范围切分）"><a href="#连续切分（范围切分）" class="headerlink" title="连续切分（范围切分）"></a>连续切分（范围切分）</h3><p>连续分表可以快速定位到表进行高效查询，大多数情况下，可以有效避免跨表查询。如果想扩展，只需要添加额外的分表就可以了，无需对其他分表的数据进行数据迁移。但是，连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。</p>
<p>比如按照时间区间或ID区间来切分：</p>
<p><img src="/images/2018073004.png" alt=""></p>
<p>优点：单表大小可控，天然水平扩展。<br>缺点：无法解决集中写入瓶颈的问题，可能存在热点数据问题。</p>
<h3 id="随机切分（Hash切分、取模切分）"><a href="#随机切分（Hash切分、取模切分）" class="headerlink" title="随机切分（Hash切分、取模切分）"></a>随机切分（Hash切分、取模切分）</h3><p>随机分表是遵循规则策略进行写入与读取，而不是真正意义上的随机。通常，采用取模分表或者自定义 Hash 分表的方式进行水平拆分。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。此外，随机分表比较容易面临跨表查询的复杂问题。</p>
<p>比如以下取模切分：</p>
<p><img src="/images/2018073005.png" alt=""></p>
<p>后面这里需要再结合案例展开详细写。</p>
<p>优点：不存在热点数据问题，不存在几种写入瓶颈问题。<br>缺点：再次扩展难度增大，需要迁移旧数据。</p>
<p><strong>小结：</strong></p>
<p>水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，通常做法是把拆分后的表放到不同的库中。但这也涉及一个成本问题，需要综合考虑实际的访问量、并发数、未来可预见的一段时间的业务增长量、以及成本。</p>
<p>水平拆分可以降低单表数据量，让每个单表的数据量保持在一定范围内，从而提升单表读写性能。但水平拆分后，同一业务数据分布在不同的表或库中，可能需要把单表事务改成跨表事务，需要转变数据统计方式等。</p>
<h2 id="五、垂直水平拆分混合"><a href="#五、垂直水平拆分混合" class="headerlink" title="五、垂直水平拆分混合"></a>五、垂直水平拆分混合</h2><p>垂直水平拆分，是综合了垂直和水平拆分方式的一种混合方式。首先，按业务及表的相关性垂直分库（垂直切分），划分出不同的库，然后再挑选出数据量大、增长迅猛的表进行水平分表（水平切分）。</p>
<p>比如针对一个订单系统的垂直水平拆分如下：</p>
<p><img src="/images/2018073006.png" alt=""></p>
<p><strong>小结：</strong></p>
<p>需要注意的是，水平拆分的表需要放到不同的数据库才能减少数据库的但点压力，但是考虑到成本和后期的管理维护问题，现实情况，往往不会弄单库单表的情况（除非真的必要）。</p>
<p>为了提示机器的利用率，在水平切分完成后可再进行一次“反向的Merge”,即：将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个分片放到同一个数据库上，在逻辑上它们依然是独立的分片，有各自的主表，并且提升了数据库服务器的利用率。</p>
<p>整个过程可以参考下图：</p>
<p><img src="/images/2018073007.png" alt=""></p>
<h2 id="六、分库分表实践案例"><a href="#六、分库分表实践案例" class="headerlink" title="六、分库分表实践案例"></a>六、分库分表实践案例</h2><p>下面是唯品会以及美团点评对订单系统的分库分表，个人觉得比较有参考意义。具体详情可参考原文。</p>
<h3 id="唯品会的订单分库分表实践总结以及关键步骤"><a href="#唯品会的订单分库分表实践总结以及关键步骤" class="headerlink" title="唯品会的订单分库分表实践总结以及关键步骤"></a>唯品会的订单分库分表实践总结以及关键步骤</h3><p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p>
<h3 id="大众点评订单系统分库分表实践"><a href="#大众点评订单系统分库分表实践" class="headerlink" title="大众点评订单系统分库分表实践"></a>大众点评订单系统分库分表实践</h3><p>原文地址：<a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p>
<h3 id="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"><a href="#阿里一种可以避免数据迁移的分库分表scale-out扩容方式" class="headerlink" title="阿里一种可以避免数据迁移的分库分表scale-out扩容方式"></a>阿里一种可以避免数据迁移的分库分表scale-out扩容方式</h3><p>文章地址：<a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p>
<br/>
## 七、分库分表带来的问题以及对应的解决办法

<h3 id="1-表关联问题（跨库-Join）"><a href="#1-表关联问题（跨库-Join）" class="headerlink" title="1. 表关联问题（跨库 Join）"></a>1. 表关联问题（跨库 Join）</h3><p>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。</p>
<p>基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。所以，在设计及拆分阶段应尽量避免出现跨库Join（将那些存在关联关系的表记录存放在同一个分片上）。若开发过程中还是出现了需要跨库查询的场景，则可以通过在程序中进行拼装解决（二次查询或者通过RPC调用来得到关联的数据,然后再进行拼装）。</p>
<p><strong>下面，提供几种跨库J oin的解决思路：</strong></p>
<p><strong>ER分片</strong><br>在关系型数据库中，表之间往往存在一些关联的关系。如果我们可以先确定好关联关系，在设计或拆分阶将那些存在关联关系的表记录存放在同一个分片上，那么就能很好的避免跨分片 join 问题。</p>
<p><strong>通过全局表进行规避</strong></p>
<p>比如“数据字典表”，这种系统中的所有模块都可能会用到的表，这类数据通常也很少发生修改（甚至几乎不会），也不用太担心“一致性”问题。所以可以将这类表在每个数据库中均保存一份，以此来了避免跨库join查询。这种表，可以称之为全局表。</p>
<p><strong>通过反范式化设计进行规避</strong></p>
<p>可以通过个别字段的冗余来避免跨库join查询，这是一种典型的反范式设计。</p>
<p>举个电商业务中很简单的场景：</p>
<p>“订单表”中保存 “卖家Id” 的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。单这也存在一个问题，比如卖家修改了Name之后，是否需要在订单信息中同步更新呢？</p>
<p>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。另一方面，这种方式存在数据一致性问题，如果业务对数据一致性强要求，那就需要通过额外的手段来保证（比如可以借助数据库中的触发器或者在业务代码层面去保证）。</p>
<p><strong>通过在系统层二次查询组装解决</strong></p>
<p>可以在程序中通过或者通过RPC调用来得到关联的数据，从而避免跨库join查询。需要特别注意的是，这里的二次查询或者通过RPC调用最好不要放在循环中去执行，否则效率会很低，甚至会严重影响系统的性能。</p>
<p>通常的做法是把循环调用改成一次调用，一次取出所有关联的数据，然后再进行组装。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> QuestionResponse <span class="title">GetOrderList</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	QuestionResponse response = <span class="keyword">new</span> QuestionResponse();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取基本结构集</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Order&gt; result =  orderServer.getOrderList();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	List&lt;Long&gt; productIds = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Order order : result) &#123;			</span><br><span class="line">		productIds.add(order.getProductId());			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 传入关联数据的ID集合，一次查询出所有关联数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;Product&gt; productList =  productServer.getOrderList(productIds);</span><br><span class="line">	<span class="keyword">for</span> (Order order : result) &#123;			</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 匹配数据，并赋值		</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	response.setResult(result);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<p>简单字段组装的情况下，我们只需要先获取“主表”数据，然后再根据关联关系，调用其他模块的组件或服务来获取依赖的其他字段（如例中依赖的用户信息），最后将数据进行组装。</p>
<p>通常，我们都会通过缓存来避免频繁RPC通信和数据库查询的开销。</p>
<h3 id="2-分页与排序问题（limit、order-by）"><a href="#2-分页与排序问题（limit、order-by）" class="headerlink" title="2. 分页与排序问题（limit、order by）"></a>2. 分页与排序问题（limit、order by）</h3><p>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p>
<p>如下图所示取第一页数：</p>
<p><img src="/images/2018073008.png" alt=""></p>
<p>上图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="/images/2018073009.png" alt=""></p>
<p>那为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差（典型的大分页问题，比如搜索引擎结果页中，越往后翻响应越慢）。</p>
<h3 id="3-跨分片的函数处理-Count、Max、Min、Sum"><a href="#3-跨分片的函数处理-Count、Max、Min、Sum" class="headerlink" title="3. 跨分片的函数处理(Count、Max、Min、Sum)"></a>3. 跨分片的函数处理(Count、Max、Min、Sum)</h3><p>在使用Max、Min、Sum、Count之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：</p>
<p><img src="/images/2018073010.png" alt=""></p>
<h3 id="4-分布式事务问题"><a href="#4-分布式事务问题" class="headerlink" title="4. 分布式事务问题"></a>4. 分布式事务问题</h3><p>按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。以往在代码中通过spring注解简单配置就能实现事务，现在则需要花很大的成本去保证一致性。后面会单独写一篇文章展开讲。</p>
<h3 id="5-分布式全局唯一ID"><a href="#5-分布式全局唯一ID" class="headerlink" title="5. 分布式全局唯一ID"></a>5. 分布式全局唯一ID</h3><p><a href="https://crazyfzw.github.io/2018/07/21/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-2%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/#more">分布式系统全局唯一ID生成方案</a></p>
<h2 id="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"><a href="#八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）" class="headerlink" title="八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）"></a>八、如何考虑是否需要分库分表（我们的系统真的需要分库分表吗）</h2><p>分库与分表主要用于应对当前互联网常见的两个场景：海量数据和高并发。但是分库分表同时也提高了系统的复杂度以及维护成本。分库与分表是一把双刃剑，因此，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑通过分库与分表提高系统的性能。</p>
<p>一般表数据在1000W以内都不需要考虑分表。分库分表时应考虑尽可能考虑可预见的几年内业务的增长，对数据库服务器的QPS、连接数、容量等做合理评估和规划。</p>
<h2 id="九、分库分表后如何迁移数据"><a href="#九、分库分表后如何迁移数据" class="headerlink" title="九、分库分表后如何迁移数据"></a>九、分库分表后如何迁移数据</h2><p>对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</p>
<h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><p>[1] <a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p>
<p>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486487&idx=1&sn=066c5c3366fe232776442f95024c4a1d&chksm=96c9ba77a1be3361cd42ca0bd1e0e55e63f95160c1517855470fffe8e3d8b2ade1e7323aaf3f&scene=27#wechat_redirect" target="_blank" rel="noopener">唯品会的订单分库分表实践总结以及关键步骤</a></p>
<p>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486426&idx=1&sn=20e965a30c59613b5b11e42e004d2445&chksm=96c9bdbaa1be34ac8d25637272287da249fe2cb804315e2fc73f87d770dd7a41fdb286fa114e&scene=27#wechat_redirect" target="_blank" rel="noopener">分库分表的几种常见形式以及可能遇到的难题</a></p>
<p>[4] <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486422&idx=1&sn=f6dd2a02c96bc3467de83bb34c87fe64&chksm=96c9bdb6a1be34a0e5c218d4143a05d04404d1515a972b642c447967847c3dac58eb59f4742f&scene=27#wechat_redirect" target="_blank" rel="noopener">水平分库分表的关键步骤以及可能遇到的问题</a></p>
<p>[5] <a href="https://blog.csdn.net/clypm/article/details/51722209" target="_blank" rel="noopener">一种可以避免数据迁移的分库分表scale-out扩容方式</a></p>
<p>[6] <a href="http://jm.taobao.org/%2F2017%2F01%2F19%2F20170119%2F" target="_blank" rel="noopener">阿里巴巴分布式数据库服务DRDS研发历程</a></p>
<p>[7] <a href="https://help.aliyun.com/product/29657.html?spm=a2c4g.11186623.6.540.43ee6b20kxutaK" target="_blank" rel="noopener">阿里的分布式数据库DRDS</a></p>
<p>[8] <a href="https://juejin.im/post/5992b2f8f265da3e185eb75d" target="_blank" rel="noopener">贝聊通过DRDS实现亿级数据库分库分表实践</a></p>
<p>[9] <a href="http://blog.720ui.com/2017/mysql_core_08_multi_db_table/" target="_blank" rel="noopener">分库与分表设计</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
        <tag>分库分表</tag>
        <tag>垂直分库</tag>
        <tag>水平分表</tag>
        <tag>垂直拆分</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo篇之(一)：实现原理及架构详解</title>
    <url>/2018/06/10/dubbo-architecture/</url>
    <content><![CDATA[<h2 id="一、Dubbo-的由来及解决的问题"><a href="#一、Dubbo-的由来及解决的问题" class="headerlink" title="一、Dubbo 的由来及解决的问题"></a>一、Dubbo 的由来及解决的问题</h2><p>随着互联网的发展，市场需求快速变更，业务持续高速增长，网站早已从单一应用架构演变为分布式服务架构及流动计算架构。</p>
<p><img src="/images/2018061001.png" alt=""></p>
<a id="more"></a>


<p>业界出现了一些比较流行的 RPC 框架，如 Apache Thrift、Hessian、gRPC 等。但是随着 RPC 框架的推广和使用的日益深入，服务越来越多,当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时衍生出一些新的需求：</p>
<p><strong>1. 依赖管理：</strong>当服务越来越多时，服务URL配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大，此时需要一个服务注册中心来管理服务的依赖关系，并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>2. 透明路由：</strong>通过订阅发布机制，消费只需要关系服务本身，并不需要配置具体的服务提供地址，实现服务的自动发现。动态的注册和发现服务，使服务的位置透明。</p>
<p><strong>3. 服务治理：</strong> 业务失败之后的放通处理，超时时间控制、流程等常用的因为功能，希望能够独立出一个服务治理中心，统一对集群各节点的服务做在线治理，提升治理效率.</p>
<p><strong>为了解决以上问题，Dubbo 应运而上，Dubbo 除了 RPC 功能,还提供了丰富的服务治理功能。</strong></p>
<p><strong>1. 透明化的远程方法调用，</strong>底层封装了 Java NIO 通信框架 Netty、序列化及反序列化框架、以及应用层提供线程池和消息调度，使业务可以快速的实现跨进程的远程通信，就像调用本地服务那样去调用远程服务，而不需要关系底层的通信细节，例如链路的闪断、失败重试等，极大的提高了应用的开发效率。</p>
<p><strong>2. 软负载均衡及容错机制，</strong>可以在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</p>
<p><strong>3. 服务自动注册与发现，</strong>基于服务注册中心的订阅发布机制，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的ip地址，并且能够平滑添加或删除服务提供者。 </p>
<p><strong>4. 服务治理，</strong>包括服务注册、服务降级、访问控制、动态配置路由规则、权重调节、负载均衡。</p>
<p><strong>5. Spring 框架无缝集成、</strong>配置化发布服务。</p>
<h2 id="二、Dubbo-的工作原理"><a href="#二、Dubbo-的工作原理" class="headerlink" title="二、Dubbo 的工作原理"></a>二、Dubbo 的工作原理</h2><p><img src="/images/2018061002.png" alt=""></p>
<h3 id="1-节点说明："><a href="#1-节点说明：" class="headerlink" title="1) 节点说明："></a>1) 节点说明：</h3><p>Provider：暴露服务的服务提供方<br>Consumer：调用远程服务的服务消费方<br>Registry：服务注册与发现的注册中心<br>Monitor： 统计服务的调用次数和调用时间的监控中心<br>Container：服务运行容器</p>
<h3 id="2-调用过程及工作原理："><a href="#2-调用过程及工作原理：" class="headerlink" title="2) 调用过程及工作原理："></a>2) 调用过程及工作原理：</h3><p><strong>0.</strong> 服务容器负责启动，加载，运行服务提供者，通过 main 函数初始化 Spring 上下文，根据服务提供者配置的XML文件将服务按照指定的协议发布，完成服务化的初始化工作。。</p>
<p><strong>1.</strong> 服务提供者在启动时，根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到注册中心，向注册中心注册自己提供的服务。</p>
<p><strong>2.</strong> 服务消费者在启动时，消费者根据服务消费者XML配置文件的服务引用信息，连接到注册中心，向注册中心订阅自己所需的服务。</p>
<p><strong>3.</strong> 服务注册中心根据服务订阅的关系，返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送最新的服务地址信息给消费者。</p>
<p><strong>4.</strong> 服务消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择选一台提供者进行，然后根据协议类型建立链路，跨进程调用服务提供者，如果调用失败，再选另一台调用。</p>
<p><strong>5.</strong> 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="三、Dubbo-的实现原理-基本设计原则"><a href="#三、Dubbo-的实现原理-基本设计原则" class="headerlink" title="三、Dubbo 的实现原理(基本设计原则)"></a>三、Dubbo 的实现原理(基本设计原则)</h2><p><strong>1.</strong> 为了保持极强的扩展性，Dubbo 一开始就使用 Microkernel + Plugin （微核心+插件）的设计模式，Microkernel 只负责组装 Plugin，Dubbo 通过利用并改进JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制实现自身的大部分功能(除 Service 和 Config 层为API)。采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息，基于扩展点自适应机制，根据URL中的配置信息，在链的最后一节调用真实的引用，所以Dubbo天生就具有极强的灵活的拓展性。</p>
<p><strong>2.</strong> 从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。</p>
<h2 id="四、Dubbo-的架构与设计"><a href="#四、Dubbo-的架构与设计" class="headerlink" title="四、Dubbo 的架构与设计"></a>四、Dubbo 的架构与设计</h2><p>Dubbo 最大的特点是按照分层的方式来架构，将整个框架分为10层，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。</p>
<p>整体分层设计：</p>
<p><img src="/images/2018061003.png" alt=""></p>
<p>Dubbo框架设计一共划分了10个层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI；最上面的 Service 层是留给实际想要使用 Dubbo 开发分布式服务的开发者实现业务逻辑的接口层；图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</p>
<ol>
<li><p>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</p>
</li>
<li><p>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心，可以直接 new 配置类，也可以通过 spring 解析配置生成配置类。</p>
</li>
<li><p>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory。</p>
</li>
<li><p>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为 RegistryFactory、Registry 和 RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。</p>
</li>
<li><p>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为 Cluster、Directory、Router 和 LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</p>
</li>
<li><p>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService。</p>
</li>
<li><p>远程调用层（Protocol）：封将 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocol、Invoker 和 Exporter。Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker  的生命周期管理。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>
</li>
<li><p>信息交换层（Exchange）：封装请求响应模式，同步转异步，以 Request 和 Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer。</p>
</li>
<li><p>网络传输层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec。</p>
</li>
<li><p>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、 ObjectInput、ObjectOutput和ThreadPool。</p>
</li>
</ol>
<p>从上图可以看出，Dubbo 对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口。根据官方提供的，对于上述各层之间关系的描述，如下所示：</p>
<p>  ● 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</p>
<p>  ● 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</p>
<p>  ● 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p>
<p>  ● Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</p>
<p>  ● 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p>
<p>  ● Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</p>
<h2 id="五、Dubbo的缺点"><a href="#五、Dubbo的缺点" class="headerlink" title="五、Dubbo的缺点"></a>五、Dubbo的缺点</h2><p>对语言的支持不友好，只支持JAVA语言。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a href="http://dubbo.apache.org/books/dubbo-user-book/" target="_blank" rel="noopener">dubbo-user-book</a><br><a href="http://dubbo.apache.org/books/dubbo-dev-book/" target="_blank" rel="noopener">dubbo-dev-book</a><br><a href="http://shiyanjun.cn/archives/325.html" target="_blank" rel="noopener">Dubbo架构设计详解</a><br><a href="http://jm.taobao.org/categories/Dubbo/" target="_blank" rel="noopener">阿里中间件团队博客-Dubbo分类</a></p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>Dubbo实现原理</tag>
        <tag>Dubbo架构</tag>
        <tag>Microkernel + Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 提交代码到远程仓库</title>
    <url>/2017/12/20/git-1/</url>
    <content><![CDATA[<h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><h3 id="一、Git如何把本地代码推送到远程仓库"><a href="#一、Git如何把本地代码推送到远程仓库" class="headerlink" title="一、Git如何把本地代码推送到远程仓库"></a>一、Git如何把本地代码推送到远程仓库</h3><h4 id="1-拉取指定分支代码"><a href="#1-拉取指定分支代码" class="headerlink" title="1. 拉取指定分支代码"></a>1. 拉取指定分支代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b dev https:&#x2F;&#x2F;github.com&#x2F;crazyfzw&#x2F;RecycleViewWithHeader.git</span><br></pre></td></tr></table></figure>


<h4 id="2-初始化版本库"><a href="#2-初始化版本库" class="headerlink" title="2. 初始化版本库"></a>2. 初始化版本库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h4 id="3-添加文件到版本库（只是添加到缓存区）-代表添加文件夹下所有文件"><a href="#3-添加文件到版本库（只是添加到缓存区）-代表添加文件夹下所有文件" class="headerlink" title="3. 添加文件到版本库（只是添加到缓存区） .代表添加文件夹下所有文件"></a>3. 添加文件到版本库（只是添加到缓存区） .代表添加文件夹下所有文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h4 id="4-把添加的文件提交到版本库，并填写提交备注"><a href="#4-把添加的文件提交到版本库，并填写提交备注" class="headerlink" title="4. 把添加的文件提交到版本库，并填写提交备注"></a>4. 把添加的文件提交到版本库，并填写提交备注</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m  &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
<p><em>到目前为止，已经完成了本地代码库的初始化，但是还没有提交到远程服务器，所以关键的来了，要提交到就远程代码服务器，进行以下两步：</em></p>
<a id="more"></a>

<h4 id="5-把本地库与远程库关联"><a href="#5-把本地库与远程库关联" class="headerlink" title="5. 把本地库与远程库关联"></a>5. 把本地库与远程库关联</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 你的远程库地址</span><br></pre></td></tr></table></figure>
<h4 id="6-推送代码到远程仓库（-第一次推送时）"><a href="#6-推送代码到远程仓库（-第一次推送时）" class="headerlink" title="6. 推送代码到远程仓库（ 第一次推送时）"></a>6. 推送代码到远程仓库（ 第一次推送时）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h4 id="7-推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）"><a href="#7-推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）" class="headerlink" title="7. 推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）"></a>7. 推送代码到远程仓库（第一次推送后，直接使用该命令即可推送修改）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<a id="more"></a>


<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>2016秋招笔试面试题二：Android及网络协议部分</title>
    <url>/2016/12/31/interview-1/</url>
    <content><![CDATA[<h1 id="一、Android基础"><a href="#一、Android基础" class="headerlink" title="一、Android基础"></a><strong>一、Android基础</strong></h1><h2 id="1-Android四大组件的理解"><a href="#1-Android四大组件的理解" class="headerlink" title="1.Android四大组件的理解"></a><strong>1.Android四大组件的理解</strong></h2><p><strong>Activity：</strong>从字面上理解，Activity是活动的意思。一个Activity通常展现为一个可视化的用户界面，是Android程序与用户交互的窗口，也是Android组件中最基本也是最复杂的一个组件。从视觉效果来看，一个Activity占据当前的窗口，响应所有窗口事件，具备有控件，菜单等界面元素。从内部逻辑来看，Activity需要为了保持各个界面状态，需要做很多持久化的事情，还需要妥善管理生命周期，和一些转跳逻辑。</p>
<a id="more"></a>


<p><strong>Service：</strong>服务是运行在后台的一个组件，从某从意义上说，服务就像一个没有界面的Activity。它们在很多Android的概念方面比较接近，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事件，定义好需要接受的Intent提供同步和异步的接口。</p>
<p><strong>BroadcastReceiver：</strong>广播接收者，不执行任何任务，广播是一种广泛运用的在应用程序之间传输信息的机制 。而 BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件。Broadcast Receiver 不包含任何用户界面。然而它们可以启动一个Activity以响应接受到的信息，或者通过NotificationManager通知用户。可以通过多种方式使用户知道有新的通知产生：闪动背景灯、震动设备、发出声音等等。通常程序会在状态栏上放置一个持久的图标，用户可以打开这个图标并读取通知信息。在Android中还有一个很重要的概念就是Intent，如果说Intent是一个对动作和行为的抽象描述，负责组件之间程序之间进行消息传递。那么Broadcast Receiver组件就提供了一种把Intent作为一个消息广播出去，由所有对其感兴趣的程序对其作出反应的机制。</p>
<p><strong>Content Provider：</strong>即内容提供者，作为应用程序之间唯一的共享数据的途径，Content Provider 主要的功能就是存储并检索数据以及向其他应用程序提供访问数据。<br>对应用而言，也可以将底层数据封装成ContentProvider，这样可以有效的屏蔽底层操作的细节，并且使程序保持良好的扩展性和开放性。Android提供了一些主要数据类型的Contentprovider，比如音频、视频、图片和私人通讯录等。可在android.provider包下面找到一些android提供的Contentprovider。可以获得这些Contentprovider，查询它们包含的数据，当然前提是已获得适当的读取权限。如果我们想公开自己应用程序的数据，可以创建自己的 Content provider 的接口。</p>
<h2 id="2-Activity的生命周期"><a href="#2-Activity的生命周期" class="headerlink" title="2.Activity的生命周期"></a><strong>2.Activity的生命周期</strong></h2><p><img src="http://img.blog.csdn.net/20161231134946734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">        </p>
<h2 id="3-activity的onCreat-方法参数的作用"><a href="#3-activity的onCreat-方法参数的作用" class="headerlink" title="3.activity的onCreat()方法参数的作用"></a><strong>3.activity的onCreat()方法参数的作用</strong></h2><p>onCreate方法的参数是一个Bundle类型的参数，savedInstanceState也就是保存Activity的状态的,当<br>一个Activity在生命周期以不正常的状态结束前，会调用onsaveInstanceState该方法保存状态。</p>
<h2 id="4-AsyncTask-的使用"><a href="#4-AsyncTask-的使用" class="headerlink" title="4.AsyncTask 的使用"></a><strong>4.AsyncTask 的使用</strong></h2><p>为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它就可以非常灵活方便地从子线程切换到UI线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;  </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	        progressDialog.show();  </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Boolean <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">try</span> &#123;  </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">			<span class="keyword">int</span> downloadPercent = doDownload();  </span><br><span class="line">			publishProgress(downloadPercent);  </span><br><span class="line">			<span class="keyword">if</span> (downloadPercent &gt;= <span class="number">100</span>) &#123;  </span><br><span class="line">			    <span class="keyword">break</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	 &#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;  </span><br><span class="line">	        progressDialog.setMessage(<span class="string">"当前下载进度："</span> + values[<span class="number">0</span>] + <span class="string">"%"</span>);  </span><br><span class="line">	    &#125; </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onPostExecute</span><span class="params">(Boolean result)</span> </span>&#123;  </span><br><span class="line">	        progressDialog.dismiss();  </span><br><span class="line">	<span class="keyword">if</span> (result) &#123;  </span><br><span class="line">	            Toast.makeText(context, <span class="string">"下载成功"</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">	            Toast.makeText(context, <span class="string">"下载失败"</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>1) onPreExecute()</strong><br>这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。<br><strong>2)  doInBackground(Params…)</strong><br>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。<br><strong>3) onProgressUpdate(Progress…)</strong><br>当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。<br><strong>4) onPostExecute(Result)</strong><br>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。</p>
<p>详见：<a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="noopener">郭霖的AsyncTask完全解析</a></p>
<h2 id="5-IntentService与Service的异同"><a href="#5-IntentService与Service的异同" class="headerlink" title="5.IntentService与Service的异同"></a><strong>5.IntentService与Service的异同</strong></h2><p>IntentService是继承Service的，那么它包含了Service的全部特性，当然也包含service的生命周期，那么与service不同的是，IntentService在执行onCreate操作的时候，内部开了一个线程，去你执行你的耗时操作。</p>
<h2 id="6-IntentService-的使用"><a href="#6-IntentService-的使用" class="headerlink" title="6.IntentService 的使用"></a><strong>6.IntentService 的使用</strong></h2><p>IntentService是会自动开启子线程并会自动结束的Service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要一个无参数的构造方法，调用父类的带String参数的构造方法，参数是线程名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestIntentService</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	  <span class="keyword">super</span>(<span class="string">"TestIntentService"</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写IntentService的onHandleIntent，处理耗时的任务。这个方法是在单独线程中运行，而不是在主线程中，所以不会阻塞主线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">protectedvoid <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 耗时任务代码</span></span><br><span class="line">	    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>1) IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求。<br>2) 对于startService()请求执行onHandleIntent()中的耗时任务，会生成一个队列，每次只有一个Intent传入onHandleIntent()方法并执行。也就是同一时间只会有一个耗时任务被执行，其他的请求还要在后面排队， onHandleIntent()方法不会多线程并发执行。<br>3) 当所有startService()请求被执行完成后，IntentService 会自动销毁，所以不需要自己写stopSelf()或stopService()来销毁服务。<br>4) 提供默认的onBind()实现 ，即返回null，不适合绑定的 Service。<br>5) 提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</p>
<p>详见： 叉叉哥的IntentService 解析</p>
<h2 id="7-Android的几种数据存储方式"><a href="#7-Android的几种数据存储方式" class="headerlink" title="7.Android的几种数据存储方式"></a><strong>7.Android的几种数据存储方式</strong></h2><ul>
<li><p>SharePreferences</p>
</li>
<li><p>SQLite</p>
</li>
<li><p>Contert Provider</p>
</li>
<li><p>文件存储</p>
</li>
<li><p>网络数据库存储</p>
</li>
</ul>
<h2 id="8-SQLite数据库版本更新时如何避免数据丢失"><a href="#8-SQLite数据库版本更新时如何避免数据丢失" class="headerlink" title="8.SQLite数据库版本更新时如何避免数据丢失"></a><strong>8.SQLite数据库版本更新时如何避免数据丢失</strong></h2><p>随着应用的升级或者需求的变化，有时需要在原来的表的基础上增加字段，并且需要保证不丢失原来的数据。</p>
<p>其实SqliteOpenHelper的构造方法里有一个参数是int version, 意思是指当前数据库的版本。比如我们的1.0应用中数据库版本是1，当我们需要在2.0版本的应用中改变数据库（可能是增加一个字段，或者是删除一个字段等），我们就要设置int verison的值大于前面一个版本的数据库版本的值，例如改为2，就会触发onUpgrade()方法。所以，我们可以在onUpgrade()方法中进行更新数据库操作。</p>
<p>为了避免表结构改变而引起数据丢失，我们可以在改变表结构之前，通过建立临时表来处理。</p>
<p>那么可以采取在一个事务中执行如下语句来实现修改表的需求。<br><strong>1) 将表改为临时表</strong></p>
<p>ALTER TABLE User RENAME TO _TEMP_User;</p>
<p><strong>2) 创建新的表</strong></p>
<p>CREATE TABLE User (Userid text primary key not null, Sex text not null,Birthday text not null,Name text not null);</p>
<p><strong>3) 导入数据</strong></p>
<p>INSERT INTO User SELECT Userid,””,””,Name FROM TO_TEMP_User;</p>
<p>或者</p>
<p>INSERT INTO User() SELECT Userid,””,””,Name FROM TO_TEMP_User;<br>*注意，“”是用来补充原来不存在的数据的。</p>
<p><strong>4)  删除临时表</strong></p>
<p>DROP TABLE _TEMP_User;</p>
<p>详细可见：<a href="http://www.lai18.com/content/1369050.html" target="_blank" rel="noopener">http://www.lai18.com/content/1369050.html</a></p>
<h2 id="9-Android中，进程通讯-IPC-的方式有哪些"><a href="#9-Android中，进程通讯-IPC-的方式有哪些" class="headerlink" title="9.Android中，进程通讯(IPC)的方式有哪些"></a><strong>9.Android中，进程通讯(IPC)的方式有哪些</strong></h2><p>1)  Linux系统进程间通信有哪些方式？</p>
<ul>
<li><p>socket </p>
</li>
<li><p>name pipe命名管道</p>
</li>
<li><p>message queue消息队列     </p>
</li>
<li><p>singal信号量</p>
</li>
<li><p>share memory共享内存</p>
</li>
</ul>
<p>2) Java系统的通信方式是什么？</p>
<ul>
<li>socket  </li>
<li>name pipe</li>
</ul>
<p>3) Android系统通信方式是什么？<br> Binder 通信</p>
<p>Android进程间通信是通过Binder来实现的。远程Service在Client绑定服务时，会在onBind()的回调中返回一个Binder，当Client调用bindService()与远程Service建立连接成功时，会拿到远程Binder实例，从而使用远程Service提供的服务。</p>
<p>详细可见：<br><a href="http://gold.xitu.io/entry/570af83b8ac247004c31a130" target="_blank" rel="noopener">http://gold.xitu.io/entry/570af83b8ac247004c31a130</a></p>
<h2 id="9-Android中，线程通讯的几种方式"><a href="#9-Android中，线程通讯的几种方式" class="headerlink" title="9.Android中，线程通讯的几种方式  　"></a><strong>9.Android中，线程通讯的几种方式</strong>  　</h2><p>   　<br>    1)  handle</p>
<p>　　2)  Activity.runOnUIThread(Runnable)</p>
<p>　　3)  View.Post(Runnable)</p>
<p>　　4)  View.PostDelayed(Runnabe,long)</p>
<p>　　5)  AsyncTask<br>　　<br>　　6)IntentService：内部有handlethread，属于服务的一种执行完自动结束  优点：优先级高不易被杀死。</p>
<h1 id="二、协议"><a href="#二、协议" class="headerlink" title="二、协议"></a><strong>二、协议</strong></h1><h2 id="1-OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#1-OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="1.OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a><strong>1.OSI，TCP/IP，五层协议的体系结构，以及各层协议</strong></h2><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</p>
<p>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</p>
<p><strong>每一层的协议如下：</strong></p>
<ul>
<li><p>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） </p>
</li>
<li><p>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</p>
</li>
<li><p>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX</p>
</li>
<li><p>会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII</p>
</li>
<li><p>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS </p>
</li>
</ul>
<p><strong>每一层的作用如下：</strong></p>
<ul>
<li><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame）</p>
</li>
<li><p>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</p>
</li>
<li><p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</p>
</li>
<li><p>会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
</li>
<li><p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<p>注意：HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
</li>
</ul>
<p>详细可见：<br><a href="http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21189&amp;query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21189&amp;query=&amp;asc=true&amp;order=&amp;page=1</a></p>
<h2 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2.TCP和UDP的区别"></a><strong>2.TCP和UDP的区别</strong></h2><p>1) TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。</p>
<p>2) TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</p>
<p>3) TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</p>
<h2 id="3-TCP协议中的三次握手及四次挥手"><a href="#3-TCP协议中的三次握手及四次挥手" class="headerlink" title="3.TCP协议中的三次握手及四次挥手"></a><strong>3.TCP协议中的三次握手及四次挥手</strong></h2><p><strong>三次握手：</strong><br>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><strong>四次挥手</strong><br>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
<p>详细可见：<br><a href="http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21194&amp;query=&amp;asc=true&amp;order=&amp;page=6" target="_blank" rel="noopener">http://www.nowcoder.com/ta/review-network/review?tpId=33&amp;tqId=21194&amp;query=&amp;asc=true&amp;order=&amp;page=6</a></p>
<h2 id="4-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#4-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="4.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a><strong>4.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</strong></h2><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="5-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#5-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="5.在浏览器中输入www.baidu.com后执行的全部过程"></a><strong>5.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></strong></h2><p>1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
<p>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>android面试题</tag>
        <tag>秋招笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>2016秋招笔试面试题一：Java及基础部分</title>
    <url>/2016/12/30/interview-2/</url>
    <content><![CDATA[<h2 id="1-面向对象的特征"><a href="#1-面向对象的特征" class="headerlink" title="1.面向对象的特征"></a><strong>1.面向对象的特征</strong></h2><p><strong>1) 抽象：</strong> 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p> <strong>2) 继承：</strong> 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 </p>
<p><strong>3) 封装：</strong> 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<p> <strong>4) 多态性：</strong> 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。   </p>
<a id="more"></a>

 <br/> 
## **2.java和c++最大的区别**

<ul>
<li>内存管理 </li>
<li>指针</li>
</ul>
<h2 id="3-JAVA-中int和Integer的区别"><a href="#3-JAVA-中int和Integer的区别" class="headerlink" title="3.JAVA 中int和Integer的区别"></a><strong>3.JAVA 中int和Integer的区别</strong></h2><p>int是一种基本数据类型，而Integer是相应于int的类类型，称为对象包装。</p>
<p>Integer类在对象中包装了一个基本类型int的值。Integer类型的对象包含一个int类型的字段，Integer是int的封装类。<br>此外，该类提供了多个方法，能在int类型和String类型之间互相转换，还提供了处理int类型时非常有用的其他一些常量和方法。<br>详细可见：<a href="http://www.jianshu.com/p/4d6fc88f9458" target="_blank" rel="noopener">http://www.jianshu.com/p/4d6fc88f9458</a></p>
<br/>
## **4.Java的作用域**
**private** 私有权限。只有自己能用。
**friendly** 包权限。同一个包下的可用。不写时默认为friendly 
**protected** 继承权限。（是包权限的扩展，子女类也可使用）。
**public** 谁都可以用。
详细可见：
http://blog.csdn.net/ladofwind/article/details/774072

<br/> 
## **5.overload和override的区别**
**override：**（重写，会覆盖父类的方法，是父类与子类之间多态性的一种表现）
1) 方法名、参数、返回值必须相同。 
2) 子类方法不能缩小父类方法的访问权限。 
3) 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。 
4) 存在于父类和子类之间。，被覆盖的方法不能为private
5) 方法被定义为final不能被重写。 


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;     </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">5</span>);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;     </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">10</span>);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">override</span> </span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">   B b = <span class="keyword">new</span> B();     </span><br><span class="line">   A a= (A)b;<span class="comment">//把 b 强 制转换成A的类型     </span></span><br><span class="line">   <span class="keyword">int</span> x=a.getVal();     </span><br><span class="line">   System.out.println(x);     </span><br><span class="line">&#125;     </span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>overload</strong>（重载，一个类中定义多个同名的方法，这些方法的参数不相同，是一个类中多态性的一种表现） </p>
<p>1) 参数类型、个数、顺序至少有一个不相同。<br>2) 不能通过访问权限、返回类型、抛出的异常进行重载；<br>3) 存在于父类和子类、同类中。<br>4) 方法的异常类型和数目不会对重载造成影响； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverloadDemo</span> </span>&#123;     </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"NO parameters"</span>);     </span><br><span class="line">	&#125;     </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"a:"</span>+a);     </span><br><span class="line">	&#125;<span class="comment">//end of Overload test for one integer parameter.     </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"a and b:"</span>+a+<span class="string">" "</span>+b);     </span><br><span class="line">	       </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;     </span><br><span class="line">	   System.out.println(<span class="string">"double a:"</span>+a);     </span><br><span class="line">	   <span class="keyword">return</span> a*a;     </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span></span>&#123;     </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">	   OverloadDemo ob = <span class="keyword">new</span> OverloadDemo();     </span><br><span class="line">	   <span class="keyword">double</span> result;     </span><br><span class="line">	   ob.test();     </span><br><span class="line">	   ob.test(<span class="number">10</span>);     </span><br><span class="line">	   ob.test(<span class="number">10</span>, <span class="number">20</span>);     </span><br><span class="line">	   result = ob.test(<span class="number">123.25</span>);     </span><br><span class="line">	   System.out.println(<span class="string">"Result of ob.test(123.25):"</span>+result);  </span><br><span class="line">	 &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

 <br/> 
## **6. volatile关键字的作用**
当我们使用volatile关键字去修饰变量的时候，所以线程都会直接在内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。从而保证多线程中变量的安全性。

<h2 id="7-error和exeception的区别"><a href="#7-error和exeception的区别" class="headerlink" title="7.error和exeception的区别"></a><strong>7.error和exeception的区别</strong></h2><p><img src="http://img.blog.csdn.net/20161229225813014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>Error类和Exception类都继承自Throwable类。        </p>
<p>Error的继承关系：java.lang.Object &gt; java.lang.Throwable &gt; java.lang.Error</p>
<p>Exception的继承关系：<br>java.lang.Object &gt; java.lang.Throwable &gt;　java.lang.Exception</p>
<p><strong>二者的不同之处：</strong><br>Exception：</p>
<p>1) 可以是可被控制(checked) 或不可控制的(unchecked)<br>2) 表示一个由程序员导致的错误<br>3) 应该在应用程序级被处理        </p>
<p>Error：</p>
<p>1) 总是不可控制的(unchecked)<br>2) 经常用来用于表示系统错误或低层资源的错误<br>3) 如何可能的话，应该在系统级被捕捉<br>详细可见：<a href="http://wenku.baidu.com/link?url=Xvk-" target="_blank" rel="noopener">http://wenku.baidu.com/link?url=Xvk-</a></p>
<br/>
## **8. String、StringBuffer、StringBuilder的区别**

<p><strong>String 与StringBuffer对比</strong><br>      String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，从而降低了效率。<br>     而使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。别是字符串对象经常改变的情况下推荐使用 StringBuffer 特。 </p>
<p><strong>StringBuffer与StringBuilder对比</strong><br>StringBuffer：线程安全<br>StringBuilder：线程不安全，单在单线程中，性能比StringBuffer好</p>
<p>区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。</p>
<p>由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。<br>详细可见<br><a href="http://blog.csdn.net/rmn190/article/details/1492013" target="_blank" rel="noopener">http://blog.csdn.net/rmn190/article/details/1492013</a><br><a href="http://blog.csdn.net/mad1989/article/details/26389541" target="_blank" rel="noopener">http://blog.csdn.net/mad1989/article/details/26389541</a></p>
<br/>
## **9.final，finally, finalize的区别**
**final** 用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。
**finally** 是异常处理语句结构的一部分，表示总是执行。
**finalize**是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。

<p>详细可见：<br><a href="http://jingyan.baidu.com/article/597a064363b676312b5243ad.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/597a064363b676312b5243ad.html</a></p>
<br/>
## **10.数组与链表的区别，哪个访问更快**

<p><strong>数组：</strong>静态分配连续的存储空间，每个元素的占用的内存大小相同，可以通过下表快速访问任以元素，访问速度快，但是插入删除要移动大量元素，所以不适合做用于存储需要频繁该改变的数据。</p>
<p><strong>链表：</strong>动态分配内存，不连续，通过指针联系，如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。 </p>
<p>总结：<br>数组静态分配内存，链表动态分配内存，不易造成浪费；<br>数组在内存中连续，链表不连续；<br>数组元素在栈区，链表元素在堆区；<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。<br>详细可见：<br><a href="http://blog.csdn.net/wangshihui512/article/details/9787699" target="_blank" rel="noopener">http://blog.csdn.net/wangshihui512/article/details/9787699</a></p>
<br/>
## **11.java的垃圾处理机制**
**概念：**在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾收集意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。

<p><strong>优点：</strong><br> 1）垃圾回收能自动释放内存空间，减轻编程的负担<br> 2）有效的减少内存泄漏</p>
<p><strong>缺点：</strong><br>垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。 </p>
<p>在HotSpot虚拟机中，物理的将内存分为两个—年轻代(young generation)和老年代(old generation)。</p>
<p><strong>年轻代：</strong>新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说发生了一次“minor GC”。</p>
<p><strong>老年代：</strong>没有变得不可达，存活下来的年轻代对象被复制到这里。这块内存区域一般大于年轻代。因为它更大的规模，GC发生的次数比在年轻代的少。对象从老年代消失时，我们说“major GC”（或“full GC”）发生了。</p>
<p><strong>mimor GC</strong>（发生在年轻代中）<br>为了理解GC，我们学习一下年轻代，对象第一次创建发生在这块内存区域。年轻代分为3块，Eden区和2个Survivor区。</p>
<p>年轻代总共有3块空间，其中2块为Survivor区。各个空间的执行顺序如下：</p>
<p>绝大多数新创建的对象分配在Eden区。</p>
<p>在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。</p>
<p>在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。</p>
<p>一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。</p>
<p>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p>
<p>major GC (又叫full GC，发生在啊老年代中)<br>当老年代数据满时，基本上会执行一次GC，使数据从老年代消失时</p>
<p>详细可见：<br><a href="http://www.importnew.com/20354.html" target="_blank" rel="noopener">http://www.importnew.com/20354.html</a><br><a href="http://lemote.blog.163.com/blog/static/1748395072013111641050934/" target="_blank" rel="noopener">http://lemote.blog.163.com/blog/static/1748395072013111641050934/</a></p>
<br/>
## **12.java内存泄漏**

<p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>所以在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p>
<p><img src="http://img.blog.csdn.net/20161229230246863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>详细可见：<br><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/</a></p>
<br/>
## **13.进程及线程**
一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。
[阮一峰：进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
[JAVA多线程和并发基础面试问答](JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94)

<br/>
## **14.同步及异步**
**同步：**指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；        

<p><strong>异步：</strong>指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>
<br/>
## **15.死锁**
两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。

<p><strong>死锁的四个条件是：</strong><br>禁止抢占：no preemption<br>持有和等待：hold and wait<br>互斥：mutual exclusion<br>循环等待：circular waiting</p>
<p><strong>死锁的消除</strong><br>最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。可以把一个或多个进程回滚到先前的某个状态。<br>详细可见:<br><a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81</a></p>
<br/>
## **16.生产者消费者架构**
(在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。)

<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。<br>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法[1]等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。</p>
<p>生产者消费者模式<br>产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>用处广泛<br>Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是实现方法更高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>(补充:什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？<br>java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。<br>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。<br>BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。)<br>详细可见：<br><a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/producers-and-consumers-mode</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98</a></p>
<br/>
## **17.set用法**
http://www.cnblogs.com/TimeStory/p/3858479.html

<br/>
## **18.设计模式之设计原则**

<p><strong>1) 单一职责原则(SRP)</strong><br>定义：就一个类而言，应该仅有一个引起它变化的原因。 </p>
<p><strong>2)  开放封闭原则(ASD)</strong><br>定义：类、模块、函数等等等应该是可以拓展的，但是不可修改。</p>
<p><strong>3) 里氏替换原则(LSP)</strong><br>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象替换</p>
<p><strong>4) 依赖倒置原则(DIP)</strong><br>定义：高层模块不应该依赖低层模块，两个都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 </p>
<p><strong>5) 迪米特原则(LOD)</strong><br>定义：一个软件实体应当尽可能少地与其他实体发生相互作用。 </p>
<p><strong>6) 接口隔离原则(ISP)</strong><br>定义：一个类对另一个类的依赖应该建立在最小的接口上。 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 </p>
<p>详细可见：<br><a href="http://blog.csdn.net/itachi85/article/details/50491657" target="_blank" rel="noopener">http://blog.csdn.net/itachi85/article/details/50491657</a></p>
<br/>
## **19.抽象类与接口的区别**
![这里写图片描述](http://img.blog.csdn.net/20161230000616380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


<p><img src="http://img.blog.csdn.net/20161230000636824?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>详细可见：<br><a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">http://www.importnew.com/12399.html</a></p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>秋招笔试面试题</tag>
        <tag>java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 4 ：Java的反射机制</title>
    <url>/2018/07/07/jvm-java-reflection/</url>
    <content><![CDATA[<h2 id="一、什么是反射"><a href="#一、什么是反射" class="headerlink" title="一、什么是反射"></a>一、什么是反射</h2><p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息，以及动态调用对象的方法的功能来自于Java语言的反射（Reflection）机制。</p>
<a id="more"></a>

<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中：</p>
<ul>
<li>Class类： 代表一个类；</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）；</li>
<li>Method类：代表类的方法；</li>
<li>Constructor类：代表类的构造方法；</li>
<li>Array类：提供了动态创建数组，以及访问数组元素的静态方法。</li>
</ul>
<h2 id="二、java反射的作用-应用"><a href="#二、java反射的作用-应用" class="headerlink" title="二、java反射的作用(应用)"></a>二、java反射的作用(应用)</h2><blockquote>
<p>Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc. at compile time. It is also possible to instantiate new objects, invoke methods and get/set field values using reflection.</p>
</blockquote>
<p><strong>上面几句话概括了java反射机制的2个核心作用：</strong><br>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)动态获取类，接口，变量以及方法等信息。反射机制还可以让我们在运行期实例化对象，动态调用对象的方法。下面详细写下java机制的这2个核心作用。</p>
<h3 id="1、获取程序在运行时刻的内部结构（动态获取类的信息）"><a href="#1、获取程序在运行时刻的内部结构（动态获取类的信息）" class="headerlink" title="1、获取程序在运行时刻的内部结构（动态获取类的信息）"></a>1、获取程序在运行时刻的内部结构（动态获取类的信息）</h3><p>Java 反射的第一个主要作用是获取程序在运行时刻的内部结构。这对于程序的检查工具和调试器来说，是非常实用的功能。只需要短短的十几行代码，就可以遍历出来一个Java类的内部结构，包括其中的构造方法、声明的域和定义的方法等。</p>
<p>以下例子用反射获取类的对象，然后通过这个对象获取这个类的所有 public 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Method[] methods = ReflectionDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line"></span><br><span class="line">		    System.out.println(<span class="string">"method = "</span> + method.getName());</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070901.png" alt=""></p>
<h3 id="2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）"><a href="#2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）" class="headerlink" title="2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）"></a>2、在运行时刻对一个Java对象进行操作（动态调用对象的方法）</h3><p>java反射的另外一个作用是在运行时刻对一个Java对象进行操作。这些操作包括动态创建一个Java类的对象，获取某个域的值以及调用某个方法。在Java源代码中编写的对类和对象的操作，都可以在运行时刻通过反射API来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length;  <span class="comment">//长</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;   <span class="comment">//宽</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取对象调用方法的传统写法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Rectangle rectangle0 = 	<span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">		System.out.println(<span class="string">"长方形rectangle0的面积是："</span>+rectangle0.getArea());</span><br><span class="line">		</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 通过java反射动态调用对象的写法</span></span><br><span class="line"><span class="comment">	         */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;			</span><br><span class="line">		    Constructor constructor = Rectangle<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; <span class="comment">//获取构造方法</span></span><br><span class="line">		    Rectangle rectangle1 = (Rectangle) constructor.newInstance(<span class="number">4</span>,<span class="number">5</span>);                <span class="comment">//创建对象</span></span><br><span class="line">		    Method method = Rectangle.class.getMethod("getArea");                           //获取方法</span><br><span class="line">		    System.out.println(<span class="string">"长方形rectangle1的面积是："</span>+method.invoke(rectangle1));      <span class="comment">//调用方法</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">		    e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070902.png" alt=""></p>
<h2 id="三、java反射机制的详细用法"><a href="#三、java反射机制的详细用法" class="headerlink" title="三、java反射机制的详细用法"></a>三、java反射机制的详细用法</h2><p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中。</p>
<ul>
<li>Class类： 代表一个类。</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
<li>Array类：提供了动态创建数组，以及访问数组元素的静态方法。</li>
</ul>
<h3 id="1-Java反射-Classes"><a href="#1-Java反射-Classes" class="headerlink" title="1.Java反射-Classes"></a>1.Java反射-Classes</h3><table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>1) public String getName()</td>
<td>返回含包名的完整类名</td>
</tr>
<tr>
<td>3) public static Class forName(String className)throws ClassNotFoundException</td>
<td>加载类并返回Class对象</td>
</tr>
<tr>
<td>4) public Object newInstance()throws InstantiationException,IllegalAccessException</td>
<td>创建实例对象</td>
</tr>
<tr>
<td>5) public Class getSuperclass()</td>
<td>返回父类Class引用</td>
</tr>
<tr>
<td>6) public Field[] getFields()throws SecurityException</td>
<td>获取类的public类型的属性</td>
</tr>
<tr>
<td>7) public Field[] getDeclaredFields()throws SecurityException</td>
<td>获取类的所有属性</td>
</tr>
<tr>
<td>8) public Method[] getMethods()throws SecurityException</td>
<td>获取类的public类型的方法</td>
</tr>
<tr>
<td>9) public Method[] getDeclaredMethods()</td>
<td>获取类的所有类型的方法</td>
</tr>
<tr>
<td>10) public Method getDeclaredMethod(String name,Class[] parameterTypes)throws NoSuchMethodException,SecurityException</td>
<td>返回类中指定参数类型的方法</td>
</tr>
<tr>
<td>12) public Constructor[] getDeclaredConstructors()throws SecurityException</td>
<td>获取类的构造方法数组</td>
</tr>
<tr>
<td>13) getDeclaredConstructor(Class[] parameterTypes)</td>
<td>获取类的特定构造方法，parameterTypes参数指定构造方法的参数类型</td>
</tr>
<tr>
<td>14) public boolean isInterface()</td>
<td>判断是否是接口</td>
</tr>
<tr>
<td>15) public boolean isArray()</td>
<td>判断是否是数组</td>
</tr>
<tr>
<td>16) public boolean isPrimitive()</td>
<td>判断是否是原始数据类型</td>
</tr>
</tbody></table>
<p>以下是根据 API 中的一些方法获取类信息的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取类</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Class class1 = MainText<span class="class">.<span class="keyword">class</span></span>;	</span><br><span class="line">		Class class2 = Class.forName(<span class="string">"reflection.Rectangle"</span>);</span><br><span class="line">		System.out.println(class2.getName());</span><br><span class="line">		System.out.println(class2.getSimpleName());</span><br><span class="line">				</span><br><span class="line">		Package pack = class2.getPackage();     <span class="comment">//获取包</span></span><br><span class="line">		Field[] field = class2.getFields(); 	<span class="comment">//获取字段</span></span><br><span class="line">		Method[] method = class2.getMethods();  <span class="comment">//获取方法</span></span><br><span class="line">		Annotation[] annotations = class2.getAnnotations(); <span class="comment">//获取注解</span></span><br><span class="line">		Constructor[] constructors = class2.getConstructors(); <span class="comment">//获取构造器	</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取修饰符并判断类型</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> modifiers = class2.getModifiers();</span><br><span class="line">		<span class="comment">//判断的值为 true or false</span></span><br><span class="line">		Modifier.isAbstract(modifiers);</span><br><span class="line">		Modifier.isFinal(modifiers);</span><br><span class="line">		Modifier.isInterface(modifiers);</span><br><span class="line">		Modifier.isNative(modifiers);</span><br><span class="line">		Modifier.isPrivate(modifiers);</span><br><span class="line">		Modifier.isProtected(modifiers);</span><br><span class="line">		Modifier.isPublic(modifiers);</span><br><span class="line">		Modifier.isStatic(modifiers);</span><br><span class="line">		Modifier.isStrict(modifiers);</span><br><span class="line">		Modifier.isSynchronized(modifiers);</span><br><span class="line">		Modifier.isTransient(modifiers);</span><br><span class="line">		Modifier.isVolatile(modifiers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Java反射-Fields"><a href="#2-Java反射-Fields" class="headerlink" title="2.Java反射-Fields"></a>2.Java反射-Fields</h3><p>通过使用 java.lang.reflect.Field , 可以在运行期访问或者改变类成员变量的值。</p>
<p>下面以一个简单的例子演示下获取Field的值与改变Field的值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">private</span> <span class="keyword">int</span> x;      </span><br><span class="line">	  <span class="keyword">public</span> <span class="keyword">int</span> y;    </span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   	  </span><br><span class="line">		  <span class="keyword">super</span>();          </span><br><span class="line">		  <span class="keyword">this</span>.x = x;          </span><br><span class="line">		  <span class="keyword">this</span>.y = y; </span><br><span class="line">	  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取变量信息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Point instanceObj = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">		Class class1 = instanceObj.getClass();	</span><br><span class="line">		Field[] field1 = class1.getFields();      <span class="comment">//获取Field 列表</span></span><br><span class="line">		Field field2 = class1.getField(<span class="string">"y"</span>);      <span class="comment">//获取指定Field</span></span><br><span class="line">		String fieldName = field2.getName();      <span class="comment">//获取变量名</span></span><br><span class="line">		Object fieldType = field2.getType();      <span class="comment">//获取变量类型</span></span><br><span class="line">		<span class="keyword">int</span> a = field2.getModifiers();            <span class="comment">//获取修饰符</span></span><br><span class="line">		Modifier.isAbstract(a);                   <span class="comment">//判断是否含某修饰符       </span></span><br><span class="line">		System.out.println(field2.get(instanceObj));      <span class="comment">//获取对象对应的Field值</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 改变变量的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		field2.set(instanceObj, <span class="number">6</span>);                    <span class="comment">//改变Field的值 </span></span><br><span class="line">		System.out.println(field2.get(instanceObj));   <span class="comment">//输出改变后的值</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面一个例子是网上一个比较有趣的例子，主要体现了使用Field时一些需要特别注意的地方，摘于<a href="http://www.360doc.com/content/17/0820/17/46591991_680655030.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0820/17/46591991_680655030.shtml</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">private</span> <span class="keyword">int</span> x;      </span><br><span class="line">	  <span class="keyword">public</span> <span class="keyword">int</span> y;    </span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   	  </span><br><span class="line">		  <span class="keyword">super</span>();          </span><br><span class="line">		  <span class="keyword">this</span>.x = x;          </span><br><span class="line">		  <span class="keyword">this</span>.y = y; </span><br><span class="line">	  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里说的Field都是 类 身上的，不是实例上的  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        Point pt1 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//得到一个字段  </span></span><br><span class="line">        Field fieldY = pt1.getClass().getField(<span class="string">"y"</span>); <span class="comment">//y 是变量名  </span></span><br><span class="line">        <span class="comment">//fieldY的值是5么？？ 大错特错  </span></span><br><span class="line">        <span class="comment">//fieldY和pt1根本没有什么关系，你看，是pt1.getClass()，是 字节码 啊  </span></span><br><span class="line">        <span class="comment">//不是pt1对象身上的变量，而是类上的，要用它取某个对象上对应的值  </span></span><br><span class="line">        <span class="comment">//要这样  </span></span><br><span class="line">        System.out.println(fieldY.get(pt1)); <span class="comment">//这才是5  </span></span><br><span class="line">        <span class="comment">//现在要x了    </span></span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        Field fieldX = pt1.getClass().getField("x"); //x 是变量名 </span></span><br><span class="line"><span class="comment">        System.out.println(fieldX.get(pt1));  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//运行 报错 私有的，找不到  </span></span><br><span class="line">        <span class="comment">//NoSuchFieldException  </span></span><br><span class="line">        <span class="comment">//说明getField 只可以得到 公有的  </span></span><br><span class="line">        <span class="comment">//怎么得到私有的呢？？  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        //这个管你公的私的，都拿来 </span></span><br><span class="line"><span class="comment">        Field fieldX = pt1.getClass().getDeclaredField("x");</span></span><br><span class="line"><span class="comment">        //然后轮到这里错了 </span></span><br><span class="line"><span class="comment">        // java.lang.IllegalAccessException: </span></span><br><span class="line"><span class="comment">        //Class com.ncs.ReflectTest can not access a member of class com.ncs.Point with modifiers "private" </span></span><br><span class="line"><span class="comment">        System.out.println(fieldX.get(pt1)); </span></span><br><span class="line"><span class="comment">        */</span>           </span><br><span class="line">        <span class="comment">//三步曲 一是不让你知道我有钱 二是把钱晃一下，不给用  三是暴力抢了  </span></span><br><span class="line">        <span class="comment">//暴力反射    </span></span><br><span class="line">        Field fieldX = pt1.getClass().getDeclaredField(<span class="string">"x"</span>); <span class="comment">//这个管你公的私的，都拿来  </span></span><br><span class="line">        fieldX.setAccessible(<span class="keyword">true</span>);<span class="comment">//上面的代码已经看见钱了，开始抢了  </span></span><br><span class="line">        System.out.println(fieldX.get(pt1));             </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070903.png" alt=""></p>
<p><strong>关于 Field 的用法需要特别注意的是下表的区别：</strong></p>
<p><img src="/images/2018070904.png" alt=""></p>
<ol>
<li>getField()、getFields() 方法能获得的是 public 的字段，包括父类中的字段；</li>
<li>geDeclaredField()、geDeclaredFields() 获取的包括 public、private 和 proteced 的字段，但是不包括父类的申明字段。</li>
</ol>
<h3 id="3-Java反射-Method"><a href="#3-Java反射-Method" class="headerlink" title="3.Java反射-Method"></a>3.Java反射-Method</h3><p>通过使用 java.lang.reflect.Method, 可以在运行期动态调用对象的方法。</p>
<p>下面写个小 demo 演示下在运行期动态调用有参方法还有无参方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length;  <span class="comment">//长</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;   <span class="comment">//宽</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Rectangle instanceObj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>,<span class="number">5</span>);  </span><br><span class="line">		Class class1 = instanceObj.getClass();	</span><br><span class="line">		Method method[] = class1.getMethods();              <span class="comment">//获取所有 public 方法        		</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用无参方法</span></span><br><span class="line"><span class="comment">		 * 目标方法没有参数，那么在调用getMethod()方法时第二个参数传入null即可</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method method1 = class1.getMethod(<span class="string">"getArea"</span>, <span class="keyword">null</span>); <span class="comment">//获取指定的无参方法</span></span><br><span class="line">			System.out.println(method1);</span><br><span class="line">			System.out.println(method1.invoke(instanceObj, <span class="keyword">null</span>));</span><br><span class="line">		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) &#123;			</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用带参数的方法</span></span><br><span class="line"><span class="comment">		 * 目标方法有参数，那么在调用getMethod()方法时需要用new Class[]&#123;&#125; 参数对应的参数类型</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method method2 = class1.getMethod(<span class="string">"getArea"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>&#125;)</span>;  <span class="comment">//获取指定的带参数的方法</span></span><br><span class="line">			System.out.println(method2);</span><br><span class="line">			System.out.println(method2.invoke(instanceObj, <span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) &#123;				</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/2018070905.png" alt=""></p>
<p><strong>关于Method.invoke()方法需要特别注意2点：</strong></p>
<ol>
<li><p>如果是一个静态方法调用的话则可以用null代替指定对象作为invoke()的参数，如果调用的方法不是静态方法，就要传入有效的对象实例而不是null。</p>
</li>
<li><p>Method.invoke(Object target, Object … parameters) 的第二个参数是一个可变参数列表，必须要传入与你要调用方法的形参一一对应的实参，否则会抛出 java.lang.IllegalArgumentException:  异常。</p>
</li>
</ol>
<h3 id="4-Java反射-Annotation"><a href="#4-Java反射-Annotation" class="headerlink" title="4.Java反射-Annotation"></a>4.Java反射-Annotation</h3><p>利用Java反射机制可以在运行期获取Java类的注解信息，包括以下:</p>
<ul>
<li>类注解</li>
<li>方法注解</li>
<li>参数注解</li>
<li>变量注解</li>
</ul>
<p>下面通过一个例子演示一下类注解的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(name=<span class="string">"Java Reflection"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Class class1 = MyObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Annotation[] annotations = class1.getAnnotations();  <span class="comment">//获取类的注解</span></span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">			<span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyAnnotation) &#123;</span><br><span class="line">				MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">				System.out.println(<span class="string">"name:"</span> + myAnnotation.name());</span><br><span class="line">				System.out.println(<span class="string">"value:"</span> + myAnnotation.value());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>
下面再通过一个例子演示一下方法注解的用法：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@MyAnnotation</span>(name=<span class="string">"Java Reflection"</span>,  value = <span class="string">"Hello World"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		Class class1 = MyObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Method method = class1.getMethod(<span class="string">"doSomething"</span>, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		Annotation[] annotations = method.getAnnotations();  <span class="comment">//获取类的注解</span></span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">			<span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyAnnotation) &#123;</span><br><span class="line">				MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">				System.out.println(<span class="string">"name:"</span> + myAnnotation.name());</span><br><span class="line">				System.out.println(<span class="string">"value:"</span> + myAnnotation.value());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下2点：</p>
<ol>
<li><p>@Retention(RetentionPolicy.RUNTIME)表示这个注解可以在运行期通过反射访问。如果没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。</p>
</li>
<li><p>@Target(ElementType.TYPE) 表示这个注解只能用在类型上面（比如类跟接口），同样可以把TYPE改为FIELD或者METHOD，或者不用这个指定，那么，这个注解就在类、方法和变量上就都可以使用。</p>
</li>
</ol>
<h2 id="四、反射的适用场景及优缺点"><a href="#四、反射的适用场景及优缺点" class="headerlink" title="四、反射的适用场景及优缺点"></a>四、反射的适用场景及优缺点</h2><h3 id="反射的适用场景"><a href="#反射的适用场景" class="headerlink" title="反射的适用场景"></a>反射的适用场景</h3><blockquote>
<p>Java Reflection is quite powerful and can be very useful. For instance, Java Reflection can be used to map properties in JSON files to getter / setter methods in Java objects, like Jackson, GSON, Boon etc.does. Or, Reflection can be used to map the column names of a JDBC ResultSet to getter / setter methods in a Java object.</p>
</blockquote>
<p>Java反射机制功能强大而且非常实用，举个例子，比如 jackson，Gson ，利用 java 反射 可以把JSON 中的属性 映射到 java 实体对象 的   getter / setter 方法上。比如Hibernate通过java 反射还可以把数据库中的列字段映射到java实体对象的 getter / setter 方法上。（把从数据库查询的结果记录映射到对应的实体类）</p>
<p><strong>反射主要用在以下地方：</strong></p>
<p><strong>1. 用于开发灵活可配置的基础框架</strong><br>反射机制是很多Java框架的基石，而一般应用层面很少用。典型的如 Hibernate、Spring中也用到很多反射机制。最经典的就是在xml文件或者properties里面写好了配置，然后在Java类里面解析xml或properties里面的内容，得到一个字符串，然后用反射机制，根据这个字符串获得某个类的Class实例，这样就可以动态配置一些东西，不用每一次都要在代码里面去new或者做其他的事情，以后要改的话直接改配置文件，代码维护起来就很方便了。</p>
<p><strong>2. 插件化支持</strong><br>因为一开始还不能确定插件的类型还有名称，所以无法初始化，需要在程序运行过程中，获取到插件的信息，然后再通过反射实例化对象并完成后续的动态调用。</p>
<p><strong>3.在编码阶段还不能确定类名，</strong>类名需要从配置或者其他地方读取过来，这时候就没有办法硬编码new ClassName(),而必须用到反射才能创建这个对象。</p>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p><strong>优点：</strong><br>可以在运行期获取类信息、实例化对象、动态调用方法，修改程序行为，利用这些特性可以设计出灵活和拓展性更好的程序。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>使用反射的性能较低，jvm 需要做额外的检查校验，并且可能会导致JVM无法优化代码;</li>
<li>使用反射相对来说不安全，写法也更复杂，更容易出错，运行期的BUG比编译期的BUG更不容易被发现；</li>
<li>破坏了类的封装性，可以通过反射获取这个类的私，有方法和属性，</li>
</ol>
<h3 id="怎么考虑是否使用反射"><a href="#怎么考虑是否使用反射" class="headerlink" title="怎么考虑是否使用反射"></a>怎么考虑是否使用反射</h3><p><strong>在业务场景中，如果非必须，则不直接使用java的反射。</strong></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p><a href="http://ifeve.com/java-reflection/" target="_blank" rel="noopener">http://ifeve.com/java-reflection/</a><br><a href="https://www.javatpoint.com/java-reflection" target="_blank" rel="noopener">https://www.javatpoint.com/java-reflection</a><br><a href="http://www.360doc.com/content/11/1231/14/1954236_176297236.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/1231/14/1954236_176297236.shtml</a><br><a href="https://blog.csdn.net/tjpu_lin/article/details/23557443" target="_blank" rel="noopener">https://blog.csdn.net/tjpu_lin/article/details/23557443</a><br><a href="https://blog.csdn.net/zolalad/article/details/29370565" target="_blank" rel="noopener">https://blog.csdn.net/zolalad/article/details/29370565</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>反射机制</tag>
        <tag>java反射</tag>
        <tag>java反射-Fields</tag>
        <tag>java反射-Classes</tag>
        <tag>Java反射-Method</tag>
        <tag>Java反射-Annotation</tag>
        <tag>动态调用</tag>
      </tags>
  </entry>
  <entry>
    <title>java 虚拟机 5：Java内存区域划分以及对象创建的过程</title>
    <url>/2018/07/11/jvm-memory-division/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>与 C、C++ 相比，Java 把内存控制权交给了虚拟机，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去配对delete/free代码，最直接的好处就是不容易出现内存泄露和内存溢出问题，但是一旦出现内存泄露和内存溢出的问题，如果不了解JVM是如何划分内存区域的，那就难以排查问题，所以了解虚拟机的内存区域以及会引起内存泄露和内存溢出的常见场景，将会帮助我们更快的排查问题，这也是成为 OOM Killer 的基本素质。</p>
<a id="more"></a>

<h2 id="二、内存区域划分"><a href="#二、内存区域划分" class="headerlink" title="二、内存区域划分"></a>二、内存区域划分</h2><p>java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。如下图所示：</p>
<p><img src="/images/2018091701.png" alt=""></p>
<p>上图描述了Java虚拟机运行时的数据区，下面再详细讲下各个区域的特点，下面我用思维导图的形式描述。</p>
<p><img src="/images/2018091702.png" alt=""></p>
<h2 id="三、对象创建的过程"><a href="#三、对象创建的过程" class="headerlink" title="三、对象创建的过程"></a>三、对象创建的过程</h2><p>Java是一门面向对象的语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（克隆、反序列化）就是一个new关键字而已，但再背后虚拟机为我们做了哪些事呢？下面看一下在虚拟机层面上创建对象的步骤：</p>
<p>1、虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的初始化过程。</p>
<p>2、类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。这里分配内存的方式有两种：</p>
<ul>
<li><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。</p>
</li>
<li><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。</p>
</li>
</ul>
<p>另外需要特别注意的是new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。</p>
<p>3、内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>4、对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。</p>
<p>5、执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<p><strong>整个过程可以简要概括为： 检查加载类 -&gt; 给对象分配内存 -&gt; 初始化零值 -&gt; 设置对象头信息 -&gt; 调用构造函数初始化<init></strong></p>
<h2 id="四、对象的内存布局"><a href="#四、对象的内存布局" class="headerlink" title="四、对象的内存布局"></a>四、对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中的布局分为3快区域：对象头（Header）、实例数据（Instance Data）、对其填充（Padding）。如下图所示：</p>
<p><img src="/images/2018091703.png" alt=""></p>
<h2 id="五、对象的访问"><a href="#五、对象的访问" class="headerlink" title="五、对象的访问"></a>五、对象的访问</h2><p>引用存放在虚拟机栈中，数据类型为reference，对象实例存放在堆中。<br>而我们的Java程序需要通过栈上的 reference 数据（引用）来操作堆上的具体对象，那么引用是如何指向对象实例的呢？主流的访问方式有两种：</p>
<p>第一种是通过句柄池，如果使用句柄池，那么java堆中将会划分出一部分内存作为句柄池，句柄包含对象类型指针指向方法区的类型信息，还有对象实例指针，指向堆中的实例地址。如下图所示：</p>
<p><img src="/images/2018091704.png" alt=""></p>
<p>第二种是reference引用直接指向堆中的对象实例，对象实例的对象头存放对象类型指针。如下图所示：</p>
<p><img src="/images/2018091705.png" alt=""></p>
<p><strong>对比：</strong><br>两种方法各有优势，第一种可以在对象实例在GC时移动的时候只改变句柄池中的对象实例数据指针，而不用改变reference引用本身。第二种方法就是访问速度快，减少了一次指针定位的时间开销。目前HotSpot虚拟机就采用的第二种方式。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>《深入理解Java虚拟机》 –第二章 周志明著 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存区域划分</tag>
        <tag>对象的内存布局</tag>
        <tag>对象创建的过程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SPI 机制</title>
    <url>/2019/08/24/java-spi/</url>
    <content><![CDATA[<h2 id="SPI-可以用来做什么"><a href="#SPI-可以用来做什么" class="headerlink" title="# SPI 可以用来做什么"></a><a href="#SPI-可以用来做什么" title="# SPI 可以用来做什么"></a># SPI 可以用来做什么</h2><p>在设计一个框架或者组件，甚至是项目中的某些模块时，经常都需要考虑扩展性， 而扩展性好应该符合以下两点：</p>
<ol>
<li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码或者修改配置即可。</li>
</ol>
<p>而 Java SPI 可以很好的满足以上两点，从而达到良好的扩展性。</p>
<p>Java SPI(Service Provider Interface)是 JDK 内置的一种动态加载扩展点的实现，是一种“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。对扩展性支持非常友好，想要扩展实现，新只需要增实现接口，然后把接口的实现描述给JDK就行了。</p>
<a id="more"></a>
<p>（大致原理就是：在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用 java.util.ServiceLoader 来加载具体的实现。）</p>
<p><img src="/images/2019082401.png" alt=""></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><a href="#使用场景" title="使用场景"></a>使用场景</h3><p>概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：</p>
<ol>
<li><p>JDBC自动加载不同类型的数据库驱动， mysql-connector-java-xxx.jar</p>
</li>
<li><p>日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类</p>
</li>
<li><p>Dubbo中在Java SPI 的基础上做了加强， 实现了根据方法参数或者配置来决定该使用哪个扩展。比如LoadBalance 做到了根据调用者参数的指定来应用不同的负债均衡策略。</p>
</li>
</ol>
<h2 id="如何实现一个自定义-SPI"><a href="#如何实现一个自定义-SPI" class="headerlink" title="# 如何实现一个自定义 SPI"></a><a href="#如何实现一个自定义-SPI" title="# 如何实现一个自定义 SPI"></a># 如何实现一个自定义 SPI</h2><p>这里由于现实情况不同厂商的实现肯定是分开的，所以不同厂商我是建了不同的 maven-modules， 目录结果如下：</p>
<p><img src="/images/2019082402.png" alt=""></p>
<h3 id="1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来"><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" class="headerlink" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a><a href="#1-定义一个接口IRepository用于实现数据储存-类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来" title="1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)"></a>1. 定义一个接口IRepository用于实现数据储存 (类似于强制制定了一种规范，你们不同的数据厂商可以有不同的实现，但是必须按照我这个标准接口来)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 建立连接</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span></span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h3 id="2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" class="headerlink" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a><a href="#2-不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository" title="2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository"></a>2. 不同厂商分别提供了自己不同的实现，MysqlRepository、OracleRepository、MongoRepository</h3><p> MysqlRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mysql"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.mysql.MysqlRepository</span>
</pre></td></tr></table></figure>

<p>OracleRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Oracle"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span>
</pre></td></tr></table></figure>

<p>MongoRepository 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String url)</span> </span>&#123;</span>
<span class="line">        System.out.println(<span class="string">"connect "</span> + url + <span class="string">" to Mongo"</span>);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>在 Resources 下新建一个 META-INF/services/com.crazyfzw.spi.api.IRepository 文件， 内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">com.crazyfzw.spi.apiimpl.oracle.OracleRepository</span>
</pre></td></tr></table></figure>

<h3 id="3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）"><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" class="headerlink" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a><a href="#3-在应用的pom-文件中根据需要选择引入不同厂商的maven-依赖-（通过切换pom引入可以实现不同厂商的切换）" title="3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）"></a>3. 在应用的pom 文件中根据需要选择引入不同厂商的maven 依赖 （通过切换pom引入可以实现不同厂商的切换）</h3><p>这里是invoker-test 模块的pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>interface-standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oracle-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"></span>
<span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-repository<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span>
<span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span>
<span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span>
<span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span>
</pre></td></tr></table></figure>

<h3 id="4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现"><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" class="headerlink" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a><a href="#4-在主调用类中通过-通过ServiceLoader加载IRepository-的实现" title="4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现"></a>4. 在主调用类中通过 通过ServiceLoader加载IRepository 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);</span>
<span class="line"></span>
<span class="line">        Iterator&lt;IRepository&gt; it = serviceLoader.iterator();</span>
<span class="line">        <span class="keyword">while</span> (it != <span class="keyword">null</span> &amp;&amp; it.hasNext())&#123;</span>
<span class="line">            IRepository repositoryService = it.next();</span>
<span class="line">            System.out.println(<span class="string">"class:"</span> + repositoryService.getClass().getName());</span>
<span class="line">            repositoryService.connect(<span class="string">"172.0.0.1:3306"</span>);</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>运行效果图如下：</p>
<p><img src="/images/2019082403.png" alt=""></p>
<p><strong>调用主类无需修改代码，只需通过修改pom引入不同的依赖，就可以选择切换不同的实现。</strong></p>
<h2 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="# SPI 的优缺点"></a><a href="#SPI-的优缺点" title="# SPI 的优缺点"></a># SPI 的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><a href="#优点：" title="优点："></a>优点：</h3><ol>
<li>Java SPI的使用很简单。也做到了基本的加载扩展点的功能，可以使业务代码和组件代码脱耦，启用替换可插拔</li>
<li>拓展性好，在不修改原来代码的基础上，通过添加代码就可以拓展新的能力</li>
<li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便</li>
</ol>
<h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><a href="#不足：" title="不足："></a>不足：</h3><ol>
<li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li>
<li>不提供类似于Spring的IOC和AOP功能，扩展如果依赖其他的扩展，做不到自动注入和装配</li>
</ol>
<p>针对这些问题， Dubbo在原生  Java SPI 的基础上做了一些拓展。 可见参考文献[3][4]。</p>
<p>*<em>本文涉及的spi-demo源码地址： *</em><br><a href="https://github.com/crazyfzw/spi-demo.git" target="_blank" rel="noopener">https://github.com/crazyfzw/spi-demo.git</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://www.cnkirito.moe/spi/" target="_blank" rel="noopener">JAVA拾遗–关于SPI机制</a></p>
<p>[2]<a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">JDBC实现及 DriverManager 源码解析</a></p>
<p>[3]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">Dubbo可扩展机制实战</a></p>
<p>[4]<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html" target="_blank" rel="noopener">Dubbo可扩展机制源码解析</a></p>
]]></content>
      <tags>
        <tag>进阶实战</tag>
        <tag>Java SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记 (一)：目录、文件、权限、账户</title>
    <url>/2017/09/23/linux-note1/</url>
    <content><![CDATA[<h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h3><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p>
<p>Linux 是进行内核研究、学习 UNIX 或学习编程的绝佳学习平台；Linux 是作为编程平台的绝佳选择。</p>
<p>您习惯 Linux 的工作方式后，您将具有更大的工具集来控制和维护您的环境。Linux 的强大之处在于它的稳定性和灵活性。一旦您领悟了 Linux 的思想，您将可以完成更多的任务，使更多的任务自动化，更多地以远程方式完成任务。</p>
<p>Linux 相对于 Windows 的许多变化都是有益的。空闲的 GUI 的开销被归还给服务。任务可以脚本化并可以自动执行。配置文件基于文本并且人类可读。在大多数情况下不必重新引导系统。实际上，您应该抑制重新引导系统的冲动。</p>
<a id="more"></a>

<p><strong>重新引导是最后的手</strong><br>如果您确实重新引导了 Linux 系统，问题很可能得不到解决，而且还会使问题更加恶化。学习并掌握 Linux 服务和运行级别是成功解决问题的关键。学习 Linux 最困难的就是克服重新引导系统的习惯。</p>
<p><strong>命令区分大小写</strong><br>所有的 Linux 命令和选项都区分大小写。例如， -R 与 -r不同，会去做不同的事情。控制台命令几乎都是小写的。
　　　</p>
<h3 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h3><p><img src="/images/2017092301.png" alt="这里写图片描述"></p>
<ul>
<li><p><strong>/bin：</strong><br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong></p>
<pre><code>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的            方式是相同的。</code></pre></li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home：</strong><br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib：</strong><br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。     </p>
</li>
<li><p><strong>/lost+found：</strong><br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文 件。</p>
</li>
<li><p><strong>/media：</strong><br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt：</strong><br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<ul>
<li><p><strong>/opt：</strong><br>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc：</strong><br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<br>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</p>
</li>
<li><p><strong>/root：</strong><br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin：</strong><br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux：</strong><br>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv：</strong><br>该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys：</strong><br>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp：</strong><br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr：</strong><br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var：</strong><br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
</ul>
<p>　　　　　　</p>
<h3 id="3-文件权限控制"><a href="#3-文件权限控制" class="headerlink" title="3.文件权限控制"></a>3.文件权限控制</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r:4            </span><br><span class="line">w:2</span><br><span class="line">x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</span><br><span class="line">others&#x3D; --- &#x3D; 0+0+0 &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770 , 如下：</p>
<p> chmod [-R] xyz 文件或目录</p>
<p>如：  <code>chmod -R 777 .bashrc    chmod 777 .bashrc</code></p>
<p>选项与参数：</p>
<ul>
<li><strong>xyz</strong> ： 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。  </li>
<li><strong>-R</strong> ：进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>那如果要将权限变成 -rwxr-xr– 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。
　　　</p>
<h3 id="4-系统用户账号的管理"><a href="#4-系统用户账号的管理" class="headerlink" title="4.系统用户账号的管理"></a>4.系统用户账号的管理</h3><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<p><strong>1、用 useradd 命令添加新的用户账号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<ul>
<li>-c comment 指定一段注释性描述。    </li>
<li>-G 用户组，用户组 指定用户所属的附加组。   </li>
<li>-s Shell文件 指定用户的登录Shell。    </li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
<p>eg:</p>
<p>1) <code>useradd –d /usr/sam -m sam</code></p>
<p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。</p>
<p>2) <code>useradd -s /bin/sh -g group –G adm,root gem</code></p>
<p>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。这里可能新建组：#groupadd group及groupadd adm<br>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p><strong>2、用 usermod 命令修改账号</strong></p>
<p>修可根据实际情况修改用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>eg: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam</span><br></pre></td></tr></table></figure>
<p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<p><strong>3、用 userdel  命令删除帐号</strong></p>
<p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。常用的选项是-r，它的作用是把用户的主目录一起删除。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel sam</span><br></pre></td></tr></table></figure>

<p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<p>4、用 passwd 命令管理用户口令</p>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。  </li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>eg:<br>1）当前普通用户修改该用户自己的口令：<br>$ passwd<br>Old password:<strong>**</strong><br>New password:<strong>***</strong><br>Re-enter new password:<strong>***</strong></p>
<p>2）超级用户，可以用下列形式指定任何用户的口令：<br> passwd sam<br>New password:<strong>***</strong><br>Re-enter new password:<strong>***</strong></p>
<p>3）删除口令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd -d sam</span><br></pre></td></tr></table></figure>

<p>注：系删除口令后，下次登录统就不再询问口令。</p>
<p>4）锁定某一用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd -l sam</span><br></pre></td></tr></table></figure>

<p>注：被锁定的用户无法登录</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>chmod</tag>
        <tag>文件权限控制</tag>
        <tag>useradd</tag>
        <tag>usermod</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记 (二)：目录文件操作常用命令</title>
    <url>/2017/10/17/linux-note2/</url>
    <content><![CDATA[<p>Linux 中的所有管理任务都可以在控制台中完成。许多情况下，使用控制台比使用图形化的程序更快捷，而且还可能实现额外的功能。不仅如此，所有的控制台任务都可以写到脚本中，这样就可以自动执行。</p>
<a id="more"></a>

<h2 id="进入控制台"><a href="#进入控制台" class="headerlink" title="进入控制台"></a>进入控制台</h2><p>在典型的 Linux 系统中，通过组合键 Ctrl + Alt + (F1 - F6) 您可以切换到另外的控制台；如果您是在图形模式下，那么您可以打开一个 终端 (terminal)以进入控制台窗口。通常在桌面的任务条上会有终端的按钮。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>所有的命令和选项都区分大小写。 -R 与 -r不同，会去执行不同的操作。控制台命令几乎全都是小写的。下面是一些最常用的命令：</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>使用我们所熟悉的 cd 命令可以在目录间切换。一定注意的是在 Linux 中用的是正斜杠 (/)，而不是您所熟悉的反斜杠 ()。反斜杠也用到了，但只是用来说明命令需要换行继续，这样可以提高比较长的命令的可读性。</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls 命令用于列出一个目录下的所有文件。可以使用许多不同的开关更改列表的表示形式：</p>
<p>列出文件<br><img src="/images/2018041701.png" alt=""></p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前工作目录</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>使用 cp 命令来复制文件。这个命令与 DOS 下的 copy 命令基本一样。基本的开关如下：<br>复制文件<br><img src="/images/2018041702.png" alt=""></p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用 mv 命令来移动和重命名文件。这个命令的工作方式基本上与 DOS 中的 move 命令一样，不过它可以移动整个目录结构及所有文件。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>使用 cat 命令来查看文件的内容。它相当于 DOS 中的 type 命令。它将把文件的内容转储到另一个文件、屏幕或者其他命令。 cat 是concatenate 的简写，还可以将一系列的文件合并为一个大文件。</p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>使用命令 more 可以以分页的方式查看文件。它基本上与 DOS 中的 more命令相同。</p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less 命令也是用来查看文件，但是它支持上下滚屏以及在文档中进行文本搜索。</p>
<h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>有一些人可能会说 vi 表示“virtually impossible”。它是 Unix 中的一个历史悠久的文本编辑器。 vi 并不真正直观，但是现在几乎所有的类 Unix 环境中都有 vi 。对于 Linux 中安装的版本有一个内置的教程，一旦您熟悉了 vi ，只需几次击键就可以完成不可思议的任务。说实话，没有任何编辑器能够取代 vi 来编辑密码和配置文件。</p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>使用 man 命令来查看命令的文档。man 是 manual 的缩写。几乎每一个命令都有相应的文档。要深入了解 man ，请输入以下命令：<br>man man</p>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>info 命令与 man 命令类似，不过它提供了超链接文本，可以更方便地浏览文档。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>cat</tag>
        <tag>man</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（三）：服务器常用命令</title>
    <url>/2017/10/20/linux-note3/</url>
    <content><![CDATA[<h4 id="查看指定关键字进程"><a href="#查看指定关键字进程" class="headerlink" title="查看指定关键字进程"></a>查看指定关键字进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看指定进程进程 ps -ef | grep  </span><br><span class="line">如查看java进程  ps -ef | grep java  </span><br><span class="line">查看tomcat进程  ps -ef | grep tomcat</span><br><span class="line">查看某项目进程  ps -ef | grep 目录名  ps -ef | grep ems</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="查看实时日志"><a href="#查看实时日志" class="headerlink" title="查看实时日志"></a>查看实时日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f logs&#x2F;catalina.out</span><br><span class="line"></span><br><span class="line">tail -5000f logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure>


<h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure>

<h4 id="根据-关键词-查看日志-并返回关键词所在行："><a href="#根据-关键词-查看日志-并返回关键词所在行：" class="headerlink" title="根据 关键词 查看日志 并返回关键词所在行："></a>根据 关键词 查看日志 并返回关键词所在行：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 路径&#x2F;文件名 | grep 关键词</span><br></pre></td></tr></table></figure>


<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sz 文件名</span><br></pre></td></tr></table></figure>

<h4 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h4 id="强制终止进程"><a href="#强制终止进程" class="headerlink" title="强制终止进程"></a>强制终止进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 5031</span><br></pre></td></tr></table></figure>

<h4 id="查看内存占用情况"><a href="#查看内存占用情况" class="headerlink" title="查看内存占用情况"></a>查看内存占用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<h4 id="实时显示各个进程的资源占用情况"><a href="#实时显示各个进程的资源占用情况" class="headerlink" title="实时显示各个进程的资源占用情况"></a>实时显示各个进程的资源占用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven初识</title>
    <url>/2017/01/25/maven/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h2><p>Maven 的主要目的是为开发者提供<br>  ● 一个可复用、可维护、更易理解的工程综合模型<br>  ● 与这个模型交互的插件或者工具</p>
<p>Maven 能够帮助开发者完成以下工作：<br>  ● 构建<br>  ● 文档生成<br>  ● 报告<br>  ● 依赖<br>  ● SCMs<br>  ● 发布<br>  ● 分发<br>  ● 邮件列表</p>
<p>Maven 工程结构和内容被定义在一个 xml 文件中 － pom.xml，是 Project Object Model (POM) 的简称，此文件是整个 Maven 系统的基础组件</p>
<a id="more"></a>



<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h2><p><a href="http://wiki.jikexueyuan.com/project/maven/environment-setup.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/maven/environment-setup.html</a></p>
<h2 id="三、POM"><a href="#三、POM" class="headerlink" title="三、POM"></a><strong>三、POM</strong></h2><p>POM 代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。</p>
<p>在创建 POM 之前，我们首先确定工程组（groupId），及其名称（artifactId）和版本，在仓库中这些属性是工程的唯一标识。这些可以在仓库repository中查看到相关信息</p>
<p><img src="http://img.blog.csdn.net/20170125110747398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>下面以java EE的常见 pom.xml为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>crazyfzw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>springmvc-demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 集中定义依赖版本号 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.4<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper.version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">mapper.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commons-io.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">commons-io.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">redis.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">redis.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-data-redis.version</span>&gt;</span>1.7.5.RELEASE<span class="tag">&lt;/<span class="name">spring-data-redis.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jxls-core.version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">jxls-core.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">poi.version</span>&gt;</span>3.15<span class="tag">&lt;/<span class="name">poi.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mchange-commons-java.version</span>&gt;</span>0.2.12<span class="tag">&lt;/<span class="name">mchange-commons-java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>4.3.9.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">quartz.version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">quartz.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fastjson.version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">fastjson.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jsp-api.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">jsp-api.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p6spy.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">p6spy.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- api --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Jackson Json处理工具包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 通用Mapper --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.abel533<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- apache-velocity --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--c3p0工具包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mchange-commons-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mchange-commons-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Apache工具组件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-io.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- POI --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-scratchpad<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- jslx --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.jxls<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxls-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jxls-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- jxl --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.jexcelapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- quartz --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;quartz.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>opensymphony<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- hibernate --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;p6spy.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">&lt;!-- ehcache --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>14.0.2.0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-data-redis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- dubbox使用jar --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.2-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jline<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jline<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.94<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/joda-time/joda-time --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jstl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jsp-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">directory</span>&gt;</span>resource<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">warSourceDirectory</span>&gt;</span>WebRoot<span class="tag">&lt;/<span class="name">warSourceDirectory</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="三、仓库："><a href="#三、仓库：" class="headerlink" title="三、仓库："></a><strong>三、仓库：</strong></h2><p><strong>1) 本地仓库</strong><br>Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。<br>Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。</p>
<p>可以在maven安装地址的conf/settings.xml 指定本地仓库的路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/myLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2）中央仓库</strong><br><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><br><a href="https://search.maven.org/" target="_blank" rel="noopener">https://search.maven.org/</a></p>
<p><strong>3)远程仓库</strong><br>可以在私有服务器上搭建自己的maven仓库，外网的内网的都可以。eg:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.176.234/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Maven 依赖搜索顺序<br>步骤1：在本地仓库找<br>步骤2：若本地仓库没找到则去中央仓库找，找到则下载到本地仓库，留着日后备用<br>步骤3：若中央仓库没找到，则会检查时候有设置远程仓库，若有，则会在远程仓库中查找并下载到本地仓库备用。若没设置远程仓库或者在远程仓库中也无法找到，则会抛出错误(无法找到依赖的文件)</p>
<p><img src="http://img.blog.csdn.net/20170125110520928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> <strong>针对这种情况，可以通过构建外部依赖的方法解决。</strong></p>
<br>

<h2 id="四、构建外部依赖"><a href="#四、构建外部依赖" class="headerlink" title="四、构建外部依赖"></a><strong>四、构建外部依赖</strong></h2><p>把jar包文件并放到工程lib下，然后在pom.xml中添加依赖，eg:</p>
<p><img src="http://img.blog.csdn.net/20170125110843211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlpXX0ZhaXRo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.bank<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumerBanking<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>consumerBanking<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="五、依赖管理-Maven的核心特点之一"><a href="#五、依赖管理-Maven的核心特点之一" class="headerlink" title="五、依赖管理(Maven的核心特点之一)"></a><strong>五、依赖管理(Maven的核心特点之一)</strong></h2><p>当一个库 A 依赖于其他库 B. 另一工程 C 想要使用库 A, 那么该工程同样也需要使用到库 B。</p>
<p>使用maven，我们只需要在每个工程的 pom 文件里去定义直接的依赖关系。Maven 则会自动的来接管后续的工作。比如我们在pom.xml中定义了依赖jar包A，那么A所依赖的其他jar包，会被自动下载，不需要我们去定义。是不是很省事？</p>
<p>本文只是初步介绍了下maven 的使用，主要是在maven管理jar包，pom.xml文件的配置方面。还没涉及到maven在项目管理以及自动化构建方面。可参考下面链接拓展学习。</p>
<p><a href="http://www.oracle.com/technetwork/cn/community/java/apache-maven-getting-started-1-406235-zhs.html" target="_blank" rel="noopener">Apache Maven 入门篇</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/maven/build-automation.html" target="_blank" rel="noopener">Maven - 构建自动化</a></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>pom.xml</tag>
        <tag>maven构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 2：Java的内存模型</title>
    <url>/2018/06/24/memory-model/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>1.为了解决物理内存读写速度慢，与处理器运算速度不匹配的问题，现代操作系统在处理器和物理内存之间加入了高速缓存：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，从而让处理器无需等待缓慢的内存读写。</p>
<p>这种基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也引发了一个新问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，这将可能导致不同处理器缓存的数据不一致的问题，这就需要一种协议来规范并保证内存与高速缓存之间的交互与访问操作。</p>
<a id="more"></a>


<p><img src="/images/2018062501.png" alt=""></p>
<p>2.计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令进行指令重排优化，在多线程环境中，程序的顺序性并不能靠代码的先后顺序来保证。这些重排优化可能会导致程序出现内存可见性问题。</p>
<p>3.并发编程下如何保证程序执行的原子性、可见性、有序性?</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store、write。除了 long 型字段和 double 型字段外，java 内存模型确保访问任意类型字段所对应的内存单元都是原子的。这包括引用其它对象的引用类型的字段。此外，volatile long 和 volatile double 也具有原子性 。（虽然 java 内存模型不保证 non-volatile long 和 non-volatile double 的原子性，但它们在某些场合也具有原子性。）(non-volatile long 在64位 JVM，OS，CPU 下具有原子性)</p>
<p>原子性可以确保获取到的结果值所对应的所有bit位，全部都是由单个线程写入，但不能确保你获得的是任意线程写入之后的最新值。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改后的最新值。对于串行程序来说，可见性是不存存进行操作后才写回到主内存中的，这就可能存在一个线程 A 修改了共享变量 i 的值，还未写回主内存时，另外一个线程 B 又对主内存中同一个共享变量 i 进行操作，但此时 A 线程工作内存中共享变量 i 对线程 B 来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外在多线程环境下，指令重排优化确实会导致程序乱序执行的问题，从而也就导致可见性问题。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。</p>
<h2 id="二、Java内存模型的目的（解决的问题"><a href="#二、Java内存模型的目的（解决的问题" class="headerlink" title="二、Java内存模型的目的（解决的问题)"></a>二、Java内存模型的目的（解决的问题)</h2><p>1.屏蔽各种硬件和操作系统的差异，以实现让 Java 程序在各平台下都能达到一致的访问效果。<br>2.定义程序中各个变量的访问规则，定义了在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。通过这些规则可以解决缓存一致性问题。<br>3.定义了一套规则帮助在并发过程中保证程序执行的 原子性、可见性、有序性这3个特性，帮助解决并发编程可能出现的线程安全问题。</p>
<h2 id="三、Java内存模型提供的解决方案"><a href="#三、Java内存模型提供的解决方案" class="headerlink" title="三、Java内存模型提供的解决方案"></a>三、Java内存模型提供的解决方案</h2><p>在 Java 内存模型中都提供一套解决方案供 Java 工程师在开发过程使用，如原子性问题，除了 JVM 自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用 synchronized 关键字或者重入锁(ReentrantLock)保证程序执行的原子性；而工作内存与主内存同步延迟现象导致的可见性问题，可以使用 synchronized 关键字或者 volatile 关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见；对于指令重排导致的可见性问题和有序性问题，则可以利用 volatile 关键字解决，因为 volatile 的另外一个作用就是禁止重排序优化；除了靠 sychronized 和 volatile 关键字来保证原子性、可见性以及有序性外，JMM 内部还定义一套 happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性，通过这个原则，可以判断数据是否存在竞争、线程是否安全。</p>
<h2 id="四、Java内存模型的包含了哪些内容"><a href="#四、Java内存模型的包含了哪些内容" class="headerlink" title="四、Java内存模型的包含了哪些内容"></a>四、Java内存模型的包含了哪些内容</h2><h3 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1.主内存与工作内存"></a>1.主内存与工作内存</h3><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（工作内存优先存储于寄存器和高速缓存中），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。</p>
<p><img src="/images/2018062502.png" alt=""></p>
<h3 id="2-主内存与工作内存间的交互协议"><a href="#2-主内存与工作内存间的交互协议" class="headerlink" title="2.主内存与工作内存间的交互协议"></a>2.主内存与工作内存间的交互协议</h3><p>*<em>Java内存模型定义了以下八种操作来完成：一个变量从主内存拷贝到工作内存、从工作内存同步到主内存之间的实现细节。<br>*</em></p>
<ul>
<li><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
</li>
<li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p>
</li>
<li><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p>
</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行（如：read a，read b，load b， load a 是允许的）。</p>
<p><strong>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</strong></p>
<ul>
<li><p>不允许 read 和 load、store 和 write 操作之一单独出现</p>
</li>
<li><p>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>
</li>
<li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，lock 和 unlock 必须成对出现。</p>
</li>
<li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</p>
</li>
<li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</p>
</li>
<li><p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</p>
</li>
</ul>
<h3 id="3-先行发生原则-happens-before"><a href="#3-先行发生原则-happens-before" class="headerlink" title="3.先行发生原则(happens-before)"></a>3.先行发生原则(happens-before)</h3><p>若在程序开发中，仅靠 sychronized 和 volatile 关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在 Java 内存模型中，还提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。</p>
<p>该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。按照官方的说法：</p>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。 要想保证操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在一个线程），那么在 A 和 B 之间必须满足 HB 原则，如果没有，将有可能导致重排序。 当缺少 HB 关系时，就可能出现重排序问题。</p>
<ul>
<li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
</li>
<li><p>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作(注意：必须是同一个锁才适用)<br>，在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行；</p>
</li>
<li><p>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p>
</li>
<li><p>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作；</p>
</li>
<li><p>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
</li>
<li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始；</p>
</li>
<li><p>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作A先行发生于操作 C；</p>
</li>
</ul>
<p>深刻的理解 happen-before，理解某些规则下上一个操作对下一个操作的有序性和操作结果的可见性。同时，通过灵活的使用传递性规则，再对规则进行组合，就可以在不使用 volatile 和 synchronized 的情况下载两个线程间实现变量共享。</p>
<h3 id="4-同步机制之voliate关键字"><a href="#4-同步机制之voliate关键字" class="headerlink" title="4.同步机制之voliate关键字"></a>4.同步机制之voliate关键字</h3><p><strong>volatile 是 Java 虚拟机提供的最轻量级的同步机制。volatile   关键字有如下两个作用:</strong></p>
<ul>
<li>被 volatile 修饰的变量对所有线程可见，当一条线程修改了一个被 volatile 变量的值，新值对于其他线程来说是可以立即得知的。</li>
<li>禁止指令重排序优化。</li>
</ul>
<p>那么 <strong>JMM 是如何保证  volatile 变量的可见性的？通过一下两点：</strong></p>
<ol>
<li><p>线程对 volatile 变量写入后，在执行后续的内存访问之前，线程必须把新值刷新到内存中。</p>
</li>
<li><p>每次使用 volatile 变量之前，都要从内存重新装载变量的值。</p>
</li>
</ol>
<p>正确使用 volatile 保证线程安全的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> isOnline;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUserOnline</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isOnline=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isOnline)&#123;</span><br><span class="line">          System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于对于 boolean 变量的操作属于原子性操作，因此可以通过使用 volatile 修饰，使用该变量对其他线程立即可见，从而达到线程安全的目的。</p>
<p>错误使用 volatile 的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是以上代码不是线程安全的，java里面运算并非原子操作，比如 i++，是分成取值，添加分布执行的，当在执行添加的时候可能其他线程已经改变了i的值，所以这种情况下是无法用 volatile 来保证线程的安全性的。</p>
<p><strong>使用 volatile 必须要满足以下条件：</strong></p>
<ul>
<li>对字段的写操作不依赖于当前值（即运算结果不依赖当前变量的值），或者确保只有单一线程会修改改变了的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束（即读取操作不依赖于其它非 volatile 字段的值）。</li>
</ul>
<p>下面再通过一个例子看下 volatile 在禁止指令重排序的作用</p>
<p>以下程序不是线程安全的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"x"</span>=x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>写两个线程，一个进行 write（叫 writer）,一个进行 read（叫 reader）,运行程序会发现输出 x 的值有时是100，有时却是0。因为在 writer 线程中，编译器可能会在 writer 线程中进行重排序写入操作，这就导致可能会出现 v= true 时，x 扔为0的情况。从而引起线程的不安全。 这种情况下用 volatile 修饰变量 v, 就可以禁止编译器进行指令重排序优化，这样 v=true,时，就可以确保 x=100 已经被执行， 从而保证了线程的安全性。</p>
<p><strong>volatile 的原理和实现机制</strong><br>在 x86处理器下通过工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作 CPU 会做什么事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java代码: instance &#x3D; new Singleton();  &#x2F;&#x2F;instance是volatile变量</span><br><span class="line">汇编代码: 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure>
<p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>（2）它会强制将对缓存的修改操作立即写入主内存；<br>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p>如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><strong>如何考虑选用 synchronized 还是 volatile</strong><br>大多数场景下 volatile 的总开销要比 synchronized  低 ，我们再 volatile  中选择的唯一判断依据就是 volatile 的语义能否满足使用场景的需求，即如果用 volatile  就能解决线程安全的问题，那就选用 volatile，否则才选用  synchronized 。需要注意的是，使用 volatile 的使用必须满足以下两个条件：</p>
<ul>
<li>对字段的写操作不依赖于当前值（即运算结果不依赖当前变量的值），或者确保只有单一线程会修改改变了的值，</li>
<li>变量不需要与其他的状态变量共同参与不变约束（即读取操作不依赖于其它非volatile字段的值）</li>
</ul>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明 第十二章<br><a href="http://ifeve.com/syn-jmm/" target="_blank" rel="noopener">同步和Java内存模型 </a><br><a href="http://ifeve.com/syn-jmm-pre/" target="_blank" rel="noopener">Java内存模型FAQ </a><br><a href="https://blog.csdn.net/javazejian/article/details/72772461#%E5%8F%AF%E8%A7%81%E6%80%A7" target="_blank" rel="noopener">全面理解Java内存模型(JMM)及volatile关键字</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java内存模型</tag>
        <tag>JMM</tag>
        <tag>volatile</tag>
        <tag>happens-before</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 3：Redis 的Java 客户端 Jedis</title>
    <url>/2018/08/12/redis-java-client-Jedis/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Jedis 是 Redis 官方推荐的 Java 连接开发工具。Jedis 是一个非常小但又功能健全的 java 客户端。Jedis 是开源的，目前最新版本是 2.9.0 , 兼容 redis 2.8.x 和 3.x.x.版本，Github 地址： <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></p>
<a id="more"></a>

<p><strong>Jedis 提供了哪些支持？</strong></p>
<ul>
<li>排序</li>
<li>连接操作</li>
<li>支持 redis 所有 value 操作相关的命令</li>
<li>支持 redis 提供的五种数据结构及相关命令</li>
<li>事物 (Transactions)</li>
<li>Pipelining</li>
<li>发布/订阅 Publish/Subscribe</li>
<li>连接池 (Connection pooling)</li>
<li>分片 (Sharding )</li>
<li>Lua 脚本</li>
<li>集群 (Redis Cluster)</li>
<li>Persistence control commands</li>
<li>Remote server control commands</li>
</ul>
<h2 id="二、获取-Jedis"><a href="#二、获取-Jedis" class="headerlink" title="二、获取 Jedis"></a>二、获取 Jedis</h2><p>通过 maven 配置依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Jedis-直连-Redis"><a href="#三、Jedis-直连-Redis" class="headerlink" title="三、Jedis 直连 Redis"></a>三、Jedis 直连 Redis</h2><p>直连方式每次都会新建 TCP 连接，使用后再断开连接，对于频繁访问 Redis 的场景显然不是高效的使用方式。生产环境不推荐使用这种方式。</p>
<p><img src="/images/2018081301.png" alt=""></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//生成一个Jedis对象，这个对象负责和指定Redis实例进行通信</span></span><br><span class="line">    jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后通过 jedis 对象就可以调用 redis 支持的命令了，比如</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完之后关闭连接</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际项目推荐使用 try catch finally 的形式来进行代码的书写：一方面可以在 Jedis 出现异常的时候（本身是网络操作），将异常进行捕获或者抛出；另一个方面无论执行成功或者失败，将 Jedis 连接关闭掉。</p>
<p>创建 Jedis 时，还可以调用以下构造函数，指定 客户端连接超时时间、客户端读写超时时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> soTimeout);</span><br></pre></td></tr></table></figure>

<h2 id="四、Jedis-连接池方式"><a href="#四、Jedis-连接池方式" class="headerlink" title="四、Jedis 连接池方式"></a>四、Jedis 连接池方式</h2><p>所有Jedis对象预先放在池子中（JedisPool），每次要连接 Redis，只需要在池子中借，用完了在归还给连接池。生产环境一般都使用这种方式。</p>
<p><img src="/images/2018081302.png" alt=""></p>
<p>Jedis提供了 JedisPool 这个类作为对 Jedis 的连接，同时使用了 Apache 的通用对象池工具 common-pool2 作为资源的管理工具。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.common-pool2 连接池配置</span></span><br><span class="line">GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"><span class="comment">//可以根据需要设置相关属性</span></span><br><span class="line">poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">poolConfig.setMaxIdle(<span class="number">50</span>);</span><br><span class="line">poolConfig.setMinIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.初始化Jedis连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>



<p>此时，获取 Jedis 对象不再是直接生成一个 Jedis 对象进行直连，而是从连接池直接获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//从连接池借用 jedis 对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123; </span><br><span class="line">       <span class="comment">//使用完后归还连接池</span></span><br><span class="line">       jedis.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong>以上代码有点需要注意的是：使用 JedisPool 的时候，jedis.close() 不是关闭连接，而是表示归还连接池。</p>
<p>看下 Jedis 对 close方法的实现就很清楚了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client.isBroken()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnBrokenResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource.returnResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Jedis 对于 close 的实现，会先通过 dataSource 是否为 null 判断是否是使用连接池，若是，则调用归还资源函数，否则才真正执行关闭连接的操作。</p>
<p><strong>GenericObjectPoolConfig 的重要属性如下图所示：</strong><br><img src="/images/2018081303.jpg" alt=""></p>
<h2 id="五、Jedis直连方式和连接池方式对比"><a href="#五、Jedis直连方式和连接池方式对比" class="headerlink" title="五、Jedis直连方式和连接池方式对比"></a>五、Jedis直连方式和连接池方式对比</h2><blockquote>
<p>You shouldn’t use the same instance from different threads because you’ll have strange errors. And sometimes creating lots of Jedis instances is not good enough because it means lots of sockets and connections, which leads to strange errors as well. A single Jedis instance is not threadsafe! To avoid these problems, you should use JedisPool, which is a threadsafe pool of network connections. You can use the pool to reliably create several Jedis instances, given you return the Jedis instance to the pool when done. This way you can overcome those strange errors and achieve great performance.</p>
</blockquote>
<p>单个Jedis对象是线程不安全的，我们不应该在多个线程中使用共用同一个Jedis对象，然而，如果通过直连方式创建多个Jedis对象，又意味着会创建大量的socket以及TCP连接，带来大量的开销。为了避免这个问题，Jedis 为我们提供了一个线程安全的线程池JedisPool，通过连接池的方式，可以预先可靠地创建好多个Jedis连接对象，然后每次需要的时候就从Jedis连接池借用，使用完之后归还即可。这种方式提供了更大的安全性以及灵活性，所以，生产环境推荐使用连接池方式。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直连</td>
<td align="center">简单方便，适用于少量长期连接的场景</td>
<td align="center">1）存在每次新建/关闭 TCP 连接开销<br/> 2）资源无法控制，可能会出现连接泄露  <br/> 3）Jedis对象线程不安全</td>
</tr>
<tr>
<td align="center">连接池</td>
<td align="center">1）无需每次连接都生成Jedis对象，降低开销<br/>2）使用连接池的方式控制和保护资源的使用</td>
<td align="center">相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规则不合理也会出现问题</td>
</tr>
</tbody></table>
<h2 id="六、Pipelining"><a href="#六、Pipelining" class="headerlink" title="六、Pipelining"></a>六、Pipelining</h2><blockquote>
<p>Sometimes you need to send a bunch of different commands. A very cool way to do that, and have better performance than doing it the naive way, is to use pipelining. This way you send commands without waiting for response, and you actually read the responses at the end, which is faster.</p>
</blockquote>
<p>Redis 支持 Pipelining 特性，Pipeline在某些场景下非常有用，比如有时想批量提交多个命令，而且他们对相应结果没有互相依赖，而且对结果响应也无需立即获得，那么久可以利用 Pipelining 实现这种批量处理，一次性发送多条命令并在执行完后一次性将结果返回。pipeline通过减少客户端与redis的通信次数来实现降低往返延时时间。过程大致如下：</p>
<p><img src="/images/2018081304.jpg" alt=""></p>
<p><strong>通过Jedis使用 Pipelining 的示例如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pipeline p = jedis.pipelined();</span><br><span class="line">p.set(<span class="string">"fool"</span>, <span class="string">"bar"</span>); </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">1</span>, <span class="string">"barowitch"</span>);  </span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barinsky"</span>);</span><br><span class="line">p.zadd(<span class="string">"foo"</span>, <span class="number">0</span>, <span class="string">"barikoviev"</span>);</span><br><span class="line">Response&lt;String&gt; pipeString = p.get(<span class="string">"fool"</span>);</span><br><span class="line">Response&lt;Set&lt;String&gt;&gt; sose = p.zrange(<span class="string">"foo"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">p.sync(); </span><br><span class="line"><span class="keyword">int</span> soseSize = sose.get().size();</span><br><span class="line">Set&lt;String&gt; setBack = sose.get();</span><br></pre></td></tr></table></figure>


<h2 id="七、发布-订阅（Publish-Subscribe）"><a href="#七、发布-订阅（Publish-Subscribe）" class="headerlink" title="七、发布/订阅（Publish/Subscribe）"></a>七、发布/订阅（Publish/Subscribe）</h2><p>Redis 通过 PUBLISH、SUBSCRIBE 等命令实现了订阅与发布模式，Redis 的 SUBSCRIBE 命令可以让客户端订阅任意数量的频道，每当有新信息 发布到被订阅的频道时， 信息就会被发送给所有订阅指定频道的客户端。</p>
<p>整个模型过程如下图所示：</p>
<p><img src="/images/2018081305.png" alt=""></p>
<p>上图展示了频道 channel1 ，以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系，当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端。</p>
<p><strong>使用场景：</strong></p>
<p>Publish/Subscribe 是目前广泛使用的通信模型，有很多的使用场景，比如内容订阅的的场；<br>；比如分布式架构中实现读写分离的场景，在写入的过程中，就可以使用redis发布订阅，使得写入值及时发布到各个读的程序中，保证数据的完整一致性。场景还有很多，有待挖掘。</p>
<p><strong>在 Jedis 使用 Publish/Subscribe 的示例，可以参考：</strong><a href="https://www.cnblogs.com/xinde123/p/8489054.html" target="_blank" rel="noopener">java实现 redis的发布订阅（简单易懂）</a></p>
<h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><p>[1] 《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://github.com/xetorthio/jedis/wiki/Getting-started" target="_blank" rel="noopener">Jedis WiKi</a><br>[3] <a href="https://xetorthio.github.io/jedis/" target="_blank" rel="noopener">Jedis API</a><br>[4] <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis 源码</a><br>[5] <a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html#id2" target="_blank" rel="noopener">订阅与发布</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>jedisPool</tag>
        <tag>Pipelining</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 4：Redis 集群的搭建与运维</title>
    <url>/2018/08/24/redis-cluster-setup-and-operation/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>集群的搭建可以分为以节点准备、节点握手、分配槽三个步骤。</p>
<h3 id="节点准备"><a href="#节点准备" class="headerlink" title="节点准备"></a>节点准备</h3><p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让 Redis 运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下。</p>
<a id="more"></a>


<h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信，达到感知对方的过程。<br>我们只需要在集群内任意节点上执行 cluster meet 命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6381</span><br></pre></td></tr></table></figure>

<h3 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h3><p>Redis集群把所有的数据映射到16384个槽中。每个 key 会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5641&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二、用-redis-trib-rb-搭建集群"><a href="#二、用-redis-trib-rb-搭建集群" class="headerlink" title="二、用 redis-trib.rb 搭建集群"></a>二、用 redis-trib.rb 搭建集群</h2><p>虽然手动搭建集群可以让我们了解集群建立的流程和细节，单当节点多时，手动搭建比较繁琐，并且容易出错，所以生产环境推荐使用 redis-trib.rb 集群管理工具进行搭建。 redis-trib.rb 提供了集群的创建、检查、修复、均衡等命令行工具，输入 redis-trib.rb 命令可以查看到具体的参数用法。</p>
<p>这里用3台机器，每个机器上安装4个节点，总共12个节点，按1主1从组成集群。</p>
<table>
<thead>
<tr>
<th align="center">服务器</th>
<th align="center">节点实例端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.2.8.94</td>
<td align="center">7000,7001,7002,7003</td>
</tr>
<tr>
<td align="center">10.2.8.95</td>
<td align="center">7004,7005,7006,7007</td>
</tr>
<tr>
<td align="center">10.2.8.96</td>
<td align="center">7008,7009,7010,7011</td>
</tr>
</tbody></table>
<p><strong>准备节点</strong></p>
<p>下面以一台服务器为例，安装4个节点，其余2台机器也采用同样的方式进行安装。</p>
<h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>


<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#service iptables stop #关闭防火墙</span><br><span class="line">#service iptables status #查看状态</span><br></pre></td></tr></table></figure>

<h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"># wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.3.tar.gz #下载安装包</span><br><span class="line"># tar -xf redis-3.2.3.tar.gz #解压安装包</span><br><span class="line"># ln -s redis-3.2.3 redis #建立软链接,方便以后升级维护</span><br><span class="line"># cd redis</span><br><span class="line"># make &amp;&amp; make install </span><br><span class="line"># cd src</span><br><span class="line"># .&#x2F;redis-cli -v #验证安装是否成功</span><br><span class="line"># export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure>
<p>这一步可以参考我的上一篇博客：<a href="https://crazyfzw.github.io/2018/08/10/Redis%20%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4%202%EF%BC%9ARedis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A-Redis-shell-%E7%9A%84%E4%BD%BF%E7%94%A8/#more">Redis环境搭建及Redis shell的使用</a></p>
<h3 id="安装-redis-trib-rb-工具"><a href="#安装-redis-trib-rb-工具" class="headerlink" title="安装 redis-trib.rb 工具"></a>安装 redis-trib.rb 工具</h3><p>redis-trib.rb 是采用Ruby实现的Redis集群管理工具。内部通过Cluster相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用前需要安装Ruby环境。注意由于我们用redis-trib.rb 在一台服务器上就可以操作整个集群了，所以只需要挑选一台服务器安装既可，不需要每天服务器都安装。</p>
<h4 id="1）安装Ruby"><a href="#1）安装Ruby" class="headerlink" title="1）安装Ruby"></a>1）安装Ruby</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 local]# wget https:&#x2F;&#x2F;cache.ruby-lang.org&#x2F;pub&#x2F;ruby&#x2F;2.3&#x2F;ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# tar -xf ruby-2.3.1.tar.gz</span><br><span class="line">[root@gdyt-wbredis01 local]# ln -s ruby-2.3.1 ruby</span><br><span class="line">[root@gdyt-wbredis01 local]# cd ruby</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;configure</span><br><span class="line">[root@gdyt-wbredis01 ruby]# make &amp;&amp; make install</span><br><span class="line">[root@gdyt-wbredis01 ruby]# .&#x2F;ruby  -v</span><br><span class="line">ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-linux]</span><br><span class="line"></span><br><span class="line">[root@gdyt-wbredis01 ruby]# export &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src:&#x2F;usr&#x2F;local&#x2F;ruby:&#x2F;usr&#x2F;local&#x2F;ruby&#x2F;bin:$PATH&quot; #设置环境变量</span><br></pre></td></tr></table></figure>

<h4 id="2）安装-rubygem-redis-依赖。"><a href="#2）安装-rubygem-redis-依赖。" class="headerlink" title="2）安装 rubygem redis 依赖。"></a>2）安装 rubygem redis 依赖。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ruby]# gem sources --add https:&#x2F;&#x2F;ruby.taobao.org&#x2F; --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]#  gem sources -l</span><br><span class="line">https:&#x2F;&#x2F;ruby.taobao.org&#x2F;</span><br><span class="line">[root@gdyt-wbredis01 bin]# gem install redis</span><br></pre></td></tr></table></figure>
<p>安装好后执行 redis-trib.rb 命令确认是否安装成功。</p>
<p><img src="/images/2018082404.png" alt=""></p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="1）创建集群配置文件夹"><a href="#1）创建集群配置文件夹" class="headerlink" title="1）创建集群配置文件夹"></a>1）创建集群配置文件夹</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mkdir &#x2F;etc&#x2F;redis&#x2F;redis_cluster -p</span><br></pre></td></tr></table></figure>

<h4 id="2）创建多个实例目录"><a href="#2）创建多个实例目录" class="headerlink" title="2）创建多个实例目录"></a>2）创建多个实例目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 redis_cluster]# mkdir 7000 7001 7002 7003</span><br><span class="line">[root@gdyt-wbredis01 redis_cluster]# ls -l</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7000</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7001</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7002</span><br><span class="line">drwxr-xr-x 2 root root 4096 8月  16 09:59 7003</span><br></pre></td></tr></table></figure>

<h4 id="3）-配置文件"><a href="#3）-配置文件" class="headerlink" title="3） 配置文件"></a>3） 配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7000&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7001&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7002&#x2F;redis.conf</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf 7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 10.2.8.94 #绑定本机IP</span><br><span class="line">daemonize yes #后台运行</span><br><span class="line">pidfile  &#x2F;var&#x2F;run&#x2F;redis_7000.pid #PID文件</span><br><span class="line">port  7000 #监听端口</span><br><span class="line">cluster-enabled yes #开启集群</span><br><span class="line">cluster-config-file  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;nodes-7000.conf #实例节点配置</span><br><span class="line">cluster-node-timeout 5000 #集群通信超时</span><br><span class="line">appendonly yes #AOF日志开启写</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">cluster-require-full-coverage no #设置为no主节点故障时，不会影响其他节点的可用性</span><br></pre></td></tr></table></figure>


<h4 id="4）用配置文件启动各个节点"><a href="#4）用配置文件启动各个节点" class="headerlink" title="4）用配置文件启动各个节点"></a>4）用配置文件启动各个节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7004&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7005&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7006&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis02 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7007&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7008&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7009&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7010&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis03 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7011&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="5）配置集群-At-least-6-nodes-are-required-至少需要6个节点"><a href="#5）配置集群-At-least-6-nodes-are-required-至少需要6个节点" class="headerlink" title="5）配置集群(At least 6 nodes are required., 至少需要6个节点)"></a>5）配置集群(At least 6 nodes are required., 至少需要6个节点)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]#redis-trib.rb create  --replicas  1  10.2.8.94:7000  10.2.8.94:7001  10.2.8.94:7002  10.2.8.94:7003  10.2.8.95:7004  10.2.8.95:7005 10.2.8.95:7006 10.2.8.95:7007 10.2.8.96:7008 10.2.8.96:7009 10.2.8.96:7010 10.2.8.96:7011</span><br></pre></td></tr></table></figure>


<p><strong>其中 –replicas 后面的 数字 表示给每个主节点配备几个从节点，这里需要特别注意的是，redis-trib.rb会重新排序列表顺序，来确定主从角色，尽可能的保证主从节点不分配在统一机器下。</strong></p>
<p><img src="/images/2018082401.png" alt=""></p>
<p>可以用 redis-trib.rb 的 info 或 check 来查看或检查集群的信息</p>
<p><img src="/images/2018082402.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-trib.rb check 10.2.8.94:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.2.8.94:7001)</span><br><span class="line">S: 84923706efb5d77511707b8f74abd3f57d3c26a9 10.2.8.94:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b5819808aa06db5ada355e111dda2a129aa3597c</span><br><span class="line">M: 1c864de9ba655958f0ceae2363acfc298d5039e8 10.2.8.96:7009</span><br><span class="line">   slots:13653-16383 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 07a32cf512dd04a9ead49cc7dc1ce6c087c799a5 10.2.8.94:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8c141a332d7bc488ac9236a778791f6b80aec1e3</span><br><span class="line">M: 8c141a332d7bc488ac9236a778791f6b80aec1e3 10.2.8.95:7004</span><br><span class="line">   slots:2731-5460 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 4eeb5d5207f599a7469dd8f031517ae7b69be126 10.2.8.94:7003</span><br><span class="line">   slots:5461-8191 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3 10.2.8.95:7006</span><br><span class="line">   slots:0-2730 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 107fc0afc81a5c1c3a72e72dc0a9832bb543ed13 10.2.8.96:7011</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed</span><br><span class="line">S: 4ba0b34eb289ac7d5222e0e1f55a461ebdc97d66 10.2.8.94:7000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e2d75e2d9375255e6d0c877208ff0e85fa4fd7d3</span><br><span class="line">M: 24f3d8feb7c16ac2b5fa72cd60e9f34dd04b11ed 10.2.8.95:7005</span><br><span class="line">   slots:10923-13652 (2730 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e33c091a22ba1963ad6f17ee4fb8b11b405e553d 10.2.8.96:7008</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 4eeb5d5207f599a7469dd8f031517ae7b69be126</span><br><span class="line">S: 306ac97503a76b662fe5a6515f699e8c47f9f219 10.2.8.95:7007</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1c864de9ba655958f0ceae2363acfc298d5039e8</span><br><span class="line">M: b5819808aa06db5ada355e111dda2a129aa3597c 10.2.8.96:7010</span><br><span class="line">   slots:8192-10922 (2731 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>



<h4 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h4><p>通过 -c 参数进入集群模式进行验证后， 在任意一台服务器连接任意实例端口操作数据，将会自动在片区进行操作。</p>
<p><img src="/images/2018082403.png" alt=""></p>
<p>至此，整个集群已经配置完成了。</p>
<h2 id="三、设置密码"><a href="#三、设置密码" class="headerlink" title="三、设置密码"></a>三、设置密码</h2><p>vi /etc/redis/redis_cluster/7000/redis.conf</p>
<p>在文件末尾加入。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth &quot;crazyfzw&quot;</span><br><span class="line">requirepass &quot;crazyfzw&quot;</span><br></pre></td></tr></table></figure>

<p>按照同样的方法给集群的所有节点设置相同的密码（一定要相同），然后通过配置文件重新启动所有服务就可以了。</p>
<p><strong>设置密码后的注意事项：</strong></p>
<p>需要注意的是设置密码后，执行 redis-cli 连接的时候需要一定要指定密码，否则无法执行任何命令，会报错(error) NOAUTH Authentication required.，如下图：</p>
<p><img src="/images/2018082405.png" alt=""></p>
<p>正确的操作应该这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -c -h 10.2.8.94 -p 7000 -a yourpass</span><br></pre></td></tr></table></figure>

<p>*<em>设置密码后 redis-trib.rb 工具将会无法使用，执行相关命令会报错： *</em></p>
<p><img src="/images/2018082406.png" alt=""></p>
<p>解决办法：修改 client.rb 的中的密码。（tip: 可以通过find命令找到文件所在的目录）</p>
<p><img src="/images/2018082407.png" alt=""></p>
<h2 id="四、优化系统"><a href="#四、优化系统" class="headerlink" title="四、优化系统"></a>四、优化系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">#TCP监听队列值</span><br><span class="line">net.core.somaxconn &#x3D; 2048</span><br><span class="line">#内存分配策略，选择1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何；</span><br><span class="line">#默认0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程</span><br><span class="line">vm.overcommit_memory &#x3D; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用配置生效</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Redis不使用透明大页</span><br><span class="line">#加入开机启动</span><br><span class="line"># vi  &#x2F;etc&#x2F;rc.local</span><br><span class="line">echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</span><br><span class="line">&#96;&#96;</span><br></pre></td></tr></table></figure>


<h2 id="五、创建方便运维的脚本"><a href="#五、创建方便运维的脚本" class="headerlink" title="五、创建方便运维的脚本"></a>五、创建方便运维的脚本</h2><p>一般我们出于对成本的考虑，我们会在一台服务器上装几个节点， 所以一旦集群出现故障，需要重启时，需要分别执行命令去启动几个节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">[root@gdyt-wbredis01 ~]# redis-server  &#x2F;etc&#x2F;redis&#x2F;redis_cluster&#x2F;7003&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<p>特别是生产故障时，这种做法非常不方便，所以可以自己写个 shell 脚本，<br>方便日后在一台机器上通过一个命令就可以管理这台机器上的所有节点。</p>
<p>编写脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 55 25</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Redis实例集群服务启动和停止脚本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">公共参数</span></span><br><span class="line">REDIS_BIN="/usr/local/redis/src/"</span><br><span class="line">LOCAL_IP=`ip addr | grep "inet" | grep  -v "inet6" | awk -F ' ' '&#123;print $2&#125;' | awk -F '/' '&#123;print $1&#125;' | grep -v "127.0.0.1"` #如果IP有多个,需要指定IP</span><br><span class="line">PORT_LIST="7000 7001 7002 7003" #端口需要根据实际情况定义,每个端口使用空格隔开</span><br><span class="line">CONFIG_DIR="/etc/redis/redis_cluster"</span><br><span class="line">PASSWORD="yourpassword"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for port in $PORT_LIST</span><br><span class="line">do</span><br><span class="line">	if [ ! -f "$CONFIG_DIR/$port/redis.conf" ]</span><br><span class="line">	then</span><br><span class="line">		echo "$CONFIG_DIR/$port/redis.conf is not exist!"</span><br><span class="line">		exit 2</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH=$REDIS_BIN:$PATH</span><br><span class="line"></span><br><span class="line">function status()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		pid=`ps aux |  grep -v grep  | grep "redis-server $LOCAL_IP:$port" | awk -F ' ' '&#123;print $2&#125;'`</span><br><span class="line">		if [ ! -z "$pid" ]</span><br><span class="line">		then</span><br><span class="line">			echo "redis process [$pid] $LOCAL_IP:$port is run.."</span><br><span class="line">		else</span><br><span class="line">			echo "redis process [$pid] $LOCAL_IP:$port not run.."</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		redis-server $CONFIG_DIR/$port/redis.conf </span><br><span class="line">	done</span><br><span class="line">	status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop()&#123;</span><br><span class="line">	for port in $PORT_LIST</span><br><span class="line">	do</span><br><span class="line">		redis-cli -h $LOCAL_IP -p $port -a $PASSWORD shutdown</span><br><span class="line">	done	</span><br><span class="line">	status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">	start)</span><br><span class="line">		echo "start redis.."</span><br><span class="line">		start</span><br><span class="line">		;;</span><br><span class="line">	stop)</span><br><span class="line">		echo "stop redis.."</span><br><span class="line">		stop</span><br><span class="line">		;;</span><br><span class="line">	status)</span><br><span class="line">		echo "redis status.."</span><br><span class="line">		status</span><br><span class="line">		;;</span><br><span class="line">	restart)</span><br><span class="line">		echo "restart redis.."</span><br><span class="line">		echo "stop redis.."</span><br><span class="line">		stop</span><br><span class="line">		echo "start redis.."</span><br><span class="line">		start</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo $"Usage: $0 &#123;start|stop|status|restart&#125;"</span><br><span class="line">		exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<p>注册服务，并设置成开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@gdyt-wbredis01 init.d]# ls -l &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">-rwxr-xr-x 1 root root 1506 8月  17 09:47 &#x2F;etc&#x2F;init.d&#x2F;redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig --add redis-server</span><br><span class="line">[root@gdyt-wbredis01 init.d]# chkconfig on redis-server</span><br></pre></td></tr></table></figure>


<p><strong>使用脚本进行启动，停止，重启 redis 服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server start #启动</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server status #状态</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server stop #停止</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;redis-server restart #重启</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018082408.png" alt=""></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis cluster</tag>
        <tag>Redis集群搭建</tag>
        <tag>redis-trib.rb</tag>
      </tags>
  </entry>
  <entry>
    <title>订阅 Redis 的 key 过期事件实现动态定时任务</title>
    <url>/2019/04/09/redis-keyspace-notifications/</url>
    <content><![CDATA[<h3 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a><a href="#一、需求" title="一、需求"></a>一、需求</h3><ol>
<li>设置了生存时间的Key，在过期时能不能有所提示？</li>
<li>如果能对过期Key有个监听，如何对过期Key进行一个回调处理？</li>
<li>如何使用 Redis 来实现定时任务？</li>
</ol>
<p>比如：</p>
<ul>
<li>处理订单过期自动取消，12306 购票系统超过30分钟没有成功支付的订单会被回收处理;</li>
<li>购买商品15天后默认好评；</li>
<li>外卖系统的送餐超时提醒；</li>
<li>客服与顾客聊天，客服超过多长时间没回复，系统给客服发一个提醒消息；<br>…</li>
</ul>
<a id="more"></a>

<p>这里的定时任务并不是  Crontab 这种如 <code>0 0 23 * * ?</code> (每日23点执行) 定死多长时间执行一次的， 而是某种特定动作触发创建的一个多长时间后执行的任务。比如有100个 用户触发了这个动作，那么就会创建100个定时任务，并且这100个任务由于触发创建的时间不同，执行的时间也很可能不在同一时间。</p>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a><a href="#二、思路" title="二、思路"></a>二、思路</h3><p>在 Redis 的 2.8.0 版本之后，其推出了一个新的特性——键空间消息（Redis Keyspace Notifications），它配合 2.0.0 版本之后的 SUBSCRIBE 就能完成这个定时任务的操作了。</p>
<p><strong>Redis 的键空间通知支持  订阅指定 Key 的所有事件  与 订阅指定事件  两种方式。</strong></p>
<blockquote>
<p>Keyspace notifications are implemented sending two distinct type of events for every operation affecting the Redis data space. For instance a DEL operation targeting the key named mykey in database 0 will trigger the delivering of two messages, exactly equivalent to the following two PUBLISH commands:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH <strong>keyspace@0</strong>:mykey del</span><br><span class="line">PUBLISH <strong>keyevent@0</strong>:del mykey</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>通过 Redis 的键空间通知（keyspace notification）可以做到：下单时将订单 id 写入 redis，设置过期时间30分钟，利用 redis 键过期回调提醒，30分钟后可以在回调函数里检查订单状态，如果未支付，则进行处理。</strong></p>
<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a><a href="#三、实现" title="三、实现"></a>三、实现</h3><h4 id="1-修改-redis-conf-开启redis-key过期提醒"><a href="#1-修改-redis-conf-开启redis-key过期提醒" class="headerlink" title="1. 修改 redis.conf 开启redis key过期提醒"></a><a href="#1-修改-redis-conf-开启redis-key过期提醒" title="1. 修改 redis.conf 开启redis key过期提醒"></a>1. 修改 redis.conf 开启redis key过期提醒</h4><blockquote>
<p>By default keyspace events notifications are disabled because while not very sensible the feature uses some CPU power. Notifications are enabled using the notify-keyspace-events of redis.conf or via the CONFIG SET.</p>
</blockquote>
<p>由于键空间通知比较耗CPU, 所以 Redis默认是关闭键空间事件通知的， 需要手动开启 notify-keyspace-events 后才启作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line">K：keyspace事件，事件以__keyspace@&lt;db&gt;__为前缀进行发布；        </span>
<span class="line">E：keyevent事件，事件以__keyevent@&lt;db&gt;__为前缀进行发布；        </span>
<span class="line">g：一般性的，非特定类型的命令，比如del，expire，rename等；       </span>
<span class="line">$：String 特定命令；        </span>
<span class="line">l：List 特定命令；        </span>
<span class="line">s：Set 特定命令；        </span>
<span class="line">h：Hash 特定命令；        </span>
<span class="line">z：Sorted 特定命令；        </span>
<span class="line">x：过期事件，当某个键过期并删除时会产生该事件；        </span>
<span class="line">e：驱逐事件，当某个键因maxmemore策略而被删除时，产生该事件；        </span>
<span class="line">A：g$lshzxe的别名，因此”AKE”意味着所有事件。</span>
</pre></td></tr></table></figure>

<p><strong><code>notify-keyspace-events Ex</code> 表示开启键过期事件提醒</strong></p>
<h4 id="2-继承-JedisPubSub-实现一个消息监听器类"><a href="#2-继承-JedisPubSub-实现一个消息监听器类" class="headerlink" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a><a href="#2-继承-JedisPubSub-实现一个消息监听器类" title="2. 继承 JedisPubSub 实现一个消息监听器类"></a>2. 继承 JedisPubSub 实现一个消息监听器类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span>
<span class="line">    </span>
<span class="line">       <span class="comment">//message.toString()可以获取失效的key</span></span>
<span class="line">      String expiredKey = message.toString();</span>
<span class="line">      <span class="keyword">if</span>(expiredKey.startsWith(<span class="string">"key:prefix"</span>))&#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * TODO</span></span>
<span class="line"><span class="comment">             * 如果是自己想要监控的KEY, 则可以在这里处理业务</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>由于每个key过期都会回调 onPMessage 方法， 所以不建议在 onPMessage  回调方法中直接处理业务， 这里可以通过 MQ 来做缓冲，在 onPMessage 中 把消息直接扔到 MQ 里， 然后再去监听队列消费消息处理具体的业务。</strong></p>
<p>改进版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpiredListener</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RedisKeyExpiredListener.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Resource</span></span>
<span class="line">    <span class="keyword">private</span> ICommonsMqService commonsMqService;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        <span class="keyword">try</span> &#123;</span>
<span class="line">            commonsMqService.sendSingleMessageAsync(<span class="string">"REDIS_TIMEOUT_KEY_QUEUE"</span>, message);</span>
<span class="line">            logger.info(<span class="string">"发送支付超时MQ消息成功：&#123;&#125;"</span>,message);</span>
<span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span>
<span class="line">            logger.error(<span class="string">"发送支付超时MQ消息失败：&#123;&#125;"</span>,e.toString());</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h4 id="3-订阅指定-db-的过期事件"><a href="#3-订阅指定-db-的过期事件" class="headerlink" title="3. 订阅指定 db 的过期事件"></a><a href="#3-订阅指定-db-的过期事件" title="3. 订阅指定 db 的过期事件"></a>3. 订阅指定 db 的过期事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="meta">@Order</span>(value = <span class="number">4</span>)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberRedisKeyTimeout</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SubscriberRedisKeyTimeout.class);</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Resource</span></span>
<span class="line">    RedisKeyExpiredListener redisKeyExpiredListener;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span>
<span class="line"></span>
<span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span>
<span class="line">        Jedis jedis = pool.getResource();</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 订阅线程：接收消息</span></span>
<span class="line"><span class="comment">         * 由于订阅者（subscriber）在进入订阅状态后会阻塞线程，</span></span>
<span class="line"><span class="comment">         * 因此新起一个线程（new Thread()）作为订阅线程</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span>
<span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span>
<span class="line">                <span class="keyword">try</span> &#123;</span>
<span class="line">                    logger.info(<span class="string">"Subscribing. This thread will be blocked."</span>);</span>
<span class="line">                    <span class="comment">//使用subscriber订阅 db0上的key过期事件消息，这一句之后，线程进入订阅模式，阻塞。</span></span>
<span class="line">                     jedis.subscribe(redisKeyExpiredListener, <span class="string">"__keyevent@0__:expired"</span>);</span>
<span class="line">     </span>
<span class="line">                    <span class="comment">//当unsubscribe()方法被调用时，才执行以下代码</span></span>
<span class="line">                    logger.info(<span class="string">"Subscription ended."</span>);</span>
<span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">                    logger.error(<span class="string">"Subscribing failed."</span>, e);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;).start();</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a><a href="#4-测试" title="4. 测试"></a>4. 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJedisExpipreNotice</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="keyword">new</span> JedisPoolConfig(), <span class="string">"127.0.0.1"</span>, <span class="number">8005</span>);</span>
<span class="line">        Jedis jedis = pool.getResource();</span>
<span class="line"></span>
<span class="line">        jedis.setex(<span class="string">"REDIS:EXPIPRE:NOTICE:TEST"</span>,<span class="number">5</span>, <span class="string">"测试键过期事件回调"</span>);</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<p>5秒后控制台打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">2019-03-26 17:35:44.248  INFO 20464 --- [ Thread-127] c.p.c.r.b.r.RedisKeyExpiredListener  : 发送聊天会话超时MQ消息成功：REDIS:EXPIPRE:NOTICE:TEST</span>
</pre></td></tr></table></figure>

<h3 id="四、-subscribe-psubscibe-的区别"><a href="#四、-subscribe-psubscibe-的区别" class="headerlink" title="四、 subscribe/psubscibe 的区别"></a><a href="#四、-subscribe-psubscibe-的区别" title="四、 subscribe/psubscibe 的区别"></a>四、 subscribe/psubscibe 的区别</h3><p>Redis 提供了 publish 和  subscribe/psubscibe 指令来实现发布/订阅模型，发布和订阅的目标称为通道(channel)。 subscribe/psubscribe 了一个或多个通道的客户端，可以收到其他客户端向这个通道publish的消息。subscribe和psubscribe的区别是，前者指定具体的通道名称，而后者可以指定一个正则表达式，匹配这个表达式的通道都被订阅。</p>
<p><img src="/images/20190327.svg" alt=""></p>
<p>上图展示了一个带有频道和模式的例子， 其中 <code>tweet.shop.*</code>  模式匹配了 <code>tweet.shop.kindle</code> 频道和 <code>tweet.shop.ipad</code> 频道， 并且有不同的客户端分别用 psubscibe 订阅它们三个：当有信息发送到 <code>tweet.shop.kindle</code> 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅 <code>tweet.shop.*</code>  模式的 client123 和 client256。</p>
<h3 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a><a href="#五、参考文献" title="五、参考文献"></a>五、参考文献</h3><p>[1]<a href="https://redis.io/topics/pubsub" target="_blank" rel="noopener">Redis Pub/Sub</a></p>
<p>[2]<a href="https://redis.io/topics/notifications" target="_blank" rel="noopener">Redis Keyspace Notifications</a></p>
<p>[3]<a href="https://my.oschina.net/itblog/blog/601284?p=1" target="_blank" rel="noopener">Redis的Pub/Sub模式</a></p>
<p>[4]<a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noopener">Redis设计与实现第一版-订阅与发布</a></p>
<p>[5]<a href="https://www.cnblogs.com/tinywan/p/5903988.html" target="_blank" rel="noopener">Redis实践操作之—— keyspace notification（键空间通知</a></p>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Pub/Sub</tag>
        <tag>Redis Keyspace Notifications</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 2：Redis环境搭建及Redis shell的使用</title>
    <url>/2018/08/10/redis-shell/</url>
    <content><![CDATA[<h2 id="一、版本选择"><a href="#一、版本选择" class="headerlink" title="一、版本选择"></a>一、版本选择</h2><blockquote>
<p>Redis 借鉴了 Linux 操作系统对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2、4.0）。当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。所以我们在生产环境通常选取偶数版本的 Redis。</p>
</blockquote>
<a id="more"></a>


<p>生产环境推荐选用偶数版本，推荐从 2.6、2.8、3.0、3.2 、4.0 这几个重大版本中选。几个版本的区别可参考 <a href="https://www.cnblogs.com/yangmingxianshen/p/8043851.html" target="_blank" rel="noopener">Redis重大版本</a></p>
<h2 id="二、安装-Redis"><a href="#二、安装-Redis" class="headerlink" title="二、安装 Redis"></a>二、安装 Redis</h2><p>进入 /usr/local 目录</p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081101.png" alt=""></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081102.png" alt=""></p>
<h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p>建立一个名叫 redis 的软链接指向 redis-4.0.0 目录，这样做是为了不把 redis 目录固定在指定版本上，有利于Redis未来版本升级，算是安装软件的一种好习惯。（类型window 系统的快捷方式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s redis-4.0.0 redis</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081103.png" alt=""></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081104.png" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081105.png" alt=""></p>
<p>make install 会将 Redis 的相关运行文件放到 /usr/local/bin/ 下，这样就可以在任意目录下执行 Redis 的命令了。</p>
<p><img src="/images/2018081106.png" alt=""></p>
<p>查看 redis 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -v</span><br></pre></td></tr></table></figure>

<p>显示如下，说明已经安装成功啦。</p>
<p><img src="/images/2018081107.png" alt=""></p>
<p><strong>小结：</strong><br>整个安装过程其实非常简单，总共6步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ tar xzf redis-4.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ ln -s redis-4.0.0 redis</span><br><span class="line"></span><br><span class="line">$ cd redis</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h2 id="三、配置、-启动、-操作、-关闭-Redis"><a href="#三、配置、-启动、-操作、-关闭-Redis" class="headerlink" title="三、配置、 启动、 操作、 关闭 Redis"></a>三、配置、 启动、 操作、 关闭 Redis</h2><p>前面已经提到 使用 make install 安装 Redis 之后，src和/usr/local/bin目录下多了几个以redis开头可执行文件，我们称之为RedisShell，这些可执行文件可以做很多事情，比如可以启动和停止Redis、可以检测和修复Redis的持久化文件，还可以检测Redis的性能。 下面是是我们最常用到的 Redis shell 说明：</p>
<table>
<thead>
<tr>
<th align="center">可执行文件</th>
<th align="center">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redis-server</td>
<td align="center">启动 Redis</td>
</tr>
<tr>
<td align="center">redis-cli</td>
<td align="center">Redis 命令行客户端</td>
</tr>
<tr>
<td align="center">redis-benchmark</td>
<td align="center">Redis 基准测试工具</td>
</tr>
<tr>
<td align="center">redis-check-aof</td>
<td align="center">Redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-check-dump</td>
<td align="center">Redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-sentinel</td>
<td align="center">启动 Redis Sentinel</td>
</tr>
</tbody></table>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动 Redis 服务的方法有三种，分别是：默认配置启动、运行配置启动、配置文件启动。生产环境推荐用配置文件启动，因为这种方式提供了更大的灵活性。</p>
<p>下面分别介绍下三种启动方式：</p>
<p><strong>默认配置启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>直接启动无法自定义配置，生产环境应该避免使用这种方式启动 Redis 服务。</p>
<p><strong>运行配置启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --configKey1 configValue1	 --configKey2 configValue2 ...</span><br></pre></td></tr></table></figure>

<p>比如要指定端口（注： Redis 的默认端口是 6379），可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure>

<p><strong>配置文件启动（生产环境推荐使用这种方式）</strong></p>
<p>通常我们会在一台机器上启动多台 Redis，并且将配置管理在集中目录下，习惯性的做法是把 Redis安装目录下的 redis.conf 拷贝到  /opt/redis/ 下，然后作为模板根据需要修改。</p>
<p>然后通过指定该配置文件启动 Redis 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server  &#x2F;opt&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="/images/2018081108.png" alt=""></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作是通过 Redis命令行客户端来完成，有两种方式，一种是交互方式，一种是命令方式，推荐使用交互方式。</p>
<p>在用 redis-cli 连接 Redis服务之前，可以先用 ps -ef |grep redis 看redis是否在服务，以及查看对应的 ip 端口信息。</p>
<p><img src="/images/2018081109.png" alt=""></p>
<p><strong>交互方式（推荐使用这种方式）</strong><br>通过 redis-cli -h{host}- p{port} 的方式连接到Redis服务，之后所有的操作都是通过交互的方式实现，不需要再执行redis-cli了。</p>
<p><img src="/images/2018081110.png" alt=""></p>
<p><strong>命令方式</strong><br>用 redis-cli -h{host} -p{port} {command} 直接得到命令的返回结果。</p>
<p><img src="/images/2018081111.png" alt=""></p>
<h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>
<p><img src="/images/2018081112.png" alt=""></p>
<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis shell</tag>
        <tag>Redis 环境搭建</tag>
        <tag>redis-server</tag>
        <tag>redis-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 开发与运维 1：聊聊 Redis</title>
    <url>/2018/08/01/talk-about-redis/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是一种基于键值对（key-value）的高性能内存数据库。与很多键值对数据库不同的是，Redis 的值支持 string（字符串）、 hash（哈希）、list（列表）、set（集合）、 zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位) 等多种数据结构，因此适用场景也更加丰富。Redis 是用 C 语言实现的，采用单线程架构，把所有的数据都放到内存中，因此 Redis 速度很快。除此之外，Redis 还提供了 持久化、主从复制、集群 以及以下几点功能：</p>
<ul>
<li>提供了键过期功能，可以用来实现缓存。</li>
<li>提供了发布订阅功能，可以用来实现消息系统。</li>
<li>支持 Lua 脚本功能，可以根据需要定制自己的 Redis 命令。</li>
<li>提供了简单的事务功能， 能在一定程度上保证事物特性。</li>
<li>提供了流水线（Pipeline）功能， 客户端可以将一批命令一次性传到 Redis，从而减少网络的开销。</li>
</ul>
<a id="more"></a>

<p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。redisObject 最主要的信息如图所示：</p>
<p><img src="/images/20180808000.png" alt=""></p>
<p>其中 type 代表一个 value 对象具体是何种数据类型，encoding 是不同数据类型在redis内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int。</p>
<h2 id="二、Redis提供的五种数据结构"><a href="#二、Redis提供的五种数据结构" class="headerlink" title="二、Redis提供的五种数据结构"></a>二、Redis提供的五种数据结构</h2><p><strong>五种数据结构：</strong></p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>字符串类型是 Redis 最基础的数结构。首先键都是字符串类型， 而且其他几种数据结构 都是 在字符串类型基础上构建的。</p>
<p><img src="/images/2018080801.svg" alt=""></p>
<p>上图是string 在 redis 中的宏观样子，它的数据结构如下图所示：</p>
<p><img src="/images/2018080802.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>每种数据类型对应的命令都非常多，以下只列举 string 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set</td>
<td align="center">set key value</td>
<td align="center">设置指定 key 的值</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get key</td>
<td align="center">获取指定 key 的值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del key</td>
<td align="center">删除指定 key 的值</td>
</tr>
<tr>
<td align="center">setex</td>
<td align="center">setex key seconds value</td>
<td align="center">设置健并指定多少秒后过期</td>
</tr>
<tr>
<td align="center">setnx</td>
<td align="center">setnx key value</td>
<td align="center">只有当 key 不存在时才设置成功(setnx 可以作为分布式锁 的一种实现方案)</td>
</tr>
<tr>
<td align="center">mset</td>
<td align="center">mset key1 value1 key2 value2 …</td>
<td align="center">批量设置多个 key-value 对</td>
</tr>
<tr>
<td align="center">mget</td>
<td align="center">mget key1 key2 key3 …</td>
<td align="center">批量获取多个 key 的值</td>
</tr>
<tr>
<td align="center">incr</td>
<td align="center">incr key</td>
<td align="center">对值做自增操作</td>
</tr>
</tbody></table>
<p><strong>mset、mget 等批量操作可以减少网络传输的次数，从而可以提高效率。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>string 的典型使用场景：</strong></p>
<ul>
<li>缓存功能</li>
<li>计数</li>
<li>共享 Session</li>
<li>限速</li>
</ul>
<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>哈希类型是指键值本身又是一个键值对结构，形如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value&#x3D;&#123;&#123; field1， value1&#125;，...&#123; fieldN， valueN&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<p><img src="/images/2018080804.svg" alt=""></p>
<p>下图是字符串和哈希类型的对比：</p>
<p><img src="/images/2018080803.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 hash 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hset</td>
<td align="center">hset key field value</td>
<td align="center">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td align="center">hget</td>
<td align="center">hget key field</td>
<td align="center">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel key field1 field2 …</td>
<td align="center">删除一个或者多个 field</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen key</td>
<td align="center">计算 field 个数</td>
</tr>
<tr>
<td align="center">hmset</td>
<td align="center">hmset key field value field1 field2 …</td>
<td align="center">批量设置一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hmget</td>
<td align="center">hmget key field field1 field2 …</td>
<td align="center">批量获取一个key中的多个字段</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists key field</td>
<td align="center">判断 key 中是否存在某个 field</td>
</tr>
<tr>
<td align="center">hkeys</td>
<td align="center">hkeys key</td>
<td align="center">获取指定 key 中的所有 field</td>
</tr>
<tr>
<td align="center">hvals</td>
<td align="center">hvals key</td>
<td align="center">获取指定 key 中的所有 value</td>
</tr>
<tr>
<td align="center">hgetall</td>
<td align="center">hgetall key</td>
<td align="center">获取指定 key 中的所有 field-value</td>
</tr>
</tbody></table>
<p><strong>在使用 hgetall 时， 如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果只需要获取部分 field，可以使用 hmget，如果一定要获取全部 field-value，可以使用 hscan 命令，该命令会渐进式遍历哈希类型。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>hash 的典型使用场景：</strong><br>比如缓存用户信息。每个用户属性使用一对field-value，但是只用一个键保存。如下图所示：</p>
<p><img src="/images/2018080805.png" alt=""></p>
<p>优点：简单直观，如果使用合理可以减少内存空间的使用。</p>
<p>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>
<h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>列表类型是用来存储多个有序的字符串，支持两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p>
<p><img src="/images/2018080806.svg" alt=""></p>
<p>下图为列表两端插入和弹出操作，a、b、c、d、e五个元素从左到右组成了一个有序的列表，列表中的每个字符串称为元素（element），一个列表最多可以存储232-1个元素。</p>
<p><img src="/images/2018080807.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 list 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rpush</td>
<td align="center">rpush key value1 value2 …</td>
<td align="center">从右边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">lpush</td>
<td align="center">lpush key value1 value2 …</td>
<td align="center">从左边插入一个或多个元素</td>
</tr>
<tr>
<td align="center">linsert</td>
<td align="center">linsert key before</td>
<td align="center">在 pivot 前或者后插入一个新元素 value</td>
</tr>
<tr>
<td align="center">lrange</td>
<td align="center">lrange key start end</td>
<td align="center">获取指定索引范围内的所有元素，索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N。 lrange key 0 -1  表示从左到右获取列表的所有元素</td>
</tr>
<tr>
<td align="center">lindex</td>
<td align="center">lindex key index</td>
<td align="center">获取列表指定索引下标的元素，lindex key -1 表示获取列表的最后一个元素</td>
</tr>
<tr>
<td align="center">llen</td>
<td align="center">llen key</td>
<td align="center">获取列表长度</td>
</tr>
<tr>
<td align="center">lpop</td>
<td align="center">lpop key</td>
<td align="center">从列表左侧弹窗元素</td>
</tr>
<tr>
<td align="center">rpop</td>
<td align="center">rpop key</td>
<td align="center">从列表右侧弹出元素</td>
</tr>
<tr>
<td align="center">lrem</td>
<td align="center">lrem key count value</td>
<td align="center">当 count&gt;0 , 从左到右，删除count个值等于 value的元素；当 count&lt;0，从右到左，删除count的绝对值个值等于value的元素；当 count=0，删除所有值等于 value的元素</td>
</tr>
<tr>
<td align="center">ltrim</td>
<td align="center">ltrim key start end</td>
<td align="center">只保留key 从start 到end 的元素</td>
</tr>
<tr>
<td align="center">lset</td>
<td align="center">lset key index newValue</td>
<td align="center">修改指定索引小标的元素</td>
</tr>
</tbody></table>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p><strong>list 的典型使用场景：</strong></p>
<ul>
<li>消息队列</li>
<li>文章列表</li>
</ul>
<p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">·lpush+lpop&#x3D;Stack（栈）</span><br><span class="line">·lpush+rpop&#x3D;Queue（队列）</span><br><span class="line">·lpsh+ltrim&#x3D;CappedCollection（有限集合）</span><br><span class="line">·lpush+ brpop&#x3D; Message Queue（消息队列）</span><br></pre></td></tr></table></figure>

<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>集合类型也是用来保存多个的字符串元素，但和列表类型不同的是，集合中的元素是无序并且不可重复的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p>
<p><img src="/images/2018080809.svg" alt=""></p>
<p><img src="/images/2018080808.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 set 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sadd</td>
<td align="center">sadd key value1 value2 …</td>
<td align="center">添加一个或多个元素</td>
</tr>
<tr>
<td align="center">srem</td>
<td align="center">srem key value1 value2 …</td>
<td align="center">删除一个或多个元素</td>
</tr>
<tr>
<td align="center">scard</td>
<td align="center">scard key</td>
<td align="center">计算元素个数</td>
</tr>
<tr>
<td align="center">sismember</td>
<td align="center">sismember key element</td>
<td align="center">判断元素是否在集合中，返回1表示存在，0 表示不存在</td>
</tr>
<tr>
<td align="center">srandmember</td>
<td align="center">srandmember key count</td>
<td align="center">随机从集合返回count个元素，count 不写默认为1</td>
</tr>
<tr>
<td align="center">spop</td>
<td align="center">spop key</td>
<td align="center">从集合随机弹出元素</td>
</tr>
<tr>
<td align="center">smembers</td>
<td align="center">smembers key</td>
<td align="center">获取所有元素</td>
</tr>
<tr>
<td align="center">sinter</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">suinon</td>
<td align="center">suinon key1 key2 …</td>
<td align="center">求多个集合的并集</td>
</tr>
<tr>
<td align="center">sdiff</td>
<td align="center">sdiff key1 key2 …</td>
<td align="center">求多个集合的差集</td>
</tr>
<tr>
<td align="center">sinterstore</td>
<td align="center">sinterstore key key1 key2 …</td>
<td align="center">求多个集合的交集并保存到key中</td>
</tr>
<tr>
<td align="center">suinonstore</td>
<td align="center">suinonstore key key1 key2 …</td>
<td align="center">求多个集合的并集并保存到key中</td>
</tr>
<tr>
<td align="center">sdiffstore</td>
<td align="center">sdiffstore key key1 key2 …</td>
<td align="center">求多个集合的差集并保存到key中</td>
</tr>
</tbody></table>
<p><strong>smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>set 的典型使用场景：</strong></p>
<ul>
<li>sadd=Tagging（标签）</li>
<li>spop/srandmember=Randomitem（生成随机数，比如抽奖）</li>
<li>sadd+sinter=SocialGraph（社交需求）</li>
</ul>
<p>标签（tag）是集合类型一个比较典型的使用场景。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签。</p>
<h3 id="ZSET（sorted-set）"><a href="#ZSET（sorted-set）" class="headerlink" title="ZSET（sorted set）"></a>ZSET（sorted set）</h3><p>有序集合，保留了集合元素不可重复的特性，并在集合的基础上增加了元素排序功能。需要注意的是，它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。有序集合还提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。</p>
<p><img src="/images/20180808010.svg" alt=""></p>
<p>下图是一个有序集合的例子，该有序集合包含kris、mike、frank、tim、martin、tom，它们的分数分别是1、91、200、220、250、251。</p>
<p><img src="/images/20180808011.png" alt=""></p>
<p><strong>常用命令</strong></p>
<p>以下只列举 zset 比较常用的命令，方便日后查看：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zadd</td>
<td align="center">zadd key score member [score member …]</td>
<td align="center">向有序集合添加一个或多个成员以及分数，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="center">zcard</td>
<td align="center">zcard key</td>
<td align="center">计算成员个数</td>
</tr>
<tr>
<td align="center">zscore</td>
<td align="center">zscore key member</td>
<td align="center">计算某个成员的分数，存在则返回分数，否则返回 nil</td>
</tr>
<tr>
<td align="center">zrank</td>
<td align="center">zrank key element</td>
<td align="center">返回分数从低到高的排名</td>
</tr>
<tr>
<td align="center">zrevrank</td>
<td align="center">zrevrank key count</td>
<td align="center">返回分数从高到低的排名</td>
</tr>
<tr>
<td align="center">zrem</td>
<td align="center">zrem member [member …]</td>
<td align="center">删除一个或多个成员</td>
</tr>
<tr>
<td align="center">zincrby</td>
<td align="center">zincrby key increment member</td>
<td align="center">给key中的member 增加 increment 分</td>
</tr>
<tr>
<td align="center">zrange</td>
<td align="center">sinter key1 key2 …</td>
<td align="center">求多个集合的交集</td>
</tr>
<tr>
<td align="center">zremrangebyscore</td>
<td align="center">zremrangebyscore key min max</td>
<td align="center">删除指定分数范围的成员</td>
</tr>
</tbody></table>
<p><strong>zset 同样可以计算集合的交、并、差，以上没有一一列举</strong></p>
<p>下面简单使用下一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<p><strong>zset 的典型使用场景：</strong></p>
<p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p>
<p>以点赞数位例，主要需要实现以下4个功能</p>
<ul>
<li>添加用户赞数</li>
<li>取消用户赞数</li>
<li>展示获取赞数最多的十个用户</li>
<li>展示用户信息以及用户分数</li>
</ul>
<h2 id="三、Redis的使用场景"><a href="#三、Redis的使用场景" class="headerlink" title="三、Redis的使用场景"></a>三、Redis的使用场景</h2><p>由于 redis 支持多种数据类型，所以适用场景也非常多。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>对于热点数据，缓存的价值非常大。例如，分类栏目(读频率高)等。可以将这些热点数据放到内存中，通过设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 </p>
<h3 id="共享Session（会话缓存）"><a href="#共享Session（会话缓存）" class="headerlink" title="共享Session（会话缓存）"></a>共享Session（会话缓存）</h3><p>在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息。比如我们公司就使用Redis共享Session来实现单点登录。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>数据统计的需求非常普遍，通过原子递增保持计数。例如，应用数、资源数、点赞数、收藏数、分享数等。这种高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作。</p>
<h3 id="排行榜以及热门列表"><a href="#排行榜以及热门列表" class="headerlink" title="排行榜以及热门列表"></a>排行榜以及热门列表</h3><p>例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：比如按照时间、播放量、点击率、点赞数等。可以利用有序集合 zset 实现。</p>
<h3 id="社交列表"><a href="#社交列表" class="headerlink" title="社交列表"></a>社交列表</h3><p>社交属性相关的列表信息，例如，用户点赞列表、用户分享列表、用户收藏列表、用户关注列表、用户粉丝列表等，使用 Hash 类型数据结构是个不错的选择。</p>
<h3 id="记录用户判定信息"><a href="#记录用户判定信息" class="headerlink" title="记录用户判定信息"></a>记录用户判定信息</h3><p>记录一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否评论分享等。</p>
<h3 id="交集、并集和差集"><a href="#交集、并集和差集" class="headerlink" title="交集、并集和差集"></a>交集、并集和差集</h3><p>在某些场景中，例如社交场景，通过交集、并集和差集运算，可以非常方便地实现共同好友，共同关注，共同偏好等社交关系。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>例如验证码只有60秒有效期，超过时间无法使用，或者基于 Oauth2 的 Token 只能在 5 分钟内使用一次，超过时间也无法使用。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中list的数据结构实现是双向链表，所以非常适合应用于消息队列（生产者/消费者模型）。 生产者利用 lpush 命令将数据添加到链表头部，消费者通过 brpop（右端阻塞弹出） 命令将元素从链表尾部取出。并且可以保证消息的有序性。比如可以用这种方式让多个应用更新最新的内容。</p>
<p>不过最好还是用 RabbitMQ 等市面上成熟的消息队列中间件。</p>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>由于Redis的单线程命令处理机制，如果有多个客户端同时执行 setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="四、Redis的数据淘汰策略-内存淘汰机制"><a href="#四、Redis的数据淘汰策略-内存淘汰机制" class="headerlink" title="四、Redis的数据淘汰策略(内存淘汰机制)"></a>四、Redis的数据淘汰策略(内存淘汰机制)</h2><h3 id="内存淘汰的过程"><a href="#内存淘汰的过程" class="headerlink" title="内存淘汰的过程"></a>内存淘汰的过程</h3><p>首先，客户端发起了需要申请更多内存的命令（如set）。</p>
<p>然后，Redis检查内存使用情况，如果已使用的内存大于 maxmemory 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p>
<p>最后，如果上面都没问题，则这个命令执行成功。</p>
<h3 id="6种淘汰策略"><a href="#6种淘汰策略" class="headerlink" title="6种淘汰策略"></a>6种淘汰策略</h3><p>当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持以下6种策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">noeviction</td>
<td align="center">当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错</td>
</tr>
</tbody></table>
<p>需要注意的是：作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<h3 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h3><p>下面看看几种策略的适用场景</p>
<p>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。</p>
<p>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</p>
<p>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。</p>
<p><strong>推荐用法：</strong><br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h3 id="如何配置最大内存及淘汰策略"><a href="#如何配置最大内存及淘汰策略" class="headerlink" title="如何配置最大内存及淘汰策略"></a>如何配置最大内存及淘汰策略</h3><p>我们通过配置redis.conf中的 maxmemory 这个值来开启内存淘汰功能，以及配置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 100000</span><br><span class="line"></span><br><span class="line">#设置淘汰策略</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>需要注意的是，maxmemory 为0的时候表示我们对Redis的内存使用没有限制。</p>
<p>此外，redis支持动态改配置，无需重启。</p>
<p>设置最大内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set maxmemory 100000</span><br></pre></td></tr></table></figure>

<p>设置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set maxmemory-policy noeviction</span><br></pre></td></tr></table></figure>

<h2 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h2><p>Redis支持RDB和AOF两种持久化机制，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化，从而能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p>
<h3 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据生成快照（Snapshot）以紧凑压缩的二级制文件格式保存到硬盘。</p>
<p>触发RDB持久化过程分为手动触发和自动触发。手动触发分别对应save和bgsave命令，其中save存在阻塞问题，基本已经废弃，Redis内部所有的涉及RDB的操作都采用bgsave的方式。执行save 或 bgsave 将在 redis 安装目录中创建dump.rdb （可配置）文件,如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</p>
<p>可以在redis.conf中做一些 RDB 相关的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 快照的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 存放快照的目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"># 在进行镜像备份时,是否进行压缩。</span><br><span class="line"># yes：压缩，但是需要一些cpu的消耗。</span><br><span class="line"># no：不压缩，需要更多的磁盘空间。</span><br><span class="line">rdbcompression yes</span><br><span class="line">#900秒后且至少1个key发生变化时创建快照  </span><br><span class="line">save 900 1  </span><br><span class="line">#300秒后且至少10个key发生变化时创建快照  </span><br><span class="line">save 300 10  </span><br><span class="line">#60秒后且至少10000个key发生变化时创建快照  </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p><strong>RDB的优点：</strong></p>
<ul>
<li><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p>
</li>
<li><p>Redis加载RDB恢复数据远远快于AOF的方式。</p>
</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p>
</li>
<li><p>一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。例如，每隔30分钟或者更长的时间来创建一次快照，Redis停止工作时（例如意外断电）就可能丢失这30分钟的数据。</p>
</li>
<li><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p>
</li>
</ul>
<h3 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h3><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过 appendfilename 配置设置，默认文件名是 appendonly.aof。保存路径同 RDB 持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。如下图所示：</p>
<p><img src="/images/20180808012.png" alt=""></p>
<p>AOF 工作流程 ：</p>
<p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p>
<p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p>
<p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p>
<p><strong>下面分别讲下每个过程：</strong></p>
<h4 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h4><p>AOF命令写入是吧文本协议格式的内容追加到缓存区。</p>
<p>如以下 set hello world 命令的文本协议格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></table></figure>

<p><strong>采用文本协议格式的原因：</strong><br>文本协议具有可读性，方便直接修改和处理。同时还可以避免二次开销。</p>
<p><strong>先写入缓存区而不是直接写入硬盘的原因：</strong><br>如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。Redis支持三种不同的缓冲区同步文件策略如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，影响 Redis 的高性能，一般不推荐使用。</span><br><span class="line"># appendfsync always </span><br><span class="line"></span><br><span class="line">#完全依赖操作系统的写入，一般为30秒左右一次，性能最好但是数据安全性无法保证，不被推荐。</span><br><span class="line"># appendfsync no  </span><br><span class="line"></span><br><span class="line">#每秒钟强制写入磁盘一次，兼顾性能和数据安全性，在性能和持久化方面做了很好的折中，理论上只有在系统突然宕机的情况下丢失1秒的数据。是受推荐的方式。</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p>
<p>重写的过程主要做了一下事情：</p>
<p>1）进程内已经超时的数据不再写入文件。</p>
<p>2）旧的AOF文件中的无效命令不再写入，如delkey1、hdelkey2、sremkeys、seta111、seta222 等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p>
<p>3）多条写命令可以合并为一个，如：lpushlista、lpushlistb、lpushlistc可以转化为：lpushlistabc。</p>
<p>具体的重写流程如下图所示：</p>
<p><img src="/images/20180808013.png" alt=""></p>
<p>可以通过下面配置设置什么时候开启自动重写：</p>
<p>AOF重写过程可以手动触发（直接调用bgrewriteaof命令）和自动触发：根据配置的auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># AOF文件名  </span><br><span class="line">appendfilename appendonly.aof </span><br><span class="line"></span><br><span class="line">#当进程中BGSAVE或BGREWRITEAOF命令正在执行时不阻止主进程中的fsync()调用（默认为no，当存在延迟问题时需调整为yes）  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">#当AOF增长率为100%且达到了64mb时开始自动重写AOF  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>


<h3 id="重启加载-数据恢复"><a href="#重启加载-数据恢复" class="headerlink" title="重启加载(数据恢复)"></a>重启加载(数据恢复)</h3><p>RDB 和 AOF 文件都可以用于服务器重启时的数据恢复。</p>
<p>下图为 Redis 持久化文件加载流程(即重启阶段恢复数据的流程)：</p>
<p><img src="/images/20180808014.png" alt=""></p>
<p>流程说明：</p>
<p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p>
<p>2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p>
<p>3）加载AOF/RDB文件成功 后，Redis 启动成功。 </p>
<p>4）AOF/RDB文件存在错误时，Redis 启动失败并打印错误信息。</p>
<h2 id="六、Redis-为什么速度快"><a href="#六、Redis-为什么速度快" class="headerlink" title="六、Redis 为什么速度快"></a>六、Redis 为什么速度快</h2><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p>
<ul>
<li><p>纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒。</p>
</li>
<li><p>Redis采用了单线程设计，单线程避免了线程切换和竞态产生消耗。</p>
</li>
<li><p>Redis采用了非阻塞I/O模型，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p>
</li>
<li><p>Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p>
</li>
</ul>
<h2 id="七、Redis-为什么采用单线程"><a href="#七、Redis-为什么采用单线程" class="headerlink" title="七、Redis 为什么采用单线程"></a>七、Redis 为什么采用单线程</h2><p>Redis 为什么采用单线程设计，主要原因如下：</p>
<ul>
<li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li>
<li>采用单线程设计，可以极大简化数据结构和算法的实现，使代码更清晰，处理逻辑更简单。</li>
<li>单线程避免了不必要的线程切换和竞态产生消耗。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，不会出现死锁而导致的性能消耗。</li>
</ul>
<p>采用单线程设计也有一个弊端，就是无法发挥多核CPU性能，如果某个命令执行过长，会造成其他命令的阻塞。</p>
<p>解决的办法是，通过在一个多核的机器上部署多个redis实例，组成master-master，master-slave的形式，实现读写分离。把耗时的读命令完全可以放到slave中来解决。</p>
<h2 id="八、Redis的内部结构"><a href="#八、Redis的内部结构" class="headerlink" title="八、Redis的内部结构"></a>八、Redis的内部结构</h2><p>Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p>
<p>可以通过阅读 <a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a> 来学习。<br>还可以参考下 <a href="http://zhangtielei.com/posts/server.html" target="_blank" rel="noopener">Redis内部数据结构详解</a> 系列博客</p>
<h2 id="九、Redis-集群方案与实现"><a href="#九、Redis-集群方案与实现" class="headerlink" title="九、Redis 集群方案与实现"></a>九、Redis 集群方案与实现</h2><p>后面会单独写篇文章讲 Redis 的 复制、哨兵、集群。</p>
<h2 id="十、Redis-与-Memcached-的差异"><a href="#十、Redis-与-Memcached-的差异" class="headerlink" title="十、Redis 与 Memcached 的差异"></a>十、Redis 与 Memcached 的差异</h2><p>Redis 和 Memcache 都是基于内存的数据存储系统。Redis是一个开源的key-value存储系统，而Memcached是高性能分布式内存缓存服务。那么Redis 与 Memcached 之间有什么区别呢？</p>
<p>Redis的作者Salvatore Sanfilippo曾经对这两种基于内存的数据存储系统进行过比较：</p>
<ul>
<li><p>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p>
</li>
<li><p>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p>
</li>
<li><p>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p>
</li>
</ul>
<h3 id="数据类型支持不同"><a href="#数据类型支持不同" class="headerlink" title="数据类型支持不同"></a>数据类型支持不同</h3><p>Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。</p>
<p>Memcached仅支持简单的key-value结构的数据记录。</p>
<h3 id="内存管理机制不同"><a href="#内存管理机制不同" class="headerlink" title="内存管理机制不同"></a>内存管理机制不同</h3><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
<p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。</p>
<p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题，但是它最大的缺点就是会导致空间浪费，因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
<h3 id="数据持久化支持"><a href="#数据持久化支持" class="headerlink" title="数据持久化支持"></a>数据持久化支持</h3><p>Redis支持内存数据的持久化，而且提供了RDB快照和AOF日志两种主要的持久化策略。</p>
<p>memcached是不支持数据持久化操作的。</p>
<h3 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h3><p>Redis 本身提供了 Cluster，引入Master节点和Slave节点，支持在服务器端构建分布式存储。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>
<p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p>
<h2 id="十一、参考文献"><a href="#十一、参考文献" class="headerlink" title="十一、参考文献"></a>十一、参考文献</h2><p>[1]《Redis 开发与运维》付磊; 张益军著<br>[2] <a href="https://redislabs.com/community/ebook/" target="_blank" rel="noopener">《Redis IN ACTION》</a> ah L. Carlson<br>[3] <a href="http://blog.720ui.com/columns/redis_action_all/" target="_blank" rel="noopener">Redis实战 文集</a><br>[4] <a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis应用场景</a><br>[5] <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考</a><br>[6] <a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述Redis和Memcached的差异</a><br>[7] <a href="https://www.zhihu.com/question/19645807" target="_blank" rel="noopener">MongoDB 或者 redis 可以替代 memcached 吗?</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis有哪些数据类型</tag>
        <tag>Redis的使用场景</tag>
        <tag>Redis的持久化机制</tag>
        <tag>Redis的内存淘汰机制</tag>
        <tag>Redis为什么采用单线程设计</tag>
        <tag>Redis为什么速度快</tag>
        <tag>Redis的内部结构</tag>
      </tags>
  </entry>
  <entry>
    <title>夯实基础 1：ArrayList、Vector、LinkedList 的区别</title>
    <url>/2018/08/30/the-diff-ArrayList-Vector-LinkedList/</url>
    <content><![CDATA[<h2 id="一、集合框架层次结构"><a href="#一、集合框架层次结构" class="headerlink" title="一、集合框架层次结构"></a>一、集合框架层次结构</h2><p>ArrayList、Vector、LinkedList 这三者都是集合框架中的 List，所以要弄清楚它们之间的区别与联系，最好先对集合框架类的层级有个整体直观的认识。</p>
<p>下面是集合框架的简要类图：</p>
<p><img src="/images/2018083001.png" alt=""></p>
<p>从上图可以看到，Collection接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p>
<a id="more"></a>

<ul>
<li><p>List，有序集合，列表中的元素可重复，它提供了方便的访问、插入、删除等操作。</p>
</li>
<li><p>Set，Set是不允许元素重复的，这是和List最明显的区别，也就是不存在两个equals返回true的情况。广泛用于需要保证元素唯一的场合。</p>
</li>
<li><p>Queue/Deque ，则是Java提供的标准队列结构的实现，除了集合的基本功能，它还支持类似 先入先出（FIFO ，First-in-First-Out)储后入先出（LIFO，Last-In-First-Out)等特定行 为。这里不包括 BlockingQueue ，因为通常是并发编程杨合，所以被放置在并发包里。</p>
</li>
</ul>
<p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如AbstractList就集中了各种List操作的 通用部分。这些集合不是完全孤立的，比如，LinkedList本身，既是List，也是 Deque。</p>
<h2 id="二、ArrayList、Vector、LinkedList"><a href="#二、ArrayList、Vector、LinkedList" class="headerlink" title="二、ArrayList、Vector、LinkedList"></a>二、ArrayList、Vector、LinkedList</h2><p>下面可以看一个简化版的类图：</p>
<p><img src="/images/2018083002.png" alt=""></p>
<p>从上图可以看到 ArrayList、Vector、LinkedList 三者都实现了List 接口。因此，它们在功能及用法上都非常的相似，比如都提供按照索引位置进行取值、添加、删除操作，都提供了迭代器用于遍历元素等功能。它们之间的主要区别，来源于底层实现上的不同，所以在行为、性能、线程安全性上有所差别。</p>
<ul>
<li>ArrayList 是一个可改变大小的动态数组，随着元素的添加，会动态的增加容量，因为ArrayList本质上就是一个数组，所以内部的元素可以直接通过get与set方法进行访问。需要注意的是，ArrayList 本身不是线程安全的，所以与Vector 相比，不存在同步的开销，性能上好很多。</li>
</ul>
<ul>
<li><p>Vector 和ArrayList类似，不同的是在方法的前面加了synchronized，因此Vector 是线程安全的。<br>如果你的程序本身是线程安全的（即不存在多个线程之间共享同一个集合/对象），那么不建议选择Vector ，毕竟同步是有额外开销的。</p>
</li>
<li><p>LinkedList 是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList。 LinkedList 还实现了 Queue 接口，该接口比List提供了更多的方法,包括 offer()、peek()、poll()等。LinkedList本身，既是List，也是 Deque。</p>
</li>
</ul>
<h2 id="三、性能比较"><a href="#三、性能比较" class="headerlink" title="三、性能比较"></a>三、性能比较</h2><p>下面写个例子对比下 ArrayList、LinkedList 在访问、添加、删除元素方面的差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// ArrayList add</span></span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		arrayList.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  add: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList add</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		linkedList.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList add: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="comment">// ArrayList get</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		arrayList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  get: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList get</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		linkedList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList get: "</span> + duration);</span><br><span class="line">	 	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ArrayList remove</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		arrayList.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"ArrayList  remove: "</span> + duration);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// LinkedList remove</span></span><br><span class="line">	startTime = System.nanoTime();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9999</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		linkedList.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">	endTime = System.nanoTime();</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"LinkedList remove: "</span> + duration);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在JDK1.7 中的运行效果如下所示：</p>
<p><img src="/images/2018083003.png" alt=""></p>
<p><strong>小结：</strong><br>可以看到，ArrayList 在访问元素比 LinkedList 好，单在添加、删除元素方面 LinkedList 性能更好。 </p>
<h2 id="四、不同容器适合的场景-如何考虑选择"><a href="#四、不同容器适合的场景-如何考虑选择" class="headerlink" title="四、不同容器适合的场景(如何考虑选择)"></a>四、不同容器适合的场景(如何考虑选择)</h2><ul>
<li>Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会先对较差，比如我们在中间插入一个元素，需要移动后续的所有元素。</li>
<li>LinkedList 进行节点的插入、删除却要高效的多，但随机访问性能却要比动态数组慢。</li>
</ul>
<p>所以在开发的过程中，应考虑对应的功能是偏向于插入、删除、还是随机访问比较多，来进行针对性的选择。<strong>如果是插入、删除比较频繁，则选用 LinkedList ；如果随机性访问多，则选择动态数组（Vector 和 ArrayList），然后再结合是否需要线程安全来进一步选择，如果需要线程安全则使用Vector，如果不需要线程安全，则选择 ArrayList 。</strong></p>
<h2 id="五、Vector和ArrayList-的扩容机制"><a href="#五、Vector和ArrayList-的扩容机制" class="headerlink" title="五、Vector和ArrayList 的扩容机制"></a>五、Vector和ArrayList 的扩容机制</h2><p>Vector和ArrayList在随着元素的添加，当数组满时，会请求更大的空间，创建新数组，并拷贝原有数组数据。区别的是，Vector 每次扩容时增加1倍，而ArrayList则是增加 50%。如下面的代码所示：</p>
<p><strong>Vector 的 grow 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *这里可以看到，如果在构造 Vector 的时候指定了 步长 capacityIncrement ，</span></span><br><span class="line"><span class="comment">     *则在原容量基础上增加指定步长，否则增加1倍原容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>ArrayList 的 grow 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="comment">//这里可以看到在原容量的基础上再增加 原容量的一半。</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>最佳实践：</strong><br>值得注意的是，动态扩容会创建新数组，并拷贝原有数组数据到新的数组，所以每次扩容都会带来一定的开销。而默认情况下 ArrayList 和 Vector 的初始容量非常小，在JDK1.7 中默认是10，所以JDK提供了构造函数，支持在创建动态数组的时候指定数组的初始容量。所以<strong>如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销。</strong></p>
<p><strong>ArrayList 的 相应的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Vector 的 相应的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * capacity increment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment"> *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， 创建 ArrayList 和 Vector 时，都可以指定数组的初始容量，并且 Vector  还可以指定数组每次扩容的增量。</p>
<p>下面写个例子测试对比一下使用默认初始容量与指定初始初始容量的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10000000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// arrayList1 add</span></span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">		arrayList1.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	System.out.println(<span class="string">"arrayList1  add: "</span> + duration);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// arrayList2 add</span></span><br><span class="line">	<span class="keyword">long</span> startTime2 = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">		arrayList2.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> endTime2 = System.nanoTime();</span><br><span class="line">	<span class="keyword">long</span> duration2 = endTime2 - startTime2;</span><br><span class="line">	System.out.println(<span class="string">"arrayList2  add: "</span> + duration2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下所示： </p>
<p><img src="/images/2018083004.png" alt=""></p>
<p>可以看到，如果可以预估数据量的话，分配一个较大的初始值可以减少动态扩容带来的开销，效果还是比较明显的。</p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">关于Java集合的小抄</a></p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>夯实基础</tag>
        <tag>ArrayList</tag>
        <tag>Vector</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机 1：线程模型及Java的线程模型</title>
    <url>/2018/06/19/thred-model/</url>
    <content><![CDATA[<h2 id="一、进程、线程"><a href="#一、进程、线程" class="headerlink" title="一、进程、线程"></a>一、进程、线程</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源(内存地址、文件 I/O 等)拥有的基本单位。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<a id="more"></a>
<h2 id="二、用户态和内核态"><a href="#二、用户态和内核态" class="headerlink" title="二、用户态和内核态"></a>二、用户态和内核态</h2><p>由于进程的调度以及系统资源的分配是离不开操作系统的，所以学习谈线程设计之前，有必要先看下操作系统的体系结构，以 Unix/Linux 的体系架构为例。</p>
<p><img src="/images/2018061901.png" alt=""></p>
<p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux 的设计哲学之一就是：对不同的操作赋予不同的执行等级(有多大能力做多大的事)，用户态(User Mode)和内核态(Kernel Mode)。</p>
<p>运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中有时候会需要切换到内核态执行，常见如以下三种：</p>
<p><strong>1.系统调用：</strong>发一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如 printf()，调用的是 wirte()系统调用来输出字符串，等等。</p>
<p><strong>2.不可知的异常事件：</strong>就会触发从当前用户态执行的进程转向内核态执行相关的异常事件。</p>
<p><strong>3.外围设备的中断：</strong>CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
<p><strong>而在用户态和内核态之间的上下文切换，不可避免的会产生一定的开销，这也是线程设计中必须考虑到的点。</strong></p>
<h2 id="三、线程设计的三个难点"><a href="#三、线程设计的三个难点" class="headerlink" title="三、线程设计的三个难点"></a>三、线程设计的三个难点</h2><p>1、在 CPU 密集型任务、I/O 密集型任务以及充分利用多核 CPU 提升程序性能上找到一个平衡点。<br>2、尽可能支持规模更大的线程数量。<br>3、减少线程在用户态(User Mode)和内核态(Kernel Mode)中切换带来的开销。</p>
<h2 id="四、三种不同的线程模型"><a href="#四、三种不同的线程模型" class="headerlink" title="四、三种不同的线程模型"></a>四、三种不同的线程模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1-用户线程与内核级线程"><a href="#1-用户线程与内核级线程" class="headerlink" title="1.用户线程与内核级线程"></a>1.用户线程与内核级线程</h4><p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<h4 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h4><p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<h4 id="3-多线程模型"><a href="#3-多线程模型" class="headerlink" title="3.多线程模型"></a>3.多线程模型</h4><p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="三种多线程模型："><a href="#三种多线程模型：" class="headerlink" title="三种多线程模型："></a>三种多线程模型：</h3><h4 id="1-使用用户线程实现（多对一模型-M-1）"><a href="#1-使用用户线程实现（多对一模型-M-1）" class="headerlink" title="1.使用用户线程实现（多对一模型 M:1）"></a>1.使用用户线程实现（多对一模型 M:1）</h4><p>多个用户线程映射到一个内核线程，用户线程建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，对内核透明。</p>
<p><img src="/images/2018061902.png" alt=""></p>
<p><strong>优点：</strong></p>
<p>1) 线程的上下文切换都发生在用户空间，避免了模态切换（mode switch），减少了性能的开销。<br>2) 用户线程的创建不受内核资源的限制，可以支持更大规模的线程数量。</p>
<p><strong>缺点：</strong></p>
<p>1) 所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，浪费了其它处理器资源，不支持并行，在多处理器环境下这是不能够被接受的，如果线程因为 I/O 操作陷入了内核态，内核态线程阻塞等待 I/O 数据，则所有的线程都将会被阻塞。</p>
<p>2) 增加了复杂度，所有的线程操作都需要用户程序自己处理，而且在用户空间要想自己实现 “阻塞的时候把线程音响到其他处理器上” 异常困难。</p>
<h4 id="2-使用内核线程实现（一对一模型-1-1）"><a href="#2-使用内核线程实现（一对一模型-1-1）" class="headerlink" title="2.使用内核线程实现（一对一模型 1:1）"></a>2.使用内核线程实现（一对一模型 1:1）</h4><blockquote>
<p>程序使用的是内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程,轻量级进程也是属于用户线程。</p>
</blockquote>
<p>所以这里统一称为用户线程。</p>
<p>每个用户线程都映射到一个内核线程，每个线程都成为一个独立的调度单元，由内核调度器独立调度，一个线程的阻塞不会影响到其他线程，从而保障整个进程继续工作。</p>
<p><img src="/images/2018061903.png" alt=""></p>
<p><strong>优点：</strong></p>
<p>1) 每个线程都成为一个独立的调度单元，使用内核提供的线程调度功能及处理器映射，可以完成线程的切换，并将线程的任务映射到其他处理器上，充分利用多核处理器的优势，实现真正的并行。</p>
<p><strong>缺点：</strong></p>
<p>1) 每创建一个用户级线程都需要创建一个内核级线程与其对应，因此需要消耗一定的内核资源,而内核资源是有限的，所以能创建的线程数量也是有限的。<br>2) 模态切换频繁，各种线程操作，如创建、析构及同步，都需要进行系统调用，需要频繁的在用户态和内核态之间切换，开销大。</p>
<h4 id="3-使用用户线程加轻量级进程混合实现（多对多模型-M-N）"><a href="#3-使用用户线程加轻量级进程混合实现（多对多模型-M-N）" class="headerlink" title="3.使用用户线程加轻量级进程混合实现（多对多模型 M:N）"></a>3.使用用户线程加轻量级进程混合实现（多对多模型 M:N）</h4><p>内核线程和用户线程的数量比为 M : N，这种模型需要内核线程调度器和用户空间线程调度器相互操作，本质上是多个线程被映射到了多个内核线程。</p>
<p><img src="/images/2018061904.png" alt=""></p>
<p><strong>综合了前面两种模型的优点：</strong></p>
<p>1) 用户线程的创建、切换、析构及同步依然发生在用户空间，能创建数量更多的线程，支持更大规模的并发。</p>
<p>2) 大部分的线程上下文切换都发生在用户空间，减少了模态切换带来的开销。</p>
<p>3) 可以使用内核提供的线程调度功能及处理器映射，充分利用多核处理器的优势，实现真正的并行，并降低了整个进程被完全阻塞的风险。</p>
<h2 id="五、Java的线程模型"><a href="#五、Java的线程模型" class="headerlink" title="五、Java的线程模型"></a>五、Java的线程模型</h2><p><strong>一句话总结：Java 的线程是映射到操作系统的原生线程之上的。</strong></p>
<p>JVM 没有限定 Java 线程需要使用哪种线程模型来实现， JVM 只是封装了底层操作系统的差异，而不同的操作系统可能使用不同的线程模型，例如 Linux 和 windows 可能使用了一对一模型，solaris 和 unix 某些版本可能使用多对多模型。所以一谈到 Java 语言的多线程模型，需要针对具体 JVM 实现。</p>
<p>比如 Sun JDK 1.2开始，线程模型都是基于操作系统原生线程模型来实现，它的 Window 版和 Linux 版都是使用系统的 1:1 的线程模型实现的。</p>
<h2 id="六、Java的并发为什么不如GO"><a href="#六、Java的并发为什么不如GO" class="headerlink" title="六、Java的并发为什么不如GO"></a>六、Java的并发为什么不如GO</h2><p>以后再展开补充。</p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>《深入理解Java虚拟机》 – 周志明   第十二章第四小节<br> <a href="https://www.cnblogs.com/binyue/p/6555730.html" target="_blank" rel="noopener">Go语言并发机制初探</a><br> <a href="https://www.itency.com/topic/show.do?id=338701" target="_blank" rel="noopener">关于Golang和JVM中并发模型实现的探讨</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>线程模型</tag>
        <tag>java的线程模型</tag>
        <tag>模态切换</tag>
        <tag>用户态</tag>
        <tag>内核态</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储 2：分布式系统全局唯一ID生成方案</title>
    <url>/2018/07/21/unique-id-generate/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近在 ifeve.com 看到这么一个面试题 “<a href="http://ifeve.com/question/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%9C%89%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%B2%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%8C%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82/" target="_blank" rel="noopener">京东面试题 – 有一个生成唯一串的需求，并发请求量非常大，该如何实现？</a>”。在现实开发中，这也是必须要考虑到的一个点。比如分库分表后主键采用什么策略生成？在分布式系统中如何生成唯一ID标识？</p>
<a id="more"></a>

<p>从业务上来说，常见的如订单号，支付单号等，都需要唯一 ID 做标识，简单的数据库递增是不能满足的，因为这样既会显得不专业，也会不安全，比如你的竞争对手可以今天中午12点下个单记录下订单号，明天中午12点再下个单，通过对比2个订单号大概计算出你们的订单量，这是非常可怕的事情。</p>
<p><strong>那么，业务系统对ID号有哪些要求呢？</strong></p>
<ol>
<li><p>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p>
</li>
<li><p>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，是用B+tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。针对这点，后面根据索引原理展开讲一下。</p>
</li>
<li><p>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</p>
</li>
<li><p>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p>
</li>
</ol>
<p><strong>这里结合索引原理展开讲下为什么ID需要趋势递增</strong><br>InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用选用趋势递增的ID作为主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。如下图所示：</p>
<p><img src="/images/2018072401.png" alt=""></p>
<p>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。否则，如使用身份证号或学号等无序的数作为主键，则每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动大量数据，从而降低写入数据的性能。如下图所示：</p>
<p><img src="/images/2018072402.png" alt=""></p>
<h2 id="二、Twitter的snowflake方案"><a href="#二、Twitter的snowflake方案" class="headerlink" title="二、Twitter的snowflake方案"></a>二、Twitter的snowflake方案</h2><p>snowflake 是 Twitter 开源的分布式ID生成算法，是一种划分命名空间来生成ID的一种算法，结果是一个long型的ID。其核心思想是：把64-bit分别划分成多段。如下图所示：<br><img src="/images/2018072301.png" alt=""></p>
<p>其中，41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给数据中心(IDC)，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<p>这种方式的优缺点是：</p>
<p><strong>优点：</strong></p>
<ul>
<li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li>
<li>可以根据自身业务特性分配bit位，非常灵活。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p>
<p>具体实现的代码可以参看：<a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">https://github.com/twitter/snowflake</a>，遗憾的是 snowflake 已经不再维护，但是还是可以下载  snowflake-2010 tag , 下载的版本是用 scala 实现的。我们可以根据思想，自己用java语言实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==============================Fields===========================================</span></span><br><span class="line">    <span class="comment">/** 开始时间截 (2010/11/4 9:42:54) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdFactory</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Test=============================================</span></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	IdFactory idFactory = <span class="keyword">new</span> IdFactory(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//传入工作ID (0~31),数据中心ID (0~31)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idFactory.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、Flicker-团队的数据库生成方案"><a href="#三、Flicker-团队的数据库生成方案" class="headerlink" title="三、Flicker 团队的数据库生成方案"></a>三、Flicker 团队的数据库生成方案</h2><p>在分布式系统中，为了解决单点故障问题、单点IO性能问题，在分布式系统中，我们的数据库服务器往往也不只一台，那么在多台数据库服务器的情况下如何生成符合要求的ID呢？Flickr团队在2010年撰文介绍的一种主键生成策略(<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>)。这种方案的思想是给不同的机器设置不同的初始值，相同的步长。</p>
<p>比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment &#x3D; 2</span><br><span class="line">auto-increment-offset &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p>
<p><img src="/images/2018072302.png" alt=""></p>
<p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。机器多的时候要扩容十分复杂。</li>
<li>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h2 id="四、美团的Leaf-segment数据库方案"><a href="#四、美团的Leaf-segment数据库方案" class="headerlink" title="四、美团的Leaf-segment数据库方案"></a>四、美团的Leaf-segment数据库方案</h2><p>Leaf-segment 在使用数据库的方案上做了优化，利用proxy server批量获取，每次获取一段IDs(step决定大小)，然后把这段IDs作为id池缓存起来使用。用完之后再去数据库获取新的号段，从而大大的减轻数据库的压力。解决了原方案每次获取ID都得读写一次数据库，造成数据库压力大的问题。Leaf-segment的总体架构如下：</p>
<p><img src="/images/2018072303.png" alt=""></p>
<p>这种模式有以下优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<p>Leaf-segment 后2点缺点，Leaf-segment做了双buffer优化，以及“一主两从”的高可用容灾。</p>
<h2 id="五、美团的Leaf-snowflake方案"><a href="#五、美团的Leaf-snowflake方案" class="headerlink" title="五、美团的Leaf-snowflake方案"></a>五、美团的Leaf-snowflake方案</h2><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID等生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是非常可怕的。针对这一问题，美团点评提供了 Leaf-snowflake 方案，用于满足对这种安全性有要求的场景。</p>
<p><img src="/images/2018072304.png" alt=""></p>
<p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。相比 snowflake，Leaf-snowflake做了以下2点优化：</p>
<ol>
<li>使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID，一定程度的提高系统的伸缩性和容错性。</li>
<li>解决时钟回拨会可能导致生成重复的ID号的问题。</li>
</ol>
<p>Leaf-snowflake 的架构图如下：</p>
<p><img src="/images/2018072305.png" alt=""></p>
<p><strong>Leaf-snowflake是按照下面几个步骤启动的：</strong></p>
<ol>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ol>
<h2 id="六、微信的序列号生成器seqsvr"><a href="#六、微信的序列号生成器seqsvr" class="headerlink" title="六、微信的序列号生成器seqsvr"></a>六、微信的序列号生成器seqsvr</h2><p>seqsvr 是微信的一个高可用、高可靠的序列号生成器，利用生成的序列号，实现终端与后台的数据增量同步机制。这套同步机制仍然在消息收发、朋友圈通知、好友数据更新等需要数据同步的地方发挥着核心的作用。seqsvr的架构可以分为两层，即StoreSvr和AllocSvr（存储层和缓存中间层）。</p>
<p>架构图如下：</p>
<p><img src="/images/2018072306.png" alt=""></p>
<p>seqsvr 的设计考虑有其殊性，比如按用户id进行切分。但是其实现还有一些容灾设计事非常值得参考的。</p>
<p>具体细节及演进过程可看 <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/</a></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><p>[1] <a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter snowflake</a></p>
<p>[2] <a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a></p>
<p>[3] <a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture/" target="_blank" rel="noopener">微信序列号生成器架构设计及演变</a></p>
]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
        <tag>唯一ID</tag>
        <tag>分布式系统ID生成器</tag>
        <tag>snowflake</tag>
        <tag>Leaf-segment</tag>
        <tag>Leaf-snowflake</tag>
        <tag>seqsvr</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Apache CXF 实现Web Service</title>
    <url>/2018/04/15/webserver-apache-xcf/</url>
    <content><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1、Web-service的概念："><a href="#1、Web-service的概念：" class="headerlink" title="1、Web service的概念："></a>1、Web service的概念：</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。Web Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署，Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。</p>
<a id="more"></a>

<h3 id="2、Web-Service有以下的优越性："><a href="#2、Web-Service有以下的优越性：" class="headerlink" title="2、Web Service有以下的优越性："></a>2、Web Service有以下的优越性：</h3><p>1）平台无关。不管你使用什么平台，都可以使用Web service。<br>2）编程语言无关。只要遵守相关协议，就可以使用任意编程语言，向其他网站要求Web service。这大大增加了web service的适用性，降低了对程序员的要求。<br>3）对于Webservice提供者来说，部署、升级和维护Web service都非常单纯，不需要考虑客户端兼容问题，而且一次性就能完成。<br>4）对于Webservice使用者来说，可以轻易实现多种数据、多种服务的聚合（mashup），因此能够做出一些以前根本无法想像的事情。</p>
<h3 id="3、Apache-CXF的概念"><a href="#3、Apache-CXF的概念" class="headerlink" title="3、Apache CXF的概念"></a>3、Apache CXF的概念</h3><p>Apache CXF是Apache旗下一个重磅的SOA简易框架，CXF 继承了 Celtix 和 XFire 两大开源项目的精华，提供了多种Binding 、DataBinding、Transport 以及各种 Format 的支持，并且可以根据实际项目的需要，采用代码优先（Code First）或者 WSDL 优先（WSDL First）来轻松地实现 Web Services 的发布和使用。而且可以天然的和Spring进行无缝集成。(CXF不仅支持嵌入式代码中通过jetty发布WebService，也可以通过Web容器发布WebService。)</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><h3 id="1-服务提供方实现"><a href="#1-服务提供方实现" class="headerlink" title="1.服务提供方实现"></a>1.服务提供方实现</h3><h4 id="1-引入jar"><a href="#1-引入jar" class="headerlink" title="1) 引入jar"></a>1) 引入jar</h4><pre><code>可在http://cxf.apache.org/download.html 可在下载，也可以用maven引入</code></pre><h4 id="2）实现接口类和实现类"><a href="#2）实现接口类和实现类" class="headerlink" title="2）实现接口类和实现类"></a>2）实现接口类和实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cxfdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CXFDemoService</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String foo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cxfdemo;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CXFDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">CXFDemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3）通过-Web-容器发布-WebService"><a href="#3）通过-Web-容器发布-WebService" class="headerlink" title="3）通过 Web 容器发布 WebService"></a>3）通过 Web 容器发布 WebService</h4><p>CXF提供了spring的集成，同时还提供了org.apache.cxf.transport.servlet.CXFServlet用于在web容器中发布WebService。 前面的例子中增加了整个apache-cxf的依赖，所以会自动增加对srping的引用。</p>
<h5 id="3-1-只需要写beans配置文件和web-xml文件即可。"><a href="#3-1-只需要写beans配置文件和web-xml文件即可。" class="headerlink" title="3.1)只需要写beans配置文件和web.xml文件即可。"></a>3.1)只需要写beans配置文件和web.xml文件即可。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &lt;!-- CXF --&gt;</span><br><span class="line">&lt;servlet&gt;      </span><br><span class="line">      &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;      </span><br><span class="line">      &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;      </span></span><br><span class="line"><span class="class">          <span class="title">org</span>.<span class="title">apache</span>.<span class="title">cxf</span>.<span class="title">transport</span>.<span class="title">servlet</span>.<span class="title">CXFServlet</span>       </span></span><br><span class="line"><span class="class">      &lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;/<span class="title">servlet</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">CXFServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;      </span></span><br><span class="line"><span class="class">      &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">webservice</span>/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;      </span></span><br><span class="line"><span class="class">  &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>在web.xml中增加spring的ContextLoaderListener并配置context-param</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加对spring的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/classes/applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Spring ApplicationContext 载入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-添加bean配置文件-applicationContext-cxf-xml-自定义的名字"><a href="#3-2-添加bean配置文件-applicationContext-cxf-xml-自定义的名字" class="headerlink" title="3.2)添加bean配置文件   applicationContext-cxf.xml (自定义的名字)"></a>3.2)添加bean配置文件   applicationContext-cxf.xml (自定义的名字)</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:jaxws</span>=<span class="string">"http://cxf.apache.org/jaxws"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">xsi:schemaLocation</span>=<span class="string">"   </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/beans/spring-beans.xsd   </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	  http://cxf.apache.org/jaxws </span></span></span><br><span class="line"><span class="tag"><span class="string">      http://cxf.apache.org/schemas/jaxws.xsd"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf.xml"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-extension-soap.xml"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-servlet.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">address</span>=<span class="string">"/CXFDemoService"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">implementor</span>=<span class="string">"#CXFDemoServiceImpl "</span></span></span><br><span class="line"><span class="tag">		<span class="attr">serviceName</span>=<span class="string">"CXFDemoService"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!--有多个可写一起--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">address</span>=<span class="string">"/CXFDemoService2"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">implementor</span>=<span class="string">"#CXFDemoService2Impl "</span></span></span><br><span class="line"><span class="tag">		<span class="attr">serviceName</span>=<span class="string">"CXFDemoService2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>启动Tomcat WebService就已经在web容器中发布了。</strong></p>
<h3 id="2-使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务"><a href="#2-使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务" class="headerlink" title="2.使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务"></a>2.使用CXF中JaxWsProxyFactoryBean客户端代理工厂调用web服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        JaxWsProxyFactoryBean factoryBean = <span class="keyword">new</span> JaxWsProxyFactoryBean();  </span><br><span class="line">        factoryBean.setServiceClass(CXFDemoService<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        <span class="comment">//webService提供方的地址</span></span><br><span class="line">        factoryBean.setAddress(<span class="string">"http://localhost:8080/webservice/CXFDemoService"</span>); </span><br><span class="line">        CXFDemoService cXFDemoService= (CXFDemoService)factoryBean.create();  </span><br><span class="line">        String returnResult = cXFDemoService.sayHello(<span class="string">" webService"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"调用结果:"</span>+returnResult );  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>参考文章<br><a href="http://cxshun.iteye.com/blog/1275408" target="_blank" rel="noopener">http://cxshun.iteye.com/blog/1275408</a><br><a href="https://blog.csdn.net/shb_derek1/article/details/8018287" target="_blank" rel="noopener">https://blog.csdn.net/shb_derek1/article/details/8018287</a></p>
]]></content>
      <categories>
        <category>WebService</category>
      </categories>
      <tags>
        <tag>webservice</tag>
        <tag>CXF</tag>
        <tag>CXF 实现 webservice的发布与调用</tag>
        <tag>JaxWsProxyFactoryBean</tag>
      </tags>
  </entry>
  <entry>
    <title>慢谈 Redis 实现分布式锁 以及 Redisson 源码解析</title>
    <url>/2019/08/24/distributed-locks-with-redis/</url>
    <content><![CDATA[<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="# 产生背景"></a><a href="#产生背景" title="# 产生背景"></a># 产生背景</h2><blockquote>
<p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p>
</blockquote>
<p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p>
<p>随着互联网技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p>
<a id="more"></a>

<h2 id="实现分布式锁的三种选择"><a href="#实现分布式锁的三种选择" class="headerlink" title="# 实现分布式锁的三种选择"></a><a href="#实现分布式锁的三种选择" title="# 实现分布式锁的三种选择"></a># 实现分布式锁的三种选择</h2><ul>
<li>基于数据库实现分布式锁*   基于zookeeper实现分布式锁</li>
<li>基于Redis缓存实现分布式锁</li>
</ul>
<p>以上三种方式都可以实现分布式锁，其中，从健壮性考虑， 用 zookeeper 会比用 Redis 实现更好，但从性能角度考虑，基于 Redis 实现性能会更好，如何选择，还是取决于业务需求。</p>
<h2 id="基于-Redis-实现分布式锁的三种方案"><a href="#基于-Redis-实现分布式锁的三种方案" class="headerlink" title="# 基于 Redis 实现分布式锁的三种方案"></a><a href="#基于-Redis-实现分布式锁的三种方案" title="# 基于 Redis 实现分布式锁的三种方案"></a># 基于 Redis 实现分布式锁的三种方案</h2><ul>
<li>用 Redis 实现分布式锁的正确姿势（实现一）</li>
<li>用 Redisson 实现分布式可重入锁（RedissonLock）（实现二）</li>
<li>用 Redisson 实现分布式锁(红锁 RedissonRedLock)（实现三）</li>
</ul>
<p><strong>本文主要探讨基于 Redis 实现分布式锁的方案，主要分析并对比了以上三种方案，并大致分析了 Redisson 的 RedissonLock 、 RedissonRedLock 源码。</strong></p>
<h2 id="分布式锁需满足四个条件"><a href="#分布式锁需满足四个条件" class="headerlink" title="# 分布式锁需满足四个条件"></a><a href="#分布式锁需满足四个条件" title="# 分布式锁需满足四个条件"></a># 分布式锁需满足四个条件</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li>
<li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li>
</ol>
<h2 id="用-Redis-实现分布式锁的正确姿势（实现一）"><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" class="headerlink" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a><a href="#用-Redis-实现分布式锁的正确姿势（实现一）" title="# 用 Redis 实现分布式锁的正确姿势（实现一）"></a># 用 Redis 实现分布式锁的正确姿势（实现一）</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a><a href="#主要思路" title="主要思路"></a>主要思路</h3><p>通过 set key value px milliseconds nx 命令实现加锁， 通过Lua脚本实现解锁。核心实现命令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁（unique_value可以是UUID等）</span></span>
<span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span>
<span class="line"></span>
<span class="line"><span class="comment">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span></span>
<span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span>
<span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span>
<span class="line"><span class="keyword">else</span></span>
<span class="line">    <span class="keyword">return</span> <span class="number">0</span></span>
<span class="line">end</span>
</pre></td></tr></table></figure>

<p>这种实现方式主要有以下几个要点：</p>
<ul>
<li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p>
</li>
<li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p>
</li>
<li><p>释放锁时要验证 value 值，防止误解锁；</p>
</li>
<li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p>
</li>
</ul>
<h3 id="完整代码实现如下："><a href="#完整代码实现如下：" class="headerlink" title="完整代码实现如下："></a><a href="#完整代码实现如下：" title="完整代码实现如下："></a>完整代码实现如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span>
<span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span>
<span class="line">        </span>
<span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><a href="#加锁代码分析" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p>
<h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><a href="#解锁代码分析" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p>
<h3 id="这种方式仍存在单点风险"><a href="#这种方式仍存在单点风险" class="headerlink" title="这种方式仍存在单点风险"></a><a href="#这种方式仍存在单点风险" title="这种方式仍存在单点风险"></a>这种方式仍存在单点风险</h3><p><strong>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</strong></p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。</li>
<li>主从切换，slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</li>
</ol>
<p><strong>所以在这种实现之下，不论Redis的部署架构是单机模式、主从模式、哨兵模式还是集群模式，都存在这种风险。因为Redis的主从同步是异步的。 运行的是，Redis 之父 antirez 提出了 redlock算法 可以解决这个问题。</strong></p>
<h2 id="Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）"><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" class="headerlink" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a><a href="#Redisson-实现分布式可重入锁及源码分析-（RedissonLock）（实现二）" title="# Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）"></a># Redisson 实现分布式可重入锁及源码分析 （RedissonLock）（实现二）</h2><h3 id="什么是-Redisson"><a href="#什么是-Redisson" class="headerlink" title="什么是 Redisson"></a><a href="#什么是-Redisson" title="什么是 Redisson"></a>什么是 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><a href="#Redisson-分布式重入锁用法" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span>
<span class="line">Config config = <span class="keyword">new</span> Config();</span>
<span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line"><span class="comment">// 2.构造RedissonClient</span></span>
<span class="line">RedissonClient redissonClient = Redisson.create(config);</span>
<span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span>
<span class="line">RLock rLock = redissonClient.getLock(lockKey);</span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    rLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="加锁源码分析"><a href="#加锁源码分析" class="headerlink" title="加锁源码分析"></a><a href="#加锁源码分析" title="加锁源码分析"></a>加锁源码分析</h3><p><strong>1.通过 getLock 方法获取对象</strong></p>
<p><strong>org.redisson.Redisson#getLock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     *  构造并返回一个 RedissonLock 对象 </span></span>
<span class="line"><span class="comment">     * commandExecutor: 与 Redis 节点通信并发送指令的真正实现。需要说明一下，CommandExecutor 实现是通过 eval 命令来执行 Lua 脚本</span></span>
<span class="line"><span class="comment">     * name: 锁的全局名称</span></span>
<span class="line"><span class="comment">     * id: Redisson 客户端唯一标识，实际上就是一个 UUID.randomUUID()</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name, id);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>2.通过tryLock方法尝试获取锁</strong></p>
<p>tryLock方法里的调用关系大致如下：</p>
<p><img src="/images/2019041501.png" alt=""></p>
<p><strong>org.redisson.RedissonLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="comment">//取得最大等待时间</span></span>
<span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span>
<span class="line">    <span class="comment">//记录下当前时间</span></span>
<span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span>
<span class="line">    <span class="comment">//取得当前线程id（判断是否可重入锁的关键）</span></span>
<span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span>
<span class="line">    <span class="comment">//1.尝试申请锁，返回还剩余的锁过期时间</span></span>
<span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">    <span class="comment">//2.如果为空，表示申请锁成功</span></span>
<span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="comment">//3.申请锁的耗时如果大于等于最大等待时间，则申请锁失败</span></span>
<span class="line">    time -= System.currentTimeMillis() - current;</span>
<span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 通过 promise.trySuccess 设置异步执行的结果为null</span></span>
<span class="line"><span class="comment">         * Promise从Uncompleted--&gt;Completed ,通知 Future 异步执行已完成</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    current = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.订阅锁释放事件，并通过await方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：</span></span>
<span class="line"><span class="comment">     * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争</span></span>
<span class="line"><span class="comment">     * 当 this.await返回false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败</span></span>
<span class="line"><span class="comment">     * 当 this.await返回true，进入循环尝试获取锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span>
<span class="line">    <span class="comment">//await 方法内部是用CountDownLatch来实现阻塞，获取subscribe异步执行的结果（应用了Netty 的 Future）</span></span>
<span class="line">    <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span>
<span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span>
<span class="line">            subscribeFuture.onComplete((res, e) -&gt; &#123;</span>
<span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    unsubscribe(subscribeFuture, threadId);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;);</span>
<span class="line">        &#125;</span>
<span class="line">        acquireFailed(threadId);</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        <span class="comment">//计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败</span></span>
<span class="line">        time -= System.currentTimeMillis() - current;</span>
<span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">            acquireFailed(threadId);</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 5.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁</span></span>
<span class="line"><span class="comment">         * 获取锁成功，则立马返回true，</span></span>
<span class="line"><span class="comment">         * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回false结束循环</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="comment">// 再次尝试申请锁</span></span>
<span class="line">            ttl = tryAcquire(leaseTime, unit, threadId);</span>
<span class="line">            <span class="comment">// 成功获取锁则直接返回true结束循环</span></span>
<span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//超过最大等待时间则返回false结束循环，获取锁失败</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            currentTime = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span>
<span class="line">                <span class="comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="comment">//则就在wait time 时间范围内等待可以通过信号量</span></span>
<span class="line">                getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">//7.更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span></span>
<span class="line">            time -= System.currentTimeMillis() - currentTime;</span>
<span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                acquireFailed(threadId);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125; <span class="keyword">finally</span> &#123;</span>
<span class="line">        <span class="comment">//7.无论是否获得锁,都要取消订阅解锁消息</span></span>
<span class="line">        unsubscribe(subscribeFuture, threadId);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>其中 tryAcquire 内部通过调用 tryLockInnerAsync 实现申请锁的逻辑。申请锁并返回锁有效期还剩余的时间，如果为空说明锁未被其它线程申请则直接获取并返回，如果获取到时间，则进入等待竞争逻辑。</p>
<p><strong>org.redisson.RedissonLock#tryLockInnerAsync</strong></p>
<p><strong>加锁流程图：</strong><br><img src="/images/2019041502.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span>
<span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span>
<span class="line">              <span class="comment">// 1.如果缓存中的key不存在，则执行 hset 命令(hset key UUID+threadId 1),然后通过 pexpire 命令设置锁的过期时间(即锁的租约时间)</span></span>
<span class="line">              <span class="comment">// 返回空值 nil ，表示获取锁成功</span></span>
<span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">// 如果key已经存在，并且value也匹配，表示是当前线程持有的锁，则执行 hincrby 命令，重入次数加1，并且设置失效时间</span></span>
<span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span>
<span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span>
<span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span>
<span class="line">                  <span class="string">"return nil; "</span> +</span>
<span class="line">              <span class="string">"end; "</span> +</span>
<span class="line">               <span class="comment">//如果key已经存在，但是value不匹配，说明锁已经被其他线程持有，通过 pttl 命令获取锁的剩余存活时间并返回，至此获取锁失败</span></span>
<span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span>
<span class="line">               <span class="comment">//这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span>
<span class="line">               Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><p>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key；</p>
</li>
<li><p>ARGV[1]就是internalLockLeaseTime，即锁的租约时间（持有锁的有效时间），默认30s；</p>
</li>
<li><p>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值 value，即UUID+threadId。</p>
</li>
</ul>
<h3 id="解锁源码分析"><a href="#解锁源码分析" class="headerlink" title="解锁源码分析"></a><a href="#解锁源码分析" title="解锁源码分析"></a>解锁源码分析</h3><p>unlock 内部通过 get(unlockAsync(Thread.currentThread().getId()))  调用 unlockInnerAsync 解锁。</p>
<p><strong>org.redisson.RedissonLock#unlock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span>
<span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span>
<span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span>
<span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="keyword">throw</span> e;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p>get方法利用是 CountDownLatch 在异步调用结果返回前将当前线程阻塞，然后通过 Netty 的 FutureListener 在异步调用完成后解除阻塞，并返回调用结果。</p>
<p><strong>org.redisson.command.CommandAsyncService#get</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">get</span><span class="params">(RFuture&lt;V&gt; future)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">if</span> (!future.isDone()) &#123;   <span class="comment">//任务还没完成</span></span>
<span class="line">        <span class="comment">// 设置一个单线程的同步控制器</span></span>
<span class="line">        CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span>
<span class="line">        future.onComplete((res, e) -&gt; &#123;</span>
<span class="line">            <span class="comment">//操作完成时，唤醒在await()方法中等待的线程</span></span>
<span class="line">            l.countDown();</span>
<span class="line">        &#125;);</span>
<span class="line"></span>
<span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span>
<span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span>
<span class="line">            <span class="keyword">try</span> &#123;</span>
<span class="line">                <span class="comment">//阻塞等待</span></span>
<span class="line">                l.await();</span>
<span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span>
<span class="line">                interrupted = <span class="keyword">true</span>;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span>
<span class="line">            Thread.currentThread().interrupt();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span>
<span class="line">        <span class="keyword">return</span> future.getNow();</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">throw</span> convertException(future);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>org.redisson.RedissonLock#unlockInnerAsync</strong></p>
<p><strong>解锁流程图：</strong><br><img src="/images/2019041503.png" alt=""></p>
<p><strong>实现源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 通过 EVAL 命令执行 Lua 脚本获取锁，保证了原子性</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span>
<span class="line">            <span class="comment">//如果分布式锁存在，但是value不匹配，表示锁已经被其他线程占用，无权释放锁，那么直接返回空值（解铃还须系铃人）</span></span>
<span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span>
<span class="line">                <span class="string">"return nil;"</span> +</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">             <span class="comment">//如果value匹配，则就是当前线程占有分布式锁，那么将重入次数减1</span></span>
<span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只能更新失效时间，还不能删除</span></span>
<span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span>
<span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span>
<span class="line">                <span class="string">"return 0; "</span> +</span>
<span class="line">            <span class="string">"else "</span> +</span>
<span class="line">             <span class="comment">//重入次数减1后的值如果为0，这时就可以删除这个KEY，并发布解锁消息，返回1</span></span>
<span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span>
<span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span>
<span class="line">                <span class="string">"return 1; "</span>+</span>
<span class="line">            <span class="string">"end; "</span> +</span>
<span class="line">            <span class="string">"return nil;"</span>,</span>
<span class="line">            <span class="comment">//这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span>
<span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h3 id="解锁消息处理"><a href="#解锁消息处理" class="headerlink" title="解锁消息处理"></a><a href="#解锁消息处理" title="解锁消息处理"></a>解锁消息处理</h3><p><strong>org.redisson.pubsub#onMessage</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockPubSub</span> <span class="keyword">extends</span> <span class="title">PublishSubscribe</span>&lt;<span class="title">RedissonLockEntry</span>&gt; </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_MESSAGE = <span class="number">0L</span>;</span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long READ_UNLOCK_MESSAGE = <span class="number">1L</span>;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockPubSub</span><span class="params">(PublishSubscribeService service)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">super</span>(service);</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> RedissonLockEntry <span class="title">createEntry</span><span class="params">(RPromise&lt;RedissonLockEntry&gt; newPromise)</span> </span>&#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLockEntry(newPromise);</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RedissonLockEntry value, Long message)</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 判断是否是解锁消息</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (message.equals(UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">            <span class="keyword">if</span> (runnableToExecute != <span class="keyword">null</span>) &#123;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 释放一个信号量，唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            value.getLatch().release();</span>
<span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(READ_UNLOCK_MESSAGE)) &#123;</span>
<span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span>
<span class="line">                <span class="comment">/**</span></span>
<span class="line"><span class="comment">                 * 如果还有其他Listeners回调，则也唤醒执行</span></span>
<span class="line"><span class="comment">                 */</span></span>
<span class="line">                Runnable runnableToExecute = value.getListeners().poll();</span>
<span class="line">                <span class="keyword">if</span> (runnableToExecute == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    <span class="keyword">break</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                runnableToExecute.run();</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            value.getLatch().release(value.getLatch().getQueueLength());</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">&#125;</span>
<span class="line"></span>
</pre></td></tr></table></figure>

<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><a href="#总结对比" title="总结对比"></a>总结对比</h3><p>通过 Redisson 实现分布式可重入锁（实现二），比纯自己通过set key value px milliseconds nx +lua 实现（实现一）的效果更好些，虽然基本原理都一样，因为通过分析源码可知，RedissonLock<br>是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。   </p>
<p><strong>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</strong></p>
<p><strong>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</strong></p>
<h2 id="redlock算法"><a href="#redlock算法" class="headerlink" title="# redlock算法"></a><a href="#redlock算法" title="# redlock算法"></a># redlock算法</h2><p>Redis 官网对 redLock 算法的介绍大致如下：</p>
<blockquote>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">The Redlock algorithm</a></p>
</blockquote>
<p>在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li><p>获取当前Unix时间，以毫秒为单位。</p>
</li>
<li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p>
</li>
<li><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p>
</li>
<li><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p>
</li>
</ol>
<h2 id="用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）"><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" class="headerlink" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a><a href="#用-Redisson-实现分布式锁-红锁-RedissonRedLock-及源码分析（实现三）" title="# 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）"></a># 用 Redisson 实现分布式锁(红锁 RedissonRedLock)及源码分析（实现三）</h2><p>这里以三个单机模式为例，需要特别注意的是他们完全互相独立，不存在主从复制或者其他集群协调机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
</pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span>
<span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span>
<span class="line"></span>
<span class="line">Config config2 = <span class="keyword">new</span> Config();</span>
<span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span>
<span class="line"></span>
<span class="line">Config config3 = <span class="keyword">new</span> Config();</span>
<span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span>
<span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span>
<span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span>
<span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span></span>
<span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span>
<span class="line"><span class="comment"> */</span></span>
<span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span>
<span class="line"></span>
<span class="line"><span class="keyword">try</span> &#123;</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 4.尝试获取锁</span></span>
<span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span>
<span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span>
<span class="line">    <span class="keyword">if</span> (res) &#123;</span>
<span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span>
<span class="line">    &#125;</span>
<span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span>
<span class="line">&#125;<span class="keyword">finally</span>&#123;</span>
<span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span>
<span class="line">    redLock.unlock();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<p><strong>最核心的变化就是需要构建多个 RLock ,然后根据多个 RLock 构建成一个 RedissonRedLock，因为 redLock 算法是建立在多个互相独立的 Redis 环境之上的（为了区分可以叫为 Redission node），Redission node 节点既可以是单机模式(single)，也可以是主从模式(master/salve)，哨兵模式(sentinal)，或者集群模式(cluster)。这就意味着，不能跟以往这样只搭建 1个 cluster、或 1个 sentinel 集群，或是1套主从架构就了事了，需要为 RedissonRedLock 额外搭建多几套独立的 Redission 节点。 比如可以搭建3个 或者5个 Redission节点，具体可看视资源及业务情况而定。</strong></p>
<p><strong>下图是一个利用多个 Redission node 最终 组成 RedLock分布式锁的例子，需要特别注意的是每个  Redission node 是互相独立的，不存在任何复制或者其他隐含的分布式协调机制。</strong></p>
<p><img src="/images/2019041504.png" alt=""><br><img src="/images/2019041505.png" alt=""></p>
<h2 id="Redisson-实现redlock算法源码分析（RedLock）"><a href="#Redisson-实现redlock算法源码分析（RedLock）" class="headerlink" title="# Redisson 实现redlock算法源码分析（RedLock）"></a><a href="#Redisson-实现redlock算法源码分析（RedLock）" title="# Redisson 实现redlock算法源码分析（RedLock）"></a># Redisson 实现redlock算法源码分析（RedLock）</h2><p><strong>加锁核心代码</strong></p>
<p> <strong>org.redisson.RedissonMultiLock#tryLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
<span class="line">101</span>
<span class="line">102</span>
<span class="line">103</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span>
<span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span>
<span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span>
<span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        remainTime = unit.toMillis(waitTime);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 1\. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 2\. 遍历所有节点通过EVAL命令执行lua加锁</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span>
<span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span>
<span class="line">        RLock lock = iterator.next();</span>
<span class="line">        <span class="keyword">boolean</span> lockAcquired;</span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">try</span> &#123;</span>
<span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                lockAcquired = lock.tryLock();</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span>
<span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span>
<span class="line">            &#125;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span>
<span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span>
<span class="line">            unlockInner(Arrays.asList(lock));</span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span>
<span class="line">            lockAcquired = <span class="keyword">false</span>;</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             *4\. 如果获取到锁则添加到已获取锁集合中</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            acquiredLocks.add(lock);</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            <span class="comment">/**</span></span>
<span class="line"><span class="comment">             * 5\. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span>
<span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span>
<span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span>
<span class="line"><span class="comment">             */</span></span>
<span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span>
<span class="line">                <span class="keyword">break</span>;</span>
<span class="line">            &#125;</span>
<span class="line"></span>
<span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span>
<span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">                &#125;</span>
<span class="line">                failedLocksLimit = failedLocksLimit();</span>
<span class="line">                acquiredLocks.clear();</span>
<span class="line">                <span class="comment">// reset iterator</span></span>
<span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span>
<span class="line">                    iterator.previous();</span>
<span class="line">                &#125;</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                failedLocksLimit--;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line"></span>
<span class="line">        <span class="comment">/**</span></span>
<span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span>
<span class="line"><span class="comment">         */</span></span>
<span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span>
<span class="line">            remainTime -= System.currentTimeMillis() - time;</span>
<span class="line">            time = System.currentTimeMillis();</span>
<span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span>
<span class="line">                unlockInner(acquiredLocks);</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span>
<span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span>
<span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span>
<span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span>
<span class="line">            futures.add(future);</span>
<span class="line">        &#125;</span>
<span class="line">        </span>
<span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span>
<span class="line">            rFuture.syncUninterruptibly();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span></span>
<span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span>
<span class="line"><span class="comment">     */</span></span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="# 参考文献"></a><a href="#参考文献" title="# 参考文献"></a># 参考文献</h2><p>[1]<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p>
<p>[2]<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">Distributed locks with Redis 中文版</a></p>
<p>[3]<a href="https://redis.io/commands/set" target="_blank" rel="noopener">SET - Redis</a></p>
<p>[4]<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">EVAL command</a></p>
<p>[5] <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></p>
<p>[6]<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">Redis分布式锁的正确实现方式</a></p>
<p>[7]<a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">Redlock实现分布式锁</a></p>
<p>[8]<a href="https://mp.weixin.qq.com/s/iaZcc7QGbGHkZkfLeYp1yg" target="_blank" rel="noopener">Redisson实现Redis分布式锁</a></p>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Redisson</tag>
        <tag>RedissonLock</tag>
        <tag>RedissonRedLock</tag>
      </tags>
  </entry>
</search>
